id	title	keywords	abstract	entities	authors	year	journal	doi	fos	area	x	y	ix
c7e47be6b0c4e9e2db3c54102328057a5d2b6c15	the design of a temporal logic for open distributed systems	temporal logic	In order to convey the essential ideas about a given problem, the system designer defines a requirement specification, consisting of the conceptual system architecture and the system behaviour. In Chapter 2, we have informally introduced basic architectural concepts and shown how they can be composed to yield system architectures. In this chapter, we will develop semantical models and design a temporal logic for the formal modeling and specification of system architectures and system behaviour. As it will turn out, this formalism can also be used to define the semantics of basic architectural concepts.	distributed computing;temporal logic	Reinhard Gotzhein;Friedrich H. Vogt	1991			interval temporal logic;distributed computing;distributed design patterns	Theory	-38.99542599336402	28.672854404862267	43365
5acdddd3e4edfa354fc66177ec26a080f0027b76	temporal graph queries to support software evolution	outil logiciel;transformacion grafo;software tool;industrial case study;legacy software;logica temporal;tool support;temporal logic;base donnee temporelle;interrogation base donnee;interrogacion base datos;metric;development process;graph transformation;logiciel patrimonial;transformation graphe;software evolution;reingenieria;reingenierie;logique ordre 1;logicial herencia;algorithme evolutionniste;metrico;algoritmo evolucionista;temporal databases;information system;evolutionary algorithm;herramienta software;legacy system;reengineering;database query;logique temporelle;systeme information;first order logic;metrique;logica orden 1;sistema informacion	Graph transformation techniques have already been used successfully by several research groups to support re-engineering of large legacy systems. Where others often aim at transforming the system to improve it, we advocate an evolutionary approach that embeds transformations within the ordinary development process and provides tool support to monitor the ongoing progress regularly. In this paper, we discuss how temporal graph queries based on Fujaba story diagrams can provide a natural means to express trend-oriented metrics and consistency rules that we identified in our industrial case studies. To this end, we discuss a first-order logic rather than operational interpretation of a graph queries and show how well-known temporal logic operators can be added to express rules over consecutive states of the same instance graph.	code generation (compiler);continuation;diagram;evolutionary algorithm;evolutionary computation;first-order logic;first-order predicate;graph (discrete mathematics);graph rewriting;iterative and incremental development;legacy system;software evolution;temporal logic	Tobias Rötschke;Andy Schürr	2006		10.1007/11841883_21	wait-for graph;computer science;artificial intelligence;evolutionary algorithm;data mining;legacy system;graph database;algorithm;graph rewriting	SE	-42.396332357436	24.991302339203276	43506
e53082ed77677a921e47c784b34c8a656c506ae6	from autosar models to co-simulation for mil-testing in the automotive domain	automotive engineering;software;automotive electronics;integration testing;model in the loop;engineering process autosar models mil testing model components electronic control units automotive domain testing model in the loop simulation integration testing simulator coupling co simulation based test scenarios modeling language co simulation based test environments;software architecture automotive components automotive electronics control engineering computing digital simulation open systems program testing;testing;test;modeling language;automatic generation;data model;experience report;connectors;software architecture;program testing;testing software automotive engineering couplings connectors adaptation models data models;automotive components;model based testing;autosar model based testing model in the loop test;control engineering computing;autosar;couplings;adaptation models;open systems;electronic control unit;digital simulation;data models	Models in testing are important for describing, understanding, and managing tests. In the automotive domain, AUTOSAR is an important standard to model components of electronic control units. AUTOSAR, however, lacks information about tests or test scenarios. Early testing in the automotive domain is often done by Model-in-the-Loop simulation. Simulations of several components are run in different environments, each. Thus, they need to be connected (co-simulated) for integration testing of these components, e.g., via simulator coupling. This paper is focused on closing the gap between AUTOSAR models and co-simulation-based test scenarios that use simulator coupling. Our main contribution is the definition of a modeling language to describe test environments. The instances of this language can be derived from existing AUTOSAR models and can also be used to automatically generate co-simulation-based test environments. Furthermore, we provide a workflow to integrate this model in the engineering process and an experiment report to demonstrate the applicability and the advantages of the approach.	autosar;closing (morphology);co-simulation;computer simulation;integration platform;integration testing;modelisar;model-driven architecture;model-driven engineering;modeling language;requirement;test case;traceability	Marcus Mews;Jaroslav Svacina;Stephan Weißleder	2012	2012 IEEE Fifth International Conference on Software Testing, Verification and Validation	10.1109/ICST.2012.137	embedded system;real-time computing;systems engineering;engineering;software engineering;east-adl;software testing	SE	-47.88448974623183	31.401479217469774	43508
82f05744e5d88ddecdeec3c9fa62f0ee31010dc4	csp with synthesisable systemc(tm) and osss		C. Hoare’s Communicating Sequential Processes (CSP) notation [12] to describe communication patterns of highly parallel systems is based on a well defined semantic and is accompanied by a wealth of research. This allows automatic checks for important properties like deadlock-freedom, livelock-freedom etc.. In order to obtain an executable system for simulation and later synthesis the algebraic CSP notation has to be translated and augmented with behaviour. There are several library implementations of CSP concepts for various programming languages. Other languages have built-in CSP elements or are based on CSP. This paper presents an implementation of CSP concepts in synthesisable SystemC. The key features of CSP are available to the programmer allowing a high-level approach to system design. The CSP constructs are modelled after the CSP-based programming language occam, all the advanced C++ features like object-orientation etc. are still usable. By adhering to the Oldenburg System Synthesis Subset (OSSS, [10, 11]) the resulting designs will be set to be synthesised down to hardware automatically by the tools developed in the ICODES project [10]. An 3x3 image filter example is used to demonstrate the design flow from a CSP specification to an OSSS implementation.	c++;communicating sequential processes;composite image filter;deadlock;executable;high- and low-level;hoare logic;programmer;programming language;simulation;systemc;systems design;occam	Claus Brunzema;Wolfgang Nebel	2007			computer science;overpressure;real-time computing;mechanics;systemc;pressure sensor;pressure control;flow (psychology);pressure swing adsorption;control system	EDA	-40.00673489622057	31.785843186761188	43609
46927655b84756c623d7f4241feac0efdc6206ca	computing of applied digital ecosystems	complex dynamics;multi agent system;service oriented architectures;ecosystem oriented architectures;multi agent systems;service oriented architecture;distributed evolutionary computing;evolutionary computing	A primary motivation for our research in digital ecosystems is the desire to exploit the self-organising properties of biological ecosystems. Ecosystems are thought to be robust, scalable architectures that can automatically solve complex, dynamic problems. However, the computing technologies that contribute to these properties have not been made explicit in digital ecosystems research. Here, we discuss how different computing technologies can contribute to providing the necessary self-organising features, including Multi-Agent Systems (MASs), Service-Oriented Architectures (SOAs), and distributed evolutionary computing (DEC). The potential for exploiting these properties in digital ecosystems is considered, suggesting how several key features of biological ecosystems can be exploited in Digital Ecosystems, and discussing how mimicking these features may assist in developing robust, scalable self-organising architectures. An example architecture, the Digital Ecosystem, is considered in detail. The Digital Ecosystem is then measured experimentally through simulations, considering the self-organised diversity of its evolving agent populations relative to the user request behaviour.	digital ecosystem;evolutionary computation;experiment;multi-agent system;population;robustness (computer science);scalability;self-organization;service-oriented device architecture;simulation	Gerard Briscoe;Philippe De Wilde	2009		10.1145/1643823.1643830	simulation;computer science;artificial intelligence;theoretical computer science;service-oriented architecture;multi-agent system;distributed computing	HCI	-40.87682357177777	19.82083278811708	43617
77487073cbb71a2a4bfb1b02ff41fa9cdecefd86	interacting subsystems in uml	semantics;langage modelisation unifie;semantica;semantique;specification language;subsystem;sous systeme;unified modeling language;lenguaje especificacion;langage specification;subsistema	In this paper we give a description of the subsystem construct in the Uniied Modeling Language, emphasizing its dynamic aspects , thus giving a detailed description of the semantics of interaction with subsystems. Depending on whether the surroundings of the subsystem make use of public elements in the subsystem or not, the subsystem is considered to be open or closed, respectively. This leads to two diier-ent ways to use the services of the subsystem: either importing it and directly accessing its public elements, or associating it and only communicating with the subsystem itself. We also discuss some implications which closed subsystems have on collaborations.	unified modeling language	Gunnar Övergaard;Karin Palmkvist	2000		10.1007/3-540-40011-7_26	unified modeling language;specification language;computer science;theoretical computer science;database;system;semantics;programming language;algorithm	SE	-39.50870068805048	27.61761742167457	43675
0aa7b91e99d9749adbdca55286c31c0c990fe849	entwurf eingebetteter systeme: ausführbare modelle und fehlersuche		With increasing complexity of technical systems, model-driven development gains increasing signi cance. In the past, graphical models were mainly used for documentation purposes. Today the semantics of modeling languages are speci ed in a way that allows to use them as programming languages to describe software. This thesis evaluates the question which requirements must be ful lled by a exible development environment for executable models. It focuses on the Unied Modeling Language (UML), CASE-tools that are common for embedded software development and domain speci c modeling approaches. All approaches were combined into an integrated model. Using an integrated tool-chain this model can be rendered to an executable binary. A model-tocode tranformation closes a gap for UML models by providing a code generator for UML Actions. Searching for defects is an important task a developer has to ful l during software development. This thesis describes a exible architecture for debugging executable graphical models. It is based on reversing through the abstraction layers that were traversed during model-to-executable transformations. The exible software-platform ModelScope allows to integrate di ent types of execution platforms and visualizations of system state using di erent views on the running system. Both axes of heterogeneity were evaluated and implemented for a number of target systems and modeling paradigms that are important in the area of embedded software/con gware development.	code generation (compiler);computer-aided software engineering;debugging;documentation;embedded software;embedded system;executable;graphical model;model-driven engineering;naruto shippuden: clash of ninja revolution 3;programming language;requirement;reversing: secrets of reverse engineering;software development;toolchain;unified modeling language	Philipp Graf	2008				SE	-42.09153338569335	25.55670064864605	43810
ecb112a15ee503491322cb78082c114d79272853	model-driven engineering of multi-agent systems based on ontologies		Model-driven engineering provides abstractions and notations for improving the understanding and for supporting the modelling, coding, and verification of applications for specific domains. Ontologies, on the other hand, provide formal and explicit definitions of shared conceptualisations and enable the use of semantic reasoning. Although these areas have been developed by different communities, important synergies can be achieved when both are combined. These advantages can be explored in the development of multi-agent systems, given their complexity and the need for integrating several components that are often addressed from different angles. This work investigates how to apply ontologies for agentoriented software engineering. Initially, we present a new modelling approach where multiagent systems are designed using the proposed OntoMAS ontology. Then, we describe techniques, implemented in a tool, to help programmers bring their concepts into code and also generate code automatically from instantiated ontology models. Several advantages can be obtained from these new approaches to model and code multi-agent systems, such as semantic reasoning to carry out inferences and verification mechanisms. But the main advantage is the unified high (knowledge) level specification language that allows modelling the three dimensions that are united in the JaCaMo framework so that systems specifications can be better communicated across developing teams. The evaluations of these proposals indicate that they contribute with the different aspects of agent-oriented software engineering, such as the specification, verification, and programming of these systems.	agent-oriented software engineering;artificial intelligence;experiment;model-driven architecture;model-driven engineering;multi-agent system;ontology (information science);synergy	Artur Freitas;Rafael H. Bordini;Renata Vieira	2017	Applied Ontology	10.3233/AO-170182	software engineering;computer science;system of systems engineering;data mining;agent-oriented software engineering;ontology (information science);ontology;specification language;model-driven architecture;multi-agent system;idef5	AI	-43.941886111076634	23.187683361477085	43832
442cbb4994d32a437b68a8989203cf58ee51bb64	contract-based requirement modularization via synthesis of correct decompositions	verification;decomposition;general terms design;additional key words and phrases contract;requirement;acm reference format;synthesis;contract;theory;distributed systems;i64 computing methodologies model validation and analysis	In distributed development of modern systems, contracts play a vital role in ensuring interoperability of components and adherence to specifications. It is therefore often desirable to verify the satisfaction of an overall property represented as a contract, given the satisfaction of smaller properties also represented as contracts. When the verification result is negative, designers must face the issue of refining the subproperties and components. This is an instance of the classical synthesis problems: “can we construct a model that satisfies some given specification?” In this work, we propose two strategies enabling designers to synthesize or refine a set of contracts so that their composition satisfies a given contract. We develop a generic algebraic method and show how it can be applied in different contract models to support top-down component-based development of distributed systems.	carrier-to-noise ratio;component-based software engineering;database normalization;design by contract;distributed computing;interoperability;linear algebra;operand;refinement (computing);requirement;top-down and bottom-up design;verification and validation	Thi Thieu Hoa Le;Roberto Passerone;Ulrich Fahrenberg;Axel Legay	2016	ACM Trans. Embedded Comput. Syst.	10.1145/2885752	contract;verification;computer science;requirement;operating system;decomposition;programming language;theory	Logic	-43.56377612597869	29.365335735974167	43841
3fcb6e7b58dc3fb13d2e3e108f816b3dc53f26ec	a model for dynamic adaptation in reconfigurable hardware systems	dynamic programming;dynamic change;microprocessors;logic arrays;dynamic adaptation model;high level programming;software prototyping reconfigurable architectures field programmable gate arrays;dscircal model;reconfigurable computing;software prototyping;information science;dynamically changing hardware systems dynamic adaptation model reconfigurable hardware systems connective topological structure dscircal model reconfigurable evolvable hardware compilation mechanism high level programming;reconfigurable architectures;hip;reconfigurable logic;adaptation model hardware field programmable gate arrays microprocessors logic arrays reconfigurable logic information science australia hip dynamic programming;evolvable hardware;adaptation model;complex system;reconfigurable evolvable hardware;dynamically changing hardware systems;field programmable gate arrays;reconfigurable hardware systems;dynamic adaptation;reconfigurable hardware;compilation mechanism;australia;connective topological structure;hardware	A theory is presented in which to model the changing structure found in reconfigurable computing devices and which provides a foundation for developing the languages necessary to program such devices. The core concept is that of a complex system of agents which interact with each other over a changing, connective topological structure. The agents themselves may be created, destroyed and evolve in a biological– like manner. These concepts and the manner in which they are harnessed within the dsCircal model are presented in this paper. The relationship between these concepts and reconfigurable evolvable hardware is outlined, giving a basis for a compilation mechanism allowing the high–level programming of dynamically changing hardware systems.	autonomous robot;compiler;complex system;concurrency (computer science);dynamical system;evolvable hardware;field-programmable gate array;high-level programming language;logical connective;reconfigurable computing	George J. Milne	1999		10.1109/EH.1999.785448	computer architecture;real-time computing;computer science;computer engineering	ML	-39.82488011180266	20.318604982015675	43885
0a35a126c5a1042fa1cd65a9bd12d6200b4cc4bf	a fuzzy logic approach to measure complexity of generic aspectoriented systems	fuzzy logic	Aspect-oriented programming (AOP) is an emerging technique that provides a mechanism to clearly encapsulate and implement concerns that crosscut other modules. It is claimed that this technique improves code modularization and therefore reduces complexity of object-oriented programs (OOP). Most of the proposed complexity measurement frameworks for AOP are for AspectJ programming language. In this paper, a generalized framework for assessment of complexity of aspect-oriented (AO) systems, has been defined that takes into account three, the most well known families of available AOP languages, AspectJ, CaesarJ and Hyper/J. In order to automate complexity measurement, a tool has been developed using fuzzy logic, in which some set of rules have been defined as rule base. Using this tool, complexity of majority of AOP languages can be measured, which will further help in the measurement of external software qualities, such as maintainability, reusability, adaptability and understandability.	fuzzy logic	Rajesh Kumar;P. S. Grover;Avadhesh Kumar	2010	Journal of Object Technology	10.5381/jot.2010.9.3.a1	fuzzy logic;dynamic logic;t-norm fuzzy logics;combs method;fuzzy electronics;description logic;logic optimization;defuzzification;fuzzy classification;computer science;fuzzy number;neuro-fuzzy;fuzzy associative matrix;fuzzy set operations;multimodal logic;fuzzy control language;fuzzy control system	Logic	-45.62263070044554	27.760421146682845	43958
3269ebe39bd26af7929ee7302e11e18b5fa4753f	automated environment generation for software model checking	automatic control;programming environments;formal specification;java programming;software model checking;program verification computers;compiler generators;compiler generators open systems program verification java formal specification software architecture;nontrivial concurrent programs automated environment generation software model checking open systems environment modeling tractable verification java program fragments sound abstractions bandera environment generator beg;software systems;program verification;software engineering;software architecture;model checking;mathematical models;systems analysis;java software systems context modeling computational intelligence society space technology nasa open systems costs yarn independent component analysis;java programming language;computer systems programs;open system;computer components;architecture computers;open systems;java	A key problem in model checking open systems is environment modeling (i.e., representing the behavior of the execution context of the system under analysis). Sojhare systems are fundamentally open since their behavior is dependent on patterns of invocation of system components and values defined outside the system but referenced within the system. Whether reasoning about the behavior of whole programs or about program components, an abstract model of the environment can be essential in enabling suficiently precise yet tractable verijication. In this papel; we describe an approach to generating environments of Java program fragments. This approach integrates formally specijied assumptions about environment behavior with sound abstractions of environment implementations to form a model of the environment. The approach is implemented in the Bandera Environment Generator (BEG) which we describe along with our experience using BEG to reason about properties of severcl non-trivial concurrent Java programs.	approximation algorithm;cobham's thesis;computational complexity theory;java;lock (computer science);model checking	Oksana Tkachuk;Matthew B. Dwyer;Corina S. Pasareanu	2003		10.1109/ASE.2003.1240300	computer architecture;real-time computing;computer science;software engineering;automatic control;open system;programming language	SE	-47.13546906723813	30.3429725992902	44009
3e4d8d37ec22f9900f83010a4624a865261d96a4	defining object-oriented execution semantics using graph transformations	developpement logiciel;modelizacion;lenguaje programacion;graph theory;distributed system;methode a pas;transformacion grafo;teoria grafo;trajectoire;systeme reparti;object oriented language;programming language;orientado aspecto;metodo formal;methode formelle;semantics;systeme ouvert;semantica;semantique;theorie graphe;graph transformation;formal method;modelisation;step method;transformation graphe;formal verification;sistema repartido;trajectory;object oriented;desarrollo logicial;directed graph;graphe oriente;software development;langage programmation;oriente objet;verification formelle;grafo orientado;trayectoria;aspect oriented;open systems;sistema abierto;modeling;orientado objeto;language design;oriente aspect;metodo a paso	In this paper we describe an application of the theory of graph transformations to the practise of language design. In particular, we have defined the static and dynamic semantics of a small but realistic object-oriented language (called TAAL) by mapping the language constructs to graphs (the static semantics) and modelling their effect by graph transformation rules (the dynamic semantics). This gives rise to execution models for all TAAL-programs, which can be used as the basis for formal verification. This work constitutes a first step towards a method for defining all aspects of software languages, besides their concrete syntax, in a consistent and rigorous manner. Such a method facilitates the integration of formal correctness in the software development trajectory.	correctness (computer science);formal verification;graph rewriting;parse tree;programming language;software development	Harmen Kastenberg;Anneke Kleppe;Arend Rensink	2006		10.1007/11768869_15	formal methods;formal semantics;computer science;graph theory;theoretical computer science;formal semantics;semantics;programming language;object-oriented programming;operational semantics;algorithm;computational semantics	PL	-40.447953613778125	26.112394971223146	44048
fb0c003b48ef420d6410bc865668f0c5156197d2	test case generation of a communication protocol by an adaptive state exploration	state exploration;test case generation;conformance testing;extended finite state machine;protocol conformance testing;reducing state explosion;communication protocol;state explosion	State exploration, which is widely used for generation of executable test cases for conformance test of a protocol, often causes state explosion problem. This paper proposes an adaptive state exploration method to overcome the problem for a single module protocol. Since state explosion arises in relation to the predicate, it tries to find out efficiently predicated transitions with priority by emulating the normal and erroneous communication environments closely related to the predicates. A test case generation method using the method is also proposed, which uses an Subdivided Extended Finite State Machine (SEFSM) as a protocol model to reduce semantic loss by modeling and adjusted UIO sequences for the protocol model. The empirical results of the proposed methods show their efficacy.	communications protocol;test case	Tae-Hyong Kim;Ik-Soon Hwang;MinSeok Jang;Jai-Yong Lee	2001	Computer Communications	10.1016/S0140-3664(00)00343-1	extended finite-state machine;communications protocol;real-time computing;simulation;computer science;operating system;conformance testing;computer security;algorithm	Robotics	-37.85614833100961	32.157835715590664	44117
46c9e16fbc6651cd7dc3ad0e347fe8bba77c5e75	cassting: synthesizing complex systems using non-zero-sum games		25 Formal methods for verifying comput-erised systems offer a powerful approach for validating the adequacy of the systems against their requirements. Based on deep theoretical results in logics and automata, model checking is one such approach. This approach involves modelling a system as a mathematical object (a finite-state automaton in the basic case), and applying algorithms for comparing the behaviour of that model against a logical property. Model checking has now reached maturity [1] through the development of efficient symbolic techniques, state-of-the-art tool support, and numerous successful applications to various areas. Building on this framework, automatic synthesis techniques have recently been proposed. These techniques allow a model of a system (that is correct in construction) to be built automatically based on certain specifications. This model can then be refined to produce a validated implementation, thereby avoiding a trial-and-error approach of model checking. It is usual-and convenient-to rephrase the problem of automatic synthesis in the framework of game theory. In this metaphor, the system to be synthesized is then represented as a strategy, which should win against any behaviour of the system's environment, represented by the other player. The winning condition is used to express the correctness properties that we want the system to satisfy. This game-based approach to the synthesis of systems interacting with their environment has been greatly developed over the last twenty years, and is approaching maturity [2]. It should be noted, however, that up until now, formal methods have mostly focused on two-player zero-sum games, which only encompass the purely antagonist setting and may only model centralized control. Multiple-player games with non-zero-sum objectives have been considered, e.g., in algorithmic game theory, but they were strategic games, as opposed to the infinite-duration games on graphs that apply particularly well to synthesis. Within the Cassting project, we are designing a game-based framework for modelling and reasoning about cyber-physical systems. This is much more than just a minor extension of the existing framework: while the basic concept of using game models is preserved , radically new concepts and techniques have to be developed in order to build a powerful formalism, equipped with efficient algorithms and tools for modelling and synthesizing such complex systems. In particular, while winning strategies are the central concept in adversarial games, multiple-player games come with a full range of equilibria for globally characterizing the admissible behaviours of the players. Understanding how this can be adapted to …	algorithm;algorithmic game theory;automatic control;automaton;capability maturity model;centralized computing;complex systems;correctness (computer science);cyber-physical system;finite-state machine;formal methods;game engine;interaction;logic synthesis;model checking;requirement;semantics (computer science)	Nicolas Markey	2014	ERCIM News		data mining;discrete mathematics;complex system;zero-sum game;computer science	Logic	-39.58243952754168	29.778297866856995	44164
7143e4a373807fa7c5b7ee116fc61704bd00c0f5	decomposing global quantitative properties into local ones		In this paper we address the problem of identifying what local properties the sub-components of a system have to satisfy in order to guarantee a (security) property on the behaviour of the whole system. We associate each action with a value. Hence, we end up with quantitative properties on them, which are specified through a modal logic equipped with a parametric algebraic structure (i.e., a c-semiring). The aim is to have a value related to the satisfaction of a formula. Starting from the behaviour of a general distributed system (or context), we propose a formal approach to decompose a global quantitative property into the local quantitative properties to be satisfied by its sub-contexts.	centralisation;computer security;distributed computing;formal verification;linear algebra;modal logic	Ilaria Matteucci;Francesco Santini	2016		10.1007/978-3-319-47072-6_3	mathematical optimization;algebraic structure;modal logic;parametric statistics;mathematics	Logic	-36.38061293660363	24.259396140254136	44171
f87dd04f36d9605ef748bf059498a278a93267ab	an experimental multi-agent environment for engineering design	engineering design;cognitive agents;agent communication;design environment;communication protocol;agent architecture;distributed architecture	Real world engineering design projects require the cooperation of multidisciplinary design teams using sophisticated and powerful engineering tools. The individuals or the individual groups of the multidisciplinary design teams work in parallel and independently often for quite a long time with diierent tools located on various sites. In order to ensure the coordination of design activities in the different groups or the cooperation among the diierent tools, it is necessary to develop an eecient design environment. This paper discusses a distributed architecture for integrating such engineering tools in an open design environment, organized as a population of asynchronous cognitive agents. Before introducing the general architecture and the communication protocol, issues about an agent architecture and inter-agent communications are discussed. A prototype of such an environment with a number of independent agents located in several workstations is then presented and demonstrated on an example of a small mechanical design.	agent architecture;communications protocol;distributed computing;engineering design process;intelligent agent;open design;prototype;workstation	Weiming Shen;Jean-Paul A. Barthès	1996	Int. J. Cooperative Inf. Syst.	10.1142/S0218843096000063	agent architecture;communications protocol;simulation;computer science;artificial intelligence;distributed design patterns;engineering design process	SE	-39.883673439844	18.337065687927108	44215
1da472b899e7ba419e1782b3ffaff622be02bee8	a holistic approach to test-driven model checking	oracle problem;problema oraculo;model specification;verificacion modelo;raisonnement base sur cas;razonamiento fundado sobre caso;validacion;metodo formal;methode formelle;software systems;verification modele;intelligence artificielle;holistic approach;program verification;formal method;software architecture;verificacion programa;test case generation;probleme oracle;model checking;specification modele;especificacion modelo;generation test;test methods;architecture basee modele;test generation;artificial intelligence;validation;inteligencia artificial;case based reasoning;verification programme;generacion prueba;model driven architecture;architecture logiciel;arquitectura basada modelo	Testing is the most common validation method in the software industry. It entails the execution of the software system in the real environment. Nevertheless, testing is a cost-intensive process. Because of its conceptual simplicity the combination of formal methods and test methods has been widely advocated. Model checking belongs to the promising candidates for this marriage. The present paper modifies and extends the existing approaches in that, after the test case generation, a model checking step supports the manual test process. Based on the holistic approach to specification-based construction of test suites, this paper proposes to generate test cases to cover both the specification model and its complement. This helps also to clearly differentiate the correct system outputs from the faulty ones as the test cases based on the specification are to succeed the test, and the ones based on the complement of the specification are to fail. Thus, the approach handles the oracle problem in an effective manner.	formal methods;holism;model checking;software industry;software system;test case	Fevzi Belli;Baris Güldali	2005		10.1007/11504894_45	model checking;case-based reasoning;software architecture;simulation;formal methods;computer science;artificial intelligence;test method;test case;specification;test management approach;algorithm;software system	SE	-42.833052466900575	26.51952591140834	44303
44b06ea34cfb8bf5344edea6f65d7a54aef51646	harmonizing intra- and inter-object specification and verification: a multi-object logics approach	incremental development;interaction point;temporal logic;formal semantics;software engineering;specification language;requirements;large scale;multiple objectives;state machines;model checking;specification and verification;object oriented;interaction pattern;state space;semantic description;object oriented approach;information system;mobile agent;scenarios;biological process	Object-oriented approaches to designing information systems suggest to distinguish between intra- and inter-object aspects. While intra-object design and verification tools are being used on a large scale, inter-object techniques are not yet well established. There are a variety of approaches addressing the concurrency and communication aspects of multi-object systems, but fundamental problems remain.The TROLL object specification language project aims at providing logic-based formal semantics to intra- and inter-object aspects, among others. For the former, a conventional temporal logic was employed. For the latter, an extension called multi-object logic was developed. It has proven useful for semantics descriptions, recently also for a mobile-agent extension where the innovative contribution was to distinguish between the ever-mobile units and those which provide fixed subsystems as contexts for the mobile entities.While being developed for giving semantics, multi-object logics showed surprising potential for verification. Conventionally, intra-object verification techniques are applied to inter-object verification by building a global state space. This state space, however, grows exponentially with the number of objects in the system. In spite of sophisticated techniques which have been developed to overcome this 'state-space explosion' problem, there is a notorious complexity barrier. It is not feasible to verify large systems this way.In the multi-object logic approach, the construction of the global state space - or any fraction or abstraction thereof - is avoided. So it has the potential to handle large systems. The method is applicable in cases where the objects and interaction patterns in a system are known beforehand, when writing the global conditions to be checked. Although these conditions are bound to objects, they are 'global' in the sense that they may refer to the states of other objects at interaction points.This way, conditions concerning interacting objects may be written in a still basically sequential logic, although multiple objects are assumed to behave concurrently. Global checking conditions may then be automatically and equivalently split into local conditions for the objects involved, plus interaction requirements for these objects. All these conditions and requirements can be checked locally, one after the other, where only the objects involved in the condition have to be taken into account.While we are working on the potential of the approach for software engineering, it may have potential beyond: we are also working on a project to simulate and analyze biological processes using object-oriented techniques. For instance, model checking can be used to find possible scenarios leading to biological cell states of interest. Applying the multi-object approach here is a challenging problem.		Hans-Dieter Ehrich	2005	ACM SIGSOFT Software Engineering Notes	10.1145/1082983.1083184	model checking;requirements analysis;specification language;temporal logic;computer science;state space;theoretical computer science;iterative and incremental development;formal semantics;data mining;mobile agent;finite-state machine;programming language;object-oriented programming;biological process;information system;algorithm	SE	-40.669491514978205	28.111872108995495	44476
4f55f3555a1ae6f8a7771dbf7d153516d85a1303	viewpoint consistency in odp	distributed system;object z;formal methods;qa 76 software;formal method;computer programming;standardisation;viewpoint consistency;consistency checking;lotos;open distributed processing	Open Distributed Processing (ODP) is a joint ITU/ISO standardisation framework for constructing distributed systems in a multi-vendor environment. Central to the ODP approach is the use of viewpoints for specification and design. Inherent in any viewpoint approach is the need to check and manage the consistency of viewpoints. In previous work we have described techniques for consistency checking, refinement, and translation between viewpoint specifications, in particular for LOTOS and Z/Object-Z. Here we present an overview of our work, motivated by a case study combining these techniques in order to show consistency between viewpoints specified in LOTOS and Object-Z.	distributed computing;language of temporal ordering specification;rm-odp;refinement (computing);view model;viewpoint	Eerke A. Boiten;Howard Bowman;John Derrick;Peter F. Linington;Maarten W. A. Steen	2000	Computer Networks	10.1016/S1389-1286(00)00114-6	real-time computing;formal methods;computer science;consistency model;computer programming;database;programming language	SE	-39.479451079199535	27.896325644663342	44519
0cbcb9641841a673ab68171e5f7d2e14368102cc	deriving feasible deployment alternatives for parallel and distributed simulation systems	dseep;parallel and distributed simulations;model transformations;software architecture;metamodeling;high level architecture	Parallel and distributed simulations (PADS) realize the distributed execution of a simulation system over multiple physical resources. To realize the execution of PADS, different simulation infrastructures such as HLA, DIS and TENA have been defined. Recently, the Distributed Simulation Engineering and Execution Process (DSEEP) that supports the mapping of the simulations on the infrastructures has been defined. An important recommended task in DSEEP is the evaluation of the performance of the simulation systems at the design phase. In general, the performance of a simulation is largely influenced by the allocation of member applications to the resources. Usually, the deployment of the applications to the resources can be done in many different ways. DSEEP does not provide a concrete approach for evaluating the deployment alternatives. Moreover, current approaches that can be used for realizing various DSEEP activities do not yet provide adequate support for this purpose. We provide a concrete approach for deriving feasible deployment alternatives based on the simulation system and the available resources. In the approach, first the simulation components and the resources are designed. The design is used to define alternative execution configurations, and based on the design and the execution configuration; a feasible deployment alternative can be algorithmically derived. Tool support is developed for the simulation design, the execution configuration definition and the automatic generation of feasible deployment alternatives. The approach has been applied within a large-scale industrial case study for simulating Electronic Warfare systems.	algorithm;simulation;software deployment	Turgay Çelik;Bedir Tekinerdogan;Kayhan M. Imre	2013	ACM Trans. Model. Comput. Simul.	10.1145/2499913.2499917	metamodeling;software architecture;real-time computing;simulation;computer science	Metrics	-41.72551409092855	22.177851590392354	44552
4a5d4d8a05b41393109fc8dae6dd47b780bbd8fb	reusable web services	reconfiguration;developpement logiciel;reconfiguracion;componente logicial;reutilizacion;service web;composant logiciel;web service;reuse;transmision asincronica;desarrollo logicial;component reuse;software development;software component;asynchronous transmission;transmission asynchrone;reutilisation;servicio web;dynamic configuration	Designing systems of asynchronous web services is challenging. Addressing the design in terms of component reuse helps address important questions that need to be answered if dynamic configuration of business solutions from web services is to be achieved. The fact that the components are web services doesn’t mean that all the problems of reuse have been solved. An architecture for dealing with reuse and dynamic reconfiguration, based on stateless services and stateful messages, is investigated. A notation for describing the flow of documents in such a system is introduced. This is shown to be effective at describing the behaviour of components, a necessary part of designing reusable components, especially those that participate in long-running, asynchronous interactions.	asynchronous i/o;interaction;state (computer science);stateless protocol;third-party software component;web service	Peter Henderson;Jingtao Yang	2004		10.1007/978-3-540-27799-6_15	web service;web modeling;real-time computing;computer science;control reconfiguration;component-based software engineering;software development;operating system;ws-policy;service-oriented architecture;asynchronous communication;ws-addressing;reuse;database;distributed computing;services computing;programming language;world wide web;computer security	SE	-40.648169361458855	24.344269479922538	44680
b9626134f727c67c28c5405873675ad34208d3f3	ulf-ware - an open framework for integrated tools for itu-t languages	simulation ordinateur;modelizacion;outil logiciel;alignement;software tool;verificacion modelo;langage modelisation;programa control;code generation;software systems;verification modele;program transformation;model transformation;program verification;transformation programme;language family;software engineering;familia lenguaje;modelisation;software architecture;verificacion programa;transformacion programa;analyse syntaxique;development environment;metamodel;model checking;metamodele;modelling language;lenguaje modelizacion;analisis sintaxico;metamodelo;syntactic analysis;model driven engineering;checking program;alineamiento;recouvrement ensemble;programme controle;software deployment;architecture basee modele;system development;simulacion computadora;set covering;cubierta conjunto;work in progress;verification programme;herramienta software;modeling;computer simulation;famille langage;model driven architecture;alignment;language model;architecture logiciel;model simulation;arquitectura basada modelo	Model driven engineering is a popular attempt to deal with the complexity of modern software systems. For the telecommunication sector a model driven approach means that you have to handle several ITU-T modelling languages in a single process to cover all aspects of telecommunication system development. Unfortunately, this is a difficult task, because the ITU-T languages are hard to use together. That is why the ITU-T started the Unified Language Family (ULF) initiative with the goal to unify the ITU-T language definitions and allow an easier alignment and integrated use of these languages. We present a tooling framework for those ULF languages: called ULF-ware. Our framework uses metamodelling and a shared use of common language concepts for a tight language integration. Around these language models it incorporates a set of tools to cover the various responsibilities of development environments such as program parsing, model checking, model transformation and code generation. This paper shows work in progress. We demonstrate our ideas on a tool chain for a subset of SDL. But the overall goal is an open framework that is extendable with other languages, even beyond ULF, and with tools for other software engineering tasks such as model simulation or software deployment.	abstract syntax notation one;code generation (compiler);extensibility;integrated development environment;language model;metamodeling;model checking;model transformation;model-driven engineering;modeling language;parsing;simple directmedia layer;simulation;software deployment;software engineering;software system;toolchain;unified modeling language;warez;way to go	Joachim Fischer;Andreas Kunert;Michael Piefel;Markus Scheidgen	2005		10.1007/11506843_1	computer simulation;metamodeling;model checking;software architecture;model-driven architecture;simulation;systems modeling;computer science;domain-specific language;third-generation programming language;parsing;work in process;development environment;fifth-generation programming language;software deployment;second-generation programming language;algorithm;code generation;language model;software system	SE	-42.038326622251674	25.733874132375927	44974
528af3e499a031ae928b5eb57e44e4c2d742cc0b	figures de transformation pour des architectures logicielles	modele reference;developpement logiciel;distributed system;systeme reparti;reference model;program transformation;systeme ouvert;transformation programme;software architecture;transformacion programa;sistema repartido;object oriented;desarrollo logicial;software development;architecture basee modele;oriente objet;open systems;sistema abierto;orientado objeto;model driven architecture;architecture logiciel;arquitectura basada modelo;modelo referencia	Reasoning about software architecture helps to improve design of applications. According to most of the software architects, architecture design has to be separated in different viewpoints. Nonetheless the transition between two viewpoints is not easy. In the DASIBAO methodology based on RM-ODP (Reference Model for Open Distributed Processing), there is a gap in the process to turn a functional architecture into a technical one. This paper presents a new concept, called architectural figure, which describes how to add technical concerns in a functional architecture and the mechanism to perform this transformation.		H. Tran;Laurence Duchien;Philippe Bedu;H. Nguyen;Jean Perrin	2005	L'OBJET	10.3166/objet.11.1-2.63-78	multilayered architecture;enterprise architecture framework;functional software architecture;reference architecture;software architecture;space-based architecture;reference model;database-centric architecture;computer science;engineering;applications architecture;artificial intelligence;software development;software engineering;solution architecture;software architecture description;open system;object-oriented programming;view model;algorithm;data architecture	Crypto	-41.418601850369534	25.376789036964468	45105
678b46b964e915c39ceab53144e55aa95ef48bbc	rest to javascript for better client-side development	api design;javascript api;conference;web services;web idl;javascript wrapper;rest api	In today's Web-centric era, embedded systems become mashup various web services via RESTful web services. RESTful web services use REST APIs that describe actions as resource state transfers via standard HTTP methods such as GET, PUT, POST, and DELETE. While RESTful web services are lightweight and executable on any platforms that support HTTP methods, writing programs composed of only such primitive methods is not a familiar concept to developers. Therefore, no single design strategy for (fully) RESTful APIs works for arbitrary domains, and current REST APIs are system dependent, incomplete, and likely to change. To help sever-side development of REST APIs, several domain-specific languages such as WADL, WSDL 2.0, and RDF provide automatic tools to generate REST APIs. However, client-side developers who often do not know the web services domain and do not understand RESTful web services suffer from the lack of any development help. In this paper, we present a new approach to build JavaScript APIs that are more accessible to client-side developers than REST APIs. We show a case study of our approach that uses JavaScript APIs and their wrapper implementation instead of REST APIs, and we describe the efficiency in the client-side development.	client-side;domain-specific language;embedded system;executable;hypertext transfer protocol;javascript;mashup (web application hybrid);representational state transfer;resource description framework;web application description language;web services description language;web service	Hyunghun Cho;Sukyoung Ryu	2014		10.1145/2567948.2579219	web service;web of things;web design;computer science;web api;operating system;service-oriented architecture;database;law;world wide web	SE	-47.156471913060166	19.891841196070196	45129
dd78a3be53db21a673ce92b81230ef093ff77629	object-oriented communication for distributed discrete event simulation	object oriented;discrete event simulation		simulation	Thomas Necker	1995			real-time computing;discrete event simulation;discrete event dynamic system;object-oriented programming;computer science	Theory	-36.07615731228152	28.095672317503173	45188
45616dd3a1d171ffd072f37be2c82f91598b825b	discovering optimal features using static analysis and a genetic search based method for android malware detection		Mobile device manufacturers are rapidly producing miscellaneous Android versions worldwide. Simultaneously, cyber criminals are executing malicious actions, such as tracking user activities, stealing personal data, and committing bank fraud. These criminals gain numerous benefits as too many people use Android for their daily routines, including important communi-cations. With this in mind, security practitioners have conducted static and dynamic analyses to identify malware. This study used static analysis because of its overall code coverage, low resource consumption, and rapid processing. However, static analysis requires a minimum number of features to efficiently classify malware. Therefore, we used genetic search (GS), which is a search based on a genetic algorithm (GA), to select the features among 106 strings. To evaluate the best features determined by GS, we used five machine learning classifiers, namely, Naïve Bayes (NB), functional trees (FT), J48, random forest (RF), and multilayer perceptron (MLP). Among these classifiers, FT gave the highest accuracy (95%) and true positive rate (TPR) (96.7%) with the use of only six features.		Ahmad Firdaus;Nor Badrul Anuar;Ahmad Karim;Mohd Faizal Ab Razak	2018	Frontiers of Information Technology & Electronic Engineering	10.1631/FITEE.1601491	mathematical optimization;naive bayes classifier;genetic algorithm;android (operating system);malware;code coverage;static analysis;machine learning;computer science;random forest;multilayer perceptron;artificial intelligence	SE	-35.42683980291411	23.168151835322785	45252
66a4cb3f31deb0a7ed25d7b9ad82a3378ab31f6d	suitability of active rules for model transformation	active rule;model transformation;model driven architecture	Model transformation promises faster and higher-quality system development processes by automating certain development steps. There are numerous proposals such as QVT and triple graph grammars that are applied in practical design environments. To our surprise, active rule systems have not yet been considered as a platform to execute model transformations. We investigate in this paper the suitability of active rule systems via a case study. An empirical analysis of the complexity is provided as well. It turns out that active rules support the basic functional requirements but some extensions to their execution engine and join order optimization would be needed.	event condition action;functional requirement;mathematical optimization;model transformation;qvt	Lingzhe Liu;Manfred A. Jeusfeld	2012			functional requirement;theoretical computer science;model transformation;computer science;monad (category theory);graph;rule-based machine translation	DB	-45.226424726239976	25.927509837910165	45365
11e5a0e4234b0a636feb056c60099378eb59c209	simulation graphical modeling and analysis (sigma) tutorial	computer graphics;discrete event simulation;graphical user interfaces;program processors;visual programming;sigma;discrete event simulation;discrete event worldviews;event scheduling;interactive graphics;logic diagrams;network flow process	SIGMA (Σ), an interactive graphics approach to teaching discrete event simulation, is described. Σ is specifically designed to make learning the fundamentals of simulation modeling easy. Σ can automatically translate a simulation model into Pascal or C source code that can be compiled and run on a wide variety of computers. It is possible to represent systems in all of the conventional discrete event worldviews with Σ. The viewpoint is the modeler's choice, not a dictate of the language. Σ combines the modeling advantages of using network flow process and logic diagrams with the generality and flexibility of explicit event scheduling. The complete source code for Σ-generated simulation models is available to students. Although Σ is elementary, it is completely general; any discrete event simulation (indeed, any computer program) can be created using Σ	simulation	Lee W. Schruben	1990			real-time computing;simulation;computer science;technical report;theoretical computer science;discrete event simulation;graphical model;programming language;computer graphics;logic;source code	Logic	-34.72305690466465	27.139788371923085	45393
ad5e817b7e592665e8221b8a3ad9264ad82dea68	a fipa-based communication infrastructure for a reconfigurable multi-robot system		This paper presents a high-level communication infrastructure to deal with dynamically changing reconfigurable multi-robot systems. The infrastructure builds upon official standards of the Foundation for Intelligent Physical Agents (FIPA). FIPA standards have been successfully applied in a variety of multi-agent frameworks, but they have found little application in the domain of robotics. This paper introduces an implementation that can complement existing robotic communication frameworks and allows the robotics community to take better advantage of multi-agent research efforts. We present the essential components of the infrastructure and show its interoperability using the widely known multi-agent framework JADE.	robot	Thomas M. Roehr;Satia Herfert	2015		10.1007/978-3-319-27146-0_51	converged infrastructure	Robotics	-40.86367489359571	20.777744880845272	45568
9c1c082799e105662888272126e52271e231e19b	on using pre and postconditions to tackle the aspect scheduling problem by rewriting systems: a design-level approach		The aspect-oriented paradigm promises separation of crosscutting concerns by modularizing them as aspects. This paradigm allows then weaving aspects upon some points in the base system. Unfortunately, the interaction of aspects may have an undesirable effect on each other and/or on the base system if they are executed in any order. Many works tried to solve this problem but the proposed solutions were either limited to some simple models of aspects or used to check if a set of temporal properties is preserved when aspects are introduced. In this paper, we propose a framework based on extended UML diagrams (class and state/transition diagrams) in order to make the detection of undesirable interaction more powerful and realistic. This framework relies on finite state automata (FSA); it transforms the interaction problem into a reachability issue. In fact, bad interaction is expressed as a generic LTL property which is independent of the system to be verified. This property can be checked using any model-checker like Maude. To concretize the proposed framework, we propose a rewriting system that allows an implicit construction of the FSA of the base system and the aspects in addition to the aspects composition and the weaving mechanism. Therefore, the proposed system defines a translation scheme of UML models into rewriting logic specifications written in Maude language. Thanks to the advances of the on-the-fly technique in Maude, the use of its LTL model-checker avoids a systematic exploration of all possible combinations of the aspects. The approach will be illustrated by a case study in order to explain how it works.	aspect-oriented software development;automata theory;cross-cutting concern;diagram;finite-state machine;maude system;model checking;postcondition;programming paradigm;reachability;rewriting;scheduling (computing);state transition table;syntax-directed translation;uml state machine;unified modeling language	Toufik Benouhiba;Amina Boudjedir	2014	Journal of Object Technology	10.5381/jot.2014.13.6.a1	real-time computing;computer science;distributed computing;algorithm	Logic	-41.589298463906886	29.026034511970526	45672
edd37e6d5fff0897c43155d22f39297f912d318e	object-based data flow testing of web applications	hypermedia markup languages;information resources;flow graphs object based data flow testing world wide web html documents;mission critical systems;application software;testing;object oriented programming;companies;flow graphs;html;program testing;web sites;object based data flow testing;sun;world wide web;data flow computing;program testing information resources hypermedia markup languages data flow computing object oriented programming;testing html companies web server application software computer science sun web sites flow graphs mission critical systems;web server;computer science;data flow;web technology;html documents	Recently, the extraordinary growth in the World Wide Web has been sweeping through business and industry. Many companies have developed or integrated their mission-critical applications using Web technologies. As Web applications become complex, testing Web applications becomes crucial. This paper extends traditional data flow testing techniques to Web applications. Several data flow issues for analyzing HTML documents in Web applications are discussed A test model that captures data flow lest artifacts of Web applications is presented In the test model, each component of a Web application is modeled as an object. The dataflow information of the Web application is captured using flow graphs. From the test model, dataflow test cases for the Web application then can be derived based on the intra-object, inter-object, and interclient perspectives.	dataflow architecture;html;mission critical;object-based language;test case;web application;world wide web	Chien-Hung Liu;David Chenho Kung;Pei Hsia;Chih-Tung Hsu	2000		10.1109/APAQ.2000.883773	web service;web modeling;data web;web analytics;web mapping;web-based simulation;web design;computer science;web navigation;data mining;database;web intelligence;world wide web;mashup	SE	-47.10902482063086	20.23669392817685	45802
62381549419e39fc8996bfc5c724b18542a55c26	electricity demand and population dynamics prediction from mobile phone metadata		Energy efficiency is a key challenge for building modern sustainable societies. World’s energy consumption is expected to grow annually by 1.6 %, increasing pressure for utilities and governments to fulfill demand and raising significant challenges in generation, distribution, and storage of electricity. In this context, accurate predictions and understanding of population dynamics and their relation to electricity demand dynamics is of high relevance.	mobile phone;population dynamics	Brian Wheatman;Alejandro Noriega;Alex Pentland	2016		10.1007/978-3-319-39931-7_19	multimedia;internet privacy;world wide web	ML	-34.52381564142811	18.515943195970486	45855
01e0cfa54c15fa4ec0e66699e156b3634809b4fe	vmc: recent advances and challenges ahead	behavioral variability;model checking;product families	The variability model checker VMC accepts a product family specified as a Modal Transition System (MTS) with additional variability constraints. Consequently, it offers behavioral variability analyses over both the family and its valid product behavior. This ranges from product derivation and simulation to efficient on-the-fly model checking of logical properties expressed in a variability-aware version of action-based CTL. In this paper, we first explain the reasons and assumptions underlying the choice for a modeling and analysis framework based on MTSs. Subsequently, we present recent advances on proving inheritance of behavioral analysis properties from a product family to its valid products. Finally, we illustrate challenges remaining for the future.	heart rate variability;model checking;simulation;spatial variability;transition system;variational monte carlo	Maurice H. ter Beek;Franco Mazzanti	2014		10.1145/2647908.2655969	model checking;computer science;operations management;algorithm	Logic	-44.051387452541796	28.83024901568435	45890
0158d8d99fbdcf38d6616d7e9d6c97c08a650345	session on conformance requirements and test purposes in the context of formal methods	formal method		conformance testing;formal methods;requirement	Dieter Hogrefe	1991			reliability engineering;formal methods;computer science;software engineering;programming language	SE	-46.31333558727513	30.933960662394604	46006
33bde3d6f8d2c541ad48fdd65640ececc3196d5d	from the specification to the implementation of norms: an automatic approach to generate rules from norms to govern the behavior of agents	norm;governance of multi agent system;multi agent system;implementation of norms;rule based system;specification of norms;dialogical action;non dialogical action;open multi agent systems	Open multi-agent systems composed of heterogeneous, autonomous and independently designed agents are usually governed by a set of norms. The established norms regulate the behavior of the agents by pointing out their permissions, prohibitions and obligations. This paper presents a normative language to specify norms and proposes the implementation of such norms by using a rule-based system. The implementation is achieved by automatically transforming the specification of each norm of the system into a set of rules used to govern the behavior of the agents according to the norm. The governance system is able to activate and deactivate norms, to point out the norms violations and fulfillments and to inform about punishments and rewards.	agent-based model;authorization;autonomous robot;emergence;formal language;graphical user interface;html;intelligent agent;jess;linear algebra;multi-agent system;observable;point of view (computer hardware company);rule-based system;software engineering;txl;transformer;undo	Viviane Torres da Silva	2008	Autonomous Agents and Multi-Agent Systems	10.1007/s10458-008-9039-8	rule-based system;computer science;knowledge management;artificial intelligence;multi-agent system;norm	AI	-42.79802220931065	20.09559153334974	46024
de2a90b4a93ff7256709ffc7eb01cc2613e4faac	an incremental refinement approach to a development of tmn protocol	rodin;event b;refinement;formal method;tmn protocol	The Tatebayashi, Matsuzaki and Newman (TMN) protocol is a key exchange cryptographic protocol for mobile communication systems. This paper presents an incremental formal modeling of the TMN protocol using Event-B method. We model in this paper the protocol step by step using refinement, a technique of Event-B. The first step will be the modeling of the most abstract specification of the protocol. Then by the second refinement more details of the protocol specification will be added to the model. By this approach, the model will be a more explicit representation of the target protocol by each refinement. In the developed Event-B models of the TMN protocol described in this paper, all proofs are generated and discharged by the Rodin tool.	automated theorem proving;b-method;consistency model;correctness (computer science);cryptographic protocol;cryptography;discharger;formal methods;key exchange;refinement (computing);rodin tool;telecommunications management network	Sanae El Mimouni;Mohamed Bouhdadi	2015	2015 11th International Conference on Information Assurance and Security (IAS)	10.1109/ISIAS.2015.7492758	real-time computing;computer science;database;distributed computing	Embedded	-33.997269508673185	31.69529190770798	46167
2d89dc3a40b326edb2aeff1b87dbf1153d5fb794	sdl design of a radio resource control protocol for 3g evolution systems with two different approaches	lenguaje programacion;programming language;software maintenance;metodo formal;resource management;methode formelle;developpement produit;specification language;formal method;maintenance logiciel;gestion recursos;lenguaje descripcion;radio resource control;langage programmation;gestion ressources;lenguaje especificacion;empirical evaluation;langage specification;desarrollo producto;langage description;description language;product development	Despite the increasing need of formal methods, people in the industry still hesitate to use them for product development because they are not sure of success with that novel approach in their own situation. In order to encourage those people we show our experience of designing a radio resource control protocol for ETRI's 3G evolution systems in SDL with two different approaches: pure-SDL and hybrid-SDL approaches. From our design and verification results, we make an empirical evaluation of those two approaches in several aspects and suggest a simple guideline for selecting an appropriate approach according to the situation.		Tae-Hyong Kim;Jae-Woo Kim;Qi-Ping Yang;Jae-Hyoung Lee;Soon-Gi Park;Yeun-Seung Shin	2006		10.1007/11951148_11	simulation;specification language;computer science;artificial intelligence;resource management;programming language;software maintenance;new product development	Embedded	-42.569029133834896	26.366401790611544	46213
b06eb16ad7f89133b5048a9d20393fbb102f64a5	web services composition by i/o data structure correspondences	service composition;i o data structure;workflow description;probability density function;input output programs;program synthesis web service service composition data structure;web services data structures service oriented architecture flowcharts web and internet services software engineering industrial relations automatic control control systems parallel processing;web service;program synthesis;data mining;skeleton;web service composition;web services data structures input output programs;data structures;web services composition;web services;service oriented architecture;program synthesis web services composition i o data structure workflow description;programming;data structure	The Web service composition from existing web services to obtain the more suitable service for application still is a highly complex task. We propose a method to combine existing web services with list of results as their output into more functional Web service with nested list of results, which seems to be synthesis of the existing web service results, as its output. The method requires no workflow description, like flowchart, but only data correspondences among data structures of existing and combined Web services, as composition specification.	business process execution language;correspondence rule;data structure diagram;flowchart;input/output;service composability principle;unified modeling language;web services description language;web service;world wide web	Qiushi Wang;Osamu Shigo	2009	2009 16th Asia-Pacific Software Engineering Conference	10.1109/APSEC.2009.31	web service;web development;web modeling;data web;web mapping;data structure;web design;web standards;computer science;ws-policy;social semantic web;data mining;ws-addressing;semantic web stack;database;programming language;ws-i basic profile;world wide web;mashup	SE	-46.6841336641421	20.202323500857982	46299
3f15db73069bafb0eb1f8e839af553d6372da69f	architectural concepts and design patterns for behavior modeling and integration	object oriented model;concept design;behavior modeling;intelligent control;software architecture;complex system;walking robot;polymorphism;design pattern;unified modeling language;complex behaviors;design patterns;software design pattern;finite state machine;object oriented modeling;control software	The design of the control software for complex systems is a difficult task. It requires the modeling, the simulation, the integration and the adaptation of a multitude of interconnected entities and behaviors. To tackle this complexity, the approach proposed consists in combining architectural concepts, Design Patterns and object-oriented modeling with unified modeling language (UML). In this context, the present paper describes a modeling framework to take greater advantage of these concepts and to design flexible, intelligible control software. It proposes to objectify the behaviors, which leads to a two-level architecture based on three concepts: resources software images of the controlled system-behaviors applied to these resources, and meta-behaviors, i.e. means for behavior integration and adaptation. Two Design Patterns are proposed to describe how to specify behaviors and define the means to combine and adapt them. The first pattern, Polymorphic Behavior, provides the means to define new behaviors for a system and to plug them dynamically. The second one, Structured Behavior, provides the means to use finite state machines for behavior switching. The originality of the framework is that it defines concepts, a UML-based notation and heuristics which specifies how to apply these concepts. To illustrate the elements mentioned, this paper uses the control software of a walking robot as a running example. © 2005 IMACS. Published by Elsevier B.V. All rights reserved.	behavior model;complex systems;content-control software;entity;finite-state machine;heuristic (computer science);mobile robot;simulation;unified modeling language	Jean-Marc Perronne;Laurent Thiry;Bernard Thirion	2006	Mathematics and Computers in Simulation	10.1016/j.matcom.2005.11.004	software design pattern;simulation;computer science;artificial intelligence;intelligent control	Robotics	-44.35155193526388	23.55954245468165	46662
e3f662614ebe586a96984545a655853a77fc62cd	addressing cross-tool semantic ambiguities in behavior modeling for vehicle motion control	formal specification;motion control;behavior modeling;software engineering;proof of concept;extended finite state machine;model based development;finite state machine	"""Emerging model-based development methods in the Automotive Vehicle Motion Control (VMC) domain are using different tools at various stages of the engineering process. Behavioral models created in various forms of finite state machines have to be exchanged across these tools, but semantic unknowns in modeling environments and semantic variations across tools preclude automated correct interpretation. This research presents an approach to address this issue through an unambiguous, math-based, tool-neutral extended finite state machine metamodel (eFSM) for behavior specifications in the automotive VMC domain. The semantics of the metamodel are anchored to formal specifications in a mathematical framework. Our approach requires modeling with commercial tool environments conforming to the eFSM. The conformance is enforced by exporting the tool native models into eFSM-conformant models and checking them against the well-formed rules encoded as OCL constraints in the eFSM. We have performed """"proof of concept"""" exercises with two commercial tools in transforming their native models into eFSM-conformant forms, and have been able to show that certain ambiguities in both tools can be prevented through the eFSM, promising higher confidence software engineering for the VMC domain."""		Sandeep Neema;Sushil Birla;Shige Wang;Tripti Saxena	2006		10.1007/978-3-540-70930-5_2	simulation;computer science;systems engineering;engineering drawing	Robotics	-45.40880773110924	29.536494910180345	46672
3353a88e26b11160b168daecb81a0c2f50bc88fe	conformance testing based on formal methods	formal method;conformance testing		conformance testing;formal methods	Dieter Hogrefe	1990			formal methods;computer science;conformance testing;programming language	Logic	-45.60807823201014	30.856083741745937	46678
a71571704301a47742e72ac2e422c921186df1d8	distributed process management system based on object-centered process modeling	distributed system;interfase usuario;systeme reparti;management system;base composition;concepcion sistema;user interface;distributed processing;software development process;process centered software engineering environment;ingenieria logiciel;software engineering;development environment;sistema repartido;software process model;system design;software development environment;software development;genie logiciel;interface utilisateur;process model;software reuse;conception systeme;gestion developpement logiciel;software development management;software process	Most of process-centered software engineering environments and those languages focus on how to produce the product. However, recent software development tend to require to focus on what should be made, because of emergence of various types of software developments; e.g., software reuse, component-based composition, and so on. To achieve this, we propose in this paper a new development environment named MonoProcess/SME, which is based on an object-centered software process model MonoProcess we also propose. MonoProcess consists of a set of objects which represent artifacts and resources in the software development. An object has attributes and methods, which represent characteristics and operations of the object, respectively. MonoProcess/SME is an software development environment for project management and development support, using the idea of MonoProcess modeling. MonoProcess/SME illustrates software development environment as it is, and provides an environment for software process execution, management, and improvement. This paper is submitted to WWCA98. Correspondence: Makoto Matsushita, Division of Software Science, Department of Informatics and Mathematical Science, Graduate School of Engineering Science, Osaka University, 1-3 Machikayenama, Toyonaka, Osaka 560, Japan. Phone: +81-6-850-6571, Facsimile: +81-6-850-6574, Email: matusita@ics.es.osaka-u.ac.jp	code reuse;component-based software engineering;email;emergence;enactive interfaces;informatics;integrated development environment;management system;process modeling;prototype;software development process;state transition table;tetsuo asano	Makoto Matsushita;Makoto Oshita;Hajimu Iida;Katsuro Inoue	1998		10.1007/3-540-64216-1_44	personal software process;verification and validation;software engineering process group;software sizing;software project management;computer science;package development process;backporting;social software engineering;software framework;component-based software engineering;software development;software design description;software construction;development environment;software walkthrough;empirical process;software deployment;goal-driven software development process;software development process;software system;software peer review	SE	-40.705353890636566	25.54351577487127	46916
7716d04c6e7f4c5f916011d0109d674dae7a8dd7	integrating formal specification and software verification and validation	developpement logiciel;liverpool;ciclo desarrollo;formal specification;life cycle;componente logicial;validacion;software verification;metodo formal;specification based testing;methode formelle;composant logiciel;specification programme;theory methods;repository;formal method;specification formelle;especificacion formal;formal verification;desarrollo logicial;software development;software component;cycle developpement;verification formelle;validation;university;enseignement;computer science;verification and validation;program specification;especificacion programa;teaching;ensenanza	It is not surprising that students are unconvinced about the benefits of formal methods if we do not show them how these methods can be integrated with other activities in the software lifecycle. In this paper, we describe an approach to integrating formal specification with more traditional verification and validation techniques in a course that teaches formal specification and specification-based testing. This is accomplished through a series of assignments on a single software component that involves specifying the component in Object-Z, validating that specification using inspection and a specification animation tool, and then testing an implementation of the specification using test cases derived from the formal specification.	component-based software engineering;formal methods;formal specification;object-z;software development process;software verification and validation;test case	Roger Duke;Tim Miller;Paul A. Strooper	2004		10.1007/978-3-540-30472-2_8	reference implementation;biological life cycle;software requirements specification;verification and validation;formal methods;specification language;formal verification;software verification;computer science;component-based software engineering;software development;product design specification;system requirements specification;analysis effort method;formal specification;refinement;programming language;programming language specification;language of temporal ordering specification;specification pattern	SE	-42.54964445218714	26.56028280816738	46959
ff9180ccdfea4cf2a51ed7085478554c2c8e2297	first steps towards conceptual schema testing	conference lecture	Like any software artifact, conceptual schemas of information systems can be tested. Testing conceptual schemas has some similarities with testing programs, but there are important differences. We present a list of six kinds of tests that can be applied to conceptual schemas. Some of them require complete schemas comprising both the structural and the behavioral parts, but we show that it is useful to test incomplete schema fragments. We introduce CSTL, a language for writing automated tests of executable schemas written in UML/OCL. We sketch the implementation of a test processor to automatically execute CSTL tests as many times as needed, following the style of the modern xUnit testing frameworks.	artifact (software development);conceptual schema;executable;information system;object constraint language;unified modeling language;xunit	Albert Tort;Antoni Olivé	2009			schema migration;computer science;database;programming language;algorithm	SE	-47.85610160932981	26.4417060737082	46990
9aa48696f8ff515da48c400189a8f192fa8b1455	samat - a tool for software architecture modeling and analysis		A software architecture specification plays a critical role in software development process. SAM is a general framework for developing and analyzing software architecture specifications. SAM supports the scalability of architectural descriptions through hierarchical decomposition and the dependability analysis of architectural descriptions using a dual formalism based on Petri nets and temporal logic. In this paper, we present SAMAT (Software Architecture Modeling and Analysis Tool), a tool to support the hierarchical modeling and analyzing of software architecture specifications in SAM. SAMAT nicely integrates two external tools PIPE+ for behavioral modeling using high-level Petri nets and SPIN for model checking system properties.	behavioral modeling;dependability;distributed computing;high- and low-level;model checking;open-source software;petri net;spin;scalability;semantics (computer science);software architecture;software development process;systems modeling;temporal logic	Su Liu;Reng Zeng;Zhuo Sun;Xudong He	2012			model checking;service-oriented modeling;computer science;software development process;systems engineering;petri net;software architecture;reference architecture;computer architecture;dependability;spin-½	SE	-42.36527055017475	32.163889445353256	47492
bddc0bc5174e6b3fc6294ab9d39442c111c1d0c2	a framework for the automatic verification of discrete-time matlab simulink models using boogie		Matlab/Simulink is a widely used industrial tool for the development of embedded systems, especially for the development of embedded controller software in automotive industries. Since such embedded systems are often deployed in safety critical areas where an error may lead to severe injuries and even to death of persons, comprehensive and complete quality assurance measures are required for ensuring their correctness in all possible cases. Still, incomplete techniques like testing are favored over safe formal techniques in practice. Although there exist some formal verification approaches for Matlab/Simulink models that can guarantee correctness, they are either poorly automated or suffer from scalability issues. To overcome this problem, we present an approach for a highly automated verification framework for Matlab/Simulink models that enables the formal verification of discrete-time controller models. Our main idea is to use inductive verification techniques in combination with an automatic extraction of verification goals for a number of important run-time error classes to provide an automatic verification flow. Furthermore, as automatic model reduction technique, we present a slicing approach for Matlab/Simulink. With that, we increase the scalability by dividing a possibly complex verification task into a number of less complex subtasks. To enable the automatic verification of Matlab/Simulink models, we present a formal semantics for discrete-time models based on a mapping of the informally defined sequential simulation semantic into the formally well defined intermediate verification language Boogie2. Together with automatically generated invariants and verification goals that are automatically weaved into the formal model, this mapping enables the verification of the models using the Boogie verification framework and inductive verification techniques. To achieve a high degree of automation, we also support inductive verification over more than one simulation step (k-induction), which allows for weaker invariants that can be generated automatically at the price of decreased scalability. To overcome scalability issues for k-induction, we use our novel slicing technique for Matlab/Simulink models to automatically reduce a model to those blocks that are relevant for a (possible) error at a particular block. Furthermore, we propose a process for the efficient use of our verification and slicing techniques. To show the practical applicability of our framework, we have implemented our approach as the MeMo tool suite and applied our verification process to two industrial case studies. With that, we demonstrate the performance and the capability to automatically verify a given model for the absence of important run-time errors with our verification framework for discrete-time Matlab/Simulink models.	correctness (computer science);embedded controller;embedded system;existential quantification;formal language;formal methods;formal verification;inductive reasoning;matlab;memo model;run time (program lifecycle phase);scalability;semantics (computer science);simulation;simulink	Robert Reicherdt	2015			computational science;computer science;programming language;computer engineering	SE	-40.25185113661462	31.787179009074137	47696
0505e9c714a81cf40d8f589215fbcab573a6c626	a retrospective view of fa/c distributed problem solving	cooperative control;modelizacion;distributed system;agent interaction;systeme reparti;computation theory;search problems computation theory distributed processing planning artificial intelligence problem solving;distributed processing;planning artificial intelligence;intelligence artificielle;resolucion problema;modelisation;decomposition tâche;sistema repartido;task decomposition;satisficing cooperative control functionally accurate cooperative paradigm asynchronous co routine exchange data directed control computation theory distributed problemsolving system partial results cooperative control mechanisms coordinating agents goal directed control dynamic metalevel information partial global planning distributed search local control;distributed search;artificial intelligence;distributed problem solving;search problems;inteligencia artificial;modeling;traitement reparti;organizational structure;problem solving;resolution probleme;problem solving bandwidth computer networks helium optical wavelength conversion computer science knowledge based systems research initiatives distributed computing resource management;tratamiento repartido	The Functionally-Accurate, Cooperative (FA/C) paradigm provides a model for task decomposition and agent interaction in a distributed problem-solving system. In this model, agents need not have all the necessary information locally to solve their subproblems, and agents interact through the asynchronous, co-routine exchange of partial results. This model leads to the possibility that agents may behave in an uncoordinated manner. This paper traces the development of a series of increasingly sophisticated cooperative control mechanisms for coordinating agents. They include integrating dataand goal-directed control, using static meta-level information specified by an organizational structure, and using dynamic meta-level information developed in partial global planning. The framework of distributed search motivates these developments. Major themes of this work are the importance of sophisticated local control, the interplay between local control and cooperative control, and the use of satisficing cooperative control. Ongoing and new directions for research in FA/C systems are presented.	consensus dynamics;control system;coroutine;distributed web crawling;fractional anisotropy;problem solving;programming paradigm;tracing (software)	Victor R. Lesser	1991	IEEE Trans. Systems, Man, and Cybernetics	10.1109/21.135681	organizational structure;mathematical optimization;simulation;systems modeling;theory of computation;computer science;artificial intelligence;machine learning;control theory;distributed computing	AI	-39.19226306797365	19.510087809622735	47818
1278a7a14f0e99d89f7a47baf0b908fc8b7652f2	earning benefits of the object-oriented paradigm in dynamic system simulation	sequences;program reuse;object oriented methods;application software;building block;array model;model structure;differential equation;semantics;dynamic system;computational modeling;adaptation model;difference equations;object oriented;adaptive arrays;model structure object oriented paradigm dynamic system simulation difference equations differential equations semantics program reuse coupled models array model dynamic adaptation;differential equations;coupled models;dynamic system simulation;dynamic adaptation;object oriented modeling computational modeling differential equations adaptation model discrete event simulation context modeling sequences application software adaptive arrays difference equations;context modeling;object oriented modeling;digital simulation;object oriented paradigm;discrete event simulation;difference equations digital simulation object oriented methods differential equations	We discuss the relevance of object-orientation in the field of dynamic system simulation. Difference and differential equations are the well known methods to describe the structure and behavior of such systems. Traditionally, these descriptions are directly translated into computer programs. This approach, though computationally efficient, shows several drawbacks: The semantics of a model are buried, model and program reuse is limited. We show how the application of the object-oriented paradigm can help to overcome these drawbacks. The work is based on an environment which supports the classical concept of coupled models as well as a novel “building block”, the so-called array model consisting of a series of structurally compatible components (i.e., instances of the same model class or subclasses thereof) in parallel corresponding to the individuals of a set to be modeled. As the number of components in an array model may vary over time, this concept allows for dynamic adaptation of a model’s structure.	algorithmic efficiency;computer program;dynamic simulation;dynamical system;ecology;message passing;programming paradigm;relevance;systems modeling;universal instantiation;whole earth 'lectronic link	Martin Hitz;Hannes Werthner	1997		10.1109/HICSS.1997.663203	real-time computing;simulation;computer science;theoretical computer science;semantics;differential equation	SE	-36.29381043269163	26.703846388986797	47842
aa262808f17cc86387890a14e38d3bb317d944fb	from requirements to a restful web service: engineering content oriented web services with rest		This chapter presents an approach for proceeding from a set of require- ments to an implemented RESTful Web service for content oriented systems. The requirements are captured into a simple domain model and then refined into a resource model. The resource model re-organizes the domain concepts into address- able entities: resources and interconnecting links, hypermedia representations, URIs and default HTTP operations and status codes. The approach has emerged from the experiences gained during developing RESTful Web services at Nokia Research Center.	representational state transfer;requirement;web service	Petri Selonen	2011		10.1007/978-1-4419-8303-9_11	computer science;database;multimedia;world wide web	Web+IR	-47.72488831747064	21.21044016334357	47868
8e2cfa699a21a4d330ddcff277a4d5b710bb8942	synthesis of communications protocols: an annotated bibliography	protocol design;development process;automatic generation;communication protocol;requirement specification;protocol engineering	Protocol synthesis attempts to formalize and automate the process of designing communications protocols. Protocol design is an important step in the communications software or protocol engineering development process. Protocol synthesis has been addressed extensively by many researchers around the world, and various approaches have been proposed: from the stepwise refinement of a high level requirements specification to the automatic generation starting from a formal service specification. In this paper, we introduce protocol synthesis in the context of the protocol engineering process, and we briefly describe and survey the main features of the proposed synthesis methods. Tables summarizing this survey are also provided.	asynchronous circuit;asynchronous system;communications protocol;entity;high-level programming language;internet information services;llvm;liveness;nil;petri net;powerflasher fdt;refinement (computing);requirement;service-oriented device architecture;simple directmedia layer;software requirements specification;stepwise regression;temporal logic;top-down and bottom-up design	Kassem Saleh	1996	Computer Communication Review	10.1145/242896.242900	communications protocol;computer science;database;software development process;computer network	SE	-40.90742608824145	30.554420091367117	47927
6b8dc1a9cfeb62e52ee62b3b3d4395cf604b6800	j-sim: an integrated environment for simulation and model checking of network protocols	telecommunication computing digital simulation formal verification protocols;routing protocols;protocols;simulation and modeling;state space methods;network protocol;prototypes;telecommunication computing;integrated environment model checking network protocols network simulator;network simulator;software architecture;network protocols;computational modeling;formal verification;model checking;routing protocols java computational modeling computer simulation safety buildings performance analysis state space methods prototypes software architecture;integrated environment;safety;performance analysis;computer simulation;buildings;digital simulation;java	In this paper, we report our work on extending the J-Sim network simulator to be an integrated environment for both simulation and model checking of network protocols. We also present a case study in which we model-checked AODV in J-Sim.	communications protocol;comparison of command shells;complex network;model checking;requirement;simulation;software bug	Ahmed Sobeih;Mahesh Viswanathan;Darko Marinov;Jennifer C. Hou	2007	2007 IEEE International Parallel and Distributed Processing Symposium	10.1109/IPDPS.2007.370519	computer simulation;communications protocol;real-time computing;computer science;theoretical computer science;network simulation;distributed computing;programming language;computer network	Embedded	-35.90562089855266	31.158628893359026	48196
86ff76a6d657df3d811a27bddf948e42f2a7b046	verification algorithm of evidence life cycles in extended uml activity diagrams	activity diagram;document handling;extended uml activity diagram;unified modeling language floors helium toy industry information technology software engineering computer errors redundancy;life cycle;evidence verification algorithm;formal verification;unified modeling language;unified modeling language document handling formal verification;unified modeling language extended uml activity diagram evidence verification algorithm	"""In this paper, we introduce an algorithm called """"EVA"""" (Evidence Verification Algorithm), which verifies consistency of life cycles of evidence-documents in workflows. As syntax of workflows, we use extended UML activity diagrams, which have additional information about evidence-documents. EVA verifies the existence of consistent sequences of flows between occurrences of evidence-documents in a workflow. It is significant to verify consistency of life cycles of evidence-documents, since one can find some defects of a workflow itself by checking inconsistent life cycles of evidence-documents in the workflow."""	activity diagram;algorithm;database;directed acyclic graph;eva (benchmark);enterprise software;unified modeling language;verification and validation	Osamu Takaki;Takahiro Seino;Izumi Takeuti;Noriaki Izumi;Koichi Takahashi	2007	International Conference on Software Engineering Advances (ICSEA 2007)	10.1109/ICSEA.2007.84	unified modeling language;biological life cycle;package diagram;communication diagram;activity diagram;formal verification;systems modeling language;uml tool;computer science;systems engineering;theoretical computer science;applications of uml;class diagram;database;programming language;node	SE	-45.75471499214963	28.232194674295183	48548
856602111504efd5bd22a87ed4f24a929a04ed90	statistical model checking for hybrid petri nets with multiple general transitions		The modeling formalism of hybrid Petri nets allows investigating the dependability of e.g. critical infrastructures with hybrid characteristics. Hybrid Petri nets can model random delays with so-called general transitions. Approaches for analyzing such Petri nets are available for models with one or two general transitions, which change the discrete marking of the system by firing only once. We extend the formalism to more general transitions that possibly fire multiple times. This work provides a definition of the probability space for the evolution of hybrid Petri nets over time and presents an efficient approach to discrete-event simulation. Statistical Model Checking techniques are introduced to verify complex properties on hybrid Petri nets. The presented methods are implemented in Java and we show their feasibility in a case study that also serves to validate our results.	computation;dependability;formal system;item unique identification;java;model checking;petri net;simulation;statistical model;steady state	Carina Pilch;Anne Remke	2017	2017 47th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)	10.1109/DSN.2017.41	discrete event simulation;petri net;computer science;theoretical computer science;distributed computing;hybrid system;statistical model;stochastic petri net;process architecture;java;dependability	EDA	-36.49425254105888	30.333983046926114	48712
c81eb5aaa2744f9d8d976c62d41b77d4fddc155d	validation, verification and testing: procedures in the life cycle of knowledge-based systems	knowledge based system;life cycle		knowledge-based systems	Cathérine Martin-Mattei	1991			knowledge-based systems;reliability engineering;computer science	HCI	-46.86778136793007	31.740180505889306	48877
5df39fd990d91376ba961ab00225d648cd4ca213	uml-based approach for network qos specification	distributed system;network design;systeme reparti;lenguaje uml;specification;function point;langage modelisation unifie;qualite service;sistema repartido;especificacion;unified modelling language;network management;point of view;quality of service;service quality;calidad servicio	New applications require Quality of Service from networks. Managing QoS increases even more the complexity of networks. Network development techniques must apprehend this complexity from a functional point of view but also from QoS point of view. The object paradigm and UML in particular can help reducing the network design complexity. In this paper, we propose a language formally defined and compliant with the object paradigm, intended to specify QoS in networked environments.	quality of service;unified modeling language	Cédric Teyssié;Zoubir Mammeri	2005		10.1007/978-3-540-31956-6_33	network management;unified modeling language;network planning and design;real-time computing;mobile qos;quality of service;computer science;function point;applications of uml;database;specification;service quality;computer network	Theory	-39.562102371104096	26.82656308645956	48927
8d35c364c9200ccf881839da0f74a7dbf7a83160	on the quantitative analysis of agent-oriented models	modelizacion;software metrics;utilisation information;uso informacion;multiagent system;belief;sistema experto;organisation entreprise;orientado agente;information use;metrique logiciel;analisis cuantitativo;oriente agent;information organization;enterprise organization;modelisation;goal oriented modeling;organizacion informacion;organizacion empresa;croyance;reingenieria;predictability;analyse quantitative;reingenierie;organisation information;quantitative analysis;agent oriented;expert knowledge;predictabilidad;information system;systeme expert;intencion;external research report;creencia;sistema multiagente;predictabilite;modeling;reengineering;business process reengineering;systeme information;intention;information system development;systeme multiagent;sistema informacion;expert system	Goaland agent-oriented models are used in organization and information system modelling as a formalism aimed at providing intentional descriptions of processes as a network of relationships among actors. As such, they capture and represent goals, dependencies, intentions, beliefs, alternatives, etc., that appear in several contexts: business process reengineering, information system development, etc. In this paper, we are interested in the definition of a quantitative framework for the analysis of the properties that these models exhibit. Indicators and metrics for these properties are defined in terms of the model elements (e.g., actors, dependencies, scenario paths, etc.). Our approach is basically quantitative in nature, which allows defining indicators and metrics that can be reused in many contexts. However, a qualitative dimension can be introduced if trustable expert knowledge is available; the extent up to which quantitative and qualitative aspects are intertwined can be determined in every single case. We apply our proposal to the i* notation and we take as main case study a highly-intentional property, predictability of model elements.		Xavier Franch	2006		10.1007/11767138_33	business process reengineering;computer science;systems engineering;engineering;knowledge management;management;expert system	SE	-41.73245648499451	24.32258363871507	49170
61392bfa396f4d6de94c4639682e6688de47e990	multi-agent system based on psychological models for mobile robots		We describe the design of Intelligent Agents and experimenting with learning environments in mobile robotics, using new technologies such as the Knowledge Query and Manipulation Language (KQML), and new features of the Jade programming language, for the creation of distributed applications such as Remote Method Invocation (RMI). A society of intelligent agents could solve these problems. These agents would be able to migrate from one node to another, the ability to communicate with other agents, using an expressive communication language, work together cooperatively to accomplish complex objectives for a user, act on their own initiative and use local information and knowledge to manage resources and requirements of other agents. Most existing software ignores the fact that generally the tasks performed by an individual are part of collective activities. There is individual work, is working with third-group contributions and consensus with others, is why the support systems to collaborative work are presented as a particular need for the development of future software and intelligent agents, as an essential component design and implementation.	mobile robot;multi-agent system	Arnulfo Alanis Garza;Oscar Castillo;José Mario García Valdez	2011		10.1007/978-3-642-15534-5_9	agent architecture;simulation;computer science;knowledge management;artificial intelligence;machine learning	Robotics	-41.52473474546817	19.461420771206193	49468
3399fef769e712b6e71a376d8e8dbd791ad220c7	bit-precise formal verification of discrete-time matlab/simulink models using smt solving	automotive engineering;model analysis;model analysis matlab simulink formal verification;safety critical software automotive engineering formal verification;formal verification;safety critical software;automotive domain bit precise formal verification discrete time matlab simulink model smt solving model based development embedded systems safety critical application formal verification technique input language uclid system verification bounded model checking inductive invariant checking automatic verification variable overflow variable underflow industrial design;matlab simulink;matlab mathematical model model checking semantics computational modeling vectors	Matlab/Simulink is widely used for model-based development of embedded systems. In particular, safety-critical applications are increasingly designed in Matlab/Simulink. At the same time, formal verification techniques for Matlab/Simulink are still rare and existing ones do not scale well. In this paper, we present an automatic transformation from discrete-time Matlab/Simulink to the input language of UCLID. UCLID is a toolkit for system verification based on SMT solving. Our approach enables us to use a combination of bounded model checking and inductive invariant checking for the automatic verification of Matlab/Simulink models. To demonstrate the practical applicability of our approach, we have successfully verified the absence of one of the most common errors, i. e. variable over- or underflow, for an industrial design from the automotive domain.	arithmetic underflow;embedded system;formal verification;matlab;model checking;model-driven engineering;simulink;simultaneous multithreading;uclid	Paula Herber;Robert Reicherdt;Patrick Bittner	2013	2013 Proceedings of the International Conference on Embedded Software (EMSOFT)	10.1109/EMSOFT.2013.6658586	real-time computing;verification;formal verification;computer science;theoretical computer science;programming language;functional verification	Embedded	-39.98818164173506	31.84873287296971	49545
b0b80c865ac82eab0ae4637a35ebc216d5ec4bcf	modelling and verification of concurrent programs using uppaal		This paper describes the design and implementation of a library of reusable UPPAAL template processes which support reasoning and property checking of concurrent programs, e.g. to be realized in the Java programming language. The stimulus to the development of the library originated in the context of a systems programming undergraduate course. The library, though, can be of help to general practitioners of concurrent programming which nowadays are challenged to exploiting the potentials of modern multicore architectures. The paper describes the library and demonstrates its usage to modelling and exhaustive verification of mutual exclusion and common concurrent structures and synchronizers. UPPAAL was chosen because it is a popular and continually improved toolbox based on timed automata and model checking and it is provided of a user-friendly graphical interface which proves very important for debugging and property assessment of concurrent models. Java was considered as target implementation language because of its diffusion among application developers.	active oberon;automata theory;concurrency (computer science);concurrent computing;control system;correctness (computer science);debugging;experiment;graphical user interface;java;model checking;multi-core processor;mutual exclusion;object language;programming language;prototype verification system;system programming;tla+;timed automaton;uppaal;usability	Franco Cicirelli;Libero Nigro;Francesco Pupo	2011		10.7148/2011-0525-0533	programming language;debugging;model checking;toolbox;system programming;concurrent computing;java;mutual exclusion;graphical user interface;computer science	Logic	-39.622304063416685	31.812532067023355	49654
70b732deaf66dda855116a2a7eaafd5a852ea723	mining suspicious tax evasion groups in a corporate governance network		There is a new tendency for corporations to evade tax via Interest Affiliated Transactions (IAT) that are controlled by a potential “Guanxi” between the corporations’ controllers. At the same time, the taxation data is a classic kind of big data. These issues challenge the effectiveness of traditional data mining-based tax evasion detection methods. To address this problem, we first coin a definition of controller interlock, which characterizes the interlocking relationship between corporations’ controllers. Next, we present a colored and weighted network-based model for characterizing economic behaviors, controller interlock and other relationships, and IATs between corporations, and generate a heterogeneous information network-corporate governance network. Then, we further propose a novel Graph-based Suspicious Groups of Interlock based tax evasion Identification method, named GSG2I, which mainly consists of two steps: controller interlock pattern recognition and suspicious group identification. Experimental tests based on a real-world 7-year period tax data of one province in China, demonstrate that the GSG2I method can greatly improve the efficiency of tax evasion detection.	big data;corporate governance;data mining;evasion (network security);interlock (engineering);pattern recognition;weighted network	Wenda Wei;Zheng Yan;Jianfei Ruan;Qinghua Zheng;Bo Dong	2017		10.1007/978-3-319-65482-9_33	control theory;weighted network;computer science;distributed computing;guanxi;computer security;interlock;interlocking;colored;big data;corporate governance	ML	-35.92678976161346	21.789851264932366	49782
25ea089500cc1a8d463a8af394e9f36200fc24c7	a generic tool for tracing executions back to a dsml's operational semantics	translational semantics;original dsml;execution result;analysis tool;targeted language;domain specific modeling language;modeldriven engineering;operational semantics;generic tool;code generation;process modeling language	The increasing complexity of software development requires rigorously defined domain specific modeling languages (dsml). Modeldriven engineering (mde) allows users to define a dsml’s syntax in terms of metamodels. The behaviour of a language can also be described, either operationally, or via transformations to other languages (e.g., by code generation). If the first approach requires to redefine analysis tools for each dsml (simulator, model-checker...), the second approach allows to reuse existing tools in the targeted language. However, the second approach (also called translational semantics) imply that the results (e.g., a program crash log, or a counterexample returned by a model checker) may not be straightforward to interpret by the users of a dsml. We propose in this paper a generic tool for formally tracing such analysis/execution results back to the original dsml’s syntax and operational semantics, and we illustrate it on xSPEM, a timed process modeling language.	algorithm;aspect-oriented software development;automated theorem proving;code generation (compiler);compiler;crash (computing);directory services markup language;domain-specific language;domain-specific modeling;kermeta;metamodeling;model checking;model transformation;modeling language;operational semantics;petri net;process modeling;software development	Benoît Combemale;Laure Gonnord;Vlad Rusu	2011		10.1007/978-3-642-21470-7_4	computer science;theoretical computer science;programming language;algorithm	SE	-43.45586930990674	28.06676671272891	49803
3728aa27ca42d4753666a3e76e6422b11893f57e	test-driven specification: paradigm and automation	specification based testing;functional coverage;specification language;specification driven testing;model based testing;state box;decision table	This paper introduces test-driven specification, whereby the specification process is aided by the use of test cases. We also introduce an automated tool, the test-driven specification assistant (TDSA), which supports this approach. Test cases reveal specification anomalies such as incorrectness, incompleteness and ambiguity. Specification-based test coverage criteria are applied to reveal deficiencies in the set of test cases. Decision tables are used as a lightweight specification language capable of modeling black-box and Mills' state box specifications.	black box;decision table;fault coverage;programming paradigm;specification language;test case	Edward L. Jones	2006		10.1145/1185448.1185641	reliability engineering;software requirements specification;specification language;computer science;systems engineering;software engineering;system requirements specification;analysis effort method;formal specification;functional specification;programming language specification;language of temporal ordering specification;specification pattern	SE	-46.24827025164974	31.869909951841247	49908
eeeb6bf205928007bc17da3135ddbadafaf45061	coordinating agents plans in multi-agent systems using colored petri nets	multi agent system;formal model;coordination mechanisms;colored petri nets;dependency;agent plan;coordination mechanism;colored petri net	Applying coordination mechanisms to handle interdependencies that exist between agents in multi-agent systems (MASs), is an important issue. In this paper, two levels MAS modeling scheme and a language to describe a MAS plan based on interdependencies between agents' plans are proposed. Initially a generic study of possible interdependencies between agents in MASs is presented, followed by the formal modeling (using Colored Petri Nets) of coordination mechanisms for those dependencies. These mechanisms control the dependencies between agents to avoid unsafe interactions where individual agents' plans are merged into a global multi-agent plan. This separation, managed by the coordination mechanisms, offers more powerful modularity in MASs modeling.	multi-agent system;petri net	Maryam Nooraee Abadeh;Kamran Zaminifar;Mohammad-Reza Khayyambashi	2008		10.1007/978-3-540-89674-6_4	dependency;simulation;computer science;artificial intelligence;multi-agent system;petri net	AI	-41.7803047955187	20.32475722987402	49944
c8c528bc0d14c08d055f301c0aef317656552d17	spark annotations within executable uml	developpement logiciel;modelizacion;anotacion;ada;lenguaje uml;generation code;integrable system;generacion codigo;code generation;langage modelisation unifie;integrite;annotation;integridad;modelisation;integrity;unified modelling language uml;desarrollo logicial;unified modelling language;software development;software industry;ada language;modeling	The emergence in the software industry of the Unified Modelling Language (UML) has led to the question as to whether it may be used to complement existing development techniques for high integrity systems. Work is in progress to develop a code generator for SPARK Ada from the executable UML (xUML) subset. This paper concentrates on the work completed, which enables the utilisation of SPARK annotations within xUML models for a prototype code generator. The code generated by this prototype has been successfully analysed using the SPARK toolset.	executable uml;spark;unified modeling language	Damian Curtis	2006		10.1007/11767077_7	unified modeling language;integrable system;systems modeling;ada;computer science;software development;applications of uml;database;programming language;algorithm;code generation	NLP	-42.00282096851701	25.837177780747226	50111
ec68d9fe65413d71f128b6129d879e751bb949e7	extraction of classes through the application of formal concept analysis	fca;object oriented;class hierarchy engineering;formal concept analysis	The class hierarchy is one of the most important activities of the object-oriented software development. The class design and its hierarchy is a difficult task especially when what is sought is an extensive and complex modeling. Some problems are difficult to understand even when modeled using a methodology. The precise construction of a class hierarchy requires deep understanding of the problem, a correct identification of attributes and methods, their similarities, dependencies and specializations. An inaccurate or incomplete class hierarchy entails manufacturing defects of the software, making it difficult to maintain or make corrections. The Formal Concept Analysis provides a theory which enables troubleshoot hierarchy of classes to accomplish the maximum factoring of classes while preserving the relationships of specialization. This paper presents an approach to the application of Formal Concept Analysis theory in class factoring to simplify the design stages of new classes. A framework was developed to support experiments.	class hierarchy;experiment;formal concept analysis;integer factorization;partial template specialization;software development	Decius Pereira;Luis E. Zárate;Mark A. J. Song	2014		10.5220/0004892302750282	computer science;formal concept analysis;artificial intelligence;machine learning;data mining;concept class;object-oriented programming;algorithm	SE	-46.339900228423545	25.24639303660896	50194
1b41445bc8497792898c676db7d0c98956fe3a10	derri common reference model for distributed energy resources - modeling scheme, reference implementations and validation of results	simulation;real-time simulation;portability;exchangeability;data model;smart grids;common reference model;distributed energy resources	One main issue in current research activities regarding power distribution networks is the grid operation with a high penetration of Distributed Energy Resources (DER), particularly renewable sources from wind, solar or biomass, characterized by intermittent and only partially predictable production. In fact, in order to keep power quality and grid stability in presence of great amount of variable production from renewable sources, a large effort is necessary to control the distributed power generators and/or the energy demand (i.e., loads and storages). The exchange and reuse of DER dynamic simulation models between different users is very complicated today. In fact, heterogeneous models are used for representing component models, which are normally described for a particular simulation environment, contain different levels of details and are difficult to compare. In order to improve sharing of simulation models the project partners of the European DERri project have developed a standardized modeling schema and exchange format called Common Reference Model (CRM). This approach and specification is suited to study the DER-grid interactions, in dynamic conditions, under various simulation scenarios and time horizons. Within this work, rules and procedures for modeling DER components in simulation environments in an implementation independent representation based on the CRM specification are proposed. In addition, some reference implementations are presented which are validated by comparing simulation results in different platforms.	agent-based model;documentation;electric power quality;experiment;interaction;mathematical model;real-time clock;reference implementation;reference model;simula;simulation language;software portability;test case	Filip Andren;Felix Lehfuss;Peter Jonke;Thomas I. Strasser;Evangelos Rikos;Panos Kotsampopoulos;Panayiotis Moutis;Federico Belloni;Carlo Sandroni;Carlo Tornelli;Alberto Villa;Anastasia Krusteva;Rad Stanev	2014	Elektrotechnik und Informationstechnik	10.1007/s00502-014-0231-z	control engineering;real-time computing;engineering;grid parity;smart grid;intermittent energy source	HPC	-37.57782857452716	22.03956709394309	50242
abd1df07f28e1e7a9f938242f47b700023ff2836	reasoning about safety and progress using contracts	distributed system;data exchange;component framework	Designing concurrent or distributed systems with complex architectures while preserving a set of high-level requirements through all design steps is not a trivial task. Building upon a generic notion of contract framework which relies on a component framework and two refinement relations: conformance and refinement under context, we provide a condition under which circular reasoning can be used for checking dominance, i.e. refinement between contracts. We then propose an instantiation of such a contract framework for safety and progress requirements in component systems with data exchange. This allows us to prove non-trivial properties of a protocol for tree-like networks.	concurrent computing;conformance testing;distributed computing;high- and low-level;refinement (computing);requirement;universal instantiation	Imene Ben Hafaiedh;Susanne Graf;Sophie Quinton	2010		10.1007/978-3-642-16901-4_29	data exchange;computer science;data mining	PL	-39.109624236878226	29.763623214556404	50264
abbde21f62a9ffc21b25fcf712b47df3ca6a3bfb	formally designing web services for mobile team collaboration	internet;formal specification;formal verification;groupware;middleware;mobile computing;web services;formal specification;formal verification;middleware;mobile team collaboration	We illustrate a symbiotic relationship between existing model oriented specification techniques and Web services. Through the formal re-design of a platform for mobile team collaboration, we investigate the suitability of existing formal specification and verification techniques to Web services. In general, this preliminary work suggests that a lot is still to be done on understanding the computational behavior of Web services, hence on specifying and verifying them.	business process execution language;daml-s;data modeling;formal specification;formal verification;human-readable medium;middleware;software system;stepwise regression;verification and validation;web service;xml	Schahram Dustdar;Pascal Fenkam	2004	Proceedings. 30th Euromicro Conference, 2004.	10.1109/EURMIC.2004.1333408	web service;middleware;web development;web modeling;formal methods;web standards;computer science;knowledge management;ws-policy;formal specification;ws-addressing;database;services computing;ws-i basic profile;world wide web	SE	-46.49740533212811	18.821360362045702	50280
5fb49517510bcc8e5bf892a52271307f3b167f5e	efficient controllability analysis of open nets	formal model;process verification and validation;business process analysis;business process management;interaction protocol;state explosion;petri nets;formal models in business process management;verification and validation;petri net;data structure	A service is designed to interact with other services. If the service interaction is stateful and asynchronous, the interaction protocol can become quite complex. A service may be able to interact with a lot of possible partner services, one partner or no partner at all. Having no partner surely is not intended by the designer. But the stateful interaction between services can be formalized and thus analyzed at design time. We present a formalization which is centered around a graph data structure that we call interaction graph, which represents feasible runs of a partner service according to the interaction protocol. As interaction graphs suffer from state explosion, we introduce a set of suitable reduction rules to alleviate the complexity of our approach. As our case studies show we are able to analyze the interaction behavior of a service efficiently.	data structure;directed acyclic graph;graph (abstract data type);input/output;interaction design;interaction protocol;partial order reduction;state (computer science)	Daniela Weinberg	2008		10.1007/978-3-642-01364-5_14	simulation;data structure;computer science;distributed computing;programming language;petri net	HCI	-41.09352788029655	30.51420511596304	50381
4f1980ba798c7b4a203e5d56354dfab5299950e0	abstractions on test design techniques	generators;iso standards;testing;engines;unified modeling language;uml testing profile utp model based testing mbt test generation automated test design test design techniques;adaptation models;program testing program diagnostics;model based test design test design techniques abstractions automated test design test artifacts test cases formal test basis test generator test coverage goal;unified modeling language generators iso standards testing adaptation models engines	Automated test design is an approach to test design in which automata are utilized for generating test artifacts such as test cases and test data from a formal test basis, most often called test model. A test generator operates on such a test model to meet a certain test coverage goal. In the plethora of the approaches, tools and standards for model-based test design, the test design techniques to be applied and test coverage goals to be met are not part of the test model, which may easily lead to difficulties regarding comprehensibility and repeatability of the test design process. This paper analyzes current approaches to and languages for automated model-based test design and shows that they are lacking important information about the applied test design techniques. Based on this analysis, we propose to introduce another layer of abstraction for expressing test design techniques in a tool-independent, yet generic way.	abstraction layer;automata theory;concatenation;fault coverage;holism;model-based testing;profile (uml);repeatability;requirement;seamless3d;test automation;test case;test data;test design;turing test;twisted pair;unified modeling language	Marc-Florian Wendland	2014	2014 Federated Conference on Computer Science and Information Systems	10.15439/2014F316	keyword-driven testing;test plan;unified modeling language;exploratory testing;model-based testing;simulation;computer science;automatic test pattern generation;test suite;software testing;system under test;test method;test script;test case;test management approach;test harness	SE	-45.854179715866366	32.14480400107496	50440
d70678e608a33247a870d885b81fd2079e4b114d	coordination of many agents	lenguaje programacion;programmation logique avec contrainte;concurrent language;multiagent system;syntax;architecture systeme;constraint logic programs;blackboard architecture;distributed agents;programming language;active database;programmation reactive;programacion logica con restriccion;semantics;distributed programs;syntaxe;semantica;semantique;declenchement;triggering;software architecture;induccion;shared knowledge;coordination agent;langage programmation;arquitectura sistema;constraint logic programming;sintaxis;system architecture;sistema multiagente;architecture logiciel;systeme multiagent;knowledge base	This paper presents a reactive programming and triggering framework for the coordination of a large number of distributed agents with shared knowledge. At the heart of this framework is a highly structured shared store in the form of a constraint logic program (CLP), which is used as a knowledge base and being reacted to by agents through the use of “reactors”. The biggest challenge arising from such a reactive programming framework using CLP is to develop a trigger mechanism that allows efficient “wakeup” of blocked reactors. This paper addresses the architecture of this open framework, and discusses a general methodology for doing triggering of logic conditions using views and abstractions.	knowledge base;logic programming;reactive programming	Joxan Jaffar;Roland H. C. Yap;Kenny Q. Zhu	2005		10.1007/11562931_10	constraint logic programming;blackboard system;software architecture;knowledge base;real-time computing;syntax;computer science;artificial intelligence;database;distributed computing;semantics;linguistics;programming language;algorithm	AI	-38.70531345021585	24.24707548397516	50446
d2ce1316aa2e5db0afed2ea26323913f67d7b4c2	structuring product-lines: a layered architectural style	developpement logiciel;concepcion modular;layered architecture;software systems;product line;industrial production;desarrollo logicial;product line architecture;software development;software package;modular design;progiciel;structure produit;product structure;conception modulaire	A product-line is a set of software systems sharing the same architecture and implementation platform. Based on an analysis of several industrial product-lines, a general layered model is proposed as the main structuring principle of a product-line. It is demonstrated that the model can be used to explain and clarify several existing product-line architectures.	software system	Tommi Myllymäki;Kai Koskimies;Tommi Mikkonen	2002		10.1007/3-540-46102-7_50	multilayered architecture;industrial production;reference architecture;software architecture;computer science;multitier architecture;software development;software architecture description;resource-oriented architecture;modular design;software system;systems design	SE	-41.42029077655856	25.45637516362388	50574
3543d3f889ece918435092b7de91d0ad5e52e25a	a goal-oriented approach for modelling self-organising mas	dynamic change;bottom up;goal orientation;multi agent system;software agent;agent oriented software engineering;adaptive behaviour;adaptive system;networked systems;emergent behaviour	Autonomous software agents provide a promising solution to the needs of decentralised networked systems, able to adapt their behaviour in a complex and dynamically changing environment. Current agent-oriented software engineering methodologies tend to focus on different levels to realise such a self-adapting behaviour, namely the agent individual level and the global system level. The first requires to design a goal-directed agent behaviour, the second to design agents able to optimize their coordination with other peer agents in the organization, giving rise to system-level adaptation. In this paper we propose to extend a goal-oriented engineering methodology to deal with the modelling of organisations that are able to self-organise in order to reach their goals in a changing environment. To deliver on this aim, we combine Tropos4AS, an extension of TROPOS for adaptive systems, with concepts, guidelines and modelling steps from the ADELFE methodology, which provides a bottom-up approach for engineering collaborative multi-agent societies with an emergent behaviour. The resulting MAS has self-adaptation properties, having agents that are able to change their behaviour according to changes in the environment, and having organisations that adapt themselves to changing needs. The approach is illustrated by modelling a collaborative multi-agent system for conference management.	adaptive system;agent-oriented software engineering;bottom-up parsing;emergence;goal modeling;modeling language;multi-agent system;requirement;requirements analysis;self-organization;software agent;software development process;synergy;top-down and bottom-up design;traceability	Mirko Morandini;Frédéric Migeon;Marie Pierre Gleizes;Christine Maurel;Loris Penserini;Anna Perini	2009		10.1007/978-3-642-10203-5_4	simulation;systems engineering;engineering;knowledge management;multi-agent system	AI	-43.59728748237452	20.603516164688426	50976
0c1d823fb0696def691b6b6e03b8c831789fb68a	designing and specifying mobility within the multiagent systems engineering methodology	interaction refinements;design model;agent protocol descriptions;multiagent system;mobility;and deadlock detection;agent oriented software engineering;object oriented programming;software engineering;computer applications;mobile agent system;clones;java programming language;top down approach;artificial intelligence;mobile agent;methodology;models;parallel processing	Recently, researchers have created many platforms and applications for mobile agents; however, current Agent-Oriented Software Engineering (AOSE) methodologies have yet not fully integrated the unique properties of these mobile agents. This paper attempts to bridge the gap between current AOSE methodologies and mobile agent systems by incorporating mobility into the established Multiagent Systems Engineering (MaSE) methodology. We accomplished this by adding a move command to the MaSE analysis models and then defined the required transformations to incorporate the required functionality into the design. Finally, we translated the design models into Java-based agents that operate within a mobile agent environment.	agent-based model;agent-oriented software engineering;java;mobile agent;multi-agent system;systems engineering	Athie L. Self;Scott A. DeLoach	2003		10.1145/952532.952545	parallel processing;simulation;computer science;artificial intelligence;operating system;software engineering;top-down and bottom-up design;methodology;mobile agent;cloning;database;distributed computing;computer applications;programming language;object-oriented programming;mobile computing	SE	-40.26677694197936	27.8277800048333	51277
bca4e7112a402a14b927772fd66b86959a768161	a feature selection and evaluation scheme for computer virus detection	classification method feature selection scheme computer virus detection antivirus system digital signature machine learning heuristic method data mining approach;viruses medical data mining learning systems writing feature extraction information technology machine learning computer viruses performance evaluation testing;heuristic method;data mining;antivirus system;computer viruses;computer virus detection;machine learning;digital signature;feature extraction;computer virus;classification method;pattern classification;pattern classification computer viruses data mining feature extraction learning artificial intelligence;feature selection;data mining approach;learning artificial intelligence;feature selection scheme	Anti-virus systems traditionally use signatures to detect malicious executables, but signatures are over-fitted features that are of little use in machine learning. Other more heuristic methods seek to utilize more general features, with some degree of success. In this paper, we present a data mining approach that conducts an exhaustive feature search on a set of computer viruses and strives to obviate over-fitting. We also evaluate the predictive power of a classifier by taking into account dependence relationships that exist between viruses, and we show that our classifier yields high detection rates and can be expected to perform as well in real-world conditions.	antivirus software;computer virus;data mining;executable;feature selection;heuristic;machine learning;malware;overfitting	Olivier Henchiri;Nathalie Japkowicz	2006	Sixth International Conference on Data Mining (ICDM'06)	10.1109/ICDM.2006.4	computer science;machine learning;pattern recognition;data mining;feature selection;computer virus	DB	-35.16558559878678	23.09461270141287	51284
7d06cf5d73c21f2a6d68b38b4074d73224484f1a	model of adaptive learning objects for virtual enviroments	adaptive learning object;virtual education	This article presents a Model of an Adaptive Learning Object (MOAA) for virtual environments from a definition of Adaptive Learning Object, and a proposition of extension of the LOM standard to specify the adaptation metadata. The MASINA methodology and the UML diagrams are used to describe it. The model specifies modularly and independently two categories of rules, of adaptation and conversion, giving it versatility and flexibility to perform different types of adaptation to the learning objects, incorporating or removing rules in each category.	diagram;modular programming;unified modeling language;virtual reality	Carlos Guevara;José Aguilar	2016	2016 XLII Latin American Computing Conference (CLEI)	10.1109/CLEI.2016.7833352	computer science;knowledge management;artificial intelligence;machine learning	Visualization	-46.381920957115305	23.844613643559114	51286
20dfed1906be3106bb6d2f76ff60404ad0839c37	developing state diagrams using a state specialization technique	statecharts;state identification methods;system design;unified modeling language;integrity constraints;state diagram;state specialization	A state diagram models the dynamic aspect of a class or a system, representing its behavior over its lifetime. Our survey shows that there are few systematic methods of developing state diagrams. In this paper, we present a systematic method of developing state diagrams using a state specialization technique. Our method identifies meaningful states of a target class before a state diagram is constructed. We use three state-identification rules statevalued attributes, association paths, and conditions stated in integrity constraints. By using our technique, system designers will be able to systematically identify interesting and meaningful states.	class diagram;data integrity;experiment;partial template specialization;state diagram;usability	Il-Yeol Song;Ki Jung Lee	2007		10.1007/978-3-540-76292-8_11	state diagram;unified modeling language;state diagram;communication diagram;computer science;class diagram;data integrity;database;systems design	SE	-43.162795179866016	28.14517749135359	51470
53b6eff04f77beae64b2cbbf2e68a54679ecd6ea	an organic architecture for traffic light controllers	network management	Efficient control of traffic networks is a complex but important task. A successful network management vitally depends on the abilities of the traffic light controllers to adapt to changing traffic situations. In this paper a control architecture for traffic nodes is presented that is inspired by the principles of Organic Computing. It allows a node to quickly adapt to changing traffic situations and enables it to autonomously learn new control strategies if necessary.	evolutionary algorithm;organic computing;self-organization	Fabian Rochner;Holger Prothmann;Juergen Branke;Christian Müller-Schloer;Hartmut Schmeck	2006			organic computing;architecture;computer engineering;network management;control engineering;engineering	Networks	-36.923104642816945	20.82338487452545	51504
836f42a1ee778b31d967168e60f9d934845ceaae	performance modelling and optimization for video-analytic algorithms in a cloud-like environment using machine learning	cctv;thesis;machine learning;algorithms	CCTV cameras produce a large amount of video surveillance data per day, and analysing them require the use of significant computing resources that often need to be scalable. The emergence of the Hadoop distributed processing framework has had a significant impact on various data intensive applications as the distributed computed based processing enables an increase of the processing capability of applications it serves. Hadoop is an open source implementation of the MapReduce programming model. It automates the operation of creating tasks for each function, distribute data, parallelize executions and handles machine failures that reliefs users from the complexity of having to manage the underlying processing and only focus on building their application. It is noted that in a practical deployment the challenge of Hadoop based architecture is that it requires several scalable machines for effective processing, which in turn adds hardware investment cost to the infrastructure. Although using a cloud infrastructure offers scalable and elastic utilization of resources where users can scale up or scale down the number of Virtual Machines (VM) upon requirements, a user such as a CCTV system operator intending to use a public cloud would aspire to know what cloud resources (i.e. number of VMs) need to be deployed so that the processing can be done in the fastest (or within a known time constraint) and the most cost effective manner. Often such resources will also have to satisfy practical, procedural and legal requirements. The capability to model a distributed processing architecture where the resource requirements can be effectively and optimally predicted will thus be a useful tool, if available. In literature there is no clear and comprehensive modelling framework that provides proactive resource allocation mechanisms to satisfy a user’s target requirements, especially for a processing intensive application such as video analytic. In this thesis, with the hope of closing the above research gap, novel research is first initiated by understanding the current legal practices and requirements of implementing video surveillance system within a distributed processing and data storage environment, since the legal validity of data gathered or processed within such a system is vital for a distributed system’s applicability in such domains. Subsequently the thesis presents a comprehensive framework for the performance		Manal N. K. Al-Rawahi	2016			robot learning;instance-based learning;computer science;artificial intelligence;theoretical computer science;online machine learning;machine learning;computational learning theory;active learning	OS	-34.65838163558321	19.656814891975447	52019
b25b165806983d5a2b49dabf5a7345ac09922899	checking concurrent behavior in uml/ocl models	software;concurrent computing;standards;contracts;computational modeling;unified modeling language;complex systems;unified modeling language contracts concurrent computing computational modeling standards software complex systems	The Unified Modeling Language (UML) is a defacto standard for software development and, together with the Object Constraint Language (OCL), allows for a precise description of a system prior to its implementation. At the same time, these descriptions can be employed to check the consistency and, hence, the correctness of a given UML/OCL model. In the recent past, numerous (automated) approaches have been proposed for this purpose. The behavior of the systems has usually been considered by means of sequence diagrams, state machines, and activity diagrams. But with the increasing popularity of design by contract, also composite structures, classes, and operations are frequently used to describe behavior in UML/OCL. However, for these description means no solution for the validation and verification of concurrent behavior is available yet. In this work, we propose such a solution. To this end, we discuss the possible interpretations of “concurrency” which are admissible according to the common UML/OCL interpretation and, afterwards, propose a methodology which exploits solvers for SAT Modulo Theories (i. e., SMT solvers) in order to check the concurrent behavior of UML/OCL models. How to address the resulting problems is described and illustrated by means of a running example. Finally, the application of the proposed method is demonstrated.	activity diagram;computational model;concurrency (computer science);correctness (computer science);design by contract;modulo operation;object constraint language;satisfiability modulo theories;sequence diagram;software development;unified modeling language;verification and validation	Nils Przigoda;Christoph Hilken;Robert Wille;Jan Peleska;Rolf Drechsler	2015	2015 ACM/IEEE 18th International Conference on Model Driven Engineering Languages and Systems (MODELS)	10.1109/MODELS.2015.7338248	unified modeling language;complex systems;real-time computing;concurrent computing;systems modeling language;uml tool;computer science;applications of uml;class diagram;database;programming language;computational model;node;object constraint language	SE	-43.17110170656274	30.75433341939257	52030
fe6ff0c0b966ed4f2255c1187f043a55b3448144	integrating a formal specification method with pml: a case study	formal specification;object oriented systems;modelling language;process modelling	This paper outlines a Case Study of the application of one approach to the Formal Specification of Parallel Object Oriented Systems to a Process Modelling language. The purpose was to both check whether such an approach was feasible and useful and also to give insight into the ongoing design of such Process Modelling Languages.	formal specification;modeling language	Jin Sa;Brian Warboys	1992		10.1007/BFb0017510	natural language processing;formal methods;object language;specification language;formal verification;systems engineering;formal specification;refinement;programming language;programming language specification;language of temporal ordering specification	SE	-45.40717289595023	29.049589039094254	52083
08f5ec3d5fc2b2cbe8cbd1768b1bd65a98fb1326	an abstract architecture for computational reflection in multi-agent systems	multi agent system;cognition abstract architecture computational reflection multiagent system logic programming;computer architecture reflection multiagent systems cognition computer science protocols laboratories computational modeling terminology autonomous agents;cognition multi agent systems software architecture logic programming;computer model;computational reflection;software architecture;multi agent systems;logic programming;cognition	We propose a general framework for computational reflection in multi-agent systems and address some technical issues related to its implementation. Potentials of computational models of cognition and reflection in a multi-agent system are detailed, and using such models, an abstract architecture of a reflective agent is designed. We also propose important characteristics of reflective multi-agent systems build upon the presented architecture.	cognition;cognitive model;computation;computational model;multi-agent system;reflection (computer programming)	Martin Rehák;Jan Tozicka;Michal Pechoucek;Filip Zelezný;Milan Rollo	2005	IEEE/WIC/ACM International Conference on Intelligent Agent Technology	10.1109/IAT.2005.35	enterprise architecture framework;reference architecture;computer architecture;simulation;computer science;applications architecture;artificial intelligence;theoretical computer science;view model;systems architecture;systems design	Robotics	-40.19674909508467	20.120275056734787	52197
16f1fc15794595e58631063ed63c78c8ca177be8	control of connected and automated vehicles: state of the art and future challenges		Autonomous driving technology pledges safety, convenience, and energy efficiency. Challenges include the unknown intentions of other road users: communication between vehicles and with the road infrastructure is a possible approach to enhance awareness and enable cooperation. Connected and automated vehicles (CAVs) have the potential to disrupt mobility, extending what is possible with driving automation and connectivity alone. Applications include real-time control and planning with increased awareness, routing with micro-scale traffic information, coordinated platooning using traffic signals information, eco-mobility on demand with guaranteed parking. This paper introduces a control and planning architecture for CAVs, and surveys the state of the art on each functional block therein; the main focus is on techniques to improve energy efficiency. We provide an overview of existing algorithms and their mutual interactions, we present promising optimization-based approaches to CAVs control and identify future challenges.		Jacopo Guanetti;Yeojun Kim;Francesco Borrelli	2018	Annual Reviews in Control	10.1016/j.arcontrol.2018.04.011	engineering;automation;systems engineering;control engineering;architecture;efficient energy use	Robotics	-34.03896371862624	20.659246758759956	52709
2f7079f59a9b0cb06f7c033bc2653e73e8461e7f	using a process modeling language for the design and implementation of process-driven applications	design process;distributed software infrastructures;multiplayer gaming;separation of concern;yawn language;web service;modeling language;expressive power;support system;software architecture;multiplayer gaming process modeling language process driven software architectures distributed software infrastructures web service orchestration platforms process driven applications yawn language;process driven software architectures;design and implementation;specification languages;distributed programming;process modeling language;web services;process driven applications;business process management;workflow management system;engines computer architecture application software software architecture web services process design proposals workflow management software service oriented architecture computer science;process model;computer games;web services computer games distributed programming software architecture specification languages;web service orchestration platforms	Process driven software architectures are establishing themselves as prominent examples of distributed software infrastructures. Workflow Management Systems, web service orchestration platforms, Business Process Management support systems are relevant instances of process driven software architectures all of which, as the name suggests, are characterized as having a process perspective. In this paper we show that a (well designed) process modeling language and its execution engine can address the process perspective in different architectures and be (re)used among different application domains resulting in useful tools for the design and the implementation of process-driven applications. This can be achieved by maximizing the suitability of such a language via high expressive power and good separation of concerns. We also show sample process driven architectures, addressing different application domains, that are built with it.	application domain;business process execution language;business process;distributed computing;liveness;logic programming;management system;modeling language;network topology;no silver bullet;orchestration (computing);process modeling;reachability;reference implementation;rule 90;rule-based system;semantics (computer science);separation of concerns;software architecture;software engineering;transition system;web service;yet another	Davide Rossi;Elisa Turrini	2007	International Conference on Software Engineering Advances (ICSEA 2007)	10.1109/ICSEA.2007.81	web service;computer science;systems engineering;business process management;software engineering;process driven development;process control;distributed computing;programming language;business process modeling	SE	-46.80040048175698	23.381870256172583	53067
2df9fbd06fa5fac4f3f8f3e61747b1dce2b19f34	jsim: a java-based simulation and animation environment	discrete event simulation computer animation digital simulation;databases jsim java based simulation and animation environment queues serverbays graphical designer query driven simulation simulation models;java animation object oriented modeling computational modeling libraries discrete event simulation databases computer science buildings information retrieval;computer animation;simulation model;digital simulation;graphic design;discrete event simulation	In this paper, we present JSIM, a Java-based simulation and animation environment being developed at the University of Georgia. The JSIM library includes many Java classes to make developing simulation models easy. A model is constructed by building a graph with nodes (e.g. Queues and ServerBays) and edges (e.g. Transports). A model of moderate complexity can be constructed with minimal effort. Furthermore, in a future release of JSIM, much of the code will be created by a graphical designer. Using the built-in features of JSIM, the design diagram may be animated when the simulation is run. A novel aspect of the environment is that it follows the principles of Query Driven Simulation for the purpose of storing and retrieving simulation models and results in databases.	applet;c++;code generation (compiler);diagram;documentation;emergence;entity;graph (discrete mathematics);graphical model;graphical user interface;jdbc;jam;java;javadoc;mini sql or msql;persistence (computer science);persistent data structure;relational database management system;singlet fission;web-based simulation;world wide web	John A. Miller;Rajesh S. Nair;Zhiwei Zhang;Hongwei Zhao	1997		10.1109/SIMSYM.1997.586473	graphic design;simulation;computer science;theoretical computer science;discrete event simulation;simulation modeling;computer animation;programming language;computer graphics (images)	DB	-33.95821732396832	26.35611602465802	53201
677cd83e56ee6586ecaeffec3d288cb7db7cf544	a compositional operational semantics for owl-s	encapsulation;developpement logiciel;evaluation performance;semantica operacional;groupware;ontologie;business process execution language;performance evaluation;compositional semantic;red www;service orientation;evaluacion prestacion;metodo formal;operational semantics;reseau web;methode formelle;service web;composicionalidad;abstraction;encapsulacion;specification programme;web service;abstraccion;semantique compositionnelle;orientado servicio;formal method;standardisation;semantique operationnelle;lenguaje descripcion;internet;compositionnalite;desarrollo logicial;web ontology language;compositionality;software development;semantica composicional;workflow;world wide web;ontologia;arquitectura modular;oriente service;process model;program specification;collecticiel;modular architecture;ontology;composition operator;especificacion programa;langage description;architecture modulaire;servicio web;service oriented;software composition;description language	Software composition via workflow specifications has received a great deal of attention recently. One reason is the high degree of fit with the encapsulation of software modules in service-oriented fashion. In the Industry, existing workflow languages have been merged to form WS-BPEL, the Business Process Execution Language for Web Services. In the Research community OWL-S, a ontology for web services, has been submitted for standardisation alongside OWL, the Web Ontology Language in which it is expressed. The OWL-S Process Model is based on an abstraction of the common features of industrial workflow languages. On the one hand, WS-BPEL has only informal semantics; on the other, the type of semantics given to ontology-based work tends to be structural rather than computationally oriented. As a result the semantics developed for DAML-S, which led to OWL-S, are still deficient in some regards. In this paper we shall survey the existing semantics and introduce a novel semantics for the latest version of OWL-S that is focussed on the principle of compositionality, so far not tackled.	business process execution language;correctness (computer science);daml-s;dual in-line package;encapsulation (networking);function composition (computer science);haskell;owl-s;ontology (information science);open-source software;operational semantics;process modeling;service-oriented architecture;service-oriented device architecture;virtual machine;web ontology language;web service	Barry Norton;Simon Foster;Andrew Hughes	2005		10.1007/11549970_22	web service;workflow;the internet;business process execution language;formal methods;encapsulation;type erasure;computer science;composition operator;software development;operating system;ontology;formal semantics;process modeling;database;function composition;abstraction;programming language;web ontology language;well-founded semantics;operational semantics;world wide web;owl-s;denotational semantics;standardization;principle of compositionality;computational semantics	AI	-41.34767032848002	25.270216676429126	53521
109b427bccdcde87cd4986375b2e9020ba19b5d6	an on-line model verification system for model-based control algorithms		The advanced control algorithms are often based on a mathematical model of the controlled plant and the performance of the control system largely depends on the accuracy of the plant model. However, simplified phenomenological or linear models are often used in practice. Because, the accuracy of these models may differ and vary over time, it is proposed a model verification system. Its main goal is the on-line verification of the accuracy of two plant models. The system is based on a concept of cooperating agents, which are distributed over several controllers. As a result, the proposed solution can be implemented in already existing industrial control systems, where each of the programmable logic controllers (PLCs) performs its basic tasks. The verification system has been implemented and tested on the several distributed PLCs.	algorithm	Tomasz Klopot;Piotr Skupin;Witold Klopot;Piotr Gacki	2015		10.1007/978-3-319-24132-6_25	verification and validation of computer simulation models;software verification;high-level verification;runtime verification;intelligent verification	Robotics	-36.57726433308826	29.40293370484067	53595
42cf6d3376fb93a0a62618fff4f3b592b550c278	mda and analysis of web applications	gestion integrada;modelizacion;gestion integree;gestion entreprise;modele entreprise;virosis;navegacion informacion;infeccion;red www;sistema critica;lenguaje uml;navigation information;systeme critique;logic;sida;reseau web;information browsing;firm management;abstraction;traitement thermique;integrated management;langage modelisation unifie;langage ocl;interpretacion abstracta;modelo empresa;abstraccion;sistema reactivo;discriminant analysis;analyse discriminante;uml class diagram;modelisation;business model;analisis discriminante;surface treatment;critical system;internet;object oriented;unified modelling language;traitement surface;heat treatment;reactive system;systeme reactif;architecture basee modele;oriente objet;world wide web;aids;administracion empresa;platform independent model;enterprise system;information system;interpretation abstraite;abstract interpretation;viral disease;infection;modeling;tratamiento superficie;orientado objeto;virose;model driven architecture;systeme information;logique;logica;object constraint language;lenguaje forzado objeto;arquitectura basada modelo;tratamiento termico;sistema informacion	Enterprise systems are mission critical. As a result, ensuring their correctness is of primary concern. This paper aids to the analysis of Web Applications, focusing on the aspects related to the interaction of business logic and Web browsers. The method adopted is based on the Model Driven Architecture. First, the Platform Independent Model of Web Applications is refined to create a new model called Abstract Description of Interaction (ADI). An ADI is a UML class diagram annotated with OCL statements to represent an abstraction of the interaction between the thin client and the business logic. Secondly, the ADI model is automatically transferred to an Alloy model and analysed using the Alloy Analyser.	alloy analyzer;business logic;class diagram;correctness (computer science);e-commerce;enterprise system;mission critical;model-driven architecture;platform-independent model;software bug;thin client;unified modeling language;web application	Behzad Bordbar;Kyriakos Anastasakis	2005		10.1007/11681885_5	business model;enterprise system;web modeling;simulation;reactive system;computer science;artificial intelligence;abstraction;linear discriminant analysis;logic;information system;object constraint language	SE	-41.783391650198325	25.998483910009455	53614
663bff3321821f6f96ae621763ec12409522a446	integrating user operations in multichannel hypermedia	multi channel;uml;web operations;services on the web;conceptual modelling;design framework;ocl;context	"""Web Applications are progressively becoming multi-channel and cross-channel. The """"same"""" service should be made available in different delivery environments and devices. A user may invoke a service on one device, suspend it, and complete its execution in another one. In this paper we provide the reader with the main concepts and innovative aspects of MC2 a design framework for specifying Multi/Cross Channel web application services. MC2 adopts an high-level, end user perspective and exploits the notion of context, to characterize who, where and how an operation can be invoked."""	exploit (computer security);high- and low-level;hypermedia;web application	Franca Garzotto;Vito Perrone	2003		10.1145/900051.900066	web service;unified modeling language;web development;web modeling;web design;computer science;web navigation;database;web 2.0;world wide web;object constraint language	Web+IR	-47.485778558564625	21.45154916568896	54008
309d49e8c36cee94c7cad0dbf46b30b7c8fa250d	modeling advanced manufacturing systems using concurrent logic programming	fabrication;modelizacion;lenguaje programacion;systeme commande;sistema control;concurrent logic programming;fabricacion;protocole transmission;programming language;prolog;machine outil;atelier flexible;concurrent program;logical programming;productique;modelisation;protocolo transmision;control system;programmation logique;flexible manufacturing system;programa competidor;manufacturing;langage programmation;robotica;maquina herramienta;sistema flexible produccion;machine tool;robot;programacion logica;modeling;manufacturing system;computer integrated manufacturing;programme concurrent;transmission protocol	Abstract   Modern manufacturing systems are complex systems composed of the following components: numerically controlled manufacturing machines, automated material handling systems, and a computerized control system that supervises the operation of the manufacturing system. In order to operate properly there must be a sophisticated, hierarchical communication layer among the components.  It is desirable to have a tool that can capture all aspects of the manufacturing system, thus being able to model, simulate, analyze and even drive it. The modeling of concurrent asynchronous operations of a complex information intensive manufacturing system has today very limited tools.  This paper presents a new approach towards modeling of Advanced Manufacturing Systems (AMS). The modeling vehicle is a dialect of concurrent logic programming language called FCP (Flat Concurrent Prolog). This approach, in addition to the more commonly modeled features, enables the modeler to capture the dynamic nature of a system including conflicts, deadlocks, communication protocols, concurrency and information transfer.	concurrent logic programming	David Ben-Arieh;I. Miron	1990	AI in Engineering	10.1016/0954-1810(90)90034-2	manufacturing execution system;robot;real-time computing;simulation;systems modeling;process development execution system;computer science;engineering;control system;artificial intelligence;machine tool;computer-integrated manufacturing;manufacturing;fabrication;prolog	AI	-38.02420873176124	25.607692681293	54010
ff4798dffe5410f83a79e7e25f24f663471008f7	implementation of parameterized net classes with the petri net kernel of the »petri net baukasten«	petri net	"""We show in this paper how the formalism of Parameterized Net Classes is realized with the Petri Net Kernel. Parameterized Net Classes are an abstract notion of Petri nets using formal parameters to express Petri net type characteristics. This formalism allows the abstract formulation of formal concepts for a large variety of Petri net types. The Petri Net Kernel is a tool infrastructure supporting an easy implementation of Petri net algorithms. Moreover, the Petri Net Kernel is not restricted to a fixed Petri net type. Instead, only the net type has to be implemented as """"net type specification"""". It is then used as basis for implemented application algorithms. In our paper we describe an implementation of the formal net type parameters via an interface such that the parameter implementation can be transformed to a net type specification for the Petri Net Kernel. This allows on the one hand a simple change of the net type by selecting a different combination of the actual net type parameters. On the other hand, applications (like simulation or analysis algorithms) can be developed generically, i.e. independently of the Petri net type, thus supporting rapid prototyping for Petri net tools. The implementation is embedded in the development of the ?Petrinetz-Baukasten? and is therefore closely related to the contributions [3,8,24] in this volume."""	kernel (operating system);petri net	Claudia Ermel;Michael Weber	2001		10.1007/3-540-45541-8_4	discrete mathematics;stochastic petri net;computer science;theoretical computer science;distributed computing;petri net	Vision	-37.866366134443375	30.06854408600407	54246
8b935d3b038a2bca65c26311a815c5a7fbe5becf	on time actors	verification;datorsystem;computer systems;reduction technique;timed rebeca;actor model;floating time transition system	Actor model is a concurrent object-based computational model in which actors are the units of concurrency and communicate via asynchronous message passing. Timed Rebeca is an actor-based modeling language which is designed for modeling and analyzing of event-based and asynchronous systems with time constraints. Timed Rebeca is equipped with analysis techniques based on the standard semantics of timed systems, and also an innovative event-based semantics that is tailored for timed actor models. The developed techniques are applied on different applications using Afra toolset, the integrated development environment of Timed Rebeca. This paper is a survey on the published work on Timed Rebeca, its semantics, supporting tools, and applications.	actor model;asynchronous system;computational model;concurrency (computer science);integrated development environment;message passing;modeling language;object-based language	Marjan Sirjani;Ehsan Khamespanah	2016		10.1007/978-3-319-30734-3_25	real-time computing;verification;computer science;theoretical computer science;distributed computing	SE	-36.26697883000021	31.87079774300447	54551
baf6dfe7112d2924c62c97dcb1229b1fd1ea00b3	dominant design	road traffic;software architecture;traffic engineering computing	The article is discussing architecture of software-intensive systems and its application in road traffic management.		Grady Booch	2011	IEEE Software	10.1109/MS.2011.29	traffic engineering;software architecture;construction engineering;vehicle information and communication system;computer science;engineering;civil engineering;software engineering;transport engineering;advanced traffic management system	Embedded	-37.5673998192305	31.324525100276617	54671
349bb1bc11a798e95fef42f095a2faaa11c22bf9	formalising traffic rules for accountability of autonomous vehicles	theorem proving control engineering computing mobile robots road traffic road vehicles;legal issues;vienna convention;liability;vehicles roads cost accounting mobile robots law;highway law;intelligent vehicles;crashes;traffic regulations;isabelle hol traffic rule formalization autonomous vehicle accountability autonomous vehicles collision road traffic	One significant barrier in introducing autonomous driving is the liability issue of a collision; e.g. when two autonomous vehicles collide, it is unclear which vehicle should be held accountable. To solve this issue, we view traffic rules from legal texts as requirements for autonomous vehicles. If we can prove that an autonomous vehicle always satisfies these requirements during its operation, then it cannot be held responsible in a collision. We present our approach by formalising a subset of traffic rules from the Vienna Convention on Road Traffic for highway scenarios in Isabelle/HOL.	autonomous car;autonomous robot;fabian pascal;formal specification;hol (proof assistant);isabelle;motion planning;requirement	Albert Rizaldi;Matthias Althoff	2015	2015 IEEE 18th International Conference on Intelligent Transportation Systems	10.1109/ITSC.2015.269	simulation;engineering;traffic conflict;transport engineering;computer security	Robotics	-37.822390420981904	27.354601064569657	54677
78eb4905324618a12bd82bcdff4c54fceaab0acf	tutorial introduction to graph transformation: a software engineering perspective	graph theory;distributed system;image recognition;inf;metodo diagramatico;teoria grafo;articulo sintesis;article synthese;architecture description language;rule based;bibliografia;bibliography;ingenieria logiciel;control flow graph;theorie graphe;graph transformation;software engineering;methode diagrammatique;transformation graphe;diagram method;metamodel;metamodele;object oriented;metamodelo;bibliographie;genie logiciel;state diagram;model based testing;function block diagram;mobile systems;term rewriting;review;data structure;structure analysis	We give an introduction to graph transformation, not only for researchers in software engineering, but based on applications of graph transformation in this domain. In particular, we demonstrate the use of graph transformation to model object- and component-based systems and to specify syntax and semantics of diagram languages. Along the way we introduce the basic concepts, discuss different approaches, and mention relevant theory and tools.	graph rewriting;software engineering	Luciano Baresi;Reiko Heckel	2002		10.1007/3-540-45832-8_30	metamodeling;architecture description language;wait-for graph;model-based testing;state diagram;data structure;computer science;artificial intelligence;graph theory;theoretical computer science;abstract semantic graph;database;mathematics;function block diagram;graph;structural analysis;bibliography;programming language;object-oriented programming;algorithm;graph rewriting;control flow graph	SE	-34.35594826863405	24.161143188586454	54725
47b09f4bf9f59e4f6f707555edb8eaec77081004	powerful equivalence checking in the bank supply process	workflow verification;formal methods;process management;business process management;banking process;ccs	Equivalence checking is a powerful formal technique to improve the quality of computer and software systems. It is usually employed to verify the correctness in a model-based design. Notwithstanding, a detailed and precise specification is required in order to apply equivalence checking to a given domain. Unfortunately, certain fields of application like business process management lack of such adequate information. We explore the applicability of equivalence checking to validation of Business Processes described by the aid of Workflow Management systems. Due to the state explosion problem, formal methods are not very popular in the business domain. In fact, the state space grows exponentially in the number of concurrent processes leading to an impracticable verification. In this paper we deal with a heuristic-based methodology developed to beat the state explosion problem when checking non-equivalence. Our contribution is two-fold: (i) we show how equivalence checking can successfully operate in the business modelling and analysis context, (ii) we model and use the bank supply process as a real case study to evaluate and test the heuristic-based methodology. We show and debate encouraging experimental results comparing them with a state of the art model checker i.e. CADP. This suggests that the business community, mostly in the banking field, can take advantage from our efficient methodology based on process algebra.	business domain;business process;c++;computational complexity theory;computer;construction and analysis of distributed processes;correctness (computer science);experiment;formal equivalence checking;formal methods;greedy algorithm;heuristic (computer science);management system;model checking;process calculus;service composability principle;software system;state space;system equivalence;turing completeness;wiki	Giuseppe De Ruvo;Antonella Santone;Domenico Raucci	2014	2014 IEEE World Congress on Services	10.1109/SERVICES.2014.25	model checking;reliability engineering;computer science;systems engineering;artifact-centric business process model;business process management;operations management;formal equivalence checking;business process model and notation;business process modeling;abstraction model checking	SE	-44.054619544943954	29.77932527762376	54791
d11f92c565f776d4297cd94a14f5bf7c75b69cb2	ecd++ a devs based real-time simulator for embedded systems	partial differential equation;queuing model;mindstorms;embedded cd ecd;real time;real time simulation;embedded system;bond graph;discrete event system;complex system;hardware in the loop;robocart;cellular automata;real time application	In this paper we will present an M&S-driven framework to develop embedded systems based on the DEVS (Discrete Event systems Specification) formalism. DEVS provides a formal foundation to M&S that proved to be successful in different complex systems. This approach combines the advantages of a simulation -based approach with the rigor of a formal methodology. Another advantage of using DEVS is that different existing techniques (Bond Graphs, Cellular Automata, Partial Differential Equations, Queuing models, etc.) have been successfully transformed into DEVS models. CD++ is a software environment that implements DEVS theory with extensions to support real-time model execution in embedded systems. CD++ was used as the base for our development, building on previous research focused on real-time applications with hardware-in -the-loop. Embedded CD++ (ECD++) has been developed based on this tool to accomplish this aim. A small robocart has been built and tested with ECD++. The robocart uses sonar and touch sensor to detect obstacles on its way. At the end, ECD++ program has been compiled for the target and run using telnet connection on the board.		Mohammad Moallemi;J. Marcelo Gutierrez-Alcaraz;Gabriel A. Wainer	2008			cellular automaton;embedded system;complex systems;real-time computing;simulation;computer science;operating system;devs;sp-devs;bond graph;partial differential equation;hardware-in-the-loop simulation	Embedded	-37.26290477993	29.599161754994697	55024
9560761c822eb757393ee511ec5800ebcf544cbb	from visual specifications to executable code	software verification;conceptual analysis;distributed programs;object oriented programming;automatic programming;program synthesis;software engineering;functional programming;specification language;formal method;visual programming;development tool;x window system;visual representation;object oriented;graphical representation;software development environment;process development;network management;domain analysis;logic programs;high performance;software process;free software;graduate education	Conceptual analysis in many domains uses visual representation of objects and relationships. This is obviously true for engineering domains where graphics is often a part of design documentation. It is true for software engineering as well, where we have well-established graphical representation of various software artifacts. Attempts are made to formalize the semantics of visual representations, in particular, the UML is intended to be a language with quite clear semantics [1]. However, the difficulty lies in the implementation of such languages, i.e. in developing tools which enable us to use the languages with high degree of automation. In the present paper we give an example of automatic usage of visual specifications. To be able to automate software processes, we should have efficiently usable formal methods for the processes. Developments in logic programming, functional programming and software verification show that automatically usable formal methods have reached sufficient maturity to be used in software practice. We demonstrate the usage of a program synthesis method which relies on a restricted logic of intuitionistic propositional calculus, but has high performance and is applicable to large specifications. We describe a layered software development environment which provides visual tools for domain analysis. Result of the domain analysis is a visual specification language directly implementable by means of the visual tools.	capability maturity model;documentation;domain analysis;formal methods;functional programming;graphical user interface;graphics;integrated development environment;intuitionistic logic;logic programming;program synthesis;propositional calculus;software development;software engineering;software verification;specification language;unified modeling language	Enn Tyugu	1998		10.1007/3-540-49255-0_165	software verification;computer science;theoretical computer science;programming language;object-oriented programming;executable;functional programming;portable executable	SE	-46.83270819068298	29.292739414139437	55250
839fa6ff4507ecb8f06acc64e814d8c00ddd0c55	a behavioural model for product families	model verification;product lines;usu;labeled transition system;modal transition systems;product line;software families;product family	In this paper we propose a behavioural model, namely the Extended Modal Labeled Transition Systems, as a basis for the formalization of the different notions of variability usually present in product families definitions. In particular, an EMLTS is able to define a family of products by telling at any state of the system whether transitions are optional or compulsory for the products of the family. Based on this model, verification that a product belongs to a family can be carried out by means of automatic tools.	modal logic;source-to-source compiler;spatial variability	Alessandro Fantechi;Stefania Gnesi	2007		10.1145/1287624.1287700	engineering;algorithm	Logic	-44.36794785360137	28.93337681532974	55296
c06823a207b9b959f3327e3df7adb92c8b5608c7	towards the semantics for web service choreography description language	developpement logiciel;modelizacion;lenguaje programacion;programming language;par a par;web semantique;metodo formal;operational semantics;methode formelle;service web;semantics;web service;contrato;semantica;semantique;formal method;modelisation;lenguaje descripcion;contract;poste a poste;desarrollo logicial;web semantica;software development;traitement exception;semantic web;langage programmation;exception handling;contrat;peer to peer;modeling;langage description;servicio web;description language	A choreography is a multi-part contract which describes peer to peer collaboration of services regardless of any specific programming language or supporting platform. WS-CDL, issued from W3C, is the first language for describing choreography. In this paper, we propose a language CDL 0  to capture the important features of WS-CDL, including choreography composition, compensation and exception handling. An adjunctive concept role reference is introduced with the aim of distinguishing multiple participants which provide the same kind of service within a choreography model. The semantics is given by an operational approach to provide a formal base for the choreography language. We believe this formalism work helps to clear ambiguous points in the WS-CDL specification and promote the usage of choreography languages.	service choreography;web service	Jing Li;Jifeng He;Geguang Pu;Huibiao Zhu	2006		10.1007/11901433_14	contract;exception handling;web service;formal methods;computer science;software development;semantic web;database;semantics;programming language;operational semantics;world wide web	Web+IR	-40.50075388811895	24.692226906445406	55511
9270385182ec161474a284be0b8b0d28e400c2be	synthesizing state machines from two scenarios and a case study on business process management		Describing business processes by directed graphs is a common way for system designers, because it makes easier to realize how the process goes on. However the concept of serviceoriented architecture increased difficulty of the business process management system development, because the specification of the whole system and each software unit are different in general. Therefore, describing behavioral model for each software units is required. A flow of interaction of software unit is called a scenario. In our previous study, we showed the algorithm to synthesize model of each software unit when specification of whole system is given by one scenario. In this paper, we show conditions to synthesize models when the whole system has two scenarios. We also apply the conditions to a simple business process.	algorithm;behavioral modeling;business process;directed acyclic graph;directed graph;fairness measure;finite-state machine	Toshiki Kinoshita;Toshiyuki Miyamoto	2017	2017 IEEE International Conference on Systems, Man, and Cybernetics (SMC)	10.1109/SMC.2017.8122874	business process;systems engineering;architecture;finite-state machine;behavioral modeling;machine learning;directed graph;software;business process management;artificial intelligence;unified modeling language;computer science	SE	-41.09294152096432	30.73610469657902	55573
028000b5b1d4cb8a1f838ccd01e9d95fe2a02c5c	enforcing different contracts in hierarchical component-based systems	hierarchical system;prestation service;fiabilidad;reliability;behavioral analysis;componente logicial;component based systems;prestacion servicio;systeme hierarchise;composant logiciel;contrato;contracting service;automatic generation;langage dedie;sistema jerarquizado;contract;fiabilite;analyse comportementale;software component;domain specific language;analisis conductual;contrat;lenguaje dedicado	Using different specification formalisms together is necessary to leverage better reliability on component-based systems. The ConFract system provides a contracting system for hierarchical software components, but currently, only executable assertions are supported. In this paper, we describe how TLA, taken as an instance of behavioral sequence-based formalism, was integrated in ConFract. A domain specific language is proposed in order to enable designers to describe the observations needed to appropriately verify their specifications. These observations are automatically generated for assertions and in the case of TLA, we show what kind of observations must be provided to link the specifications to the concrete application.	component-based software engineering;domain-specific language;executable;norm (social);semantics (computer science)	Philippe Collet;Alain Ozanne;Nicolas Rivierre	2006		10.1007/11821946_4	contract;real-time computing;computer science;reliability;database;programming language;computer security;algorithm	SE	-39.99911852795426	25.260822731607515	55588
9d182cd26c1796daddb42c4926d558b3976bd5ab	adopting hla standard for interdependency study	modelizacion;homeland security;object oriented model;reseau electrique;sistema critica;modeling and simulation;electrical network;etude experimentale;experimental test bed;complex network;systeme critique;sistema adquisicion dato;red electrica;modelo hibrido;data acquisition system;modele hybride;power supply;hybrid model;modelisation;adverse effect;hybrid approach;control proceso;critical system;alimentation electrique;seguridad nacional;object oriented;supervisory control and data acquisition;rupture;defaillance;process control;mathematical model;scada system;oriente objet;interdependency study;failures;electric power;alimentacion electrica;distributed simulation;critical infrastructure;systeme acquisition donnee;modeling;orientado objeto;high level architecture;supervision;estudio experimental;fallo;ruptura;object oriented modeling;commande processus;open standard;infraestructura;infrastructure;securite nationale;model simulation	In recent decades, modern Critical Infrastructure (CI) has become increasingly automated and interlinked as more and more resources and information are required to maintain its day-to-day operation. A system failure, or even just a service debilitation, of any CI may have significant adverse effects on other infrastructures it is connected/interconnected with. It is vital to study the interdependencies within and between CIs and provide advanced modeling and simulation techniques in order to prevent or at least minimize these adverse effects. The key limitation of traditional mathematical models such as complex network theory is their lacking the capabilities of providing sufficient insights into interrelationships between CIs due to the complexities of these systems. A comprehensive method, a hybrid approach combining various modeling/simulation techniques in a distributed simulation environment, is presented in this paper. High Level Architecture (HLA) is an open standard (IEEE standard 1516) supporting simulations composed of different simulation components, which can be regarded as the framework for implementing such a hybrid approach. The concept of adopting HLA standard for the interdependency study is still under discussion by many researchers. Whether or not this HLA standard, or even the distributed simulation environment, is able to meet desired model/simulation requirements needs to be carefully examined. This paper presents the results from our experimental test-bed, which recreates the architecture of a typical Electricity Power Supply System (EPSS) with its own Supervisory Control and Data Acquisition (SCADA) system, for the purpose of investigating the capabilities of the HLA technique as a standard to perform interdependency studies.	interdependence	Nan Cen;Irene Eusgeld	2011	Rel. Eng. & Sys. Safety	10.1016/j.ress.2010.08.002	simulation;computer science;engineering;process control;modeling and simulation;scada	DB	-37.17338857272433	23.730880931354807	55886
602878f0bb755020b95cc88df57258e62094a289	automatic control-code generation from simulation for flexible material handling systems	automatic control;analytical models;3d animation;3d animation simulation;software agents automatic programming discrete event simulation real time systems production engineering computing conveyors computer animation;material flow logic;modular conveyor components;real time;agile manufacturing;logic;code generation;manufacturing automation;automatic programming;automatic generation;production engineering computing;software agents;conveyors;materials handling;automatic generation control;workstations;automatic control code generation;material flow;real time system;simulation analysis;functionality;computer animation;machinery;flexible material handling systems;agile manufacturing automatic control code generation discrete event simulation flexible material handling systems 3d animation simulation functionality modular conveyor components material flow logic real time system;virtual manufacturing;discrete event;automatic generation control materials handling workstations analytical models manufacturing automation logic automatic control agile manufacturing virtual manufacturing machinery;real time systems;discrete event simulation	This paper describes the design of a tool for rapid analysis and implementation of flexible material ha ndling systems. The work incorporates a commercial discre teevent and 3-D animation simulation system and exten ds its functionality with respect to material handling sys tems. Logical clusters of commercial, modular conveyor components are defined and installed as additions t the simulator’s component libraries. These logical gro upings, plus the material-flow logic specified by the user in a given simulation analysis, are used to enable autom atic generation of control code for the corresponding ph ysical implementation of the simulated system. Key elemen ts in accomplishing this connection are the definition of component logical groupings and a novel, reactive-a g nt based software organization of the real-time materi lhandling control code.	agile software development;automatic control;code generation (compiler);computer animation;computer-aided design;control flow;event-driven programming;high- and low-level;interaction;library (computing);list of discrete event simulation software;material handling;reactive planning;real-time clock;real-time computing;real-time transcription;software agent	Chrysanthie D. Chamis;Scott A. Ameduri;Wyatt S. Newman	1997		10.1109/ROBOT.1997.619279	real-time computing;simulation;computer science;automatic control;computer animation;computer engineering	Robotics	-35.236628035482546	29.715627564982093	55928
87ea33529ad080f36a8e8be8527d8adb1ea57969	introduction to simulation	generated data;simulation structure;simulation function;simulation data generation;simulation tutorial;industry;discrete-event simulation;simulation;digital simulation;data handling;computer aided analysis	This paper offers an introduction to the fundamental concepts of system modeling with emphasis on the application of digital simulation. The topics presented include system modeling, model classification, a discussion of mathematical and simulation models, their distinction and relative advantages, an overview of systems analysis, an example simulation model, and brief discussions of random numbers, random variable generation and simulation languages. The material presented is largely conceptual and requires no prior background in modeling.	formal language;mathematical model;simulation;systems modeling	J. William Schmidt	1984			verification and validation of computer simulation models;simulation;simulation software;computer science;technical report;theoretical computer science;discrete event simulation;simulation modeling;hardware-in-the-loop simulation;network traffic simulation	AI	-35.55322525085299	27.346463125939504	56021
af91c2401cc282446f47f0253620197f266cbbae	on formalizing uml 2.0 activities: stream and exception parameters			exception handling;unified modeling language	Sabine Boufenara;Faiza Belala;Narayan C. Debnath	2009			database;unified modeling language;computer science;distributed computing	HCI	-42.3699882206245	30.459384939485247	56332
92d1feae4cb1344c812bff0de2e0b13eb28949cf	itelligent agents and bist/bisr - working together in distributed systems	distributed system;bist;high level testing;self repair;performance monitoring;intelligent agent built in self test system testing automatic testing fault diagnosis computerized monitoring software standards computational modeling computer simulation automation;distributed system repair;automatic testing;distributed processing;fault repair;software modules;distributed system testing;maintenance engineering;automatic testing software agents multi agent systems built in self test fault diagnosis condition monitoring maintenance engineering distributed processing;software agents;computerized monitoring;multi agent systems;computational modeling;development environment;intelligent agents;built in self test;fault monitoring;condition monitoring;cooperative fault diagnosis repair model;cooperative fault diagnosis repair model intelligent agents bist bisr built in self test built in self repair distributed system testing distributed system repair software modules fault monitoring fault diagnosis fault repair zeus agent development environment;intelligent agent;system testing;distributed systems bist;software standards;zeus agent development environment;bisr;distributed bisr;built in self repair;computer simulation;embedded testing;fault diagnosis;automation	This paper presents an attempt of using intelligent agents for testing and repairing a distributed system, whose elements may or may not have embedded BIST (Built-In Self-Test) and BISR (Built-In Self-Repair) facilities. The agents are sofhvare modules that perform monitoring, diagnosis and repair of the faults. They form together a society whose members communicate, set goals and solve task. To demonstrate the idea we used the Zeus agent development environment. Two examples of distributed systems are presented in order to illustrate the cooperative model for fault diagnosis and repairing.	built-in self-test;distributed computing;embedded system;intelligent agent	Liviu Miclea;Szilárd Enyedi;Alfredo Benso	2002		10.1109/TEST.2002.1041849	reliability engineering;embedded system;computer science;engineering;software agent;automation;development environment;computational model;system testing;intelligent agent;computer engineering	AI	-39.702131148029416	18.682867186406718	56436
09232d9d48a849ed06ea89f6094a084e4c80b374	automated database and schema-based data interchange for modeling and simulation	database management systems;discrete event simulation;optimisation;automated database;automatic configuration;enterprise system;optimization;schema-based data interchange;simulation;student-training system	Creating a simulation of a large enterprise system by manually coding all the details into a simulator tool is not just time consuming, but yields a system that is difficult to maintain. By separating the model-configuration data from the models, a higher level of automation can be achieved, and enhance the usefulness of the simulation. The underlying data can be manipulated by the subject matter experts, and then transformed into the appropriate structure for simulator use. This paper describes a method that automatically configures a simulation using external data that interfaces to generic processing flow. The models and the simulation were co-designed along with the interchange data representation to enable generic models to be configured under software sequenced by a workflow system. This allowed model re-use, and automatic configuration changes, in support of optimization. We also describe the application of this technique to the simulation of an enterprise, student-training system.	data (computing);database schema;enterprise system;interoperability;mathematical optimization;programming paradigm;simulation;subject matter expert turing test;subject-matter expert;turing completeness;visual basic for applications;workflow engine;xml	Gregory A. Harrison;David S. Maynard;Eytan Pollak	2004	Proceedings of the 2004 Winter Simulation Conference, 2004.		enterprise system;simulation;simulation software;computer science;theoretical computer science;discrete event simulation;data mining;modeling and simulation;database;external data representation;subject-matter expert;world wide web;simulation language	HPC	-46.9554356217046	24.901764415185504	56549
a8b4f7b3da7ea94c675f542cff97ad39493ab95a	towards proactive event-driven computing	building block;agent modeling;conceptual model;computer architecture;proactive computing;paradigm shift;event processing;prediction model	Event driven architecture is a paradigm shift from traditional computing architectures which employ synchronous, request-response interactions. In this paper we introduce a conceptual architecture for what can be considered the next phase of that evolution: proactive event-driven computing. Proactivity refers to the ability to mitigate or eliminate undesired future events, or to identify and take advantage of future opportunities, by applying prediction and automated decision making technologies. We investigate an extension of the event processing conceptual model and architecture to support proactive event-driven applications, and propose the main building blocks of a novel architecture. We first describe several extensions to the existing event processing functionality that is required to support proactivity; next, we extend the event processing agent model to include two more type of agents: predictive agents that may derive future uncertain events based on prediction models, and proactive agents that compute the best proactive action that should be taken. Those building blocks are demonstrated through a comprehensive scenario that deals with proactive decision making, ensuring timely delivery of critical material for a production plant.	anytime algorithm;causality;complex event processing;decision theory;domain model;event-driven architecture;event-driven programming;high- and low-level;interaction;mathematical optimization;proactive parallel suite;programming paradigm;request–response;requirement;state space;synchronization (computer science)	Yagil Engel;Opher Etzion	2011		10.1145/2002259.2002279	paradigm shift;proactive learning;real-time computing;simulation;computer science;conceptual model;complex event processing;database;predictive modelling	AI	-40.7628930017931	21.8138180037199	56678
6c8c7ef1802c78f90df8c165e9b86ac33459190b	formal specification of a voice communication system used in air traffic control an industrial application of light-weight formal methods using vdm		A joint project of the Austrian company Frequentis and the Technical University Graz demonstrates the applicability of executable formal models. The formal method VDM has been applied to specify a safety critical voice communication system (VCS) for air-traffic control. Besides the expected improvement of the informal specification documents, 64 defects have been found, the efficiency of the system test-cases to cover the functionality of the VCS has been analyzed. In order to get a test-coverage measure, the formal specification has been animated with existing system test-cases using IFAD’s VDMTools. A	executable;formal methods;formal specification;system testing;veritas cluster server;vienna development method	Johann Hörl;Bernhard K. Aichernig	1999		10.1007/3-540-48118-4_59	embedded system;real-time computing;formal methods;specification language;vienna development method;computer science;formal specification;programming language	SE	-46.012230918093785	30.120979536424123	57023
b5fb95366885bdc26d9a17b7df43e173921f03aa	employing the object constraint language in model-based engineering	textual restriction;model-based engineering;model property;object constraint language;central role;modeling level;traditional code-centric development approach;unified modeling language;implementation level	MBE (Model-Based Engineering) proposes to develop software by taking advantage of models, in contrast to traditional codecentric development approaches. If models play a central role in development, model properties must be formulated and checked early on the modeling level, not late on the implementation level. We discuss how to validate and verify model properties in the context of modeling languages like the UML (Unified Modeling Language) combined with textual restrictions formulated in the OCL (Object Constraint Language). Typical modeling and transformation languages like UML (Unified Modeling Language), EMF (Eclipse Modeling Framework), QVT (Queries, Views, and Transformations) or ATL (Atlan Transformation Language) are complemented by the textual OCL (Object Constraint Language) enriching graphical or textual models with necessary details. Models allow the developer to formulate essential system properties in an implementationand platform-independent way. Precise object-oriented development must take into account system structure and system behavior. The system structure is often captured by class diagrams and can be instantiated in terms of prototypical exemplars by object diagrams. The system behavior can be determined by statechart diagrams, and system execution traces can be demonstrated by sequence diagrams. OCL restricts the possible system states and transitions through the use of class invariants, operation preand postconditions, state invariants, and transition preand postconditions. OCL can also be used during model development as a query language. Modeling features and their analysis through validation and verification must be supported by tools like, for example, the tool USE (UML-based Specification Environment) [1]. Within USE, UML class, object, statechart, and sequence diagrams extended with OCL are available [2]. OCL has been extended with programming language features in SOIL (Simple Ocl-like Imperative Language) which allows the developer to build operation realizations on the modeling level without having to dig into implementation level details [3]. Thus models in USE are executable, but a prescriptive SOIL model for operations can be checked against descriptive plain OCL preand postconditions. Tools like USE assist the developer in order to validate and to verify model characteristics. Validation and verification can be realized, in USE for example, by employing a so-called model validator based on relational logic and SMT	class diagram;class invariant;eclipse modeling framework;executable;graphical user interface;imperative programming;invariant (computer science);object constraint language;object diagram;postcondition;programming language;qvt;query language;relational algebra;satisfiability modulo theories;sequence diagram;state diagram;tracing (software);transformation language;unified modeling language;validator;verification and validation	Martin Gogolla	2013		10.1007/978-3-642-39013-5_1	model-driven architecture;simulation;systems modeling language;computer science;systems engineering;modeling language;programming language;object constraint language	SE	-44.59169065106166	27.410396341237096	57027
90b3c00b29d26a7603542a7fc2e2844d1e6101be	a general resource framework for real-time systems	systeme temps reel;sistema experto;bepress selected works;resource modeling real time systems process algebra;algebra proceso;algebre processus;real time system;sistema tiempo real;systeme expert;process algebra;resource modeling;real time systems;expert system	The paper describes a formal framework for designing and reasoning about resource-constrained systems. The framework is based on a series of process algebraic formalisms which have been previously developed to describe and analyze various aspects of real-time communicating, concurrent systems. We develop a uniform framework for formal treatment of resources and demonstrate how previous work fits into the new framework.	computation;concurrency (computer science);consumability;embedded system;fits;linear algebra;model-driven engineering;process calculus;real-time clock;real-time transcription;semantics (computer science)	Insup Lee;Anna Philippou;Oleg Sokolsky	2002		10.1007/978-3-540-24626-8_16	process calculus;simulation;computer science;artificial intelligence;programming language;expert system;algorithm	Embedded	-37.86879044529735	26.099547190904374	57144
036f60bf946b77a10cfaf708ddfd433a1e0c626b	towards a tool for generating aspects from medl and pedl specifications for runtime verification	formal specification;runtime verification;java mac;formal method;aspect oriented programming;runtime monitoring;software assurance	This research describes an approach to generate AspectJ aspects from formal specifications written for the Monitoring and Checking (MaC) runtime verification tool. The aspects can serve as the foundation for instrumentation of programs that can be verified at runtime. To demonstrate the practicability of the proposed approach, a benchmark from the MaC research is used. The example benchmark is based on a safety-critical railroad crossing system comprised of a train, a gate and a controller. Finally, the results from generating Java-MaC specification scripts to AspectJ aspects are described. Purpose The purpose of this approach is to enhance runtime verification by developing a tool that translates the MaC specifications into AspectJ aspects. This is important because it removes the need for an instrumentation system, such as the one included in MaC, while maintaining MaCs unique features, i.e., the MEDL and PEDL specification languages that support specification of the properties to be monitored and the events and conditions that trigger monitoring. The proposed approach allows the runtime verification community to benefit from research advances in Aspect-oriented Programming and to reduce the need to maintain instrumentation code, which is managed by AspectJ in our approach. MonVarDcl: float RRC.train_x; int RRC.train_length; int RRC.cross_x; int RRC.cross_length; MonMethodDcl: Gate.gd(); Gate.gu(); Java-MaC ReqSpec RailroadCrossing import event startIC, endIC, startGD, endGD; CondDef: Cond InCrossing = [startIC, endIC]; Cond GateDown = [startGD, endGD]; SafePropDef: SafeProp safeRRC = InCrossing -> GateDown; End RRC	aspect-oriented programming;aspect-oriented software development;aspectj;benchmark (computing);conditional (computer programming);java;run time (program lifecycle phase);runtime verification;specification language	Omar Ochoa;Irbis Gallegos;Steve Roach;Ann Q. Gates	2007		10.1007/978-3-540-77395-5_7	real-time computing;formal methods;aspect-oriented programming;computer science;formal specification;runtime verification;programming language	SE	-44.40987426757713	31.043733194753372	57175
277313515a2b0dd28d1088608237183de82247ea	organizational multi-agent architectures for information systems	institutional repositories;fedora;multi agent system;vital;autonomous agent;system design;multi agent architecture;information system;architectural pattern;vtls;business information systems;organizational theory;software quality;ils	A Multi-Agent System (MAS) architecture is an organization of coordinated autonomous agents that interact in order to achieve particular, possibly common goals. Considering real-world organizations as an analogy, this paper proposes MAS architectural patterns for information systems which adopt concepts from organizational theories. The patterns are modeled using the i* framework which offers the notions of actor, goal and actor dependency, specified in Formal Tropos and evaluated with respect to a set of software quality attributes, such as predictability or adaptability. We conduct a comparison of organizational and conventional architectures using an e-business information system case study.	actor model;architectural pattern;autonomous agent;autonomous robot;design pattern;electronic business;list of system quality attributes;management information system;matchware mediator;multi-agent system;organizational behavior;software quality;systems architecture;theory	T. Tung Do;Stéphane Faulkner;Manuel Kolp	2003			organizational theory;simulation;architectural pattern;computer science;knowledge management;artificial intelligence;autonomous agent;information system;software quality;systems design	AI	-43.651583073194494	20.450093891415207	57321
adddb13c6ffda6d5099144d7e56369b2796cd023	architecting structure-aware applications	structural model;cooperative hypermedia;conceptual model;levels of abstraction;ubiquitous computing;structural computing;architectural pattern;data structure;design for change	An extension to the well-known MVC architectural pattern is proposed to include an explicit structure model. The proposed conceptual model is further extended to address requirements from the research fields CSCW and ubiquitous computing. Furthermore, data, structure, and behavior descriptions have been identified as basic abstractions. In summary, the proposed model addresses reuse as well as design for change on different levels of abstraction.	architectural pattern;computer-supported cooperative work;data structure;model–view–controller;principle of abstraction;requirement;ubiquitous computing;whole earth 'lectronic link	Jessica Rubart	2007		10.1145/1286240.1286296	real-time computing;data structure;architectural pattern;computer science;conceptual model;database;ubiquitous computing	SE	-46.89217086810867	21.985718971307108	57354
91b2d5d44946f11f92f87442c94b6e257756cc93	model checking normative agent organisations	multi agent system;programming language;model checking;bdi agents;property specification language	We present the integration of a normative programming language in the MCAPL framework for model checking multi-agent systems. The result is a framework facilitating the implementation and verification of multi-agent systems coordinated via a normative organisation. The organisation can be programmed in the normative language while the constituent agents may be implemented in a number of (BDI) agent programming languages. We demonstrate how this framework can be used to check properties of the organisation and of the individual agents in an LTL based property specification language. We show that different properties may be checked depending on the information available to the model checker about the internal state of the agents. We discuss, in particular, an error we detected in the organisation code of our case study which was only highlighted by attempting a verification with “white box” agents.	dining philosophers problem;experiment;linear temporal logic;model checking;multi-agent system;programming language;property specification language;white box (software engineering)	Louise A. Dennis;Nick A. M. Tinnemeier;John-Jules Ch. Meyer	2009		10.1007/978-3-642-16867-3_4	specification language;computer science;database;programming language;algorithm	AI	-42.557149557352076	20.165642158640054	57479
477d37747699f92217654234fdc7da83cfae2e60	interactive modeling and simulation of transaction flow or network models using the ada simulation support environment	life cycle;top down;software systems;network model;interaction model;technical report;building model;simulation model	The Ada Simulation Support Environment (ASSE) is a software system, with the purpose to support the development and maintenance of simulation models written in Ada throughout their life cycle. We describe here the transaction flow or network part of the ASSE, which allows to build models like in GPSS or SLAM. Our view of such models is slightly different from that of the above mentioned languages, which is demonstrated in detail by the server/resource process. The design stresses modular top-down development using submodels. Models can be developed and tested interactively.	ada;gpss;interactivity;server (computing);simulation;simultaneous localization and mapping;software system;top-down and bottom-up design	Heimo H. Adelsberger	1983		10.1145/1103235.1103240	biological life cycle;parallel computing;real-time computing;simulation;computer science;technical report;operating system;network model;simulation modeling;top-down and bottom-up design;programming language;software system	SE	-34.454728064228675	26.80915701107973	57486
3701b379496fc231342594e41012af6475180fe4	towards the formalization of a reusability framework for refactoring	artefacto;developpement logiciel;design model;lenguaje programacion;programming language;computer software reusability;composant logiciel;ingenieria logiciel;software engineering;artefact;object oriented;desarrollo logicial;software development;software component;reutilisation logiciel;genie logiciel;langage programmation;oriente objet;orientado objeto;domain specificity	As industry and academia embrace component and objectbased design models, programming languages, technologies, and tools, they are outpacing our ability to formally define models and frameworks supporting organization and domain specific reuse. For software engineers to accurately assess potential and actual reuse of software artifacts, we must transition from ad-hoc reuse to a evaluative paradigm that achieves reuse of an organization’s current and future products. Towards this goal, our previous work has provided a framework for reusability assessment of components and classes via metrics and refactoring guidelines. In this paper, we work towards the formalization of this reusability framework. Our objectives and contributions are: a set of properties for the assumptions of the reusability framework; the formalization of class coupling, class generality, and related class concepts which underlie reuse assessment and refactoring; a reusability improvement factor to capture refactoring gain (or loss); and a refactoring algorithm for improving reusability.	algorithm;code refactoring;hoc (programming language);programming language;programming paradigm;software engineer	Rodrigo E. Caballero;Steven A. Demurjian	2002		10.1007/3-540-46020-9_21	computer science;component-based software engineering;software development;operating system;database;programming language;object-oriented programming	SE	-43.236520838401866	26.09207379129514	57560
5ebd92492ca3409f32ef63f96ac14e655277cd4d	performance prediction in peer-to-peer multiagent networks	multiagent system;performance metric;large scale;collaborative networks;self organization;performance prediction;p2p networks;peer to peer;high performance	Building a good autonomous, self-organizing, and collaborating networks is an important research area for the design of large scale and high performance MultiAgent Systems on top of peer-to-peer (P2P) networks. This paper focuses on developing a mechanism to evaluate and outline performance metrics in dynamic P2P networks and to translate different interactions into computable functions which can lead to solvable decision making problems.	peer-to-peer;performance prediction	Jabeom Gu;Jaehoon Nah;Hyeokchan Kwon;Jongsoo Jang;Sehyun Park	2007		10.1007/978-3-642-11368-0_3	simulation;computer science;knowledge management;management science	ML	-42.28143954448408	18.611451399821068	57806
fadcc2b88f4bbf31fb89b2fba9b78ab7d1405966	introducing x-machine models to verify plc ladder diagrams	programming language;testing;x machines;consistency model;general methods;programmable logic controllers;ladder diagram;data flow;machine model;programmable logic controller	Ladder diagram is a ubiquitous PLC programming language often used in safety-related control and protection systems. The design and analysis of ladder diagram programs by engineers is often ad hoc using a variety of techniques that may be applied with varying levels of rigour. This paper introduces X-machines, a state-based formalism, to consistently model and verify PLC ladder diagrams. X-machines model control and data flow unambiguously, and have associated with them a test set generation method that is amenable to automation. This work shows by an example, namely an oil tank warning system, how ladder diagram programs, can be successfully modelled using variants of the X-machine model.	diagram;x-machine	Colin Chambers;Mike Holcombe;Judith Barnard	2001	Computers in Industry	10.1016/S0166-3615(01)00085-9	control engineering;real-time computing;computer science;systems engineering;ladder logic;programmable logic controller;function block diagram;programming language;algorithm	DB	-45.17332750508112	31.802078585359844	57895
072d22ac0e6099c007ea38329639caf3348e36ab	basic concepts		The UK participates in both european and international standards work. One new area of possible development within international standards is to integrate requirements for energy efficiency into IeC 60364. electrical energy efficiency is intended to obtain the highest possible service from an electrical installation from the lowest energy consumption. Proposals include requirements for the design of new installations and the improvement of existing installations.	requirement	Mack W. Alford;Leslie Lamport;Geoff P. Mullery	1984		10.1007/3-540-15216-4_12		SE	-35.77206382124204	19.969143860123086	58085
2addab42fbe94a98a5b162b3e50fd471ae2a0bb7	scalability in distributed simulations of agent-based models	digital simulation;multi-agent systems;object-oriented programming;agent based simulation;agent interaction patterns;agent-based models;autonomous agents;distributed simulations;multiagent systems;optimistic synchronization protocol;scalability	Research on systems of autonomous agents, called multiagent systems (MAS), has received much interest in the domain of (distributed) artificial intelligence in recent years. MAS are most suitable for the development of distributed applications within an uncertain and dynamically changing environment (Logan 2005). For validation of such systems agent based simulation is a new modeling paradigm not limited to systems which qualify as MAS by default. The focus of the work presented here is on scalability aspects of simulation environments for agent based simulations. Scalable solutions are required, as complex models require the capability to simulate hundreds or more complex deliberative agents. This is a capability which is often lacking in existing simulation environments for agents. We investigate different aspects which influence scalability and present a solution for enabling a scalable and efficient distributed simulation of agent-based models based on an adapted optimistic synchronization protocol which limits the level of optimism by using knowledge about agent interaction patterns.	agent-based model;autonomous robot;distributed artificial intelligence;distributed computing;multi-agent system;programming paradigm;scalability;simulation;synchronization (computer science)	Dirk Pawlaszczyk;Steffen Straßburger	2009	Proceedings of the 2009 Winter Simulation Conference (WSC)		real-time computing;simulation;computer science;artificial intelligence;autonomous agent;multi-agent system;distributed computing	AI	-40.05203116614098	21.329893519504274	58212
1810af858dbbb44041839a4733fb32143b059e4d	impact of object-oriented software engineering applied to the development of security systems	developpement logiciel;lenguaje programacion;object oriented methods;monitoring control system;programming language;securite;maintenance;systeme controle commande;ingenieria logiciel;sistema control mando;program verification;schedulability analysis;software engineering;analisis programa;software requirements;verificacion programa;system synthesis;object oriented;desarrollo logicial;scheduling;synthese systeme;software development;safety;secure system;object oriented software engineering;sintesis sistema;genie logiciel;mantenimiento;langage programmation;oriente objet;system development;ordonamiento;time to market;program analysis;analyse programme;development time;verification programme;seguridad;software reliability;orientado objeto;ordonnancement	In the development of security systems the need for reuse, maintenance, adaptability and reduction of development time are becoming highly important in addition to the classical requirements such as concurrency, schedulability, high reliability and safety. This paper proposes a system development model based on object-oriented methods, schedulability analysis and validation of software requirements. The application of these methods to a remote receiver unit DEZ-9000 demonstrated improvements in software reliability, significant reduction of time-to-market and development and maintenance efforts.	software engineering	Silvije Jovalekic;Bernd Rist	1998		10.1007/3-540-49646-7_11	program analysis;software security assurance;embedded system;development testing;verification and validation;simulation;object-oriented software engineering;computer science;software development;software engineering;systems development life cycle;programming language;object-oriented programming;scheduling;software development process;software requirements;software quality	SE	-42.20262435025689	26.89124907001184	58367
ec867b6b725a8b2eb309634f1887f1bd37bad692	the triad-based design of rich user interfaces for internet applications	usixml;rich internet application;web pages;web engineering;user interface;asynchronous communication;model driven engineering;internet application;rich internet applications;web development;design methodology	Current trends in web development still are attached to the web page paradigm. Nevertheless, new uses of already available technology and recent development in terms of concepts, as the asynchronous communication, have produced a new generation of web applications: Rich Internet Applications (RIAs). These web applications tries to fulfill user expectations in terms of usability, reliability, quality, maintainability and performance. In our work, we are going to present a design methodology that pursued as goal describing and developing User Interfaces of RIAs in a standardized way.	programming paradigm;rich internet application;usability;user interface;web application;web development;web page	Francisco Javier Martínez-Ruiz	2010		10.1145/1822018.1822077	web service;ajax;web application security;web development;web application;web modeling;the internet;web of things;web-based simulation;web design;human–computer interaction;web accessibility initiative;web standards;computer science;web api;web navigation;web page;multimedia;web engineering;web 2.0;world wide web;mashup	Web+IR	-48.26188441934724	21.1976146396861	58465
f716110648e210e38f345218d05ec58fb9a0a81f	formalization and verification of hierarchical use of interaction overview diagrams using timing diagrams.		Thanks to its graphical notation and simplicity, Unified Modeling Language (UML) is a de facto standard and a widespread language used in both industry and academia, despite the fact that its semantics is still informal. The Interaction Overview Diagram (IOD) is introduced in UML2; it allows the specification of the behavior in the hierarchical way. In this paper, we make a contribution towards a formal dynamic semantics of UML2. We start by formalizing the Hierarchical use of IOD. Afterward, we complete the mapping of IOD, Sequence Diagrams and Timing Diagrams into Hierarchical Colored Petri Nets (HCPNs) using the Timed colored Petri Nets (timed CP-net). Our approach helps designers to get benefits from abstraction as well as refinement at more than two levels of hierarchy which reduces verification complexity.	digital timing diagram;graphical user interface;interaction overview diagram;petri net;programming language;refinement (computing);sequence diagram;unified modeling language	Aymen Louati;Chadlia Jerad;Kamel Barkaoui	2014	CoRR		theoretical computer science;computer science;systems engineering;petri net;sequence diagram;interaction overview diagram;notation;semantics;abstraction;unified modeling language;hierarchy	SE	-44.53624106996187	28.77361471890364	58491
eb9a963d33925db277ea11c6b671f3bc83ad29c5	representing and applying design patterns: what is the problem?	developpement logiciel;modelizacion;patron conception;reutilizacion;patron concepcion;reuse;modelisation;metamodel;metamodele;automatic detection;metamodelo;desarrollo logicial;documentacion;design pattern;software development;architecture basee modele;eclipse modeling framework;modeling;software process modelling;mdd;model driven architecture;sp metamodel;reutilisation;documentation;process modelling languages;arquitectura basada modelo	Design patterns embody proven solutions to recurring design problems. Ever since the gang of four popularized the concept, researchers have been trying to develop methods for representing design patterns, and applying them to modeling problems. To the best of our knowledge, none of the approaches proposed so far represents the design problem that the pattern is meant to solve, explicitly. An explicit representation of the problem has several advantages, including 1) a better characterization of the problem space addressed by the pattern—better than the textual description embodied in pattern documentation templates, 2) a more natural representation of the transformations embodied in the application of the pattern, and 3) a better handle on the automatic detection and application of patterns. In this paper, we describe the principles underlying our approach, and the current implementation in the Eclipse Modeling FrameworkTM.	artifact (software development);documentation;eclipse;functional requirement;item unique identification;metamodeling;metaobject;model transformation;model-driven engineering;non-functional requirement;problem domain;software design pattern	Hafedh Mili;Ghizlane El-Boussaidi	2005		10.1007/11557432_14	software design pattern;simulation;documentation;computer science;engineering;artificial intelligence;software development;software engineering;pattern language;reuse;design pattern;programming language;structural pattern;algorithm	EDA	-43.35469493352312	25.589432210249914	58580
2cbc2125e7faddbae38b453c3efff441ac27c9f9	integration of immune features into a belief-desire-intention model for multi-agent control of public transportation systems		There is a growing need to develop monitoring and control systems to maintain the performance and the quality of service of Public Transportation Systems (PTS) at acceptable levels, especially in case of traffic disturbances, such as accidents or congestion. Despite the use of Multi-Agent Systems (MAS) to control PTS, many existing systems still rely on centralized control architectures, and do not offer generic agent behavior models. Many Belief-Desire-Intention (BDI) models were developed as generic agent decision-making processes, but existing developments still lack detailed descriptions of models instantiation and implementation. This article introduces a new framework for the implementation of the Belief-Desire-Intention (BDI) model for the development of an agent based decision support system for the control of public transportation systems. The suggested framework uses a set concepts and mechanisms inspired from biological immunity. Through a simulation case study, we have presented an example of implementation of the suggested BDI framework.		Salima Mnif;Saber Darmoul;Sabeur Elkosantini;Lamjed Ben Said	2017		10.1007/978-3-319-59650-1_39	public transport;machine learning;quality of service;risk analysis (engineering);artificial intelligence;biological immunity;belief–desire–intention model;decision support system;multi-agent system;computer science;control system	ML	-40.43619393393721	21.872443038135486	58618
a7cd7d31c83131848274fa267b42769898af3442	evaluating embedded decision processes of manufacturing systems through simulation	manufacturing systems;make to order;control systems;formal languages;object oriented programming;development tool;process control;manufacturing systems object oriented modeling decision making control systems industrial engineering process control production timing object oriented programming formal languages;production;decision process;technical report;manufacturing system;object oriented modeling;industrial engineering;timing	This paper addresses the issues related to the decision processes of manufacturing system simulation. The manufacturing system is perceived in terms of intelligent entities capable of making non-programmed decisions and data driven entities capable of making programmed decisions. The system entities are classified according to the levels of the previously defined modeling formalism. The objective of the study is to investigate the effects of employing multiple layers of nonprogrammed control. An example make-to-order type of manufacturing system is simulated using the developed tool to observe the impacts of different layers on overall performance.	embedded system;entity;formal system;simulation	S. Cem Karacal	1997		10.1145/268437.268630	manufacturing execution system;build to order;formal language;integrated computer-aided manufacturing;process development execution system;computer science;systems engineering;engineering;technical report;process control;computer-integrated manufacturing;object-oriented programming;world wide web;manufacturing engineering	Robotics	-36.759669264550226	28.462726986191523	58628
a77e3a71d3e16a65275155b2199395a58a1280d3	structured multi-view modeling by tabular notation	model based requirements engineering tabular specification multi view modeling;software metrics formal specification formal verification;software systems structured multiview modeling tabular notation software complexity requirements engineering tabular expression requirements documentation tabular specification;complexity theory semantics documentation mathematical model electronic mail software systems	The growth of software complexity and high degree of dependencies between functionalities motivates the use of models during requirements engineering. Hence, readability and comprehensibility of currently requirements specification techniques should be increased. Additionally, multi-view modeling and tabular expression are widely accepted techniques in requirements documentation. We present a tool that allows structured multi-view modeling of the behavior of the system by means of tabular notation. Our tool provides various table patterns to support different behavior views, which leverage the advantages of tabular specification, e.g., unambiguous, precise, and easier to read, analyses and communicate. Our aim is to reduce the complexity in the development of software systems.	documentation;programming complexity;requirement;requirements engineering;software requirements specification;software system;table (information)	Xiuna Zhu;Dongyue Mou;Daniel Ratiu	2014	2014 IEEE 22nd International Requirements Engineering Conference (RE)	10.1109/RE.2014.6912280	software requirements specification;formal methods;computer science;theoretical computer science;formal specification;database;programming language	SE	-47.85843893018825	26.867815034005535	58861
6e6604cb893027a9e7cbc2d12dac6aa9d963b4e0	engineering hierarchical complex systems: an agent-based approach. the case of flexible manufacturing systems		This article introduces a formal model to specify, model and validate hierarchical complex systems described at different levels of analysis. It relies on concepts that have been developed in the multi-agentbased simulation (MABS) literature: level, influence and reaction. One application of such model is the specification of hierarchical complex systems, in which decisional capacities are dynamically adapted at each level with respect to the emergences/constraints paradigm. In the conclusion, we discuss the main perspective of this work: the definition of a generic meta-model for holonic multi-agent systems (HMAS).	agent-based model;complex systems;decisional diffie–hellman assumption;holon (philosophy);mathematical model;metamodeling;multi-agent system;programming paradigm;simulation	Gildas Morvan;Daniel Dupont;Jean-Baptiste Soyez;Rochdi Merzouki	2012		10.1007/978-3-642-27449-7_4	simulation	AI	-41.97833954009461	21.856768123012007	58913
f7a166218075a121a1d6d3b13e3fb0987756f7d8	the raise language, method and tools	tool support;spectrum;specification language;software development	This paper presents the RAISE1 software development method, its associated specification language, and the tools supporting it. The RAISE method enables the stepwise development of both sequential and concurrent software from abstract specification through design to implementation. All stages of RAISE software development are expressed in the wide-spectrum RAISE specification language. The RAISE tools form an integrated tool environment supporting both language and method. The paper surveys RAISE and furthermore, more detailed presentations of major RAISE results are provided. The subjects of these are (a) an example of the use of the RAISE method and language, and (b) a presentation of the mathematical semantics of the RAISE specification language.	denotational semantics;emoticon;raise;software development;specification language;stepwise regression	Mogens Nielsen;Klaus Havelund;Kim Ritter Wagner;Chris George	1989	Formal Aspects of Computing	10.1007/BF01887199	spectrum;software requirements specification;specification language;computer science;software design;software development;formal specification;programming language;programming language specification	SE	-45.40642005133182	29.091348200427703	59074
f04c4e3ef0d9dcc5c9310817b36d530a3c818e41	wst: a tool supporting timed composite web services model transformation	verification;composite web service;tool support;model transformation;web service composition;web services;choreography;modeling;real time systems	In this paper we introduce a tool called the Web Service Translation tool (WST), which we are developing to implement a methodology for the design, validation and verification of Web Services with timed restrictions. This methodology works by making several translations, from phase to phase in the software development life cycle, where the system is represented at each phase by XML models. We use XSL Transformations (XSLT), which is a language for transforming XML documents. The purpose of these translations is to generate XML code automatically for a Web Service system and to obtain Web Services description models with Timed Automata for validating and verifying composite Web Services with time restrictions.	business process execution language;compiler description language;concurrency (computer science);consistency model;diagram;grammar-based code;graphical model;kaos;model transformation;petri net;requirement;software development process;system requirements;systems design;timed automaton;uppaal;unified modeling language;verification and validation;web service;xml;xslt	María-Emilia Cambronero;Gregorio Díaz;Enrique Martínez;Valentín Valero Ruiz;M. Llanos Tobarra	2012	Simulation	10.1177/0037549710372098	web service;web development;web modeling;verification;business process execution language;data web;systems modeling;web design;web standards;computer science;systems engineering;ws-policy;service-oriented architecture;soap;ws-addressing;database;ws-i basic profile;web 2.0;world wide web;choreography	SE	-46.86314883338471	26.074354289682493	59222
7aa3481ec9ae65f958e00038d0fced1eb1a6dcb9	rough sets	permutation graph;algorithm;breadth first search;rough set;biconnected component	A rapid growth of interest in rough set theory 290] and its applications can be lately seen in the number of international workshops, conferences and seminars that are either directly dedicated to rough sets, include the subject in their programs, or simply accept papers that use this approach to solve problems at hand. A large number of high quality papers on various aspects of rough sets and their applications have been published in recent years as a result of this attention. The theory has been followed by the development of several software systems that implement rough set operations. In Section 12 we present a list of software systems based on rough sets. Some of the toolkits, provide advanced graphical environments that support the process of developing and validating rough set classiiers. Rough sets are applied in many domains, Several applications have revealed the need to extend the traditional rough set approach. A special place among various extensions is taken by the approach that replaces indiscernibility relation based on equivalence with a tolerance relation. In view of many generalizations, variants and extensions of rough sets a uniform presentation of the theory and methodology is in place. This tutorial paper is intended to fulllll these needs. It introduces basic notions and illustrates them with simple examples. It discusses methodologies for analysing data and surveys applications. It also presents and introduction to logical, algebraic and topological aspects, major extensions to standard rough sets, and it nally glances at future research.	display resolution;graphical user interface;linear algebra;list of toolkits;outline of software;rough set;set theory;software system;turing completeness	Zdzislaw Pawlak	1984		10.1145/259526.277421	biconnected component;rough set;breadth-first search;computer science;permutation graph;pattern recognition;biconnected graph	DB	-34.366856245223346	24.139815734834567	59335
c80747fc08b570e41ff37125d054314764148be0	developing components in the presence of re-entrance	parallelisme;program verification;specification language;verificacion programa;parallelism;formal verification;paralelismo;verification formelle;lenguaje especificacion;information system;verification programme;langage specification;systeme information;sistema informacion	Independent development of components according to their speci cations is complicated by the fact that a thread of control can exit and re-enter the same component. This kind of re-entrance may cause problems as the internal representation of a component can be observed in an inconsistent state. We argue that the ad-hoc reasoning used in establishing conformance of components to their speci cations that intuitively appears to be correct does not account for the presence of re-entrance. Such reasoning leads to a con ict between assumptions that component developers make about the behaviour of components in a system, resulting in the component re-entrance problem. We formulate the modular reasoning property that captures the process of independent component development and introduce two requirements that must be imposed to avoid the re-entrance problem. Then we de ne a customised theory of components, component systems, and component re nement which models the process of component development from speci cations. Using this theory, we prove that the formulated requirements are su cient to establish the modular reasoning property.	conformance testing;hoc (programming language);naruto shippuden: clash of ninja revolution 3;requirement	Leonid Mikhajlov;Emil Sekerinski;Linas Laibinis	1999		10.1007/3-540-48118-4_19	real-time computing;specification language;formal verification;computer science;theoretical computer science;component;programming language;information system;algorithm	SE	-39.61712234438813	25.250579101995914	59404
4c7c029cb4e49c58be346ecb6cd5292b2b955de7	synchronization can improve reactive systems control and modularity	datorsystem;computer systems;embedded systems;reactive system;inbaddad systemteknik	We concentrate on two major aspects of reactive system design: behavior control and modularity. These are studied from a formal point of view, within the framework of action systems. The traditional interleaving paradigm is completed with a barrier synchronization mechanism. This is achieved by introducing a new parallel composition operator, applicable to both discrete and hybrid models. While offering improvements with respect to control and modularity, the approach uses the correctness preserving mechanisms provided by the underlying reasoning environment.	barrier (computer science);control theory;correctness (computer science);forward error correction;modularity (networks);modularity of mind;programming paradigm;systems design	Cristina Cerschi Seceleanu;Tiberiu Seceleanu	2004	J. UCS	10.3217/jucs-010-10-1429	real-time computing;reactive system;computer science;distributed computing	PL	-38.879377207225644	29.29520034784642	59450
3385e8f71da3d686b79a496b6b40bdede4d736f1	emf model refactoring based on graph transformation concepts	eclipse modeling framework;model refactoring;graph transformation;structured data	The Eclipse Modeling Framework (EMF) provides a modeling and code generation framework for Eclipse applications based on structured data models. Within model driven software development based on EMF, refactoring of EMF models become a key activity. In this paper, we present an approach to define EMF model refactoring methods as transformation rules being applied in place on EMF models. Performing an EMF model refactoring, EMF transformation rules are applied and can be translated to corresponding graph transformation rules, as in the graph transformation environment AGG. If the resulting EMF model is consistent, the corresponding result graph is equivalent and can be used for validating EMF model refactoring. Results on conflicts and dependencies of refactorings for example, can help the developer to decide which refactoring is most suitable for a given model and why.	anti-grain geometry;code generation (compiler);code refactoring;data model;debugger;eclipse modeling framework;graph rewriting;in-place algorithm;model transformation;model-driven engineering;software development;unified modeling language;visual editor	Enrico Biermann;Karsten Ehrig;Christian Krause;Günter Kuhns;Gabriele Taentzer;Eduard Weiss	2006	ECEASST	10.14279/tuj.eceasst.3.34	computer science;theoretical computer science;programming language;algorithm	SE	-45.54344416888967	26.769768980945507	59525
c5b10dd2f819dc116a1e431162d67ab33a98ba41	self-aware computing systems: related concepts and research areas		Self-aware computing systems exhibit a number of characteristics (e.g., autonomy, social ability, and proactivity) which have already been studied in different research areas, such as artificial intelligence, organic computing, or autonomic and self-adaptive systems. This chapter provides an overview of strongly related concepts and areas of study from the perspective of self-aware computing systems.		Javier Cámara;Kirstie L. Bellman;Jeffrey O. Kephart;Marco Autili;Nelly Bencomo;Ada Diaconescu;Holger Giese;Sebastian Götz;Paola Inverardi;Samuel Kounev;Massimo Tivoli	2017		10.1007/978-3-319-47474-8_2	management science	HPC	-45.03147499523952	21.092047674766977	59619
61332b2ef2699cb78dce234cb593feae834d225d	testing object-oriented software: a survey	software process;object oriented programming;model validation;design for testability;abstract data types;object oriented design;object oriented analysis;test coverage;c;clos;integration testing;formal methods;eiffel;formal verification;regression testing;unit testing	Component Completeness Checklng Formal Verlflca tlon Component Implementation T Fo rrn al Artifacts Informal Artifacts Behavior Figure 3. ADT artifacts cind verification techniques TESTING OBJECT-ORIENTED SOFTWARE 135 et al., 1981; Dauchy et al., 1993; Doong and Frankl, 1994). Relationships among axioms can be exploited to generate test sequences and test case data (Bougt et al., 1986; Choquet, 1986; Gaudel and Marre, 1988; Bemot et al., 1991; Dauchy et al., 1993; Doong and Frankl, 1994). Most ADT test approaches generate operation sequences which are hoped to be faultrevealing (Jalote and Caballero, 1988; Jalote, 1992; Zweben et al., 1992; Parrish et al., 1993b; Doong and Frankl, 1994). Tests using model-based specifications select sequences by analysing define-use relationships among exported operations (Zweben et al., 1992; Parrish et al., 1993b). A coverage measure may be derived from such a test suite. In contrast, tests using algebraic specifications make use of constraints on operations (axioms) to select paths by a substitution process. Automated support for model validation and consistency checking is discussed in Section 4. Product validation is not discussed here as it can be accomplished by established methods which are not specific to ADTs or object-oriented development. 2.2. Formal verification 2.2.1. Prover’s assistant An early presentation of the ADT approach argues that algebraic specification facilitates proofs by factoring complexity and allowing automated support. ‘Writing the axioms in a certain style allows them to be used as reduction rules so that proofs become largely symbol manipulation exercises.’ (Guttag et al., 1978, p. 1062). ‘Testing’ uses a direct implementation input to the ‘data type verification system’ (DTVS). A direct implementation for data type T is an ‘implementation whose representation part is a subset of the syntactic specification of T and whose program part is a subset of the semantic specification of T.’ (Guttag et al., 1978, p. 1059). The verification process has three steps: ( 1 ) input the specification and implementation to DTVS; (2) use DTVS to generate axioms and equality axioms for the specification (verification conditions); (3) the user attempts to prove the verification conditions, using an automated support for substitution of previously established results. This process is reported to be useful for discovering missing assumptions. The tool keeps track of proofs and does some syntactic checking.	algebraic specification;formal verification;integer factorization;model checking;test case;test suite;word lists by frequency	Robert V. Binder	1996	Softw. Test., Verif. Reliab.	10.1002/(SICI)1099-1689(199609/12)6:3/4%3C125::AID-STVR121%3E3.0.CO;2-X	non-regression testing;object-oriented analysis and design;test strategy;keyword-driven testing;reliability engineering;regression testing;model-based testing;formal methods;software performance testing;white-box testing;manual testing;formal verification;system integration testing;integration testing;computer science;acceptance testing;eiffel;software reliability testing;clos network;theoretical computer science;object-oriented design;functional testing;software construction;design for testing;risk-based testing;software testing;regression model validation;unit testing;code coverage;programming language;object-oriented programming;abstract data type;system testing;software development process	Logic	-46.61177735313057	29.924041528399005	59712
9a4a4c1c1a40d3bc369905b90704c80d16ae544a	relationship-based access control policies and their policy languages	policy languages;relationship based access control;access control policies;policy language;social network;modal logic;access control policy;social networks;access control models;access control	The Relationship-Based Access Control (ReBAC) model was recently proposed as a general-purpose access control model. It supports the natural expression of parameterized roles, the composition of policies, and the delegation of trust. Fong proposed a policy language that is based on Modal Logic for expressing and composing ReBAC policies. A natural question is whether such a language is representationally complete, that is, whether the language is capable of expressing all ReBAC policies that one is interested in expressing. In this work, we argue that the extensive use of what we call Relational Policies is what distinguishes ReBAC from traditional access control models. We show that Fong's policy language is representationally incomplete in that certain previously studied Relational Policies are not expressible in the language. We introduce two extensions to the policy language of Fong, and prove that the extended policy language is representationally complete with respect to a well-defined subclass of Relational Policies.	access control;general-purpose modeling;modal logic	Philip W. L. Fong;Ida Siahaan	2011		10.1145/1998441.1998450	computer science;knowledge management;data mining;database;social network	PL	-37.441632791220925	19.248478051907075	59729
cf5b24941b8bafbb6cbd49924ea276d22d800781	a high level interactive design environment for complex systems	point to point;complex system;frequency domain;high level language;interaction design	CASSY is a system for formal representation and verification of architecture proposals at the system level. The designer describes the analog and digital signal in either the time or frequency domain using the high-level representation language SIBA. The system components are specified hierarchically with the high-level language KOBA. Then HISIM performs a symbolic and formal simulation of the specified system, avoiding point to point processing of e.g. sample streams.		Erdmuthe Meyer zu Bexten;Claudio Moraga;Jürgen Büddefeld	1991		10.1007/BFb0021034	complex systems;simulation;human–computer interaction;point-to-point;computer science;interaction design;high-level programming language;frequency domain;computer graphics (images)	HCI	-37.31369029880815	29.73044325096905	59875
8a7fc9a9f7f925a90091018521b8678364f743fc	toward rigorous design of domain-specific distributed systems			distributed computing	Mohammed Al-Mahfoudh;Ganesh Gopalakrishnan;Ryan Stutsman	2016		10.1109/FormaliSE.2016.015	fault tolerance;real-time computing;formal methods;concurrency;computer science;theoretical computer science;software engineering;distributed computing;programming language	EDA	-41.67264973211475	30.90595653785887	59944
f031d860b37b6c5280b743f6bb1e49b2a85d2f46	cocospec: a mode-aware contract language for reactive systems		Contract-based software development has long been a leading methodology for the construction of component-based reactive systems, embedded systems in particular. Contracts are an effective way to establish boundaries between components and can be used efficiently to verify global properties by using compositional reasoning techniques. A contract specifies the assumptions a component makes on its context and the guarantees it provides. Requirements in the specification of a component are often case-based, with each case describing what the component should do depending on a specific situation (or mode) the component is in. We introduce COCOSPEC, a mode-aware assume-guarantee-based contract language for embedded systems built as an extension of the Lustre language. COCOSPEC lets users specify mode behavior directly, instead of encoding it as conditional guarantees, thus preventing a loss of mode-specific information. Mode-aware model checkers supporting COCOSPEC can increase the effectiveness of the compositional analysis techniques found in assume-guarantee frameworks and improve scalability. Such tools can also produce much better feedback during the verification process, as well as valuable qualitative information on the contract itself. We presents the COCOSPEC language and illustrate the benefits of mode-aware model-checking on a case study involving a flight-critical avionics system. The evaluation uses KIND 2, a collaborative, parallel, SMT-based model checker extended to fully support COCOSPEC.	avionics;component-based software engineering;critical system;dataflow programming;embedded system;executable;experiment;feedback;lustre (programming language);model checking;outsourcing;pdf/a;requirement;scalability;simultaneous multithreading;software development;specification language;test case	Adrien Champion;Arie Gurfinkel;Temesghen Kahsai;Cesare Tinelli	2016		10.1007/978-3-319-41591-8_24	model checking;avionics;real-time computing;computer science;software development;scalability;reactive system	SE	-43.054914709974454	31.463465224795875	59992
77b5f41b4977692bbd01f629c12bebca8c87db8b	configuration fragments as the dna of system and change properties - architectural change of component-based and service-oriented systems	service orientation	The concept of a Configuration Fragment is adopted to help address the challenge of managing the different kinds of dependencies that exist during the evolution of component-based and service-oriented systems. Based upon a model of Architectural Change and an example of an application-specific context, Configuration Fragments are defined in order to express and reconcile change properties with respect to existing system properties. During system evolution, Configuration Fragments enable the configuration of Service and Service Protocol, Operation and Provided Service, Operation and Required Service, Operation and Operation, Operation and State Element, Operation and Composite Component, Component and Component, and Required Service and Provided Service dependencies. This occurs through configuration leading to association, disassociation, or refinement of these system elements.	component-based software engineering;refinement (computing);service-oriented software engineering	D'Arcy Walsh	2008			computer science	SE	-40.73369351952745	28.475221726250464	60097
d8e67d2cb4d7a339ed18e5c1b63abf88e1ca35b6	some current topics in model checking	modelizacion;commercial use;semantica juego;proceso concepcion;interes comercial;verificacion modelo;logica temporal;design process;formal specification;tranchage;change management;renemen t;incremental design;temporal logic;game semantics;verification modele;semantique jeu;abstraction;automatisation;program verification;automatizacion;abstraccion;journal article;preparacion serie fabricacion;specification formelle;modelisation;refinement method;especificacion formal;technology transfer;verificacion programa;slicing;model checking;interet commercial;feature integration;version management;mathematical model;chapeado;transferencia tecnologica;process planning;methode raffinement;refinement checking;verification programme;preparation gamme fabrication;modeling;metodo afinamiento;lenguaje formal;logique temporelle;gestion version;formal language;processus conception;transfert technologie;automation;langage formel	Model checking is a particular approach to property verification of systems. One describes a system in a mathematical model, expresses the properties one wishes to verify for the system in a formal language, and then checks whether the model satisfies the formal property. Invented 25 years ago, this approach is fully automatic and has therefore gained wide acceptance and is increasingly being used in commercial research and development units. Impediments remain on the road to successful technology transfer. For one, the size of models often increases exponentially in the number of variables or sub-models, preventing scalable automation. Abstracting a model to reduce its size can be a cost-effective way of addressing this. For another, systems and models may be subject to change, e.g. in an incremental design process. One then seeks cost-effective means of ascertaining that property verifications remain to be valid as models evolve. This special section presents current research on such abstraction and change management of model checking.	continuous design;formal language;mathematical model;model checking;scalability;verification and validation	Michael Huth	2006	International Journal on Software Tools for Technology Transfer	10.1007/s10009-006-0021-y	model checking;formal language;systems modeling;design process;temporal logic;computer science;artificial intelligence;game semantics;automation;change management;mathematical model;formal specification;abstraction;programming language;abstraction model checking;algorithm	SE	-41.83017838492564	27.256207193577925	60106
cd0efd7086784069847bcf4f624a33d1923e5263	behavior alignment and control flow verification of process and service choreographies		The representation of process and service choreographies has been recognized as an important requirement in service-oriented methodologies. The guarantee of alignment between process and service choreographies and the verification of the behavior of choreographies represent an important improvement for such methodologies, since they enable the automatic generation of choreography service specifications from well-defined choreography process models. To deal with these issues, we propose a transformation pattern that guarantees behavior alignment between process and service choreographies, and a verification method for the control flow of choreographies, which can be applied to any choreography language. These approaches make use of the Global Interaction Nets (GI-Nets) language to formalize the behavior of process and service choreographies. This formal representation can then be used to conclude on the behavioral aspects of choreographies. In addition, we present a tool for the modeling, automatic generation and verification of GI-Nets, and apply the proposed approaches to the UP-ColBPIP and WS-CDL choreography languages.	advanced process control;bidirectional transformation;business process execution language;compiler description language;control flow;deadlock;delimiter;exception handling;formal language;service choreography;service-oriented architecture;service-oriented device architecture	Jorge Roa;Pablo David Villarreal;Omar Chiotti	2012	J. UCS	10.3217/jucs-018-17-2383	business process;web service;control flow;software engineering;data mining;computer science;interaction nets;choreography;process modeling;distributed computing	PL	-41.219215125104874	30.285682149294317	60180
3165145faab3d01c0c699fd020f62753b19bbd54	simulating emergent properties of coordination in maude: the collective sort case	distributed system;stochastic transition system;collective sort;analysis and design;simulation;tuple space;term rewrite system;autonomous agent;emergent properties;complex system;coordination languages and models;transition systems;self organization;stochastic model;modelling and simulation;coordination	Recent coordination languages and models are moving towards the application of techniques coming from the research context of complex systems: adaptivity and self-organization are exploited in order to tackle the openness, dynamism and unpredictability of today’s distributed systems. In this area, systems are to be described using stochastic models, and simulation is a valuable tool both for analysis and design. Accordingly, in this work we focused on modelling and simulating emergent properties of coordination techniques. We first develop a framework acting as a general-purpose engine for simulating stochastic transition systems, built as a library for the Maude term rewriting system. We then evaluate this tool to a coordination problem called collective sort, where autonomous agents move tuples across different tuple spaces according to local criteria, and resulting in the emergence of the complete clustering property.	algorithm;autonomous robot;cluster analysis;complex systems;distributed computing;emergence;general-purpose modeling;maude system;model checking;openness;prototype;rewriting;self-organization;simulation;stochastic process;swarm;tuple space	Matteo Casadei;Luca Gardelli;Mirko Viroli	2007	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2007.05.022	complex systems;self-organization;simulation;computer science;artificial intelligence;tuple space;stochastic modelling;autonomous agent;algorithm;emergence	AI	-40.25537282155364	21.420020174429222	60272
54b76682aff725515303c69617be77dc0a5e04a8	dynamic modelling: an example of an event-driven approach		In the first part of this paper (sections 1 and 2) the development in IS-development methods will be outlined. As a conclusion it can be seen that the communication and dynamic aspects of systems are coming are increasingly the focus of interest. Obviously, the increasing demands organizations have with respect to their information systems do make it necessary to analyse the object system (i.e. that part of reality the information system has to support) in such a way that the target information system will reflect the dynamic properties of the object system. Furthermore, only executable specifications of dynamic models of the target information system can give us the opportunity to support an adequate evaluation of proposed solutions.#R##N##R##N#In section 3 the relationships between the IS and the Object System will be elaborated. The author's view towards information systems and the object system are dealt with to give the readers a reference context for understanding the type of modelling approach that is proposed in the following sections.#R##N##R##N#In section 4 the concepts used in an event driven modelling approach are discussed. A conceptual meta-schema will be presented, giving the semantic relationships between the primitives in the modelling language that is proposed. The differences and similarities between the proposed approach and the object-oriented approach that has received so much attention lately, will be discussed.#R##N##R##N#In section 5 the methodological aspects will be dealt with. It will be shown that concepts should support the modelling process not only in such a way that they make it possible to represent design decisions, but also that they should be regarded as a set of instruments that enable a good decomposition of the design procedure and that they should give effective support to the ‘semantic understanding’ of the object system.#R##N##R##N#In section 6 the main differences between the proposed approach and existing design methods will be outlined.	event-driven architecture;event-driven finite-state machine	Leo J. B. Essink	1990		10.1016/B978-0-444-88923-2.50007-0	computer science;artificial intelligence;data mining;management science	NLP	-45.05743409319051	22.817542657533835	60684
0216968d73078eee979a428287e5496c6e861a59	proving properties of stateflow models using iso standard z and cadiz	developpement logiciel;modelizacion;formal specification;norme iso;validacion;norma iso;metodo formal;methode formelle;automatisation;automatizacion;iso standard;formal method;specification formelle;modelisation;especificacion formal;theorem prover;development environment;desarrollo logicial;software development;validation;modeling;automation	This paper focuses on the use of ISO Standard Z and CADiZ in the formal validation of Stateflow models against requirements-oriented assumptions. It documents some of what the Simulink/Stateflow Analyser tool does in support of the Practical Formal Specification method. The tool aims to automate the formal validations of the method, so that users of Simulink/Stateflow can benefit from them. The Z exploits some notations that are particular to ISO Standard Z. The automation is aided by quite terse tactics interpreted by CADiZ.	computer science;decision problem;display resolution;formal methods;formal specification;forward secrecy;local variable;requirement;simulink;stateflow;systems engineering	Ian Toyn;Andy Galloway	2005		10.1007/11415787_7	formal methods;systems modeling;computer science;software development;automation;formal specification;development environment;automated theorem proving;programming language;algorithm	SE	-41.8203956243899	27.098374494845977	60830
f5ac4ec3f0375b9516270281d67e98ee2dbb15f5	power to the future: use cases and challenges for mobile, self configuring, and distributed power grids		Smart Cities are calling for a major innovation in many strategic infrastructures that shape the daily life of citizens. Arguably one of the most strategic and resilient to changes is the power transmission and distribution infrastructure. And yet, the power sector, together with the communication network infrastructure, are the major enablers of future smart cities.In this paper, we present three fictional, yet likely use cases that highlight how the Information and Communication Technologies (ICT) and Infrastructures are ready to support this much needed innovation, while the power distribution infrastructure has still a long way to go to be able to benefit from the opportunities offered by ICT. The resulting discussion will hopefully involve power grid operators and legislators to the end of promoting a thorough renovation of the power sector.		Riccardo Bonetto;Ilya Sychev;Frank H. P. Fitzek	2018	2018 IEEE International Conference on Communications, Control, and Computing Technologies for Smart Grids (SmartGridComm)	10.1109/SmartGridComm.2018.8587582	electricity generation;power transmission;distributed power;computer network;telecommunications network;grid;smart grid;computer science;use case;information and communications technology	HPC	-36.86951595597023	20.733047967404122	61137
4e07767503d1938f1b86de9e6f369e7d0fe2f1d5	safe composition of configuration knowledge-based software product lines	configuration knowledge;safe composition;software product lines	Feature models and configuration knowledge drive product generation in a Software Product Line (SPL). Mistakes when specifying these models or in the implementation might result in ill-formed products-- the safe composition problem. This work proposes an automated approach for verifying safe composition for SPLs with explicit configuration knowledge models. We translate feature models and configuration knowledge into propositional logic and use SAT Solvers to perform the verification. We evaluate our approach using seven releases of the MobileMedia SPL, which generate up to 272 products in the 7th release. We report safe composition problems related to non-conformity with the feature model, bad specification of the configuration knowledge, and implementation not envisioning the full SPL scope, that affect over 40% of the products in the 7th release.	alloy analyzer;automated theorem proving;code refactoring;compiler;complete (complexity);conformity;consistency model;fm broadcasting;feature model;knowledge representation and reasoning;programming language;propositional calculus;refinement (computing);software product line;spl (unix);verification and validation	Leopoldo Teixeira;Paulo Borba;Rohit Gheyi	2011	2011 25th Brazilian Symposium on Software Engineering	10.1016/j.jss.2012.11.006	computer science;systems engineering;engineering;operating system;software engineering;data mining;programming language;engineering drawing	SE	-44.55707261520257	29.448425998086574	61171
d64eb4b5ca17c8e5a27a273023b59eef7fdaba2d	protocol compatibility notations for service integration testing	software testing;formal model;web service;software engineering;web services;finite state automaton;test generation;service oriented architecture;choreography;service integration;orchestration	This paper provides a notation of protocol compatibility among services and describe how this can be useful to test interoperability in Service-Based Applications (SBA). Indeed, the features of a SBA, like distribution and loosely-coupling make usual testing techniques inefficient, especially when the choreography model is adopted. We argue that only the service interface description is not enough to prove and test compatibility among services. Services behavior should also be described. In this paper we introduce a formal model based on message-exchange that should fit for it, considering a service as a non-deterministic finite state automaton. According to this model, we can finally discuss a definition of protocol compatibility and its role for test generation.	deterministic finite automaton;finite-state machine;formal language;integration testing;interoperability	Francesco De Angelis;Daniele Fanì;Alberto Polzonetti	2011		10.1145/2031746.2031749	simulation;computer science;systems engineering;world wide web	SE	-46.925034057014834	18.85219400134551	61511
b0a99917ee74b457c1d3776307d3c2b9ab6e8c79	roles versus classes	object oriented model;programming language;separation of concern;object oriented technology	To improve object-oriented technologies, roles are proposed to support separation of concerns, object collaboration, and object evolutions. Compared with classes, there is confusion regarding roles in modeling, because classes are a well-accepted concept and mechanism of objectoriented technologies while roles are not. This paper explores the nature of classes and roles, clarifies the similarities and differences between them, compares the advantages and disadvantages of them in different aspects, proposes that a programming language should accommodate roles at the same level as classes, and points out the existing challenges in applying roles in programming languages.	apl;eclipse;goto;problem domain;programming language;separation of concerns;software development process;whole earth 'lectronic link	Haibin Zhu	2007			simulation;separation of concerns;computer science;artificial intelligence;programming language	PL	-43.38547303538828	23.892395633238685	61605
71980ea8dffd5552a64f7430b8d7e9cd238ccf32	a simulation model for performance analysis of large shared data bases	performance analysis;simulation model	This paper describes a data base simulator, or rather, a family of simulators, that is being developed at the University of Stockholm. The purpose of this discrete event simulation model is to provide a tool for • investigating the performance of data base oriented information systems (existing and planned) • increasing the knowledge of i) design of data base oriented information systems, ii) design of DBMS (or setting parameters when generating a DBMS).#R##N##R##N#A typical target system would be a heavily loaded multiprogrammed on-line system with a very large data base. One of the guidelines for design of the simulator has been user orientation. The preparation and execution of the model is done interactively and on a problem-oriented leve 1, e.g. the analyst describes the data base with DDL/DML instructions in a DBTG-like language. It is possible to model hierarchical as well as network-based data bases.	database;profiling (computer programming);simulation	Christer Hulten;Lars Söderlund	1977			real-time computing;simulation;computer science;simulation modeling;database;programming language	DB	-34.43664993405007	26.89011598773419	61820
d20bac2905745dabc0c5f4b9ba4e93979cdd71b6	giwa: a generator for adaptive web applications	electronic commerce;history;web interface;automatic generation;process design;html;navigation;navigation process design ontologies java xml html advertising electronic commerce education history;xml;ontologies;java;advertising	Engineering adaptive Web applications imply the development of content that can be automatically adjusted to varying classes of users and their preferences in terms of presentation. To meet this requirement, we present in this paper a generator for adaptive web applications called GIWA. GIWA‘s target is to facilitate the automatic execution of the design and the automatic generation of adaptable web interface. GIWA methodology is based on three levels: semantic level, adaptation level and presentation level. The implementation of GIWA is based on java swing interface to instantiate the models which are translated in XML files. GIWA uses then XSL files to generate the HTML page corresponding to the user.	html;swing (java);user interface;web application;xml	Raoudha Ben Djemaa;Ikram Amous;Abdelmajid Ben Hamadou	2006	Advanced Int'l Conference on Telecommunications and Int'l Conference on Internet and Web Applications and Services (AICT-ICIW'06)	10.1109/AICT-ICIW.2006.105	e-commerce;process design;navigation;xml;html;computer science;ontology;operating system;data mining;database;multimedia;user interface;java;world wide web	Web+IR	-46.68334654652472	19.54059169126617	61855
a18d75e31979e9ccf00336086ef9a08a803f3edf	modelling the provenance of data in autonomous systems	agent oriented design;goal orientation;multi agent system;autonomy;web service;autonomic system;provenance;process;service oriented architecture	Determining the provenance of data, i.e. the process that led to that data, is vital in many disciplines. For example, in science, the process that produced a given result must be demonstrably rigorous for the result to be deemed reliable. A provenance system supports applications in recording adequate documentation about process executions to answer queries regarding provenance, and provides functionality to perform those queries. Several provenance systems are being developed, but all focus on systems in which the components are reactive, for example Web Services that act on the basis of a request, job submission system, etc. This limitation means that questions regarding the motives of autonomous actors, or agents, in such systems remain unanswerable in the general case. Such questions include: who was ultimately responsible for a given effect, what was their reason for initiating the process and does the effect of a process match what was intended to occur by those initiating the process? In this paper, we address this limitation by integrating two solutions: a generic, re-usable framework for representing the provenance of data in service-oriented architectures and a model for describing the goal-oriented delegation and engagement of agents in multi-agent systems. Using these solutions, we present algorithms to answer common questions regarding responsibility and success of a process and evaluate the approach with a simulated healthcare example.	algorithm;autonomous agent;autonomous robot;autonomous system (internet);documentation;multi-agent system;service-oriented architecture;service-oriented device architecture;software agent;web service	Simon Miles;Steve Munroe;Michael Luck;Luc Moreau	2007		10.1145/1329125.1329185	web service;computer science;knowledge management;service-oriented architecture;goal orientation;multi-agent system;database;autonomy;world wide web;process	AI	-43.388217569480084	18.94939434701521	62211
2e770eb8f20e15342eb84bd63870590d3510c65e	automatic generation of simulation models for semiconductor manufacturing	enabling rule;classical petri net;sematech data;problem data specification;simulation model;large-scale simulation model;semiconductor manufacturing;data schema;automatic generation;domain specific problem definition;data structure;model verification;petri nets;petri net;data structures;object oriented;formal verification;formal specification	This article gives an overview of a framework for automatically generating large-scale simulation models from a domain specific problem definition data schema, here semiconductor manufacturing. This simulation model uses an object-oriented Petri net data structure. The Petri net based simulation uses the same enabling rules as classical Petri nets, but has extensions of time and priorities. This approach minimizes the effort of model verification. Each object identified in the problem data specification is mapped to corresponding Petri net fragments. The Petri net simulation model is synthesized from verifiable subnets. This allows ensuring the liveness of the final Petri net simulation model. The applicability of this approach is demonstrated by generating a simulation model based on the Sematech data set.	data structure;formal verification;liveness;petri net;semiconductor device fabrication;simulation;subnetwork	Ralph Mueller;Christos Alexopoulos;Leon F. McGinnis	2007	2007 Winter Simulation Conference		reliability engineering;stochastic petri net;data structure;computer science;systems engineering;database;process architecture;programming language;petri net	Robotics	-41.46417213714575	30.594813586633084	62215
67a7731449235734443a74d92c23e42682ee33c4	synthesis of asynchronous hardware from petri nets	distributed system;langage description materiel informatique;interfase usuario;proceso concepcion;diseno circuito;synthese circuit;semiconducteur;systeme reparti;design process;productivite;reachability;sintesis control;circuit commande;behavioral analysis;red petri;user interface;circuito lineal;circuit design;hardware description languages;espace etat;simultaneidad informatica;linear circuit;logique propositionnelle;elemento arquitectural;semiconductor material;constraint satisfaction;productividad;element architectural;specification language;asynchronous circuit;sintesis logica;preparacion serie fabricacion;circuit lineaire;satisfaction contrainte;semiconductor materials;concurrency;sistema repartido;programacion lineal;circuit asynchrone;logic synthesis;state space method;methode espace etat;propositional logic;synthese commande;asequibilidad;state space;analyse comportementale;control circuit;linear programming;design feature;programmation lineaire;atteignabilite;circuito asincrono;sintesis circuito;interface utilisateur;analisis conductual;conception circuit;lenguaje especificacion;circuito control;satisfaccion restriccion;process planning;productivity;logica proposicional;espacio estado;synthese logique;petri net;preparation gamme fabrication;simultaneite informatique;langage specification;control synthesis;circuit synthesis;reseau petri;metodo espacio estado;processus conception	As semiconductor technology strides towards billions of transistors on a single die, problems concerned with deep sub-micron process features and design productivity call for new approaches in the area of behavioural models. This paper focuses on some of recent developments and new opportunities for Petri nets in designing asynchronous circuits such as synthesis of asynchronous control circuits from large Petri nets generated from front-end specifications in hardware description languages. These new methods avoid using full reachability state space for logic synthesis. They include direct mapping of Petri nets to circuits, structural methods with linear programming, and synthesis from unfolding prefixes using SAT solvers.	die (integrated circuit);hardware description language;linear programming;logic synthesis;petri net;reachability;semiconductor;state space;transistor;unfolding (dsp implementation)	Josep Carmona;Jordi Cortadella;Victor Khomenko;Alexandre Yakovlev	2003		10.1007/978-3-540-27755-2_9	productivity;logic synthesis;design process;concurrency;asynchronous circuit;constraint satisfaction;specification language;computer science;state space;linear programming;artificial intelligence;circuit design;linear circuit;process architecture;propositional calculus;hardware description language;programming language;user interface;reachability;petri net;algorithm	EDA	-34.2123537761801	30.984617184377438	62260
b37b0069f2784a0250a90b0ddf37dfb496607aa1	a communication infrastructure to support knowledge level agents on the web		Agent Communication Languages (ACLs) have been developed to provide a way for agents to communicate with each other supporting cooperation in Multi-Agent Systems. In the past few years many ACLs have been proposed for Multi-Agent Systems, such as KQML and FIPA-ACL. The goal of these languages is to support high-level, human like communication among agents, exploiting Knowledge Level features rather than symbol level ones. Adopting these ACLs, and mainly the FIPA-ACL specifications, many agent platforms and prototypes have been developed. Despite these efforts, an important issue in the research on ACLs is still open and concerns how these languages should deal (at the Knowledge Level) with possible failures of agents. Indeed, the notion of Knowledge Level cannot be straightforwardly extended to a distributed framework such as MASs, because problems concerning communication and concurrency may arise when several Knowledge Level agents interact (for example deadlock or starvation). The main contribution of this Thesis is the design and the implementation of NOWHERE, a platform to support Knowledge Level Agents on the Web. NOWHERE exploits an advanced Agent Communication Language, FT-ACL, which provides high-level fault-tolerant communication primitives and satisfies a set of well defined Knowledge Level programming requirements. NOWHERE is well integrated with current technologies, for example providing full integration for Web services. Supporting different middleware used to send messages, it can be adapted to various scenarios. In this Thesis we present the design and the implementation of the architecture, together with a discussion of the most interesting details and a comparison with other emerging agent platforms. We also present several case studies where we discuss the benefits of programming agents using the NOWHERE architecture, comparing the results with other solutions. Finally, the complete source code of the basic examples can be found in appendix.	agent communications language;concurrency (computer science);deadlock;fault tolerance;high- and low-level;knowledge query and manipulation language;knowledge level;middleware;multi-agent system;requirement;symbol level;web service;world wide web	Davide Guidi	2007			computer science;systems engineering;knowledge management;distributed computing	AI	-41.76634601918314	21.171675083852893	62300
0f41bf08512b3d925148f22e3b22fe6f234da40d	new characterization for live and reversible augmented marked graphs	manufacturing systems;procesamiento informacion;algorithm analysis;systeme fabrication;augmented marked graphs;red petri;software architecture;arbre marque;informatique theorique;68r10;information processing;analyse algorithme;petri nets;augmented marked graph;software design;traitement information;graphe marque augmente;petri net;manufacturing system;analisis algoritmo;architecture logiciel;reseau petri;computer theory;informatica teorica	erved Augmented marked graphs were first introduced Chu [1]. Based on siphons and mathematical progr ming, Chu found a number of properties of augmen marked graphs pertaining to their liveness and versibility. In recent years, augmented marked gra are often used in manufacturing system design [2 A major reason is that augmented marked graphs h many desirable properties, especially on their liven and reversibility. In this paper, based on some kno properties reported in the literature, we propos new characterization for live and reversible augmen marked graphs. The new characterization provide simpler necessary and sufficient condition for effici checking of their liveness and reversibility, where only a small subset of minimal siphons which can identified through cycles are considered. A manuf turing system example is used for illustration.	liveness;marked graph;systems design	King Sing Cheung	2004	Inf. Process. Lett.	10.1016/j.ipl.2004.05.018	simulation;information processing;computer science;artificial intelligence;petri net;algorithm	Metrics	-34.26968864295404	24.186876539131852	62395
9e13fea9f443c85f886d6782ae42a9064deed8d7	formal semantic conflict detection in aspect-oriented requirements	conflict detection;base composition;predicate logic;aspect oriented requirements engineering;formal methods;formal semantics;journal article;requirements engineering;requirement engineering;natural language;crosscutting concerns;semantic composition;requirement specification;off the shelf	The goal of Aspect-Oriented Requirements Engineering is to identify possible crosscutting concerns, and to develop composition specifications, which can be used to reason about potential conflicts in the requirements. Recent work in AORE has moved from a syntactic approach to composition, which leads to fragile compositions and increased coupling between aspect and base concerns, to a semantic composition approach, based on semantics of the natural language itself. However, such compositions are at present only informally specified, and as such precise conflict detection between the requirements compositions is difficult. We present an approach for the formalisation of these semantic-based compositions which means that logical conflicts between compositions can be precisely identified and understood semantically. We show that the approach can be supported by off-the-shelf tools, meaning it is scalable and feasible for even large requirements specifications.	aspect-oriented software development;backup;cross-cutting concern;file synchronization;natural language;pointcut;report definition language;requirement;requirements engineering;robustness (computer science);scalability	Nathan Weston;Ruzanna Chitchyan;Awais Rashid	2009	Requirements Engineering	10.1007/s00766-009-0083-y	predicate logic;computer science;systems engineering;formal semantics;database;requirements engineering;natural language;programming language;non-functional requirement	SE	-42.577187669570925	28.475150983775904	62415
a332cef236b42e59bb7aa203e00c44ea7b471561	addressing security requirements through multi-formalism modelling and model transformation	model transformation;security requirements	Model-based approaches are increasingly used in all stages of complex systems design. In this paper, we use multi-formalism modelling and model transformation to address security requirements. Our methodology supports the verification of security properties using the model checker FDR2 on CSP (Communicating Sequential Processes) models. This low-level constraint checking is performed through model refinements, from a behavioural description of a system in the Statecharts formalism. The contribution of this paper lies in the combination of various formalisms and transformations between them. In particular, mapping Statecharts onto CSP models allows for combination of the deterministic system model with non-deterministic models of a system’s environment (including, for example, possible user attacks). The combination of system and environment models is used for model checking. To bridge the gap between these Statechart and CSP models, we introduce kiltera, an intermediate language that defines the system in terms of interacting processes. kiltera allows for simulation, real-time execution, as well as translation into CSP models. An e-Health application is used to demonstrate our approach.	communicating sequential processes;complex systems;environment variable;fdr (software);high- and low-level;interaction;model checking;model transformation;real-time locating system;refinement (computing);relevance;requirement;semantics (computer science);sequence diagram;simulation;software requirements;state diagram;systems design;toolchain	Miriam Zia;Ernesto Posse;Hans Vangheluwe	2007			computer security model;reliability engineering;requirements management;computer science;systems engineering;computer security	SE	-43.78561023676941	31.667923335463442	62484
bcf73b54dc982fe577296c0a4a869bac0b6015bf	a java/corba-based visual program composition environment for pses		A Problem Solving Environment (PSE) is a complete, integrated computing environment for composing, compiling and running applications in a speciic problem area or domain. Parts of the PSE are domain independent , such as the Visual Programming Composition Environment (VPCE), which may be used for constructing application in a number of diierent domains, however, other parts are domain speciic, such as rules to support particular types of components. A domain independent VPCE is rst described, which serves as a user interface for a PSE, and uses Java and CORBA to provide a framework of tools to enable the construction of scientiic applications from components. The VPCE consists of a component repository, from which the user can select oo-the-shelf or in-house components, a graphical composition area on which components can be combined, various tools that facilitate the connguration of components, the integration of legacy codes into components and the design and building of new components. The VPCE produces output using dataaow techniques in the form of a task graph, annotated with a performance model plus constraints for each component, expressed in XML. In addition, the VPCE supports a domain speciic expert system based on JESS 9] to guide the user in component selection and to perform integrity checking.	code;common object request broker architecture;compiler;expert system;graphical user interface;java;problem solving environment;visual programming language;xml	Matthew S. Shields;Omer F. Rana;David W. Walker;Maozhen Li;David Golby	2000	Concurrency - Practice and Experience	10.1002/1096-9128(200007)12:8%3C687::AID-CPE505%3E3.0.CO;2-P		SE	-33.980075483003155	25.52836668429639	62632
3454794b0ab8538cf4067c91f9a837ee5857f22f	a uml-based modeling of web application controller	application development	In this paper, the method suggested in [1] for designing web applications is extended through the modeling of logic of the web application controller. The UML diagram of the controller configuration is described in detail, and its use for the application development is explained.	diagram;unified modeling language;web application	Ekaterina A. Gorshkova;Boris Novikov;D. D. Belov;V. S. Gurov;S. V. Spiridonov	2005	Programming and Computer Software	10.1007/s11086-005-0010-z	web modeling;real-time computing;uml tool;computer science;applications of uml;rapid application development	SE	-48.15914779549659	24.31186092506413	62737
aa1c5e3548da9644399c9b5977fccfee82266422	development of reusable, configurable, extensible holonic manufacturing system	holonic manufacturing systems;manufacturing systems adaptive systems computer architecture production systems machine intelligence software maintenance software standards unified modeling language intelligent manufacturing systems application software;ima framework reusable configurable extensible holonic manufacturing system modern manufacturing systems dynamic situations customer specification changes machine break down emergency orders holonic concept adaptive manufacturing system application context system architecture system cooperation mechanisms intelligent machine architecture software architecture reusable components reconfigurable extensible systems development tool adaptive manufacturing systems extensible holonic manufacturing systems;object oriented programming;system performance;development tool;software architecture;multi agent systems;adaptive systems;manufacturing data processing;software reusability;object oriented programming manufacturing data processing software architecture software reusability adaptive systems multi agent systems;system architecture;reusable component;manufacturing system	Modern manufacturing system have to deal with dynamic situations such as customer specification changes, machine break-down, emergency orders and other kinds of disturbances. This requires the manufacturing system to be adaptive to handle such situations. The holonic concept has been proposed as an efficient paradigm for developing such an adaptive manufacturing system. There are still some critical issues to be investigated such as how to define the holons for a given application context and make them reusable, what should be an appropriate system architecture and how to design the system cooperation mechanisms for better system performance. The Intelligent Machine Architecture (IMA) is a software architecture developed at Vanderbilt University. It provides a framework for developing reusable components and constructing reconfigurable, extensible systems. Although it is mainly used for robots, it is also a suitable development tool for designing adaptive manufacturing systems. The authors explain how to build reusable, reconfigurable and extensible holonic manufacturing systems based on the IMA framework.	holon (philosophy)	Sudong Shu;D. Mitchell Wilkes;Kazuhiko Kawamura	2000		10.1109/ICSMC.2000.886349	embedded system;software architecture;real-time computing;process development execution system;computer science;artificial intelligence;adaptive system;multi-agent system;computer performance;computer-integrated manufacturing;object-oriented programming;systems architecture;software system;systems design	Robotics	-44.26447934779148	22.61593101456585	62739
10fdf3f6437b227d7f161e7d8d9fb6c42f576e9a	improved tool and data selection in task management	resource selection;task analysis;task level meta data data selection task management task creation task execution hercules task manager task resolution resource selection constraints;task management;resource management permission engineering management electronic design automation and methodology buildings user interfaces testing design automation encapsulation process design	Task management involves task creation and execution. These are facilitated using a t sk schema s exemplified in the Hercules Task Manager. Experience with Hercules has shown the task schema to be very useful for task creation, but less than ideal for taskresolution, i.e., the selection of tool and data resources to be used in execution. Tool/data interactions often lead to resource selection constraints that cannot be captured using dependency relationships in the schema. We have addressed this by adding conditions to the task schema which use task-level meta-data to constrain resource selection. With examples we show that conditions are useful for handling a wide variety of real constraints.	balance of power;condition number;hercules graphics card;interaction;task manager	John W. Hagerman;Stephen W. Director	1996		10.1145/240518.240552	real-time computing;computer science;knowledge management;function;task analysis;database;metrical task system	OS	-45.71123296122967	22.3439893484544	62775
f17ad698940b6ee4c04ae27d4ad84ade0c210aa0	improving the parallel execution of behavior trees		Behavior Trees (BTs) have become a popular framework for designing controllers of autonomous agents in the computer game and in the robotics industry. One of the key advantages of BTs lies in their modularity, where independent modules can be composed to create more complex ones. In the classical formulation of BTs, modules can be composed using one of the three operators: Sequence, Fallback, and Parallel. The Parallel operator is rarely used despite its strong potential against other control architectures such as Finite State Machines. This is due to the fact that concurrent actions may lead to unexpected problems similar to the ones experienced in concurrent programming. In this paper, we outline how to tackle the aforementioned problem by introducing Concurrent BTs (CBTs) as a generalization of BTs in which we include the notions of progress and resource usage. We show how CBTs allow safe concurrent executions of actions and we analyze the approach from a mathematical standpoint. To illustrate the use of CBTs, we provide a set of use cases in realistic robotics scenarios.		Michele Colledanchise;Lorenzo Natale	2018	2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)	10.1109/IROS.2018.8593504	operator (computer programming);computer science;autonomous agent;control engineering;robot;finite-state machine;modularity;use case;concurrent computing;distributed computing;artificial intelligence;robotics	Robotics	-38.24076422908527	29.08766446025668	62796
5baead9b79237055e6853f774c71eb5873c4b2c9	a formal methods case study: using light-weight vdm for the development of a security system module	developpement logiciel;lenguaje natural;formal specification;vienna development method;langage naturel;methode formelle;formal method;specification formelle;especificacion formal;desarrollo logicial;security systems;natural language;software development;secure system;systeme securite;software quality	"""This paper describes a formal methods case study in which one module of an existing security system was redeveloped using the \light-weight"""" Vienna Development Method supported by the IFAD Toolbox. The result is compared with the existing version in terms of eeort and quality. In this project, formal methods { even in its \light-weight"""" form { have increased software quality while the development eeorts were comparable. The second part of the paper contains a discussion of the relevance of these results from the point of view of the team that has used conventional methods for the development of the original version."""	formal methods;point of view (computer hardware company);relevance;software quality;vienna development method	Georg Droschl;Walter Kuhn;Gerald Sonneck;Michael Thuswald	2000		10.1007/3-540-40891-6_17	formal methods;vienna development method;computer science;software development;software engineering;formal specification;natural language;programming language;algorithm;software quality	SE	-45.726185260322126	29.361826734793887	62830
5aaca52b2fed428ae32d6025e43f582fb78a4684	refinement of open protocols for modelling and analysis of complex interactions in multi-agent systems	developpement logiciel;multiagent system;multi agent system;red petri;refinement method;desarrollo logicial;software development;interaction protocol;component based software development;methode raffinement;sistema multiagente;petri net;metodo afinamiento;protocol engineering;reseau petri;systeme multiagent	This paper proposes to study a refinement of open and concurrent interaction protocols, allowing hierarchical construction of complex interactions in multi-agent systems. The generic approach presented in this paper integrates Petri nets formalism and component based approach. The study of the refinement of the protocols by the principle of component-substitutability has been used to address one of the key issues of component-based software development, consistency: will a component protocol fit or not? This paper provides new results to deal with some protocol engineering issues through the specification and the verification of such protocols.	bottom-up parsing;coloured petri net;communications protocol;component-based software engineering;formal grammar;high-level programming language;interaction;interaction protocol;multi-agent system;petri net;recursion;refinement (computing);semantics (computer science);software development;top-down and bottom-up design	Nabil Hameurlain	2003		10.1007/3-540-45023-8_41	computer science;artificial intelligence;component-based software engineering;software development;multi-agent system;programming language;petri net;algorithm	SE	-39.6747244912856	25.29476104678539	62876
16a17ac31a88878cef279a4c59c25ea9d09153b2	from components to autonomic elements using negotiable contracts	distributed system;systeme reparti;negociation;dynamic reconfiguration;componente logicial;autonomous system;reconfigurable architectures;component based development;securite informatique;distributed computing;software systems;composant logiciel;bucle control;contrato;sistema autonomo;computer security;sistema repartido;contract;negociacion;seguridad informatica;systeme autonome;bargaining;software component;calculo repartido;control loop;contrat;autonomic computing;calcul reparti;feedback control;architecture reconfigurable;boucle commande	Autonomic computing aims at producing software systems that can manage themselves. As component-based development also partly addresses the complexity of large applications, we propose to combine the benefits of both approaches by using components equipped with negotiable contracts. These contracts specify the correct behavior of the components and play a central role in feedback control loops to enforce some autonomic features on components. In this paper, we present ConFract, a contract-based framework for hierarchical components in which contracts are runtime objects that are dynamically built from specifications, and automatically updated according to dynamic reconfigurations. Moreover, contracts clearly define the responsibilities (guarantor, beneficiaries) between their participating components which are exploited by some negotiations to automatically adapt components and contracts, and revalidate the system. The generic negotiation mechanism and an associated concession-based policy are presented.	autonomic computing;autonomy;component-based software engineering;content negotiation;control flow;control system;correctness (computer science);feedback;fractal;instant messaging;reference implementation;scsi initiator and target;software system;web service	Hervé Chang;Philippe Collet;Alain Ozanne;Nicolas Rivierre	2006		10.1007/11839569_8	embedded system;real-time computing;simulation;computer science;component-based software engineering;operating system;computer security;autonomic computing	SE	-39.69864554241674	24.495743647455356	63000
44c2ff61caeeb91615a617791e756be8ed107f22	a formal description of design patterns using owl	automated pattern detection design patterns object oriented design web ontology language owl software artefacts uniform resource identifiers uri software design ontology meta modelling architecture java language pattern scanner ast analysis semantic web;webontologies;uniform resource identifier;automated pattern detection;formal specification;object oriented design;web ontologies;system documentation;object oriented programming;software engineering;ontologies artificial intelligence;ontology development;unified modeling language object oriented programming ontologies artificial intelligence semantic web software reusability software architecture pattern recognition java formal specification system documentation;software architecture;pattern detection;web ontology language;software reusability;design pattern;unified modeling language;software design theory;pattern recognition;semantic web;automated pattern detection software design theory object oriented programming semantic web design patterns web ontologies;design patterns;software design;java language;java;owl software design ontologies documentation software tools design engineering computer architecture java reflection application software	Design patterns have been used successfully in the last decade to reuse and communicate object-oriented design. However, the documentation of pattern usage is often very poor. This motivates the use of tools which can detect and document design patterns found in software. A couple of approaches have been proposed in recent years. The approach introduced is based on a formal description of design patterns using the Web ontology language OWL. Software artefacts used to define design patterns in a formal and machine processable fashion are represented by uniform resource identifiers (URIs). This yields a description that is open and extensible, and facilitates the sharing of design among software engineers. We discuss the developed software design ontology, and how this approach relates to the meta-modelling architecture of the OMG. In the second part, an effective pattern scanner for the Java language is presented. This scanner is based on the ontology developed in part one and uses reflection and AST analysis to verify constraints. Various applications of this scanner are discussed.	documentation;ontology (information science);reflection (computer programming);software design pattern;software engineer;uniform resource identifier;web ontology language;world wide web	Jens Dietrich;Chris Elgar	2005	2005 Australian Software Engineering Conference	10.1109/ASWEC.2005.6	uniform resource identifier;unified modeling language;software architecture;software design pattern;architectural pattern;computer science;software design;software design description;object-oriented design;software engineering;semantic web;interaction design pattern;formal specification;database;design pattern;distributed design patterns;programming language;web ontology language;object-oriented programming;java;structural pattern;world wide web	SE	-47.65822902385665	19.4744279729025	63008
11e0e02de4419bb1c7bd60941034018736e775a8	from theory to practice in transactional composition of web services	gestion integrada;gestion integree;evaluation performance;gestion entreprise;tratamiento transaccion;process calculi;performance evaluation;evaluacion prestacion;processus metier;metodo formal;methode formelle;service web;firm management;interface programme application;integrated management;langage java;web service;formal method;application program interfaces;utilisabilite;proceso oficio;administracion empresa;lenguaje java;usabilidad;transaction processing;usability;business process;traitement transaction;servicio web;java language	We address the problem of composing Web Services in long-running transactional business processes, where compensations must be dealt with appropriately. The framework presented in this paper is a Java API called Java Transactional Web Services (JTWS), which provides suitable primitives for wrapping and invoking Web Services as activities in long-running transactions. JTWS adheres to a process calculi formalisation of long-running transactions, called Naı̈ve Sagas, which fixes unambiguously the implemented compensation policy. In particular, the primitives provided by JTWS are in one-to-one correspondence with the primitives of Sagas, and they are abstract enough to hide the complex details of their realization, thus favouring usability. Moreover, JTWS orchestrates business processes in a distributed way.	application programming interface;business process;java class library;list of java apis;norm (social);one-to-one (data model);process calculus;usability;web service;wrapping (graphics)	Roberto Bruni;Gian Luigi Ferrari;Hernán C. Melgratti;Ugo Montanari;Daniele Strollo;Emilio Tuosto	2005		10.1007/11549970_20	web service;simulation;formal methods;usability;transaction processing;computer science;operating system;database;business process;programming language;law;world wide web	Web+IR	-40.734112551549615	24.25437463110085	63066
26fe35fd65007a1ee246a4398f7a83c8c6b07648	patterns for web applications	logic design;uml;pattern;business logic;web application;natural language;unified modelling language;design pattern;case tool;object constraint language	This paper presents the preliminary results achieved in introducing a new formalism into the Web business logic layer. New useful and consistent patterns have been defined to support the modelling phase of web applications. The innovation in the use of patterns is extremely important when concepts like solidity, stability and reuse are crucial for the application design. The proposed patterns are graphically modelled using the Unified Modelling Language and formalized using the Object Constraints Language introduced by IBM. The new patterns are suitable for use in a CASE tool, to help developers build web solutions and eliminate inconsistences often present in natural languages.	business logic;natural language;object constraint language;semantics (computer science);solidity;unified modeling language;web application;world wide web	Diego Bonura;Rosario Culmone;Emanuela Merelli	2002		10.1145/568760.568887	unified modeling language;web modeling;web design;object language;computer science;systems engineering;theoretical computer science;pattern language;programming language;object constraint language	SE	-48.22311262892159	25.86084755074014	63200
5ffd314e35846def077491c00211334253e24452	building complex systems with agent-space architecture	incremental development;multi agent system;data exchange;coordination language;multi agent systems;complex system;purely reactive agent;space;subsumption;stigmergic communication	Building complex systems requires a specific kind of modularity as well as incremental development. Here we introduce an architecture where basic modules are reactive agents and the data exchange among them is based on the so-called stigmergic communication through space. In this way we have connected ideas coming from the multi-agent systems and the coordination languages on the one side and ideas of the behavior based systems on the other side. We demonstrate that this architecture manifests several interesting features which are useful for engineering of real-time systems and modeling of biological creatures or their parts. We advocate for so-called purely reactive agents which are stateless entities usually taken as too week building blocks of systems. However, their features enable us to use a special method of incremental development (so-called subsumption method).	complex systems;entity;iterative and incremental development;method (computer programming);multi-agent system;reactive planning;real-time computing;real-time locating system;stateless protocol;stigmergy;subsumption architecture	Andrej Lúcny	2004	Computers and Artificial Intelligence		data exchange;computer science;artificial intelligence;space;iterative and incremental development;multi-agent system;algorithm;systems design	AI	-41.00835878549456	20.42695665362241	63307
784b02365e53dfc4e2df603be82dc28f79474d57	a collabortive framework for integrating modelica models and computational design methods	analytical models;groupware;design process;probability;computer model;production system;aircraft landing gear collaborative framework modelica models computational design methods modelica language complex product system modelling complex product system design process design optimization probabilistic analysis xml based method collaborative process model computational sequence;integrated design;model complexity;production engineering computing;collaborative process;computational modeling;collaborative process modelica model computational design methods xml;design method;modelica model;computational modeling optimization xml analytical models algorithm design and analysis probabilistic logic;probabilistic analysis;xml;simulation languages;optimization;process model;product design;probabilistic logic;system simulation;algorithm design;algorithm design and analysis;xml groupware probability product design production engineering computing simulation languages;analytical model;computational design methods	Modelica language is been developed to model complex product systems. However, Modelica Models usually are used to simulate the performance not optimize. Computational design methods are very important methods in design process of complex product systems, which is not included in Modelica based tool. In the paper, computational design method integrating design optimization and probabilistic analysis is discussed. The design related elements are analyzed. Then an XML-based method is presented to associate the computational design related elements with Modelica model in a generic way. This method introduces a separation between the model of the system and data related to the design of the product. In order to accomplish full system simulation and optimization involving several types of models and codes, the collaborative process model is presented to represent and execute a computational sequence. Finally, the example about an aircraft landing gear is given.	code;computation;computer architecture simulator;engineering design process;ion implantation;mathematical optimization;probabilistic analysis of algorithms;process modeling;simulation;xml	Yuming Zhu;Jihong Liu;Bo Li	2012	Proceedings of the 2012 IEEE 16th International Conference on Computer Supported Cooperative Work in Design (CSCWD)	10.1109/CSCWD.2012.6221915	algorithm design;simulation;computer science;theoretical computer science;modelica;product design	EDA	-44.29380711207521	24.178623256730685	63458
9881f31f1e0164d1eb8cf8ae13e8c8d96aa5f67f	mobile agent organizations	mobile agent	Mobile agents are a useful paradigm – other than a useful technology – for the development of complex Internet applications. However, the effective development of mobile agent applications requires suitable models and infrastructures. This paper proposes an organizational approach to the high-level design of mobile agent applications. The idea is to models the Internet as a multiplicity of local and active organizational contexts, intended as the places where coordination activities of application agents occur and are ruled. The paper discusses the advantages and the generality of such an approach, also with the help of a case study in the area of tourist assistance.	high- and low-level;internet;level design;mobile agent;programming paradigm	Giacomo Cabri;Letizia Leonardi;Marco Mamei;Franco Zambonelli	2001			the internet;mobile agent;generality;business;distributed computing	HCI	-44.41908246224032	19.650254051664433	63678
1d9c97dfb6b1f518ed3c1c41462849bed263e244	abstract models and cognitive mismatch in formal verification		We present ongoing work to accommodate fine-grained analysis of interactive systems via model checking. We argue that this can be achieved by combining a basic abstract model of user behaviour and a separate constraint on the acceptable degree of cognitive mismatch. To explain the problem and illustrate our approach, we present a simple scenario related to number entry in infusion pumps.	cognition;expectation propagation;formal verification	Rimvydas Ruksenas;Paul Curzon	2011	ECEASST	10.14279/tuj.eceasst.45.655	simulation;computer science;artificial intelligence;algorithm	HCI	-41.1300222903874	29.195779221097524	63780
cac7e5029ba82273766e84e6d5bc0d4e587c1cb0	operationalizing operational logics: semiotic knowledge representations for interactive systems.		All projects in AI begin by selecting or devising knowledge representations suitable for the project’s functional requirements. Interactive systems (including games) have semiotic considerations on top of their functional requirements: they must be legible to users, players, and their own designers. AI working within or around interactive systems must acknowledge and support the concerns of human users. These concerns are generally phrased as inductive bias or domain knowledge and handled in an ad hoc way; I argue that it is possible and useful to represent them explicitly within a unifying approach. This work refines and extends operational logics, an interpretive framework describing how interactive systems communicate their own mechanisms to users. Making this move yields formal notations for interactive systems that are useful for humans and machines, with applications in modeling, verification, general game-playing, reverseengineering, and automatic self-documentation.	documentation;formal verification;functional requirement;general game playing;hoc (programming language);inductive bias;interactivity;semiotics	Joseph C. Osborn	2017		10.24963/ijcai.2017/759	semiotics;operationalization;computer science;knowledge management	HCI	-41.39843628025182	28.97598461972028	63855
6619bbe706cb70d5b310e01faaea1b8dfab7ce84	a proposal for structuring petri net-based agent interaction protocols	developpement logiciel;offre service;high level petri net;multiagent system;red petri;interaction;specification;renew;agents;especificacion;desarrollo logicial;reference nets;software development;mulan;unified modeling language;high level petri nets;auml;interaction protocol;interaccion;sistema multiagente;petri net;proposals;agent interaction protocol;reseau petri;systeme multiagent;agent interaction protocols	In this paper we introduce net components as means for structuring Petri net-based agent interaction protocols. We provide a tool for effortless application of net components to nets. Thus we facilitate the construction of nets and unify their appearance. Net components can be used to derive code for interaction protocols from a subset of extended AUML (Agent Unified Modeling Language) interaction protocol diagrams. This allows for a smooth integration of some traditional software development specification approaches with high-level Petri nets. By using net components we do not only unify the structure of Mulan agent protocols but also succeed to build a common language within a community of developers who share the net components.	petri net	Lawrence Cabac;Daniel Moldt;Heiko Rölke	2003		10.1007/3-540-44919-1_10	unified modeling language;interaction;real-time computing;computer science;artificial intelligence;software development;software agent;distributed computing;petri net;specification;statistics	Vision	-39.91741907548718	25.226270026328116	64077
f0c4c08bf923850a242a410a6ec7332e1f3c25c2	model generation issues in a simulation support environment	discrete event simulation;programming environments;software tools;model generator;simulation model development environments;computer-aided simulation engineering environment;computer-based tools;domain-independent discrete-event simulation;model development time;model quality;prototyping;quality assurance;simulation model specification;simulation support environment;software tools	This paper provides an overview of a simulation support environment and presents a discussion of a number of issues related to the generation of a simulation model. The need for automated, computer-based assistance in the generation of simulation models of large, complex systems is undeniable. The required support goes beyond the programming process and extends to all phases of the simulation model development life cycle. In the last several years, we have been developing a domain-independent simulation support environment with four layers on a Sun computer workstation. The software tools of the environment are briefly described. The most challenging tool of the environment has been the Model Generator; the tool with which a modeler creates a simulation model specification under a conceptual framework. Our experience and a discussion of issues in developing the Model Generator software tool are presented.	complex systems;programming tool;simulation;software development process;workstation	Osman Balci;Richard E. Nance;E. Joseph Derrick;Ernest H. Page;John L. Bishop	1990			computer simulation;quality assurance;simulation;computer science;systems engineering;engineering;prototype;computer engineering	SE	-35.58391525871456	27.055133836342684	64353
366a12e2cafa67252d8582cd212dd7694c64f00b	high level specification and validation of the business process execution language for web services	gestion integrada;machine abstraite;distributed system;gestion integree;propriete dynamique;gestion entreprise;reseau communication;business process execution language;systeme reparti;validacion;normalisation;processus metier;specification;maquina abstracta;service web;firm management;semantics;simultaneidad informatica;integrated management;dynamic system;web service;semantica;semantique;abstract machine;transmision asincronica;dynamical system;systeme dynamique;concurrency;sistema repartido;especificacion;community networks;propiedad dinamica;asynchronous communication;envoi message;normalizacion;message passing;asynchronous transmission;proceso oficio;oasis;administracion empresa;validation;transmission asynchrone;sistema dinamico;red de comunicacion;simultaneite informatique;deduccion;communication network;standardization;business process;servicio web;dynamic properties;deduction	We formally define an abstract executable semantics for the Business Process Execution Language for Web Services in terms of a distributed ASM. The goal of this work is to support the design and standardization of the language. “There is a need for formalism. It will allow us to not only reason about the current specification and related issues, but also uncover issues that would otherwise go unnoticed. Empirical deduction is not sufficient.” – Issue #42, OASIS WSBPEL TC. The language definition assumes an infrastructure for running Web services on some asynchronous communication architecture. A business process is built on top of a collection of Web services performing continuous interactions with the outside world by sending and receiving messages over a communication network. The underlying execution model is characterized by its concurrent and reactive behavior making it particularly difficult to predict dynamic system properties with a sufficient degree of detail and precision under all circumstances.	abstract machine;business process execution language;dynamical system;executable;graphical user interface;intelligibility (philosophy);interaction;mathematical model;microsoft research;natural deduction;nonlinear gameplay;principle of abstraction;real-time clock;refinement (computing);robustness (computer science);semantics (computer science);separation of concerns;simulation;telecommunications network;web service	Roozbeh Farahbod;Uwe Glässer;Mona Vajihollahi	2004		10.1007/978-3-540-24773-9_7	simulation;business process execution language;computer science;operating system;dynamical system;asynchronous communication;database;distributed computing;semantics;abstract machine;programming language	Web+IR	-39.99756254172665	24.92995045854416	64672
34d9a17799a2ef5597a8eb1449d10f9d9dc4f486	using ethnography to design a mass detection tool (mdt) for the early discovery of insurance fraud	dynamic change;ethnography;anomaly detection;automated knowledge updating;bayesian belief networks;bayesian belief network;bf psychology;early detection;fraud detection;insurance	We describe a Mass Detection Tool (MDT) for early detection of insurance fraud. Ethnography was used to specify needs and process, capture expertise, and design an interface for triggering fraud indicators while capturing unexpected anomalies detected by claims handlers. The MDT uses a dynamic Bayesian Belief Network of fraud indicators, whose weights are determined by how predictive each indicator is of specific types of fraud. The system uses automated knowledge updating to keep pace with dynamically changing fraud, adding new indicators that emerge from patterns of repeated anomalies.	bayesian network	Thomas C. Ormerod;Nicola J. Morley;Linden J. Ball;Charles Langley;Clive Spenser	2003		10.1145/765891.765910	anomaly detection;computer science;data science;bayesian network;data mining;ethnography;computer security	ML	-35.58551629285146	21.081151351736594	64744
23217ce9f887f838dac82dbeb057143ef53a1e66	balancing smartness and privacy for the ambient intelligence	sensibilidad contexto;reseau capteur;ciclo desarrollo;context aware;life cycle;ambient intelligence;pervasive computing;intelligence artificielle;calculo ambiente;calcul ambiant;informatica difusa;vida privada;red sensores;private life;data privacy;informatique diffuse;sensor array;cycle developpement;artificial intelligence;vie privee;ambient calculus;inteligencia artificial;sensibilite contexte;confidentialite donnee	A smart, anticipating, and learning environment will have a great impact on privacy. Ambient Intelligence will be everywhere, is invisible, has powerful sensing capabilities, and most of all has a memory. Because of this memory (or context history), people sometimes could be confronted with actions and behaviour from the past which otherwise would have been forgotten. One of the main difficulties with privacy and ubiquitous computing is the way how data is collected. When making a transaction with a web shop, it could be quite clear which kind of data has been exchanged. Ubiquitous computing techniques however, such as small sensors or cameras equipped with powerful image recognizing algorithms, often collect data when people are not aware of it [4]. In that case it is possible that people think they are in a closed private area (such as coffee rooms), but in reality they could be monitored by sensors in that room without having their consent. Several techniques have been proposed in the literature which let donors of the data specify privacy policies, in order to give control about their data to the owners of that data [5, 2]. Although such policies are rich enough to let people control who, when, how long, and what kind of information can be disclosed to specific applications, enforcing those policies is usually done through access control. Only relying on access control mechanisms to protect against unauthorized disclosure of data, is not sufficient in terms of privacy protection [1]. Perhaps the context databases can be trusted now, but they might not be in the future (e.g. due to the change of privacy regulation laws, human mistakes, et cetera). Therefore, limited retention techniques are highly desirable to prevent large context histories to be disclosed. The amount of smartness of applications is bound to the quantity and quality of the data they can use. The more accurate the data is, and the more data has been gathered from a certain individual, the better a smart application can learn from that data without user interaction [3]. The challenge is to find the best balance between the quality and quantity of data at the one side, and the privacy sensitivity of the data at the other side. To find a balance between smartness and privacy, we propose to physically degrade the data according to application requirements and/or user preferences. By degrading data, the goal is to only retain the minimal form of information needed to maintain the desired view of the data. Generating such view by means of degradation functions, and to keep the result of the queries on that view adequate is difficult, since additional information is needed to update the view when new sensor data arrives. To go a step further, progressive degradation (degrade data in multiple steps) and user defined degradation policies can be used to further balance privacy and smartness for the Ambient Intelligence.	access control;algorithm;ambient intelligence;authorization;best practice;control system;database;elegant degradation;online shopping;privacy policy;requirement;sensor;ubiquitous computing;user (computing)	Harold van Heerde;Nicolas Anciaux;Ling Feng;Peter M. G. Apers	2006		10.1007/11907503_26	ambient calculus;biological life cycle;privacy software;ambient intelligence;human–computer interaction;information privacy;privacy by design;telecommunications;computer science;artificial intelligence;computer security;ubiquitous computing;sensor array	DB	-37.089885540183985	18.668508804875582	64940
fbf0ccff62a4efa8008ea3e6756af6f996731da7	early work on the brain patch, a reflective service for system of systems integration	wrappings;wrapping;self optimization component system of systems integration reflection wrappings;monitoring;games;cognition;reflection wrapping monitoring context cognition complex systems games;complex systems;system of systems integration;self optimization component;context;reflection;systems analysis data integration expert systems self adjusting systems software architecture;domain specific expert brain patch system of systems integration sos self optimization wrappings approach cars test bed computational architectures for reflective systems	In previous work we've shown that reflection supports the integration of components and of self-optimization within a complex system. In this paper, we discuss some early work on how some of these capabilities could support a similar integration and conflict resolution among the members of a system of systems (SoS). We start with a brief overview of the Wrappings approach to reflection, the notion of a web of reflection, and the CARS test bed where we are developing our concepts. We then introduce some early work on a new reflective service, the Brain Patch which helps to integrate a system into a System of Systems (SoS) by being both a domain specific expert on the reason for the formation of the SoS and its goals, situation, operating rules, etc. And by also continually observing and building a model of the system assigned to it.	apple sos;complex system;mathematical optimization;system integration;system of systems;testbed	Kirstie L. Bellman;Christopher Landauer	2015	2015 IEEE International Conference on Autonomic Computing	10.1109/ICAC.2015.73	games;complex systems;simulation;reflection;cognition;computer science;artificial intelligence;operating system;distributed computing;computer security	Robotics	-40.473776680286036	20.174208578278826	65241
af97493baa2fc4f3d5502a53eeabb724e39f1f27	from user stories to code in one day	developpement logiciel;modelizacion;programmation agile;software engineering;agile programming;extreme programming;programacion extrema;modelisation;desarrollo logicial;software development;genie logiciel;programmation extreme;programacion agil;modeling;ingenieria informatica	User stories in software engineering serve the purpose of discovering requirements and are used as units of system development. When applying stories in a project, two elements seem to be crucial: the ability to write coherent sequences of events and the ability to transform these sequences into code quickly and resourcefully. In this paper, these qualities are reflected in a notation that can be described as “stories with notions”. This notation separates the story’s sequence of events from the description of terms used in this sequence. Such a formal separation does not limit and rather enhances invention, at the same time rising the level of consistence, and facilitating translation into models of code. This translation maps domain notions into static code constructs (classes, interfaces) and also maps stories into dynamic sequences of messages. With such a mapping, programming becomes equivalent to skilled transformation of user stories, thus giving shorter development cycles.	coherence (physics);map;requirement;software engineering;user story	Michal Smialek	2005		10.1007/11499053_5	simulation;systems modeling;extreme programming;computer science;engineering;artificial intelligence;theoretical computer science;software development;operating system;software engineering;machine learning;agile software development;database;mathematics;distributed computing;programming language;algorithm	SE	-41.77129815550953	25.341275302689997	65301
51f12f4c25f62e907bd432d4f6e240ee3d38641e	taxonomy for evaluation of distributed control strategies for distributed energy resources	classification;smart grid;control architecture;distributed energy resource;distributed control	Distributed control strategies applied to power distribution control problems are meant to offer robust and scalable integration of distributed energy resources (DERs). However, the term “distributed control” is often loosely applied to a variety of very different control strategies. In particular there is a lack of discrimination between aspects related to communication topology, physical distribution of components, and associated control objectives. This has lead to a lack of objective criteria for performance comparison and general quality assessment of state of the art distributed control solutions. For such comparison, a classification is required that is consistent across the different aspects mentioned above. This paper develops systematic categories of control strategies that accounts for communication, control and physical distribution aspects of the problem, and provides a set of criteria that can be assessed for these categories. The proposed taxonomy is applied to the state of the art as part of a review of existing work on distributed control of DER. Finally, we demonstrate the applicability and usefulness of the proposed classification to researchers and system designers.	algorithm;benchmark (computing);categorization;control flow;control theory;distributed control system;engineering design process;ibm power systems;scalability;taxonomy (general)	Xue Han;Kai Heussen;Oliver Gehrke;Henrik W. Bindner;Benjamin Kroposki	2018	IEEE Transactions on Smart Grid	10.1109/TSG.2017.2682924	decentralised system;distributed algorithm;distributed system security architecture;control engineering;process control;management science;smart grid;scalability;distributed generation;distributed design patterns;computer science	Visualization	-37.63072790735997	21.37819611052051	65429
477594a7f7a81e52fd8b71a2a6334129932d38bd	model-driven processes and tools to design robot-based generative learning objects for computer science education	model transformation;educational robots;generative learning objects glos;feature models;glo design tool	In this paper, we introduce a methodology to design robot-oriented generative learning objects (GLOs) that are, in fact, heterogeneous meta-programs to teach computer science (CS) topics such as programming. The methodology includes CS learning variability modelling using the feature-based approaches borrowed from the SW engineering domain. Firstly, we define the CS learning domain using the known educational framework TPACK (Technology, Pedagogy And Content Knowledge). By learning variability we mean the attributes of the framework extracted and represented as feature models with multiple values. Therefore, the CS learning variability represents the problem domain. Meta-programming is considered as a solution domain. Both are represented by feature models. The GLO design task is formulated as mapping the problem domain model on the solution domain model. Next, we present the design framework to design GLOs manually or semi-automatically. The multi-level separation of concepts, model representation and transformation forms the conceptual background. Its theoretical background includes: (a) a formal definition of feature-based models; (b) a graph-based and set-based definition of meta-programming concepts; (c) transformation rules to support the model mapping; (d) a computational Abstract State Machine model to define the processes and design tool for developing GLOs. We present the architecture and some characteristics of the tool. The tool enables to improve the GLO design process significantly (in terms of time and quality) and to achieve a higher quality and functionality of GLOs themselves (in terms of the parameter space enlargement for reuse and adaptation). We demonstrate the appropriateness of the methodology in the real teaching setting. In this paper, we present the case study that analyses three robot-oriented GLOs as the higher-level specifications. Then, using the meta-language processor, we are able to produce, from the specifications, the concrete robot control programs on demand automatically and to demonstrate teaching algorithms visually by robot's actions. We evaluate the approach from technological and pedagogical perspectives using the known structural metrics. Also, we indicate the merits and demerits of the approach. The main contribution and originality of the paper is the seamless integration of two known technologies (feature modelling and meta-programming) in designing robot-oriented GLOs and their supporting tools.	algorithm;chart;compiler;complexity;computation;computational model;computer science;context awareness;data structure;domain model;emoticon;feature model;graphical user interface;heart rate variability;metaprogramming;model-driven architecture;model-driven integration;natural language processing;php;problem domain;programming domain;programming paradigm;robot control;robotics;semiconductor industry;separation of concerns;shattered world;spatial variability;whole earth 'lectronic link	Vytautas Stuikys;Renata Burbaite;Kristina Bespalova;Giedrius Ziberkas	2016	Sci. Comput. Program.	10.1016/j.scico.2016.03.009	simulation;computer science;artificial intelligence;machine learning;programming language;educational robotics	Logic	-46.82049559006219	24.237287530521414	65544
13e449511d2fe8c37b054a4fa74112861f637ed4	towards an adaptive multi-agent system for dynamic big data analytics	data mining;multi agent systems;big data;pipelines;adaptation models	The big data era brought us new data processing, data management challenges to face. Existing state-of-theart analytics tools come now close to handle ongoing challenges, provide satisfactory results with reasonable cost. But the speed at which new data is generated, the need to manage changes in data both for content, structure lead to new rising challenges. This is especially true in the context of complex systems with strong dynamics, as in for instance large scale ambient systems. One existing technology that has been shown as particularly relevant for modeling, simulating, solving problems in complex systems are Multi-Agent Systems. This article aims at exploring, describing how such a technology can be applied to big data in the form of an Adaptive Multi-Agent System providing dynamic analytics capabilities. This ongoing research has promising outcomes but will need to be discussed, validated. It is currently being applied in the neOCampus project, the ambient campus of the University of Toulouse III.	algorithm;big data;complex systems;end-to-end principle;generic programming;multi-agent system;online and offline;pervasive informatics;real-time locating system;self-organization;sensor;simulation;time complexity	Elhadi Belghache;Jean-Pierre Georgé;Marie Pierre Gleizes	2016	2016 Intl IEEE Conferences on Ubiquitous Intelligence & Computing, Advanced and Trusted Computing, Scalable Computing and Communications, Cloud and Big Data Computing, Internet of People, and Smart World Congress (UIC/ATC/ScalCom/CBDCom/IoP/SmartWorld)	10.1109/UIC-ATC-ScalCom-CBDCom-IoP-SmartWorld.2016.0121	analytics;big data;computer science;data science;data mining;database;pipeline transport;world wide web	AI	-34.607490812206635	19.51048434214975	65566
66fa911328d41ecc7a674b32ef7dae97f66c5d57	model-driven design of distributed applications	distributed application;modelizacion;distributed system;proceso concepcion;systeme reparti;design process;langage modelisation;logicial personalizado;abstraction;abstraccion;preparacion serie fabricacion;intergiciel;modelisation;software architecture;sistema repartido;internet;modelling language;lenguaje modelizacion;algorithme reparti;architecture basee modele;middleware;algoritmo repartido;process planning;preparation gamme fabrication;distributed algorithm;modeling;model driven architecture;architecture logiciel;processus conception;arquitectura basada modelo	A recent trend in the design of distributed applications is to systematically separate their platform-independent and platform-specific aspects, by describing them in separate models. The main benefits of this approach stem from the possibility to derive different platform-specific models (PSMs) from the same platform-independent model (PIM), and to partially automate the model transformation process and the realization of the distributed application on specific target (middleware) platforms. This may reduce initial development costs and improve software quality, but also forms the basis for facilitating evolution and migration of software solutions, hence contributing to the limitation of maintenance costs for distributed applications. A prominent development in this trend is the Model-Driven Architecture (MDA) approach. In the context of MDA, much effort has been invested in enabling technologies and techniques for model-driven design, which include metamodelling (MOF), language definition and extension mechanisms (e.g., UML and UML profiles), model transformation specification languages (MOF Query/View/Transformation), tool support and tool chain interoperability. In contrast, the methodological and architectural foundations of platform-independent design have received little attention. In particular, the state-of-the-art in model-driven design can be criticized on a number of points: – there is a lack of guidelines to select abstraction criteria and modelling concepts for platform-independent design; – there is little methodological support to distinguish between platformindependent and platform-specific concerns, which is detrimental to the beneficial exploitation of the separation between PIMs and PSMs; – the distinction between PIM-PSM is coarse and insufficient to cope with the diversity of application requirements and platform characteristics; – little attention is given to the role of platform characteristics throughout the development trajectory, possibly leading to models with unaccept-	distributed computing;interoperability;meta-object facility;metamodeling;middleware;model transformation;model-driven architecture;model-driven engineering;model-driven integration;platform-independent model;platform-specific model;profile (uml);requirement;software quality;toolchain;unified modeling language	João Paulo A. Almeida	2004		10.1007/978-3-540-30470-8_99	software architecture;distributed algorithm;the internet;simulation;systems modeling;design process;computer science;artificial intelligence;middleware;distributed computing;abstraction	SE	-41.581263015464174	24.793155391382204	65670
33409d407ecfb38b0a4b66bf3002c3e9d91575ac	devs-based combat modeling for engagement-level simulation	model design;defense;formalism;compositional reusability;system specification formalism;discrete event system;discrete;effectiveness analysis;article;framework;model implementation;combat entity	This paper presents a modeling method to demonstrate engagement-level military simulation which includes few combat objects, or entities. To this end, the paper, on the basis of the discrete event system specification (DEVS) formalism, centers on two ideas: (1) a combat entity’s model structure at the composition level; and (2) behavioral delineation of the entity’s elementary component. In detail, we classify the combat entity model into platform and weapon models and create six groups of the model categorized by two dimensions: three activities and two abstractions. And the elementary component in the group interprets an engagement scenario as a flow of executable tasks, which are expressed by DEVS semantics. The stated structures and semantics provide intuitive appeal, reducing the effort required to read and understand the model’s behavior. From the combat experiments, we can gain interesting experimental results regarding engagement situations employing underwater weapons and their tactical operations. Finally, we expect that this work will serve an immediate application suited to various engagement situations.	abstraction layer;categorization;cryptographic primitive;devs;entity;executable;expect;experiment;formal system;high- and low-level;high-level architecture;interoperation;korea internet & security agency;purchasing;semantics (computer science);simulation	Kyung-Min Seo;Chang Beom Choi;Tag Gon Kim;Jung Hoon Kim	2014	Simulation	10.1177/0037549714532960	simulation;computer science;engineering;artificial intelligence;software framework;operating system;computer security;formalism	AI	-43.006003940327574	22.892332974692277	65814
de3e4d9c3a3dc2a0b4183b30a65afabe52da3edc	a survey of knowledge acquisition techniques and tools and their relationship to software engineering	developpement logiciel;modelizacion;sistema experto;ciclo desarrollo;analisis sistema;life cycle;sistema informatico;base connaissance;computer system;ingenieria logiciel;acquisition connaissance;software engineering;modelisation;desarrollo logicial;knowledge acquisition;software development;cycle developpement;genie logiciel;system analysis;base conocimiento;systeme informatique;analyse systeme;systeme expert;modeling;knowledge base;expert system	Abstract   Knowledge acquisition deals with the modeling of expertise for expert systems. Although research in this area has concentrated on artificial intelligence systems for knowledge-intensive domains, the knowledge acquisition problem occurs frequently in general program development. Many knowledge acquisition techniques and approaches to tool support are relevant for software engineering, especially in complex domains and during early analysis stages.	knowledge acquisition;software engineering	Henrik Eriksson	1992	Journal of Systems and Software	10.1016/0164-1212(92)90023-D	biological life cycle;knowledge base;systems modeling;computer science;systems engineering;engineering;artificial intelligence;software development;software engineering;knowledge-based systems;knowledge engineering;system analysis;operations research;expert system;domain knowledge	SE	-37.60717955550927	23.7649606713399	65924
3b4304f842e3fb72f0b339d65dab25f6245eef96	model checking software requirement specifications using domain reduction abstraction	automatic programming formal specification program verification program testing;formal specification;software prototyping medical control systems prototypes control systems temperature control nasa computer science software systems automatic control air safety;software systems;automatic programming;program verification;linear constraint;regression verification model checking software requirement specifications domain reduction abstraction automated verification validation tool static abstraction technique data equivalence trajectory reduction symbolic model checker nusmv;model checking;program testing;software requirements specification	As an automated verification and validation tool, model checking can be quite effective in practice, especially when it is used in the context of specification-centered or component-based software development frameworks. Nevertheless, model checking has been quite inefficient when dealing with systems with data variables over a large (or infinite) domain, which is a serious limiting factor for its applicability in practice. To address this issue, a static abstraction technique, domain reduction abstraction, based on data equivalence and trajectory reduction has been investigated and its prototype automation has been implemented as an extension of the symbolic model checker NuSMV. Unlike other on-thefly dynamic abstraction techniques, domain reduction abstraction statically analyzes specifications and automatically produces an abstract model which can be reused over time — a feature suitable foregression verification . This paper describes domain reduction abstraction and its prototype implementation. We also provide some performance data on an industrial avionics specification and discuss various application areas.	avionics;component-based software engineering;formal specification;model checking;nusmv;prototype;software development;turing completeness;verification and validation	Yunja Choi;Mats Per Erik Heimdahl	2003		10.1109/ASE.2003.1240328	model checking;software requirements specification;verification and validation;real-time computing;verification;formal verification;software verification;computer science;theoretical computer science;software engineering;formal specification;programming language;abstraction model checking;symbolic trajectory evaluation;software system	SE	-44.37215052112523	32.27767240668103	66103
a5e0532cd84ca21eb81eb295b7697c8c6ca6881a	a hierarchical modeling system for computer networks	discrete event simulation;hierarchical model;simulation;computer network;computer networks;simulation model	This paper describes the Hierarchical Modeling System (HMS). HMS is a tool - a unified and expandable system - which supports the development of analytic and simulator models of computer networks. The same system and workload descriptions can be interpreted as analytic queueing models with optimization techniques or as discrete event simulation models. The rationale behind the development of HMS is that high level analyses incorporating analytic techniques may be used in the early design phase for networks when many options are considered while detailed simulation studies of fewer design alternatives are appropriate during the later stages.	design rationale;high-level programming language;mathematical optimization;queueing theory;simulation	Donald F. Dubois	1982		10.1145/800047.801702	real-time computing;simulation;computer science;theoretical computer science;discrete event simulation;simulation modeling;hierarchical database model;computer network	Metrics	-35.298133773628706	27.17105187066033	66362
29b3a1b7d30ecb3aba088a95888122d037a96517	deriving biological applications from domain specific process models	process model;domain specificity	In this paper we present how the process modeling and execution tools iPM and iPE can be used to model and execute biological processes. The main focus of this paper is on the flexibility of iPM and iPE with respect to the customization to the biological application domain. We will demonstrate the flexibility of our modeling methodology by giving two examples: Modeling the invocation semantics of web services used in the biological application domain and the processing of streamed data.	application domain;domain-specific language;gene ontology;modeling language;process modeling;requirement;streaming media;web service	Stefan Jablonski;Matthias Färber;Bernhard Volz;Stefanie Genthner	2007	J. Integrative Bioinformatics	10.2390/biecoll-jib-2007-55	real-time computing;computer science;process modeling	Comp.	-48.07143686043697	18.71870934297661	66403
aa8e5680cc07cbc765cd953a5f819df6b08cab50	factory capacity and throughput planning: discrete-event simulation using systemc: interactive semic	dynamic link library;model system;register transfer;chip;discrete event simulation	"""Semiconductor fabrication factories are large enterprises with many toolsets, each having multiple production machines. The process flow is highly reentrant, therefore modeling is best done by discrete-event simulation. To describe such a fab, the author has developed a new discrete event simulator called FabSim. It is written in C++. As the simulation engine it uses SystemC, a C++ class library originally developed for modeling """"Systems on a Chip"""". The factory with its machines and lots traveling and in process is mapped onto SystemC like a hardware description during RTL (register transfer) modeling. The resulting simulator is compact, fast and efficient. In a special configuration as a MS Windows dynamic link library, the simulator is fully interactive. At any time you may define a stop in the simulation flow, retrieve the state of the whole system, change parameters, add lots, or even enter a new state and continue with the simulation."""	c++;dynamic-link library;electronic circuit simulation;library (computing);microsoft windows;reentrancy (computing);semiconductor device fabrication;semiconductor fabrication plant;system on a chip;systemc;throughput	Holger Vogt	2003		10.1145/1030818.1031004	chip;embedded system;parallel computing;real-time computing;simulation;computer science;discrete event simulation	EDA	-34.86524692353106	27.895744353145556	66785
fa06422e0ec85140b9995aee3d7b78230f6a64fb	a flexible workflow model supporting dynamic selection	intervalo tiempo;modelo dinamico;modelizacion;concepcion asistida;computer aided design;groupware;multidisciplinaire;red petri;dynamic model;satisfiability;time interval;modelisation;workflow system;system design;modele dynamique;conception assistee;workflow;multidisciplinary;multidisciplinar;ingenierie simultanee;ingenieria simultanea;petri net;collecticiel;modeling;reseau petri;concurrent engineering;intervalle temps	To improve the flexibility of workflow systems, efforts need to be made in the process of workflow modeling and system design. One of the enhancements would be the support of dynamic selection. In this paper, a workflow model based on the extended time interval Petri net with fired mark is presented, which satisfies the requirement of the dynamic treatment of workflows at the execution phase. A three-phase strategy and special node types are used to support dynamic selection, and the discussion about how they could improve the flexibility of the workflow systems is also given. Finally, a prototype system is presented to illustrate the effectiveness of the proposed model.		Shijun Liu;Xiangxu Meng;Bin Gong;Hui Xiang	2004		10.1007/11568421_34	workflow;simulation;systems modeling;computer science;computer aided design;multidisciplinary approach;windows workflow foundation;management;petri net;workflow management system;workflow engine;concurrent engineering;satisfiability;systems design;workflow technology	HCI	-38.10740116938335	23.95427329151173	66911
594b67a8b3820ef66a8bfc14e4c2cc93f8653054	mutual state capability-based role assignment model	heterogeneous teams;multi agent;capability;role assignment	We formally present the Mutual State Capability-Based Role Assignment (MuSCRA) model, as we introduce that an agent, acting in a team, has capabilities that depend not only on its own individual skills, but also on its teammates and their mutual state. The MuSCRA model includes a description of roles in terms of its association value with states and actions. Role assignment policies are evaluated with a utility accounting for the match between the new mutual state capabilities and the desired roles, weighted by a risk factor.		Somchaya Liemhetcharat;Manuela M. Veloso	2010		10.1145/1838206.1838455	capability;knowledge management;management science	NLP	-42.809582194061356	18.896582073069137	66948
3b46712a7783d02ae0373ccdab0cbd7631693a25	responsive traffic signals designed with petri nets	analytical models;transportation discrete event systems large scale systems petri nets road traffic road vehicles signalling traffic control;design model;signal design petri nets communication system traffic control traffic control roads transportation vehicle dynamics discrete event systems telecommunication traffic vehicles;signalling;sensors;complex discrete event system;road traffic;real time;vehicle platoon responsive traffic signal system petri net transportation complex discrete event system road traffic control;formal methods;traffic control;traffic flow;formal method;road traffic control;discrete event system;level of detail;traffic signals;roads;transportation;safety;traffic signals petri nets formal methods discrete event systems road traffic control;discrete event systems;joining processes;vehicles;petri nets;petri net;large scale systems;responsive traffic signal system;road vehicles;dynamic behavior;vehicle platoon	Traffic-responsive techniques make use of real-time measurements acquired with sensors to calculate in real-time suitable settings. Traffic signal systems that react to changing traffic conditions are an important component for improving transportation efficiency. The dynamic behavior of a group of traffic signals controlling a network of intersections is a complex discrete event system that can be modeled using Petri nets. In this paper, one purpose is to design a mechanism based on Petri nets with time interval associated to places to extend the green time to a main road depending on the demand of non-priority roads. Another objective is to try to allow green phases for a sequence of intersections in a small network in order to improve traffic flow for a platoon of vehicles. Modular characteristics of Petri nets are used to address complexity and design models in increasing levels of detail.	invariant (computer science);next-generation network;petri net;principle of abstraction;reachability;real-time clock;real-time computing;scalability;sensor;simulation;situated;vii	Michel dos Santos Soares;Jos L. M. Vrancken	2008	2008 IEEE International Conference on Systems, Man and Cybernetics	10.1109/ICSMC.2008.4811574	simulation;formal methods;computer science;process architecture;petri net	Robotics	-37.575217515799935	31.202130682456986	67268
61b50f2d0c3f26f6da7c5aae12c9e962725b27ea	towards configuration support for collaborative simulator development - a product line approach in model based systems engineering	software;system verification;primary production;modeling and simulation;computer model;aircraft behavior;simulation;atmospheric modeling aircraft software aerospace electronics computational modeling computer architecture;computer and information science;collaborative simulator development;product line;product data management;application integration;software configuration management;configuration support;saab gripen fighter aircraft;product data management configuration support collaborative simulator development knowledge capture product lifecycle early design evaluation system verification user training multipurpose models product line context configurator prototype system secondary product line simulation models saab gripen fighter aircraft aircraft behavior software configuration management;power plant;computer architecture;simulation mbse product line configurator;computational modeling;aerospace computing;secondary product line;secondary production;aerospace electronics;multipurpose models;configurator;user training;atmospheric modeling;knowledge capture;data och informationsvetenskap;early design evaluation;configurator prototype system;simulation model;product lifecycle;mbse;model based systems engineering;product line context;aircraft;simulation models	In development and support of complex products such as power plants, automotive vehicles, or aircrafts, modeling and simulation has become an important activity as a basis for knowledge capture. Simulation is used in several steps of the product lifecycle; for evaluation of early design, for system verification, and for user training. With emerging techniques such as tools for high-level modeling, multi-core computing, and visualization, the number of useful models is growing. This paper focuses on reuse of multipurpose models and configuration support in a product line context. A configurator prototype system is presented. The simulator set created from validated models is considered to be a secondary product line. The product set which the simulation models represent is considered to be the primary product line. The Saab Gripen fighter aircraft, together with simulators in which the aircraft behavior, performance, and handling qualities are represented, is used to exemplify application. Integration principles of the systems for simulator configuration, Software Configuration Management, and Product Data Management (PDM) are studied. Preliminary results show that a configurator tool can be used, but there is need to map structures between the simulation and PDM domains.	datasaab;exemplification;high- and low-level;knowledge management;multi-core processor;prototype;simulation;software configuration management;systems engineering	Henric Andersson;Magnus Carlsson;Johan Ölvander	2011	2011 IEEE 20th International Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprises	10.1109/WETICE.2011.74	simulation;computer science;simulation modeling;modeling and simulation;product engineering	Metrics	-45.196151695793986	24.798982617636327	67385
3f692e0f2539020f2b4f4fbe89b7deddf6374b21	an approach to the verification and correction of knowledge-based systems	knowledge based system		knowledge-based systems;verification and validation	Ahmed Younes;Moheb R. Girgis;M. R. Hassan	2000	Egyptian Computer Science Journal		computer engineering;engineering;intelligent verification;control engineering;software verification;knowledge-based systems;high-level verification;functional verification	Logic	-45.74651396470264	31.065754425842197	67407
62b5c71013c4b17f1133eca682d8ef2566838e46	invariant guided system decomposition	cross cutting invariants;event b;system decomposition	We re-examine the problem of decomposing systems in Event-B. We develop a pattern for cross-cutting events and invariants that enables the core dependencies in multi-machine systems to be tracked. We give the essential verification conditions.	b-method;invariant (computer science);shared variables	Richard Banach	2014		10.1007/978-3-662-43652-3_23	computer vision;discrete mathematics;simulation;mathematics	Logic	-43.83203115796818	27.9850661265047	67705
0bbc91b716bc8bfc07131196b7ed7cd09ce483fd	ggd: graph grammar developer for features in cad/cam	cam;cad;data exchange;graph grammar;kunstliche intelligenz;domain specificity;knowledge base;knowledge engineering	To integrate CA systems with other applications in the world of CIM one prin cipal approach currently under development is based on feature representation It enables any CIM component to recognize the higher level entities the so called features out of a lower data exchange format which might be the internal rep resentation of a CAD system as well as some standard data exchange format In this paper we present a made to measure editor for representing features in the higher level domain speci c representation language FEAT REP a representation language based on a feature speci c attributed node labeled graph grammar This intelligent tool shortly called GGD supports the knowledge engineer during the rep resentation process by structuring the knowledge base using a conceptual language and by verifying several characteristics of the features	computer-aided design;computer-integrated manufacturing;entity;graph labeling;graph rewriting;knowledge base;knowledge engineer;verification and validation	Christoph Klauck;Johannes Schwagereit	1993		10.1007/3-540-56804-2_53	data exchange;natural language processing;knowledge base;cam;computer science;artificial intelligence;knowledge engineering;cad;database	AI	-46.76186563450283	24.438067900442366	68281
3e05d654ea2d38bc2c4c28a4d637bce2a67b849e	a conceptual framework for procedural animation (cfpa)		This course presents a conceptual framework for procedural animation (CFPA) that defines and describes common language for a fundamental timing definition that can be used to design and drive procedural animation. The course will use both test and real production cases to illustrate these concepts. By following the CFPA, users can set up procedural animation rigs and tools in a highly organized and modularized way to facilitate authoring and reuse.	procedural animation	Dong Joo Byun	2018		10.1145/3214834.3214835	computer vision;simulation;conceptual framework;reuse;artificial intelligence;computer science;procedural animation	Graphics	-47.22109549867749	23.881281335357794	68702
3f7348b15d8f737b0d37d16abea927bd271feffc	middleware for large distributed systems and organizations	distributed system;complex dynamics;building block;middleware;distributed systems;dynamic organizations	Modern computational environments are complex, dynamic and highly distributed. These environments include multiple independent or grouped objects that communicate, collaborate and perform various activities. We describe Middleware++, a unifying system and computational construct that makes the use and operation of these large, fully distributed environments feasible and manageable. In this paper we present the basic Middleware++ mechanisms that provide the computational building blocks for constructing and managing dynamic relationships in rapidly changing, decentralized environments.	distributed computing;middleware	George Dimitoglou;Philippe Moore;Shmuel Rotenstreich	2003		10.1145/963600.963708	middleware;real-time computing;computer science;theoretical computer science;middleware;distributed computing	Crypto	-41.22001451416057	20.252994548177405	68754
b5b221108c59fa619332286b4ed7ef8c797b0a76	effective programming for research: development of software for kindsip	package program;developpement logiciel;interaction;dynamic system;systeme dynamique;software development;produit programme;programmation effective;systeme non lineaire;non linear system;kindsip	The software package KINDSIP was developed to characterize kinetic and nonlinear dynamic systems. We discuss some of the difficulties encountered in the design of KINDSIP, and propose an effective programming style for developing interactive programs; this approach is generally useful for nonprofessional programmers. Its principles are described along with the user interface and the software organization of KINDSIP.		Takashi Okada	1984	Computers & Chemistry	10.1016/0097-8485(84)85011-1	interaction;simulation;computer science;software framework;component-based software engineering;software development;dynamical system;machine learning;software construction;statistics;software system	Robotics	-37.0040921285829	26.00960864121297	68840
a61a26bf3f63f01fc108792f4c04fdd2df693989	a study of an approach to the collective iterative task allocation problem	virtual machine;multiagent system;multi agent system;distributed processing;absolute autonomy;distributed computing;multirobot systems;multi agent systems;cooperative systems;virtual machines;distributed computing system;virtual machines distributed processing multi agent systems;distributed computational system;virtual machine multiagent system distributed computational system relative autonomy absolute autonomy parallel system;relative autonomy;common sense;parallel system;distributed computing multiagent systems autonomous agents software agents collaborative work intelligent agent information science virtual machining couplings computational complexity;discussion paper;multiagent systems;open distributed system	The concept of autonomy is a central concept in distributed computational systems and in multi-agent systems in particular. Most researchers do not discuss the details of this concept, but rather assume a general, common-sense understanding of autonomy in the context of computational multi-agent systems. We review existing definitions and formalisms related to the notion of autonomy. We re-introduce two concepts: relative autonomy and absolute autonomy. We adopt and discuss a new formalism based on results from the study of massively parallel multi-agent systems in the context of evolvable virtual machines. We argue that for open distributed systems, entities must be connected by multiple computational dependencies and a system as a whole must be subjected to influence from external sources. However, the exact linkages are not directly known to the computational entities themselves. This provides a useful notion and the necessary means to establish a relative autonomy in such systems.	autonomy;computation;distributed computing;entity;iterative method;multi-agent system;semantics (computer science);virtual machine	Christian Guttmann;Iyad Rahwan;Michael P. Georgeff	2007		10.1109/IAT.2007.97	computer science;knowledge management;theoretical computer science;distributed computing	AI	-41.47361411244213	18.654933893480916	69096
e0e4081033ae60e3ef461eb7eef8be0cf166ea58	generating scenarios from use case map specifications	design model;formal specification;message sequence charts;user requirements notation;computer aided software engineering software quality;transformations;use case map;object oriented programming;formal specification xml unified modeling language object oriented programming;message sequence chart;unified modeling language;use case maps;xml;extensible markup language use case map specification user requirements notation itu t language family functional requirement high level design component structure automated scenario generation traversal algorithm individual scenario extraction xml file message sequence chart xslt;describing function;validation;scenarios	The use case map (UCM) notation is being standardized as part of the user requirements notation (URN), the most recent addition to ITU-T's family of languages. UCM models describe functional requirements and high-level designs with causal paths superimposed on a structure of components. The generation of individual scenarios from UCM specifications enables the validation of requirements and facilitates the transition from requirements to design. In this paper, we address the challenges faced during the automated generation of such scenarios. Scenario definitions and traversal algorithms are first used to extract individual scenarios from UCMs and to store them as XML files. Transformations to other scenario languages (for instance, message sequence charts) are then achieved using XSLT. Possible applications of this two-step generation process include early validation and synthesis of design models. Illustrative examples are given based on our current tools and recent experiments.	algorithm;causal filter;experiment;functional requirement;high- and low-level;message sequence chart;rational clearcase ucm;user requirements document;xml;xslt	Daniel Amyot;Xiangyang He;Yong Jun He;Dae Yong Cho	2003	Third International Conference on Quality Software, 2003. Proceedings.	10.1109/QSIC.2003.1319092	transformation;unified modeling language;xml;computer science;theoretical computer science;software engineering;describing function;formal specification;database;programming language;object-oriented programming;message sequence chart	SE	-47.44371944204331	27.33225178677163	69291
2ae99f5253de6d92dece7819125217b8b0fb7575	enacting proactive workflows engine in e-science	distributed system;metodo adaptativo;groupware;multiagent system;systeme reparti;agent mobile;activite specifique;distribucion geografica;agent based;programming environment;autonomous system;proactive service;agente movil;logicial personalizado;simultaneidad informatica;mobile computer;methode adaptative;intelligence artificielle;sistema autonomo;intergiciel;medio ambiente programacion;concurrency;sistema repartido;sevicio proactivo;internet;concurrent systems;specific activity;adaptive method;systeme autonome;adaptive computing;workflow;artificial intelligence;repartition geographique;middleware;inteligencia artificial;mobile agent;sistema multiagente;collecticiel;simultaneite informatique;domain specificity;geographic distribution;environnement programmation;actividad especifica;service proactif;systeme multiagent;in silico	The dynamic nature and the geographic distribution of scientific resources, require flexible and adaptive computational environment where an in-silico experiment can be executed as a workflow of activities. In this paper, we propose a software environment to dynamically generate domain-specific, agent-based workflow engines from workflow specifications. The workflow engine is a proactive multiagent system -a distributed, concurrent systemwhose autonomous components interact in performing the workflow activities in a specific domain. The proposed approach has been implemented on Hermes, agent-based mobile computing middleware, and tested within “Oncology over Internet” project.	agent-based model;autonomous robot;e-science;middleware;mobile computing;multi-agent system;proactive parallel suite;workflow engine	Ezio Bartocci;Flavio Corradini;Emanuela Merelli	2006		10.1007/11758532_138	workflow;real-time computing;the internet;simulation;concurrency;computer science;autonomous system;artificial intelligence;operating system;workflow management coalition;middleware;specific activity;mobile agent;windows workflow foundation;programming language;mobile computing;workflow management system;workflow engine;workflow technology	AI	-39.19930749333515	24.226674955818186	69297
cca015ba76a975f139e03280252f4c1ec19e5f8d	a logical treatment for the emergence of control in complex self-organising systems	complex self-organising systems;system behaviour;abstract system control;centralised control;system demand;object-oriented system;logical treatment;global system;swarm type system;complex dynamic system;control model;agile system	In a complex dynamic system the centralised control and local monitoring of system behaviour is not achievable by scaling up simple feedback adaptation and control models. This paper proposes using a variety of concepts from distributed artificial intelligence (DAI) to logically model an abstract system control using adaptable agent federations to induce self-organisation in a swarm type system. The knowledge acquisition and updates are handled through a modal logic of belief for team dynamics and the system as a whole evolves to learn from local failures that have minimal impact on the global system. Self-governance emerges from innate (given) action thresholds that are adapted dynamically to system demands. In this way it is shown that such a system conforms to the prerequisites that have been specified as necessary for a system to exhibit self-organisation and the intrinsic benefits of agent teamwork are established for a robust, reliable and agile system. The approach is illustrated by looking at team formation in a swarm scenario from a proposed NASA project. The Situation Calculus is used to formalise the dynamic nature of such systems with a dynamic logic implementation to reason about the ensuing programs. Subsequently the model is encoded using the Neptune scripting language and compiled to an object-oriented system for its deployment on distributed systems architecture.	emergence	Martin Randles;A. Taleb-Bendiab;Philip Miseldine	2005			modal logic;knowledge acquisition;software deployment;architecture;scripting language;engineering;dynamic logic (digital electronics);systems engineering;situation calculus;control system;distributed computing	Robotics	-40.047135170311726	22.34853503669266	69346
6eed9ddcf52c26ede4580781306123769fe5ae20	on the failure of game theoretic approach for distributed deadlock resolution	modeling the dynamics of mas;bounded rationality;deadlock resolution;equilibrium	Deadlocks may occur in many multi-agent environments and in various contexts. In particular, deadlock is a common problem in multiprocessing where many processes share a specific type of mutually exclusive resource. As such, the problem has received much attention in Operating Systems and Databases literature, resulting in various mechanisms for avoiding, detecting and recovering from deadlock situations. Recent advances in deadlock research extend the deadlock model to distributed environments. Here, deadlocks are harder to manage since none of the participating agents have a full knowledge of the entire system. Consequently, a number of approaches were pursued for handling deadlocks in distributed systems. Still, all these studies assume that agents are cooperative and follow a dictated deadlock resolution protocol.	deadlock;game theory	Nadav Sofy;David Sarne	2012			simulation;computer science;artificial intelligence;deadlock;concurrency control;distributed computing;deadlock prevention algorithms;bounded rationality	DB	-38.63422927634547	19.411741169104044	69505
b6af92d91f370a710a4459e6ae71cc24429f3bc8	proteus: a bioinformatics problem solving environment on grids	ontologie;environnement resolution probleme proteus;distributed computing;bioinformatique;grid;resolucion problema;calculo repartido;workflow;bioinformatica;ontology;calcul reparti;problem solving environment;problem solving;resolution probleme;bioinformatics	Bioinformatics can be considered as a bridge between life science and computer science, where high performance computational platforms and software are required to manage complex biological data. In this paper we present PROTEUS, a Grid-based Problem Solving Environment that integrates ontology and workflow approaches to enhance composition and execution of bioinformatics application on the Grid. Architecture and preliminary experimental results are reported.		Mario Cannataro;Carmela Comito;Antonio Congiusta;Pierangelo Veltri	2004	Parallel Processing Letters	10.1142/S0129626404001842	workflow;computer science;bioinformatics;artificial intelligence;ontology;distributed computing;grid;algorithm	HPC	-38.958831012507595	23.939079401272128	70102
1a58320c6825d5b8d0f9f7363a0324e1c925e603	verifying real-time systems against scenario-based requirements	automatic verification;system modeling;real time;model checking;timed automata;live sequence chart;real time systems	We propose an approach to automatic verification of realtime systems against scenario-based requirements. A real-time system is modeled as a network of Timed Automata (TA), and a scenario-based requirement is specified as a Live Sequence Chart (LSC). We define a trace-based semantics for a kernel subset of the LSC language. By equivalently translating an LSC chart into an observer TA and then nonintrusively composing this observer with the original system model, the problem of verifying a real-time system against a scenario-based requirement reduces to a classical real-time model checking problem. We show how this is accomplished in the context of the Uppaal model checker.	algorithm;audio feedback;co-np;conditional (computer programming);graphical user interface;message sequence chart;model checking;model transformation;petri nets;petri net;prototype;real-time clock;real-time computing;real-time operating system;real-time transcription;requirement;scalability;server (computing);springer (tank);systems modeling;timed automaton;uppaal;verification and validation	Kim G. Larsen;Shuhao Li;Brian Nielsen;Saulius Pusinskas	2009		10.1007/978-3-642-05089-3_43	model checking;real-time computing;systems modeling;computer science;theoretical computer science;algorithm	Embedded	-35.53595321328207	31.478157299381518	70246
51e8f463e902256434c6a0133c9a54dd2d1cd51a	petri net-based engine for adaptive learning	ims learning design;workflows;adaptive learning;petri nets	In this paper, an IMS LD engine based on a Petri net model that represents the operational semantics of units of learning based on this specification is presented. The Petri nets of this engine, which is called OPENET4LD, verify the structural properties that are desirable for a learning flow and also facilitate the adaptation of the engine if potential changes in the IMS LD specification were proposed. Furthermore, OPENET4LD has an open and flexible architecture based on a set of ontologies that describe both the semantics of the Petri nets execution and the semantics of each learning flow component of IMS LD. Furthermore, the implementation of this architecture has been exhaustively validated with a number of UoLs that are compliant with the levels A and B of IMS LD.	petri net	Juan Carlos Vidal;Manuel Lama;Alberto Bugarín	2012	Expert Syst. Appl.	10.1016/j.eswa.2012.05.013	workflow;real-time computing;computer science;theoretical computer science;distributed computing;process architecture;adaptive learning;petri net	ML	-45.88749552169565	18.62655106039927	70282
9386f2b541eee9222804b4a80f0dcb731747edff	engineering good-enough social interaction		Moreover, I claim that:  the framework should include a metamodel and the means to implement whatever sociotechnical systems are modeled and embed these systems in an environment that supports its operation.  the metamodel and the supporting environment may be understood as (electronic or artificial) institutions.  the sociotecnical systems may be understood as normative multiagent systems  the metamodel should therefore support several “governance models”  several governance models may be built if regimentation is properly implemented in the institutional infrastructure.  the “application-pull” will often impose satisfycing criteria on the “foundational push”	agent-based model;metamodeling;multi-agent system;sociotechnical system	Pablo Noriega	2012			normative;systems engineering;metamodeling;social relation;sociotechnical system;business;multi-agent system;corporate governance	AI	-43.25229829051317	19.802299719513943	70361
69df15fa6690630562c44125b8b184adb8e3e98a	orgmap: an organization-based approach for multi-agent programming	mas programming;organization theory;organization oriented programming	This paper proposes a new organization-based multi-agent programming (OrgMAP) approach to constructing dynamic and flexible software systems. A computational and programming model named Oragent is defined following software engineering principles such as modularity, reusability and etc. Oragent model not only allows programmers to represent the systems with highlevel abstractions in terms of organizations, rules, protocols and roles, but also provides a number of mechanisms, such as encapsulation, inheritance, enactment and event, to improve the dynamics and flexibility of MAS.	computation;encapsulation (networking);multi-agent system;programmer;programming model;software engineering;software system	Cuiyun Hu;XinJun Mao;Yin Chen;Huiping Zhou	2012			organizational theory;n-version programming;delegation;programming domain;reactive programming;functional reactive programming;computer science;theoretical computer science;software development;extensible programming;functional logic programming;programming paradigm;procedural programming;symbolic programming;inductive programming;programming language theory;programming language;concurrent object-oriented programming;programming in the large and programming in the small	AI	-42.05724632473294	20.896561271105636	70374
495b0e844230bbeb7c3b189bf49b34b15487d160	formal specification of agent behaviour through environment scenarios	formal specification;speech acts;analysis and design;software systems;software requirements;scenario analysis;social behavior;agent based system	Scenarios are typical situations that may occur in the operation of a software system. Scenario analysis plays an important role in software requirements analysis and design. This paper introduces a formal notation for the specification of scenario s in agent-based systems. The autonomous and collaborative behavior of an agent can be formally specified by a set of rules describing its activity in various scenarios. The power of the approach is illustrated by the formal specification of Maes' personal assistant agent Maxims. The paper also shows that agents' social behavior, such as speech act, can also be formally specified as scenario -reaction rules.	agent-based model;autonomous robot;formal specification;requirement;requirements analysis;scenario analysis;software requirements;software system	Hong Zhu	2000		10.1007/3-540-45484-5_21	reliability engineering;software requirements specification;simulation;formal methods;systems engineering;engineering;software design;formal specification	SE	-42.41026032149519	23.263105730264904	70621
0879b8d578e2ee9d1a305432a5337426d64d7939	towards instant automatic model refinement based on ocl	software prototyping prototypes software engineering sun computer science laboratories educational technology computer science education performance analysis software systems;formal specification;software tools decision making formal specification object oriented languages program verification;program verification;software tools;object constraint language instant automatic model refinement ocl specification modeling tool refinement decision making;object oriented languages;meta model;modeling tool	Model refinement is a complex task. It is difficult for developers to refine models all by themselves. A good modeling tool should not only do routine refinement work for developers, but also guide them to make decisions during the refinement process. Such refinement work is best done by modeling tools instantly while developers refine models, to provide timely assistance. In this paper, we present a general approach for meta-model designers or experts in different fields to define and describe such automatic refinement work by rules, and these rules can instruct the modeling tool to do the refinement work instantly, whenever the developers modify the model. The automatic refinement rules in our approach are based on OCL, and their semantics and behaviors are formally defined by using Dijkstra's guarded commands, so the rules are compact, unambiguous and reliable to use. We have also implemented the editor and the interpreter for the automatic refinement rules, and integrated them into our own modeling tool to support our approach.	guarded command language;interpreter (computing);language primitive;metamodeling;object constraint language;prototype;refinement (computing)	Hui Song;Yanchun Sun;Li Zhou;Gang Huang	2007	14th Asia-Pacific Software Engineering Conference (APSEC'07)	10.1109/APSEC.2007.96	metamodeling;computer science;systems engineering;formal specification;database;refinement;programming language;object-oriented programming	SE	-46.99640126969686	27.451205850603028	71028
5e522ca7d71add18fd5c84aad9e7f0496215ecf2	test criteria for model-checking-assisted test case generation: a computational study	software metrics;standards;measurement;automata computational modeling measurement standards semantics;software metrics automata theory formal verification program testing;automated test generation environment testing criteria model checking assisted test case generation verification technique unified test generation framework generalized büchi automata spin model checker;semantics;automata;computational modeling;formal verification;program testing;automata theory	Test case generation is often cited as one of the most challenging tasks in testing dependable systems [9]. Besides benefits as a verification technique by its own right, model checking is emerging as an efficient method for automating test case generation. Existing testing criteria and a range of new criteria, namely the vacuity-based ones, inspired by formal requirements have been used in model-checking-assisted test generation. This paper reviews some of these existing and new test criteria. We developed a unified framework for evaluating the effectiveness of these test criteria and the efficiency of model-checking-assisted test generation for these criteria. The benefits of this work are three-fold: first, the computational study carried out in this work assesses the practical effectiveness and efficiency of model-checking-assisted test case generation, which are important metrics to consider for selecting the right test criteria and test generation approach. Second, we propose a unified test generation framework based on generalized Büchi automata. The framework uses the same off-the-shelf model checker, in this case, SPIN model checker [10], to generate test cases for different criteria and compare them on a consistent basis. Last but not least, we describe in great details the methodology and automated test generation environment that we developed on the basis of our unified framework. Such details are of interest to researchers who needs to carry out their own experimental study on test criteria, and to practitioners who want to integrate model-checking-assisted test generation into their testing process.	adobe streamline;automata theory;code coverage;computation;dataflow;dependability;experiment;generalized büchi automaton;model checking;requirement;spin model checker;test automation;test case;test suite;unified framework	Bolong Zeng;Li Tan	2012	2012 IEEE 13th International Conference on Information Reuse & Integration (IRI)	10.1109/IRI.2012.6303064	test data generation;formal verification;computer science;artificial intelligence;theoretical computer science;automata theory;semantics;automaton;programming language;computational model;test case;test management approach;algorithm;software metric;measurement	SE	-44.04959015333604	28.97312986929358	71031
d93cb23064928ed170edfd743e09c19aeaae73d9	"""modeling of the argesim """"crane and embedded controller"""" system using the devslib modelica library"""		Abstract   DEVSLib is a free Modelica library, developed by the authors, that supports the Parallel DEVS formalism. The library is mainly designed to model discrete-event systems. It also includes interfaces to communicate the DEVSLib models with the rest of the Modelica libraries. Thus, the library can be used in the development of multi-domain and multi-formalism hybrid models. This manuscript discusses the modeling of the system “Crane and Embedded Controller,” proposed by ARGESIM, using Modelica and DEVSLib. The crane system is composed of a car that moves along a rail and a load connected to the car by a cable. A discrete controller controls the position of the car and its movement. The crane system is implemented in Modelica as a continuous-time model and the discrete controller is constructed using DEVSLib. The communication between the continuous-time and the discrete-event parts is performed using the DEVSLib interfaces. DEVSLib is freely available for download at http://www.euclides.dia.uned.es.	embedded controller;embedded system	Victorino Sanz;François E. Cellier;Alfonso Urquia;Sebastián Dormido	2009		10.3182/20090916-3-ES-3003.00016	control engineering;embedded system;simulation;engineering;modelica	Embedded	-36.79238553874378	26.895220750607738	71139
bc8dd572e0f660c37b0aea0e68b0486023314ed8	a methodology for crowd modelling with situated cellular agents	mobile agent;conceptual framework	This paper introduces a research activity aimed at the definition of a methodology to provide a solid conceptual framework for the development of simulation systems focused on crowd dynamics and based on the Situated Cellular Agent (SCA) model. After a brief introduction of the SCA Model, the general methodological approach is described. The main steps provide the definition of the spatial abstraction of the environment, the definition of its active elements, and the specification of types of mobile agents, the related behaviours with particular attention to their movement by means of the notion of utility. A case study is also briefly described in order to show how the methodology was applied in the modelling of crowd behaviour in a subway station.	mobile agent;simulation;situated	Stefania Bandini;Mizar Luca Federici;Giuseppe Vizzari	2005			situated;systems engineering;conceptual framework;mobile agent;abstraction;engineering;knowledge management	AI	-41.56851437435598	21.696016902396178	71206
50ea8dd7a17b3f055e3c355a5d97aed34c79b38a	embedding and verification of psl using asml	software development environment;formal specification;modeling language;complex system;model checking;object model;finite state machine;abstract state machine	In this paper, we propose a methodology to integrate the Property Specification Language (PSL) in the verification process of systems designed using Abstract States Machines (ASMs). We provide a complete embedding of PSL in the ASM language AsmL, which allows us to integrate PSL properties as part of the design. For the verification, we propose a technique based on the AsmL tool that translates the code containing both the design and the properties into a finite state machine (FSM) representation. We use the generated FSM to run model checking on an external tool, here SMV. Our approach takes advantage of the AsmL language capabilities to model designs at the system level as well as from the power of the AsmL tool in generating both a C# code and an FSM representation from an AsmL model. We applied our approach on SystemC designs, which are translated into AsmL models. Experimental results on a bus structure case study provided in the SystemC library showed a superiority of our approach to conventional verification.	.net framework;abstract state machines;algorithm;asml;assertion (software development);finite-state machine;model checking;modeling language;property specification language;simulation;systemc;systemverilog;systems modeling;test case;verification and validation	Amjad Gawanmeh;Ali Habibi;Sofiène Tahar	2005			complex system;abstraction model checking;.net framework;virtual finite-state machine;property specification language;programming language;language of temporal ordering specification;psl;embedding;computer science	Logic	-42.37545498376094	31.608595717430763	71330
3c01972ca35fb8c029f9c96426a587b55cbaf382	interpretation of simulation for model-based design analysis of engineered systems	text;functional representation;design analysis	This thesis attempts to answer the question Can we devise a language for interpretation of behavioural simulation of engineered systems (of arbitrary complexity) in terms of the systems’ purpose? It does so by presenting a language that represents a device’s function as achieving some purpose if the device is in a state that is intended to trigger the function and the function’s expected effect is present. While most work in the qualitative and model-based reasoning community has been concerned with simulation, this language is presented as a basis for interpreting the results of the simulation of a system, enabling these results to be expressed in terms of the system’s purpose. This, in turn, enables the automatic production of draft design analysis reports using model based analysis of the subject system. The increasing behavioural complexity of modern systems (resulting from the increasing use of microprocessors and software) has led to a need to interpret the results of simulation in cases beyond the capabilities of earlier functional modelling languages. The present work is concerned with such cases and presents a functional modelling language that enables these complex systems to be analysed. Specifically, the language presented herein allows functional description and interpretation of the following. • Cases where it is desired to distinguish between partial and complete failure of a function. • Systems whose functionality depends on achieving a sequence of intermittent effects. • Cases where a function being achieved in an untimely manner (typically late) needs to be distinguished from a function failing completely. • Systems with functions (such as warning functions) that depend upon the state of some other system function. This offers significant increases both in the range of systems and of design analysis tasks for which the language can be used, compared to earlier work.	complex systems;complexity;failure;mit engineering systems division;microprocessor;model-based reasoning;modeling language;simulation	Jonathan Bell	2006			natural language processing;computer science;theoretical computer science	Embedded	-41.25238460022522	29.407553718877004	71446
e06694149868f95a99d13ea1b49ce16d5b080144	use of k-nearest neighbor classifier for intrusion detection	k nearest neighbor classifier;system calls;program profile;intrusion detection;k nearest neighbor;text categorization;intrusion detection system	A new approach, based on the k-Nearest Neighbor (kNN) classifier, is used to classify program behavior as normal or intrusive. Program behavior, in turn, is represented by frequencies of system calls. Each system call is treated as a word and the collection of system calls over each program execution as a document. These documents are then classified using kNN classifier, a popular method in text categorization. This method seems to offer some computational advantages over those that seek to characterize program behavior with short sequences of system calls and generate individual program profiles. Preliminary experiments with 1998 DARPA BSM audit data show that the kNN classifier can effectively detect intrusive attacks and achieve a low false positive rate.	categorization;computation;document classification;experiment;intrusion detection system;k-nearest neighbors algorithm;nearest neighbour algorithm;openbsm;system call	Yihua Liao;V. Rao Vemuri	2002	Computers & Security	10.1016/S0167-4048(02)00514-X	intrusion detection system;speech recognition;computer science;machine learning;data mining;computer security	Security	-35.57636402070976	23.03256005246192	71525
4979b785b17530e0e1e7b81ba14f94bd182e8d7e	modelling of hybrid systems based on extended coloured petri nets	coloured petri net;continuous variable;hybrid system;petri net;discrete event	In this paper the modelling of hybrid systems, which are composed of both discrete event subsystems and continuous subsystems, is addressed. A general system structure for the hybrid system modelling is proposed along with their formulations. Based on these concepts, an extended coloured Petri net (ECPN) is proposed in order to implement the hybrid system modelling. Key ideas introduced in extended coloured Petri nets are dynamic colours, dynamic transitions, and dynamic places, which make ECPNs capable to model both variables governed by continuous dynamics and the ordinary Petri net tokens for discrete events. Thus, two aspects of hybrid system, continuous variables and discrete events, are unified in ECPNs by the number of tokens and the value of the tokens (defined as the colour state in this paper). A formal definition of ECPNs is also given. Finally, an illustrative example is given which shows how to use the developed approach for hybrid system modelling.	coloured petri net;hybrid system	Yong Yao Yang;Derek A. Linkens;Stephen P. Banks	1994		10.1007/3-540-60472-3_26	stochastic petri net;petri net	Logic	-36.960899540174445	29.25035230425969	71705
b2817bacad842130ed722a869bed74f10000e77b	a methodology to validate interactive storytelling scenarios in linear logic		Debugging is one of the main requirements for Interactive Storytelling (IS) authoring tools. During the authoring phase, authors have to specify large numbers of rules and actions as well as consider many possible paths. As a consequence, flaws may happen and finding them “by hand” is complex. Therefore the validation of an IS becomes a crucial issue and automatic assistance in this process is needful. Originated from those requirements, we propose, within the framework of this paper, a methodology using Linear Logic, based on analyzing automatically the resource allocation mechanisms, that helps authors derive a valid scenario of an IS. To do this, we model a scenario by a Linear Logic sequent, then prove the received sequent, which allows building and examining automatically all the possible branches in the scenario, thereby authors may guarantee that all the decisions (that may be made while unfolding the IS) lead to satisfactory endings of their goals. The paper ends with an example on an extract of an educational game to illustrate the methodology.	algorithm;debugging;graphical user interface;interactive storytelling;linear logic;logical connective;ludic interface;metamodeling;model transformation;relevance;requirement;scenario analysis;scheduling (computing);semantics (computer science);time complexity;unfolding (dsp implementation)	Kim Dung Dang;Ronan Champagnat;Michel Augeraud	2013	Trans. Edutainment	10.1007/978-3-642-37919-2_4	simulation;computer science;theoretical computer science;algorithm	Logic	-41.534771696862144	29.207048591764277	71706
b99d9c1fcd9817f6cd4c8a5ac8b934c648d6f150	generation of function block based designs using semantic web technologies	room automation designs;automated design;owl;design process;formal specification;resource description framework;function block;semantic web technology;embedded system;requirement analysis;embedded systems;design pattern;mathematical model;semantic web;programming;semantic web design automation buildings libraries embedded system assembly automatic control concrete computer science process design;buildings;function block based designs;semantic web automation embedded systems formal specification;automation;requirement analysis function block based designs semantic web embedded systems automation room automation designs	Embedded systems are used in many domains today. However, the design process of these systems is complex and time-consuming. In automation domains the complexity can be decreased by using function block based designs to specify the functionality of the system to be created. But this has to be done still manually. This paper introduces an approach to generate such function block based designs automatically from requirements. Therefore a generative approach is used, where design patterns were assembled to complete designs. The pattern description and the generation process are realized by Semantic Web technologies. The evaluation of the approach is exemplified by functional schematics of room automation designs.	algorithm;automatic programming;complexity;design pattern;embedded system;requirement;schematic;semantic web;web ontology language	Uwe Ryssel;Henrik Dibowski;Klaus Kabitzsch	2009	2009 IEEE Conference on Emerging Technologies & Factory Automation	10.1109/ETFA.2009.5347080	programming;requirements analysis;design process;computer science;systems engineering;artificial intelligence;automation;semantic web;rdf;mathematical model;formal specification;database;design pattern;engineering drawing	EDA	-48.00415858445376	29.474421682008106	71728
741da8c5bf35fc31206fb575825e7521ec2c002a	composing web services with pews: a trace-theoretical approach	web services communication system control software systems web and internet services software standards context aware services context modeling java acoustic testing;formal specification;wsdl defined operations;interface description language;data dimension;web service;service specification;web service design;pews language;web service composition;service specification web service composition pews language trace theory interface description language wsdl defined operations control dimension control workflow data dimension web service design;information flow;trace theory;specification languages;web services;control dimension;control workflow;web services formal specification specification languages user interfaces;user interfaces	PEWS is an interface description language for both individual and composed Web services. Individual Web services are expressions over WSDL-defined operations while composed Web services are expressions over PEWS-defined services. This paper distinguishes two dimensions of PEWS. The control dimension describes the control workflow of the service, i.e. the order in which the operations of the Web service will be executed. No data constraints are imposed. The data dimension adds information flow to the control dimension. In order to analyse the composability and the substitutability of composed services, we introduce a trace-theoretical presentation of the language constructs. Our long-term goal is to integrate PEWS into a Web service design system that checks useful properties of the service specification	composability;control flow;interface description language;web services description language;web service;world wide web	Cheikh Ba;Mirian Halfeld Ferrari Alves;Martin A. Musicante	2006	2006 European Conference on Web Services (ECOWS'06)	10.1109/ECOWS.2006.12	web service;web modeling;web standards;computer science;ws-policy;ws-addressing;database;services computing;programming language;ws-i basic profile;law;world wide web;universal description discovery and integration	DB	-46.81441386831661	18.560466542586155	71817
fb771a154049de95e426208d5e6469d37e90f3f8	user interface evaluation based on coloured petri nets modelling and analysis	verification;coloured petri nets;user interface evaluation computer user interfaces modelling and analysis coloured petri nets user interface verification;coloured petri net;user interfaces petri nets prototypes computer interfaces testing solids formal specifications availability product development parallel processing;availability;user interface;modelling and analysis;prototypes;formal specifications;computer user interfaces;testing;user interfaces petri nets;user interface evaluation;petri nets;computer interfaces;user interfaces;parallel processing;solids;product development	This paper proposes the modelling and analysis of computer user interfaces in coloured Petri nets (CPN). It presents a case study in which a user interface is modelled and analysed using a computational tool-Design CPN. The results of the analysis are discussed based upon the verification of the properties of the nets.	coloured petri net;user interface	Marckson R. F. de Sousa;Maria de F. Q. V. Turnell	1998		10.1109/ICSMC.1998.727849	parallel processing;human–computer interaction;computer science;theoretical computer science;process architecture;user interface;petri net	SE	-36.154789831759	28.368998266490042	71897
747eab291316064aa63d0e33a3a89abfe990c6ac	petri net-based object-oriented modeling of distributed systems	indexing terms;knowledge base;object oriented;petri net;data flow diagram;computer integrated manufacturing;user interface;distributed system	This paper presents an object-oriented approach for building distributed systems. An example taken from the field of computer integrated manufacturing systems is taken as a guideline. According to this approach a system is built up through three steps: control and synchronization aspects for each class of objects are treated first using PROT nets, which are a high-level extension to Petri nets; then data are introduced specifying the internal states of the objects as well as the messages they send each other; finally the connections between the objects are introduced by means of a data flow diagram between classes. The implementation uses ADA as the target language, exploiting its tasking and structuring mechanisms. The flexibility of the approach and the possibility of using a knowledge-based user interface promote rapid prototyping and reusability.	ada;artificial intelligence;complex system;computer-integrated manufacturing;control flow;control system;data flow diagram;database;dataflow;distributed computing;embedded system;exception handling;flexible-fuel vehicle;high- and low-level;ieee software;intel turbo memory;jim hall (programmer);knowledge-based systems;machine translation;one-class classification;pc bruno;pp (complexity);petri net;polar surface area;rapid prototyping;requirement;simulation;small-outline transistor;software system;source-to-source compiler;structured analysis;systems design;user interface	Giorgio Bruno;Alessandro Balsamo	1986		10.1145/28697.28725		SE	-38.737966540188424	26.72768599742896	72152
235b3cf1472269ffd77d9d93bafe3a8167790f2c	security (hyper-)properties in workflow systems: from specification to verification		Provable security guarantees for software systems are highly desirable. Our work aims at improving and integrating existing formal verification techniques into a framework for the specification and verification of typical security requirements of large-scale, distributed workflow systems. Challenges include the uniform modelling of different types of security requirements, the decomposition of global security requirements into requirements on subcomponents, and the refinement of an abstract specification towards an implementation. We focus our attention on workflow management systems due to their interesting security requirements and the widespread use of model-driven techniques in this area (e.g. using BPMN diagrams). We build upon existing verification techniques for a specific notion of information flow security, and intend to apply our results to concrete example systems such as a secure web-based conference management system.	diagram;formal verification;model-driven security;provable security;refinement (computing);requirement;software system;web application	Thomas Bauereiß;Dieter Hutter	2014			workflow management system;systems engineering;verification;intelligent verification;windows workflow foundation;workflow technology;workflow engine;provable security;reliability engineering;functional verification;computer science	Security	-44.59609944683413	31.27634193917231	72396
629296e2619453f761f561ab4566f92d69012671	time-aware automatic process view generation	standards organizations;bpmn;nickel;verifi;formal verification business data processing data privacy;organizations standards organizations nickel logic gates context subcontracting;inter organisational business process iobp;formal verification;model checking;logic gates;data privacy;business data processing;cation temporal constraints and dependencies business process modeling bpm inter organisational business process iobp process views bpmn model checking verifi;organizations;subcontracting;temporal constraints and dependencies business process modeling bpm;cation;context;process views;process model temporal violations time aware automatic process view generation omg standard business process model and notation bpmn business process outsourcing temporal properties temporal requirements business process modelling phase bpm phase privacy preservation interorganizational business process iobp tapvg approach verification approach model checking technique	Nowadays, the OMG standard business process model and notation BPMN is gaining widespread use in the business world. In this context, several underlying issues must be considered. In this paper, we are particularly interested in the problem of getting control over the business process outsourcing through views generation. Indeed, the concept of views is essential since it allows organizations to choose the parts that can be exposed and to keep secret the critical parts of their business processes. In this context, we are specially interested in considering temporal properties when building public views from private processes. First, we propose a BPMN extension for capturing temporal requirements during the business process modelling (BPM) phase. Second, based on this extension, our work preserves privacy in inter-organizational business processes (IOBPs) by a Time-aware Automatic Process View Generation TAPVG approach. Finally, a verification approach based on the model checking technique is used to diagnose potential temporal violations of the process model.	algorithm;automata theory;business process model and notation;model checking;outsourcing;process modeling;requirement;semantics (computer science);software propagation;timed automaton;uppaal;verification and validation	Saoussen Cheikhrouhou;Slim Kallel;Nawal Guermouche;Mohamed Jmaiel	2013	2013 IEEE 10th International Conference on e-Business Engineering	10.1109/ICEBE.2013.19	nickel;model checking;business domain;logic gate;information privacy;formal verification;computer science;organization;knowledge management;artifact-centric business process model;business process management;process modeling;database;business process model and notation;process management;business process;process mining;business process discovery;business rule;new business development;business process modeling	SE	-45.537730216405265	32.20947363417945	72403
1690e74d81490b70927ca1ed7245299f80f76f2e	towards a formal library for precise and accurate measurements		Several software quality metrics have been proposed during the last decades to reduce risks and faultiness during software development. Despite these many efforts, most defined measurements fail to reach a satisfactory level of performance due to the ambiguities detected in the way their definitions are expressed and later on interpreted. The paper introduces a formal extension of a well-known library of measures named FLAME. While this library is expressed using the semi-formal language OCL (Object Constraint Language) upon the UML meta-model, our extension make use of formal methods to provide a more precise and accurate measurements by proposing a formal definitions of software metrics upon a formal expression of the UML metamodel. Unlike the original definition of the library, this extension supports formal proofs and guarantees a unique interpretation which allows the built of tools support.		Meryem Lamrani;Younès El Amrani;Aziz Ettouhami	2014		10.1007/978-3-319-09156-3_44	software development;programming language;computer network;computer science;software metric;formal methods;metamodeling;object constraint language;mathematical proof;unified modeling language	EDA	-45.220601557197284	27.93372337626784	72694
8a91e5ffcda64577ade21362eb9ab9b32a88a3c7	hybrid multiagent systems with timed synchronization - specification and model checking	multiagent system;continuous variable;state machine;multi robot system;time synchronization;model checking;levels of abstraction;hybrid automata;state explosion;real time systems	This paper shows how multiagent systems can be modeled by a combination of UML statecharts and hybrid automata. This allows formal system specification on different levels of abstraction on the one hand, and expressing real-time system behavior with continuous variables on the other hand. It is shown how multi-robot systems can be modeled by hybrid and hierarchical state machines and how model checking techniques for hybrid automata can be applied. An enhanced synchronization concept is introduced that allows synchronization taking time and avoids state explosion to a certain extent. 1 Multiagent Systems Specifying behaviors for (physical) multiagent systems and multi-robot systems is a sophisticated and demanding task. Due to the high complexity of the interactions among agents and the dynamics of the environment the need for precise modeling arises. Since the behavior of agents usually can be understood as driven by external events and internal states, an obvious way of modeling multiagent systems is by state transition diagrams. Hierarchical state transition diagrams like statecharts are particularly well suited as they allow the specification of behaviors on different levels of abstraction [8]. They can directly be used as executable specifications for programming multiagent systems [1]. One important aspect of physical agents and robots is that they interact with a (possibly simulated) physical environment. Such interactions typically consist of continuous actions (e.g. the movement of a robot) and perceptions like the power status of a battery. Classical state transition diagrams are not well suited for modeling this kind of interactions, as the transitions between states are discrete. However, continuous extensions to these formalisms have been proposed, e.g. hybrid automata [6]. Especially for agents employed in safety critical environments, e.g. in rescue scenarios, behavior specification has to be done very carefully in order to avoid side effects ? This research is supported by the grants Fu 263/8 and Sto 421/2 from the German research foundation DFG within the special priority program 1125 on Cooperating Teams of Mobile Robots in Dynamic Environments. that may result in unwanted behaviors or even have disastrous consequences. One approach to realizing the required clarity of a specification is the use of formal design methods. Fortunately, many state transition diagram dialects like hybrid automata are equipped with a formal semantics that makes them accessible to formal validation of the modeled behavior. Thus it becomes possible to (semi-)automatically prove desirable features and the absence of unwanted properties in the specified behaviors, e.g. with the help of model checking methods. 2 Hybrid Hierarchical State Machines In this chapter we present the combination of two concepts: hierarchical statecharts and hybrid automata. As a running example, we use a scenario from the RoboCup rescue simulation league, which is shortly described in the following section. The RoboCup initiative (official homepage of the RoboCup Federation: www.robocup.org) aims at fostering research in robotics, artificial intelligence, and multiagent systems. As one example domain robotic soccer has been chosen, because soccer combines many interesting problems, e.g. dealing with uncertain and incomplete information, cooperation and coordination in a team of autonomous agents, decision support in multiagent systems, or planning and acting in a highly dynamic environment. Annual world competitions and a number of local events provide benchmarks and opportunity to present results of current research. RoboCup is divided into several leagues, which focus on different research aspects. The simulation league deals with aspects of situated multiagent systems like teamwork, spatial reasoning, decision making, and opponent modeling. There are also non-soccer leagues, e.g. the so-called rescue leagues (see next section).	agent-based model;artificial intelligence;automata theory;autonomous robot;benchmark (computing);computation;decision support system;executable;execution unit;formal system;hoare logic;hybrid automaton;interaction;mobile robot;model checking;multi-agent system;precomputation;principle of abstraction;reachability;real-time computing;real-time transcription;robotics;semantics (computer science);side effect (computer science);simulation;situated;spatial–temporal reasoning;state diagram;state transition table;synchronization (computer science);uml state machine;unified modeling language	Ulrich Furbach;Jan Murray;Falk Schmidsberger;Frieder Stolzenburg	2007		10.1007/978-3-540-79043-3_13	model checking;real-time computing;simulation;computer science;distributed computing;finite-state machine;abstraction model checking	AI	-38.970977249922996	29.711752530697602	72922
182ffa41e8a103b38f37d7bd5e428215c71af2e8	agent-based software engineering	formal specification;multi agent system;case studies;software engineering;agent based software engineering;complex distributed open systems;software agents;multi agent systems;intelligent agents;agent verification;cooperative systems;efficient implementation;agent specification;intelligent agent;open system;open systems;specification refinement;research agent based software engineering intelligent agents multi agent systems complex distributed open systems specification refinement agent specification agent verification case studies	The technology of intelligent agents and multi-agent systems seems set to radically alter the way in which complex, distributed, open systems are conceptualized and implemented. The purpose of this paper is to consider the problem of building a multi-agent system as a software engineering enterprise. The article focuses on three issues: (i) how agents might be specified; (ii) how these specifications might be refined or otherwise transformed into efficient implementations; and (iii) how implemented agents and multi-agent systems might subsequently be verified, in order to show that they are correct with respect to their specifications. These issues are discussed with reference to a number of casestudies. The article concludes by setting out some issues and open problems for future	agent-based model;computer science;endeavour (supercomputer);expert system;intelligent agent;multi-agent system;parallels desktop for mac;rational agent;software engineering	Michael Wooldridge	1997	Software Engineering - IEE Proceedings	10.1049/ip-sen:19971026	real-time computing;computer science;systems engineering;artificial intelligence;software engineering;multi-agent system;open system;intelligent agent	SE	-42.52034406109585	20.777028326066908	72926
d0cfcbd05f63724eea355f0543fd680510b04c0b	verification criterion directed testing for formal specifications	formal specification			Ziaomu Zeng;Jeffrey J. P. Tsai;Thomas Weigert	1996			verification;systems engineering;formal specification;formal methods;computer science;language of temporal ordering specification;formal verification;refinement	SE	-45.30330138018364	30.677533404423	73136
9ede05f9837cb1845fc63f58d39a2f1c2ee0fdeb	simulation of systems with dynamically varying model structure	vhdl ams;modelica;dynamic system;modeling language;structural dynamics;continuous simulation;hybrid system;discrete continuous simulation;hybrid simulation;hybrid systems	Hybrid systems are dynamical systems composed of components with discrete and continuous behavior. Some systems change their structure during simulation, or their components behavior is essentially changing. This “structural dynamics” can be described in some modeling languages but the corresponding hybrid simulators have more or less restrictions in handling models with dynamically varying structure. Some basic approaches for the simulation of such systems are discussed in the context of modeling languages and simulators. © 2008 IMACS. Published by Elsevier B.V. All rights reserved.	dynamical system;gensim;hybrid kernel;hybrid system;iteration;modeling language;numerical analysis;simulation;structural dynamics	Peter Schwarz	2008	Mathematics and Computers in Simulation	10.1016/j.matcom.2008.02.022	real-time computing;simulation;computer science;hybrid system;simulation language	AI	-36.79528063279596	26.91604683455	73159
fc98ec63ffb5811fc6828dfea5b6e7423d3e186e	formal specification and verification of data-centric service composition	data centric service composition;web services formal specification program verification software architecture;service composition;data models contracts web services cognition object oriented modeling formal specifications adaptation model;data centric web services;formal specification;service provider;formal model;formal specifications;data centric web services formal specification formal verification data centric service composition service oriented architecture ad hoc application service based software capability formal modeling;formal methods;contracts;web service;program verification;dynamic linking;formal method;software architecture;formal methods web services;adaptation model;formal verification;ad hoc application;cognition;web services;service based software capability;service oriented architecture;formal specification and verification;object oriented modeling;formal modeling;data models	Service-oriented architecture (SOA) promotes a paradigm where ad-hoc applications are built by dynamically linking service-based software capabilities. Service providers follow specification standards to advertise their services’ capabilities and to enable loosely coupled integration between their services and other businesses over the Web. A major challenge in this domain is interpreting the data that must be marshaled between consumer and producer systems. We propose a framework to support formal modeling and contracts for data-centric Web services. We demonstrate how this framework can be used to verify correctness properties for composition of services.	component-based software engineering;correctness (computer science);design by contract;dynamic linker;formal methods;formal specification;formal verification;hoc (programming language);information privacy;loose coupling;programming paradigm;sensor;server (computing);service composability principle;service-oriented architecture;service-oriented device architecture;utility;web service;world wide web	Iman Saleh;Gregory Kulczycki;M. Brian Blake	2010	2010 IEEE International Conference on Web Services	10.1109/ICWS.2010.80	web service;formal methods;computer science;service delivery framework;ws-policy;formal specification;database;services computing;programming language;law	DB	-46.32838234141714	18.53061695306325	73190
1fa59af241ed10d0bb19ac666546b9c9dfb5b76c	uml 2.0 state machines: complete formal semantics via core state machine	state machine;formal semantics;object oriented systems;standard model;formal reasoning	UML has become the standard modeling language for object-oriented systems. The informal description of UML and its continuous extension cause many ambiguities. Therefore, a formal semantics for UML is necessary, especially for formal reasoning and tool development. We present a formal semantics of UML 2.0 state machines, which are used for modeling the reactive behavior of objects, by (i) deriving core state machines with fewer design features and a precise syntax, (ii) developing a formal semantics for core state machines, and (iii) presenting a complete transformation from UML 2.0 state machines to core state machines. Such a transformational approach provides the opportunity of easy adaption to future changes of the semantics of UML state machines.	dspace;diagram;expressive power (computer science);finite-state machine;forward error correction;semantics (computer science);uml state machine;unified modeling language	Harald Fecher;Jens Schönborn	2006		10.1007/978-3-540-70952-7_16	natural language processing;standard model;formal semantics;uml state machine;formal verification;uml tool;computer science;theoretical computer science;applications of uml;formal semantics;finite-state machine;programming language;operational semantics	PL	-43.968795347682644	26.677292313309938	73243
7b4f49de0759d7eed7cf81b60acbdc15128f69ec	refinement plans for informed formal design	modelling guidance;event-b modelling formalism;modelling formalisms;planning perspective;failed refinement step;informed formal design;modelling system;refinement plan;new technique;powerful technique;refinement step	Refinement is a powerful technique for tackling the complexities that arise when formally modelling systems. Here we focus on a posit-and-prove style of refinement, and specifically where a user requires guidance in order to overcome a failed refinement step. We take an integrated approach – combining the complementary strengths of topdown planning and bottom-up theory formation. In this paper we focus mainly on the planning perspective. Specifically, we propose a new technique called refinement plans which combines both modelling and reasoning perspectives. When a refinement step fails, refinement plans provide a basis for automatically generating modelling guidance by abstracting away from the details of low-level proof failures. The refinement plans described here are currently being implemented for the Event-B modelling formalism, and have been assessed on paper using case studies drawn from the literature. Longer-term, our aim is to identify refinement plans that are applicable to a range of modelling formalisms.	b-method;expectation propagation;experiment;high- and low-level;invariant (computer science);plug-in (computing);point of sale;refinement (computing);semantics (computer science)	Gudmund Grov;Andrew Ireland;Maria Teresa Llano	2012		10.1007/978-3-642-30885-7_15	computer science;systems engineering;data mining;refinement;algorithm	AI	-41.90474628475325	28.204819230623997	73672
5a1637b42c0bfb2f09728af571cd6cc9dab77642	covers 3.0 - a c++ based graphical modeling and simulation tool	simulation ordinateur;modelizacion;concepcion sistema;code generation;ingenieria logiciel;software engineering;modeling language;modelisation;semantic model;object oriented;system design;transition systems;reactive system;genie logiciel;graphical model;simulacion computadora;simulation tool;modeling;computer simulation;conception systeme;simulation environment;model simulation	We consider a modeling language and a simulation environment based on object-oriented principles and aimed to help in the design of reactive systems. The language framework includes diagrams of object structure and interconnection, statecharts as a behavior description, and C++ for data objects and functions. Timed Transition Systems are used as a semantical model. COVERS enables the user to perform the whole modeling-simulation-analysis cycle within a single MS Windows-based graphical environment. We overview the code generation, model execution and visualization of results. The correspondence between COVERS language and the Unified notation is outlined.	c++;graphical user interface;simulation	Andrei Borshchev;Yuri Karpov;Victor Roudakov;Alexei Filippov;Alexei Sintotskij;Sergei Fedorenko	1997		10.1007/3-540-63371-5_51	semantic data model;computer simulation;simulation;systems modeling;reactive system;computer science;theoretical computer science;graphical model;modeling language;programming language;object-oriented programming;code generation;systems design	Logic	-39.416142635549186	26.458920015422684	73781
2211a0fef17861b13572512f0c505d234cf0fe90	principles to design smart physical objects as adaptive recommenders		Recommenders have proven to be useful means to support people in their activities and in making decisions. They evolved from online recommenders to context-aware and ubiquitous recommenders. Moving forward along this line, this paper introduces the new emerging class of smart physical recommenders: context-aware recommender systems that are embedded into physical everyday objects. This paper describes the features of these systems and presents a conceptual model to design them, by analyzing a number of issues that have to be addressed by a designer and discussing the consequences of different design choices with their impact on the smartness of the designed object. The model is structured in a number of layers corresponding to different conceptual design phases in which different requirements are analyzed. The contribution of this paper is to discuss and provide design guidelines for a new rising class of recommenders that combine the features of intelligent agents, cyber-physical objects, and recommender-support systems. The description of the model is complemented by an exemplary analysis of its application.	embedded system;intelligent agent;recommender system;requirement	Federica Cena;Luca Console;Assunta Matassa;Ilaria Torre	2017	IEEE Access	10.1109/ACCESS.2017.2765746	recommender system;intelligent agent;adaptive system;conceptual model;distributed computing;data mining;human–computer interaction;computer science;conceptual design;cognition;smart objects	HCI	-45.94953248213253	21.440692554746807	73856
b1f00970ba5f102c60c38c5be7cd9b1288d9129e	modeling and validation of executable requirements using live activity diagrams	automotive engineering;activity diagram;software systems engineering;formal specification;tool support;seamless model based methodology;ignition;uml 2;operational semantics;software systems;live sequence charts;program verification;runtime;requirements engineering;unified modeling language formal specification program verification;live sequence charts requirements engineering unified modeling language model driven engineering activity diagrams;monitoring;requirements specification;requirement engineering;lads;safety;unified modeling language;model driven engineering;unified modeling language automotive engineering runtime modeling safety ignition monitoring;lscs;live activity diagrams;modeling;requirements engineering live activity diagrams seamless model based methodology requirements specification software systems engineering uml 2 lads live sequence charts lscs;requirement specification;activity diagrams;live sequence chart	A seamless model-based methodology for requirements specification becomes increasingly the key to successful software systems engineering. The enhanced activity diagrams of UML 2 offer a promising intuitive modeling approach for requirements capturing. On this basis, we propose a formal syntax and operational semantics and extend activity diagrams to LADs (Live Activity Diagrams) by liveness-enriched constructs inspired by LSCs (Live Sequence Charts) for stating precise execution modalities. We aim at a tool-supported execution of LAD specifications allowing for early simulation and validation of requirements. We present an implementation of an LAD execution engine and describe the there upon suggested requirements engineering approach by means of an automotive case study.	activity diagram;automatic programming;chart;code generation (compiler);concrete security;domain-specific language;eclipse;emulator;executable;formal grammar;graphical user interface;least absolute deviations;liveness;model checking;operational semantics;refinement (computing);requirement;requirements engineering;seamless3d;semantics (computer science);simulation;software requirements specification;software system;stepwise regression;systems engineering;top-down and bottom-up design;tracing (software);unified modeling language	Christoph Knieke;Michaela Huhn;Malte Lochau	2008	2008 Sixth International Conference on Software Engineering Research, Management and Applications	10.1109/SERA.2008.10	reliability engineering;activity diagram;computer science;systems engineering;engineering;software engineering;requirements engineering	SE	-44.19502245916865	31.99768537802551	73972
6d055233961dd2980c9942b2de07eaa2c5d7b96c	embedding languages within design environments	programming environment;embedded language;large scale;design environment;computer application;software design	Large-scale computer applications reflect numerous sources of complexity: complexity originating in the constructs of the application domain, complexity of feature-rich interfaces, and (in many cases) complexity arising from the inclusion of enduser programming environments. The paper discusses a software design strategy for the creation of programmable design environments (PDEs); such environments are geared toward alleviating, for users, the negative effects of various sources of complexity. The paper illustrates this notion of PDEs with a description of a charting/graphing application named SchemeChart.	application domain;computer;software design;software feature	Michael Eisenberg	1995	Knowl.-Based Syst.	10.1016/0950-7051(95)98375-G	computer science;artificial intelligence;software design;theoretical computer science;machine learning;distributed computing	EDA	-45.16280482493092	21.825455894646232	73992
50c8299a93ec474dcd4e2b9151223fff491fb7ae	simulating performance of a bittorrent-based p2p tv system		In this paper we describe a prototype of a simulation framework and some ideas which are to be used to study performance of a P2P TV system in a controllable and adjustable environment. We created a simplified model describing live video distribution in a P2P TV system. Using the model we analyse how some of the system parameters influence its behaviour. We present the preliminary results obtained at different granularity levels of measurements, describing the macroscopic system performance as well as the performance of its individual components.	bittorrent;chunking (computing);content delivery network;library (computing);multicast;peer-to-peer assisted streaming solution;prototype;simulation	Arkadiusz Biernacki	2011		10.1007/978-3-642-21771-5_49	simulation;multimedia;computer graphics (images)	Metrics	-35.56371212217299	20.27137459655443	74441
411546146102ea529911d83127c98d6b2157ecfc	approximation of dispatching rules in manufacturing control using artificial neural networks	dispatching rules;composability;network simulation;network emulation;neural nets;model generation;manufacturing control;training;biological system modeling;computer graphic equipment;artificial neural networks dispatching biological system modeling neurons approximation methods manufacturing training;virtual reality;production engineering computing approximation theory computer aided manufacturing discrete event simulation dispatching neural nets;coprocessors;automatic generation;production engineering computing;approximation;approximation theory;simulation experiment;artificial neural networks;parallel discrete event simulation;computer aided manufacturing;manufacturing;distributed virtual environment;multicore computing;generating function;manageable scenario approximation dispatching rules manufacturing control artificial neural networks automatic generation dynamic behavior;approximation methods;multiprocessing systems;neurons;interoperability;quality model;manageable scenario;distributed simulation;open systems;simulation model;parallel processing;control strategy;dispatching;artificial neural network;discrete event simulation;dynamic behavior	Automatic generation of simulation models has been a recurring topic in scientific papers for years. A common problem of all known model generation approaches is the generation of dynamic behavior, e.g. buffering or control strategies. This paper introduces a novel methodology for generation of dynamic behavior, based on artificial neural networks, which is usable directly in the simulation. We also test the approach in a manageable scenario; all results are illustrated via small simulation experiments.	approximation;artificial neural network;data buffer;experiment;scientific literature;simulation	Sören Bergmann;Sören Stelzer	2011	2011 IEEE Workshop on Principles of Advanced and Distributed Simulation	10.1109/PADS.2011.5936774	interoperability;generating function;parallel computing;real-time computing;simulation;computer science;theoretical computer science;discrete event simulation;operating system;approximation;simulation modeling;network simulation;distributed computing;open system;manufacturing;artificial neural network;coprocessor;approximation theory	Robotics	-35.289824787970765	27.67123458399058	74641
1736895cf78ea55b6fada04a339d4511696f5e80	modelling and analysis of communication protocols using petri nets	communication protocol;petri net		petri net	Marco Ajmone Marsan;Fabio Neri	1990			communications protocol;petri net;distributed computing;process architecture;computer science	SE	-35.854168692176664	31.38391902274923	74746
89fe2cfa88a90d05587ce0b7f17dfb335bb8d44c	reusable model structures and behaviors for software processes	modele comportement;simulation ordinateur;developpement logiciel;modelizacion;herencia;behavior model;scale model;system dynamics modeling;modele reduit;process pattern;heritage;scaling law;reutilizacion;modelo comportamiento;dynamic model;object oriented framework;product line;sistema complejo;reuse;dynamical system;modelisation;systeme dynamique;modelo reducido;software process model;systeme complexe;model building;complex system;object oriented;ley escala;desarrollo logicial;software development;software package;oriente objet;estructura producto;simulacion computadora;progiciel;sistema dinamico;loi echelle;inheritance;modeling;orientado objeto;computer simulation;structure produit;paquete programa;product structure;software process;reutilisation	An organization of increasingly complex system dynamics model structures and behaviors has been developed to promote modeling reuse for software processes. It uses an object-oriented framework for describing structures in a class hierarchy with inheritance relationships. This original approach provides a set of common assets that can be referenced for a “product line” of software process models. The structures and their behaviors are process patterns that frequently occur, and the recurring structures are model building blocks that can be reused. They provide a framework for understanding, modifying and creating system dynamics models regardless of experience. Previous work can be understood easier and the structures incorporated into new models with minimal modification. A goal of this work is to help accelerate software process modeling and simulation activities. Experience indicates that the model assets scale from small to large, complex models. Examples of the constructs and executable versions of associated models are also available.		Raymond J. Madachy	2006		10.1007/11754305_25	computer simulation;behavioral modeling;simulation;model building;systems modeling;computer science;artificial intelligence;software development;dynamical system;reuse;system dynamics;object-oriented programming;scale model;software development process	SE	-39.06130903210934	25.52334725706862	74887
36df1539df9f5e72f864b5095826ee72665d5740	declarative support for prototyping interactive systems		The development of complex, multi-user, interactive systems is a difficult process that requires both a rapid iterative approach, and the ability to reason carefully about system designs. This thesis argues that a combination of declarative prototyping and formal specification provides a suitable way of satisfying these requirements. The focus of this thesis is on the development of software tools for prototyping interactive systems. In particular, it uses a declarative approach, based on the functional programming paradigm. This thesis makes two contributions. The most significant contribution is the presentation of FranTk, a new Graphical User Interface language, embedded in the functional language Haskell. It is suitable for prototyping complex, concurrent, multi-user systems. It allows systems to be built in a high level, structured manner. In particular, it provides good support for specifying real-time properties of such systems. The second contribution is a mechanism that allows a formal specification to be derived from a high level FranTk prototype. The approach allows this to be done automatically. This specification can then be checked, with tool support, to verify some safety properties about a system. To avoid the state space explosion problem that would be faced when verifying an entire system, we focus on partial verification. This concentrates on key areas of a design: in particular this means that we only derive a specification from parts of a prototype. To demonstrate the scalability of both the prototyping and verification approaches, this thesis uses a series of case studies including a multi-user design rationale editor and a prototype data-link Air Traffic Control system.	concurrent computing;control system;declarative programming;design rationale;embedded system;formal specification;functional programming;graphical user interface;haskell;high-level programming language;iteration;multi-user;programming paradigm;prototype;real-time clock;requirement;scalability;state space;verification and validation	Meurig Sage	2001				SE	-44.513539041209555	27.87424283981798	74900
c37fbc538ebc69b20d073d0c8ece87ad02c8f49f	checking global usage of resources handled with local policies	network resources;process calculi;formal methods;publish subscribe systems;control flow analysis	Abstract We present a methodology to reason about resource usage (acquisition, release, revision, and so on) and, in particular, to predict bad usage of resources. Keeping in mind the interplay between local and global information that occur in application-resource interactions, we model resources as entities with local policies and we study global properties that govern overall interactions. Formally, our model is an extension of π -calculus with primitives to manage resources. To predict possible bad usage of resources, we develop a Control Flow Analysis that computes a static over-approximation of process behaviour.		Chiara Bodei;Viet Dung Dinh;Gian Luigi Ferrari	2017	Sci. Comput. Program.	10.1016/j.scico.2016.06.005	formal methods;computer science;knowledge management;resource;data mining;database;programming language;control flow analysis	AI	-38.18640282941433	26.977912244506612	75125
71bec25c2164ef77d20e4b09d801cff1729d7f06	a meta-modeling approach for extending the instructional design semantics of learning management systems	least squares approximations;composition;semantics;visualization;syntactics;learning management systems;domain specific language;meta modeling;metamodeling;context	Nowadays Learning Management Systems (LMS) are not restricted to distant learning. Nevertheless, the pedagogical expressiveness of courses designed by teachers is strongly dependent on their knowledge and level of expertise on the LMS they use. The GraphiT project aims to help teachers design pedagogically sound and technically executable learning designs. To this end, we propose to support teachers by providing them with an LMS-specific Visual Instructional Design Language, according to a Domain Specific Modeling approach and tooling. This paper focuses on the abstract syntax of such language. We propose a specific LMS-centered approach for raising the pedagogical expressiveness of their implicit learning design semantics. We discussed how the LMS low-level parameterisations could be abstracted in order to build higher-level building blocks. Based on the Moodle LMS, we present and verify our meta-modeling approach by formalising the abstract syntax of a Moodle-dedicated instructional design language.	abstract syntax;conformance testing;domain-specific language;domain-specific modeling;eclipse modeling framework;executable;experiment;graphical modeling framework;graphical user interface;high- and low-level;management system;metamodeling;palette (computing);parse tree;requirement;serialization	Esteban Loiseau;Pierre Laforcade;Sébastien Iksal	2014	2014 9th International Conference on Software Paradigm Trends (ICSOFT-PT)	10.5220/0005002800720080	natural language processing;computer science;multimedia;programming language	SE	-46.668792662036736	24.11517239637052	75381
6719e44936d95816c66e564aaa76a0d239fd1ec1	architecting specifications for test case generation	tool support;rule based;specification and description language;automatic generation;conference paper;qa75 electronic computers computer science;software architecture;test case generation;program testing;specification languages;software engineering specification and description language tree and tabular combined notation test case generation sdl optimal system specification tool supported approach requirement specification rule based specification;software tools program testing specification languages software architecture;tree and tabular combined notation;software tools;computer science;computer aided software engineering product development automatic testing documentation system testing standards organizations automatic control	The Specification and Description Language (SDL) together with its associated tool sets can be used for the generation of Tree and Tabular Combined Notation (TTCN) test cases. Surprisingly, little documentation exists on the optimal way to specify systems so that they can best be used for the generation of tests. This paper, elaborates on the different tool supported approaches that can be taken for test case generation and highlights their advantages and disadvantages. A rule based SDL specification style is then presented that facilitates the automatic generation of tests.	documentation;specification and description language;table (information);test case	Richard O. Sinnott	2003	First International Conference onSoftware Engineering and Formal Methods, 2003.Proceedings.	10.1109/SEFM.2003.1236204	rule-based system;software architecture;computer science;software engineering;programming language	SE	-46.85862373598657	30.039269703051982	75472
ffdcaba6ff63b4ce61df3aa0ee11fb5b20c93011	a multiagent-system framework for hierarchical control and monitoring of complex process control systems	opc;multiagent system;agent based;design criteria;hierarchical control;control system;multiagent;process control;xml;discrete event;process control system	This paper proposes a framework for the implementation of multiagent system for hierarchical control of complex process control systems based on OPC technology that is widely applied to the automation control systems. This framework is proposed with utilization of OPC technology in both continuous-event part and discrete-event part by incorporating with XML for the negotiation and cooperation in the environments of multiagent system. The framework design criteria are also described. The comparison of the proposed framework with existing frameworks is made to demonstrate that the proposal is reliable and feasible in order to apply to agent-based process control applications.	agent-based model;control system;multi-agent system	Vu Van Tan;Dae-Seung Yoo;Myeong-Jae Yi	2008		10.1007/978-3-540-89674-6_42	ole for process control;real-time computing;advanced process control;xml;computer science;process control;hierarchical control system	Robotics	-38.11438075313742	22.15027861737095	75500
ec4e21b1142fa0e42cb7c022799288d8c12915c0	modeling and analysis of workflow based on tla	property analysis;indexing terms;schedulability analysis;temporal logic of actions;tla;workflow;modeling;modeling and analysis	We proposed an approach in modeling and analysis of workflow based on temporal logic of action. A workflow model is divided in to two parts: the description of scheduler as well as database updating and the description of properties, each part is expressed in a TLA formula. The analysis of properties is composed by scheduling analysis and database properties analysis and their proof process is equivalence to the verification of the implementation relationship between the model formula and the formula of its properties. Thus, established an unified framework for modeling and property analysis of workflow in deferent levels.	scheduling (computing);temporal logic;turing completeness;unified framework	Shu Chen;Guo Qing Wu	2009	JCP	10.4304/jcp.4.1.27-34	workflow;systems modeling;index term;computer science;theoretical computer science;data mining;database;world wide web;temporal logic of actions	SE	-36.89098761350615	31.72321451011291	76147
5e46bf941c84bd39eb61612aa6278fbe3cce77da	the integrated software development and verification system ates	interactive proofs;software development	This paper is a project report, presenting a few results of the ESPRIT project ATES, concerned with formal software development. A programming and proof system, based on a high level, abstract language, able to express the specifications necessary to develop reliable software, in a program-to-proof approach is described. Within this approach, we want to conceive a program and introduce the elements necessary for its proof, at the same time. (Those formal proof elements consist in logical assertions expressing mathematically what an algorithm does and logical properties of the function realized by the algorithm). Those proof elements will be used by the system, to verify the correctness of an algorithm, guided by an interactive proof checker.	integrated software;software development	Antonio Puccetti	1991		10.1007/3-540-54834-3_38	verification and validation;software verification;computer science;package development process;backporting;software framework;software development;software design description;software engineering;software construction;software testing;programming language;resource-oriented architecture;software deployment;software development process;software system	SE	-46.23789082401382	29.65467686013812	76181
40804df82bae5ccdcc44c0140b390e4e01358904	a language designer's workbench: a one-stop-shop for implementation and verification of language designs	types;language designer workbench;syntax;semantics;meta theory;language specification;name binding;domain specific languages	The realization of a language design requires multiple artifacts that redundantly encode the same information. This entails significant effort for language implementors, and often results in late detection of errors in language definitions. In this paper we present a proof-of-concept language designer's workbench that supports generation of IDEs, interpreters, and verification infrastructure from a single source. This constitutes a first milestone on the way to a system that fully automates language implementation and verification.	encode;integrated development environment;workbench	Eelco Visser;Guido Wachsmuth;Andrew P. Tolmach;Pierre Neron;Vlad A. Vergu;Augusto Passalaqua;Gabriël Konat	2014		10.1145/2661136.2661149	natural language processing;first-generation programming language;very high-level programming language;universal networking language;language primitive;object language;specification language;data control language;computer science;programming language implementation;theoretical computer science;compiled language;low-level programming language;modeling language;programming language;language technology;programming language specification;high-level programming language	PL	-46.98682742289951	26.574981108404756	76227
270b1446e9540960339e29942ad212d2079c1a5e	modeling workflow within distributed systems	distributed system;workflow management;power analysis;formal specification;petri nets workflow management software large scale systems process control control systems power system management power system modeling engines humans diversity methods;distributed processing;business data processing workflow management software distributed processing petri nets large scale systems formal specification formal verification;large scale;formal verification;workflow procedure verification workflow modelling distributed systems workflow management techniques business processes organizational boundaries dynamic response petri nets standard workflow structure standard workflow blocks workflow network soundness large scale workflow network decomposition self loop connected sub networks structural conditions design language specification language;business data processing;workflow management software;petri nets;petri net;business process;large scale systems;modeling tool	Workflow management techniques are aiming at supporting business process across organization boundaries. Current techniques are lacking of the formalism tools to model and analyze workflows in a large scale. And current WFMSs do not have the ability to react to the response of another WFMS dynamically. Using Petri Nets as the modeling tools, we present the concept of Standard Workflow Structure and a set of standard workflow blocks are designed. We prove that modeling a workflow process in Standard Workflow Structures can guarantee the soundness of a workflow network defined by Aalst [1]. We also presented the decomposing method of a large scaled workflow network into sub-networks. From our analysis and prove, we draw a very good conclusion that the workflow network composed by self-loop connected sub-networks maintains soundness under proper structure conditions. The methods presented are not only a design language for the specification of complex workflows, but also powerful analysis techniques to verify the workflow procedures.	business process;distributed computing;loop (graph theory);petri net;semantics (computer science)	Yuhong Yan;Alex Bejan	2001		10.1109/CSCWD.2001.942299	xpdl;computer science;knowledge management;database;windows workflow foundation;programming language;management;petri net;workflow management system;workflow engine;workflow technology	DB	-46.741733359386416	27.847313286460214	76380
33fbd1d10050aa3d380b2fd1e83745dd3bfb70ad	a web application is a domain-specific language	von neumann architecture;domain specific language dsl;web application	We introduce a correspondence between the design space of web applications and that of domain-specific languages (DSLs). We note that while most web applications today are implemented in ways that correspond to external DSLs, very little attention is given to implementation techniques corresponding to internal DSLs. We contribute a technique based on internal DSLs, and demonstrate a web application implemented with our technique.	domain-specific language;web application	David H. Lorenz;Boaz Rosenan	2016		10.1145/2984043.2989220	web application;web modeling;computer science;theoretical computer science;von neumann architecture;programming language;world wide web	PL	-48.08364421585594	24.099675679334617	76383
4038aeb8cf3e0db0952fec622b7e167e46900cd6	visual requirements validation: case study in a corba-supported environment	specification interpreter;visual requirements validation;formal specification;software prototyping;application software;user interface;authorisation;vienna development method;prototypes;formal specifications;graphical user interface;corba;object oriented programming;software engineering;computer aided software engineering;formal verification;graphical user interfaces;software reusability;software reusability distributed object management formal specification formal verification graphical user interfaces vienna development method authorisation object oriented programming;distributed object management;computer aided software engineering formal specifications user interfaces access control prototypes software engineering software prototyping graphical user interfaces application software programming;graphic user interface;validation;access control;reusable component;programming;corba compliant language;user interfaces;generic access control component;reusable component visual requirements validation formal specification graphical user interface specification interpreter corba generic access control component validation corba compliant language	We present an approach to requirements validation in which the formal specification of the requirements is directly, interpreted and the results are visually, presented to the customer through a graphical user interface, relying on the customer to visually, validate the specified requirements. The communication between the user interface and the specification interpreter is accomplished through CORBA. The approach supports the cooperation of customers and developers in eliciting and validating the requirements. We present a case study of the application of the technique to the validation of a generic access control component. The use of CORBA has the advantage that any, CORBA-compliant language can be used for the user interface, independently of the implementation of the specification interpreter The contributions of the paper are 1) the presentation of a case stud), of the visual requirement validation technique, 2) the revision and improvement of a previously presented visual validation technique, and 3) the application of requirements validation to a reusable component.	common object request broker architecture;requirement	Pascal Fenkam;Harald C. Gall;Mehdi Jazayeri	2002		10.1109/ICRE.2002.1048508	software requirements specification;computerized system validation;computer science;software engineering;system requirements specification;graphical user interface;database;programming language;validation rule	SE	-47.93814623622301	27.876353697388502	76412
0828a6aba1e65440354b37e8d7cd5fc4f383e968	building a hybrid systems modeler from synchronous language principles		Hybrid systems modeling languages are widely used in the development of embedded systems. Two representatives are Simulink/Stateflow1 that combine Ordinary Differential Equations (ODEs), data-flow and difference equations, hierarchical automata a la StateCharts [14] together with imperative features; and the Modelica language [1]2 based on DAEs with features for modeling discrete components. Ptolemy II3 is another example in which several models of computation are combined [15].  The formal verification of hybrid systems has been extensively studied [9]. Yet, we share the viewpoint of Lee and Zheng that hybrid modeling languages are best viewed as programming languages that happen to have a hybrid systems semantics [16, 17]. This raises important questions related to their design, semantics and implementation, to get efficient and reliable simulations as well as provably equivalent embedded target code. While sequential code generation in hybrid modeling tools is routinely used for efficient simulation, it is little used or not used at all to produce target embedded code in critical applications that are submitted to strong safety requirements. This results in a break in the development chain: parts of applications must be rewritten into sequential code and all properties verified on the source model cannot be trusted and have to be reverified on the target code.  Sequential code generation from a synchronous language like Lustre [12] has been studied in detail [13]. It can be formalized as a series of source-to-source transformations that eliminate high level constructs like hierarchical automata [11] and the generation of a generic intermediate representation for transition functions, turned itself into C code [6]. This approach, initiated in Lucid Synchrone [18], is implemented in the Scade Suite KCG code generator of Scade 64, used for developing various critical applications.  Yet, synchronous languages only manipulate discrete-time signals. Their expressiveness is limited to insure important safety properties like determinacy, execution in bounded time and space, and simple, traceable code generation. Their cyclic execution requires minimal run-time support and does not suffer the complications that accompany numerical solvers of ordinary differential equations. Conversely, a hybrid modeling language allows discrete and continuous time behaviors to interact. But this interaction is not constrained enough, nor specified with adequate precision in tools like Simulink/Stateflow and this occasion semantics pitfalls and bugs [10, 5, 2]. A precise description of all the compilation steps, that is, the actual implemented semantics, is mandatory in safety critical development processes where target code must be trustworthy. Our goal, in short, is to increase the expressiveness of synchronous languages without sacrificing any confidence in their compilers.  In previous works, we introduced a novel approach for the design and implementation of a hybrid modeling language that reuses synchronous language principles and an existing compiler infrastructure. We introduced an ideal synchronous semantics based on non standard analysis [5] for a Lustre-like language with ODEs [4], and then extended the kernel language with hierarchical automata [3] and a modular causality analysis [2]. These results form the foundation of Zélus [8]5 and were validated inside the industrial Scade Suite KCG code generator (Release 6.4, 2014) developed at Esterel-Technologies/ANSYS [7].  In this talk, I will summarize the ongoing work on Zélus and the way it has been applied to the Scade Suite KCG code generator. In the later, it was possible to reuse the existing infrastructure entirely with little modifications: static typing, the causality and initialization analysis, intermediate languages and the various compiler optimizations. The proposed language extension is conservative in that regular synchronous functions are compiled as before --- the same synchronous code is used both for simulation and for execution on target platforms. It also shows the versatility of the KCG infrastructure based on a successive rewriting. The precise definition of all compilation steps, built on the proven compiler infrastructure of a synchronous language avoids the rewriting of control software and may also increase the confidence in simulation results.  This work results from a collaboration with Albert Benveniste, Benoit Caillaud (INRIA, Rennes), Timothy Bourke (INRIA, Paris-Rocquencourt), Jean-Louis Colaço, Bruno Pagano and Cédric Pasteur (Esterel-Technologies/ANSYS).	automata theory;causality;code generation (compiler);dataflow;differential algebraic equation;electronic component;embedded system;esterel;formal verification;high-level programming language;hybrid system;imperative programming;indeterminacy in concurrent computation;intermediate representation;jean;linear algebra;lucid;lustre;model of computation;modeling language;numerical analysis;open-source software;optimizing compiler;pc bruno;recurrence relation;requirement;rewriting;simulation;simulink;software bug;stateflow;systems modeling;traceability;type system	Marc Pouzet	2015	2015 International Conference on Embedded Software (EMSOFT)		block diagram;embedded system;real-time computing;computer science;theoretical computer science;operating system;software engineering;mathematical model;semantics;automaton;programming language;computational model;algorithm;code generation;hybrid system	Embedded	-39.47410296880628	32.00338750915987	76655
6efbb5d3f5a89c40c2a84cffe54071c03c0c89d7	modeling concurrent operational interruptions in construction activities with simplified discrete event simulation approach (sdesa)	construction simulation;construction system;sdesa modeling;simplified discrete event simulation;valid simulation model;simple earthmoving operation simulation;construction activity;barrow concreting operation simulation;discrete simulation methodology;concurrent interruptions model;concurrent operational interruption;original sdesa;construction simulation application;construction;cross validation;discrete simulation;simulation model;discrete event simulation	Numerous previous applications have demonstrated the high potential of discrete simulation methodologies in designing and analyzing construction systems. Still, construction simulation applications largely remain software exercises at the academic level because of the time and effort as required in constructing a valid simulation model that matches the real processes and operations. This paper introduces an enhanced version of the Simplified Discrete Event Simulation Approach (SDESA) by incorporating a concurrent interruptions model, which is intended to make construction simulations more realistic without compromising the simplicity of the original SDESA. Particular emphasis is placed on how to model the effects of operational interruptions upon the system performance by applying SDESA. The well-established CYCLONE method acts as a cross-validation tool to check the results given by SDESA. And the validity and simplicity of SDESA modeling are illustrated with a simple earthmoving operation simulation and a real hoist and barrow concreting operation simulation.	cross-validation (statistics);cyclone;dual total correlation;javascript syntax;simulation;whole earth 'lectronic link	Ming Lu;Wah-Ho Chan	2004	Proceedings of the 2004 Winter Simulation Conference, 2004.		computer simulation;real-time computing;simulation;computer science;engineering;discrete event simulation	EDA	-44.328371303857544	28.678379806252007	76993
536f280e224de04a8f4fb3be43e6e4a7305cae7c	automatic production of transformation chains using structural constraints on output models	alloy constrained binary relations automatic transformation chain production structural constraints output models model transformations graph transformations chain alternatives chaining process formal logic;metals;transformations orchestration;model transformation;unified modeling language adaptation models metals object oriented modeling abstracts safety security;abstracts;design pattern;safety;unified modeling language;transformations orchestration design pattern model transformation modeling;adaptation models;security;modeling;object oriented modeling;graph theory formal logic graph grammars	Model transformations are usually difficult to automate as they require to transform graphs into other graphs while the result must respect a set of predefined constraints. In previous works, we described how to compose competing model transformations addressing the same objective with different non-functional results. In this paper, we focus on the composition of complementary transformations addressing different needs. In particular, the order in which model transformations are applied must be determined when they are not commutative. However, preconditions and post conditions must still be valid and the evaluation of chains alternatives can be time consuming. We propose to solve this problem by abstracting models, transformations, and chaining process with a formal logic in order to fasten the discovery of valid transformation chains. Our solution first translates model transformations as Alloy constrained binary relations between input and output models and second exhibits a valid chain of transformations.	boolean satisfiability problem;input/output;model transformation;postcondition;precondition;triple modular redundancy	Cuauhtemoc Castellanos;Etienne Borde;Laurent Pautet;Thomas Vergnaud;Thomas Derive	2014	2014 40th EUROMICRO Conference on Software Engineering and Advanced Applications	10.1109/SEAA.2014.13	unified modeling language;systems modeling;computer science;information security;theoretical computer science;design pattern;algorithm	SE	-45.228746199303714	25.53315742061982	77129
b2f388f74762ca47a5775cbd6f987c7d0592699f	mas meta-models on test: uml vs. opm in the soda case study	object process methodology;multiagent system;multi agent system;social interaction;interaction sociale;orientado agente;lenguaje uml;sociologia;langage modelisation unifie;intelligence artificielle;agent oriented software engineering;program verification;oriente agent;agent logiciel;software engineering;software agents;verificacion programa;metamodel;interaccion social;metamodele;metamodelo;unified modelling language;genie logiciel;artificial intelligence;agent oriented;inteligencia artificial;sociologie;sistema multiagente;verification programme;ingenieria informatica;sociology;meta model;systeme multiagent	In the AOSE (Agent-Oriented Software Engineering) area, several research efforts are underway to develop appropriate meta-models for agent-oriented methodologies. Meta-models are meant to check and verify the completeness and expressiveness of methodologies. In this paper, we put to test the well-established standard Unified Modelling Language (UML), and the emergent Object Process Methodology (OPM), and compare their meta-modelling power. Both UML and OPM are used to express the meta-model of SODA, an agent-oriented methodology which stresses interaction and social aspects of MASs (multi-agent systems). Meta-modelling SODA allows us to evaluate the effectiveness of the two approaches over both the structural and dynamics parts. Furthermore, this allow us to find out some desirable features that any effective approach to meta-modelling MAS methodologies should exhibit. 1 Meta-models for MAS The definition of a methodology is an interactive process, in which a core is defined and then extended to include all the needed concepts. Meta-modelling enables checking and verifying the completeness and expressiveness of a methodology by understanding its deep semantics, as well as the relationships among concepts in different languages or methods [1]. According to [2], the process of designing a system (object or agent-oriented) consists of instantiating the system meta-model that the designers have in their mind in order to fulfil the specific problem requirements. In the agent world this means that the meta-model is the critical element(...) because of the variety of methodology meta-models. In the context of MASs, a meta-model should be a structural representation of the elements (agents, roles, behaviour, ontology, . . . ) that constitute the actual system, along with their composing relationships. Several meta-models of AOSE methodologies can be found in the literature—for instance, GAIA [2], PASSI [2], ADELFE [2], Tropos [3], MESSAGE [4], IGENIAS [5]. Although a number of these (PASSI, MESSAGE, ADELFE) adopt some kind of UML extensions to express system models, while others (GAIA, TROPOS, IGENIAS) adopt some ad-hoc symbology for the same purpose, the meta-models of all such methodologies are still expressed in UML. 1.1 Why UML for Meta-models The Unified Modeling Language (UML)[6] is the industry-standard language for specifying, visualising, constructing, and documenting the artifacts of software systems. Like other methods, UML is based on the decomposition principle, here in the form of aspect decomposition. A system is then expressed as a multiplicity of different models, each representing a specific system aspect: actually, UML defines 12 types of diagrams, whose 4 represent the static application structure, 5 are devoted to capture the system’s dynamic behaviour, and 3 are related to the organisation and management of application modules. Altogether, all these models are expected to convey a complete system specification. However, although the availability of so many models constitutes a richness from the expressiveness viewpoint, each model introduces its own set of symbols and concepts, thus leading to an unnatural complexity in terms of vocabulary, model multiplicity and model integration [7]. This is a problem both for maintaining consistency among the different system models and views, and for the mental integration of such views, since integrating several models within one’s mind an is a very difficult process. That is why the need to concurrently refer to different models in order to understand a system and the way it operates and changes over time is a critical issue, known as the multiplicity problem [8]. Despite this issue, however, the general adoption of UML as a world standard for system modelling makes it the first natural choice for representing meta-models. Adopting UML to express meta-models of methodologies endorses some specific issues, since representing a methodology is inherently different from representing a system at the object level. In particular, when meta-modelling methodologies, UML leads to emphasise objects and object relations, leaving aside the procedural aspects, which can be revealed only indirectly, by object operations and message exchanges. Moreover, the five behavioural diagrams provided by UML to capture the dynamic behaviour of a system at the object level become of little use at the meta-level, as they were defined to express which and how interaction occurs, rather than what interaction is and what role it plays—which is what is needed when representing a methodology. So, UML-based meta-models usually exploit only package diagrams, class diagrams, and associations. 1.2 Why OPM for Meta-models In order to better address the issues of representing the dynamics at the metalevel, and possibly reduce the risk of inconsistency related to the multiplicity problem, it is natural to “look outside” the UML world, looking for some alternative approach. The Object Process Methodology (OPM henceforth) [9] is an integrated approach to the study and development of systems in general, and of software systems in particular. OPM is also a reflective methodology, i.e. a methodology that can model itself without requiring any auxiliary means or external tools. OPM unifies the system’s life-cycle stages (specification, design and implementation) within one single frame of reference, using a single diagramming tool—Object-Process Diagrams (OPDs)—and a corresponding subset of English, called Object-Process Language (OPL). The basic assumption of OPM is that not only objects, but objects and processes constitute two equally-important classes of things, which together describe the functioning, structure and behaviour of a system in a single framework (i.e., without multiplying diagrams) in virtually any domain. Indeed, OPM’s basic principle is that structure and behaviour in a system are so intertwined that effectively separating them is extremely harmful, if not impossible. Therefore, unlike the object-oriented approach, behaviour in OPM is not necessarily encapsulated within a particular object class construct: using stand-alone processes, one can model a behaviour that involves several object classes and is integrated into the system structure. Processes can be connected to the involved object classes through procedural links, which are divided, according to their functionality, into three groups: enabling links, transformation links, and control links. Opposite to UML’s aspect-based decomposition, which intrinsically violates the OPM’s goal of a single all-describing model, OPM adopts detail decomposition: rather then decomposing a system according to its various aspects, decomposition proceeds by exploring the system’s abstraction levels. This is done via three refinement/abstraction mechanisms: unfolding/folding, which refines/abstracts from the structural parts of a thing (mainly an object), inzooming/out-zooming, which exposes/hides the inner details of a thing (mainly a process) within its enclosing frame, and state expressing/suppressing, which exposes/hides the states of an object. 1.3 Why Meta-modelling SODA Interaction is a major source of complexity in software systems. This is particular true in multi-agent systems, where interaction can take different forms: for instance, social interaction is concerned with agents interacting with each other, while environmental interaction regards the agents’ interaction with their environment. Although most methodologies still focus on intra-agent issues, more recently, methodologies like GAIA [10] and Hermes [11] have begun emphasising the role of interaction, shifting their focus toward social interaction. So, since our purpose here is to exploit an agent-oriented methodology as a reference for stressing the pros and cons of different meta-modelling approaches, a methodology addressing only intra-agent issues would not fit: we need a methodology that widely deals with inter-agent issues, so that the social aspects of multi-agent systems are in the front line. SODA [12] is a methodology which explicitly focuses on suitably modelling the social aspects of a MAS. As such, it assumes interaction to be the key aspect of its modelling process: a system entity appears in a SODA model only in that it is involved in some interactions. So, designing a multi-agent system in SODA amounts to defining agents in terms of their required observable behaviour, i.e., of the interactions in which agents are involved, and of the agents’ roles in the MAS. In addition, taking interaction into account implies to consider relevant coordination issues, addressed by SODA in the design phase. Therefore, in the following we first define the SODA meta-model in UML (Section 2.1) and in OPM (Section 2.2), then comparatively discuss the pros and cons of such meta-models and, by doing so, of the two approaches in general (Section 3).	agent-oriented software engineering;class diagram;complexity;critical graph;emergence;gaia hypothesis;hoc (programming language);hyperlink;interaction;list of concept- and mind-mapping software;metamodeling;multi-agent system;object process methodology;observable;open programming language (opl);package diagram;refinement (computing);requirement;software documentation;software system;unfolding (dsp implementation);unified modeling language;verification and validation;vocabulary;whole earth 'lectronic link	Ambra Molesini;Enrico Denti;Andrea Omicini	2005		10.1007/11559221_17	metamodeling;social relation;simulation;computer science;artificial intelligence;applications of uml;multi-agent system	SE	-41.6456374134583	24.56084184159692	77239
432c6d11170bb5a98f324d957bb294e861173f25	2comm: a commitment-based mas architecture	agents artifacts model;agent oriented software engineering;jade methodology;commitment;jade;commitment based interaction protocols	This paper proposes a multi-agent system architecture where agent interaction is ruled with the help of commitment-based interaction protocols. Commitment protocols are embodied into artifacts which can be accessed and used by the interacting agents. Ideally, the architecture is orthogonal to the language that is used to specify the commitment protocols. In this paper we rely on Yolum and Singh’s proposal. The implementation that is described relies on the well-known JADE and CArtAgO frameworks.	commitment ordering;interaction;jade;multi-agent system;systems architecture;whole earth 'lectronic link	Matteo Baldoni;Cristina Baroglio;Federico Capuzzimati	2013		10.1007/978-3-642-45343-4_3	real-time computing;computer security	AI	-42.10098961129049	19.609591237612474	77262
a0e2c76c4bd9eb405d2177f518ab4e7a590c8dce	using the event-b formal method and the rodin framework for verification the knowledge base of an rule-based expert system		Verification and validation of a knowledge base of an expert systems are distinct activities that allow to increase the quality and reliability of these systems. While validation ensures the compliance of a developed knowledge base with the initial requirements, the verification ensures that the knowledge base is logically consistent. Our work is focused on the verification activity, which is a difficult task that mainly consists in determination of potential structural errors of the knowledge base. More exactly, we aimed to study the consistency of knowledge bases of rule-based expert systems that use the forward chaining inference, a very important aspect in the verification activity, among others, such as completeness and correctness. We use Event-B as a modelling language because it has a mathematical background that allows to model a dynamic system by specifying its static and dynamic properties. In addition we use the Rodin platform, a support tool for Event-B, which allows to verify the correctness of the specified systems and its properties. For a better understanding of our method, an example written in the CLIPS language is presented in the paper.	b-method;expert system;formal methods;knowledge base	Marius Brezovan;Costin Badica	2018		10.1007/978-3-319-64161-4_6	rule-based system;knowledge base;formal methods;verification and validation;data mining;correctness;forward chaining;expert system;computer science;legal expert system	AI	-45.54593935003715	28.11551471672137	77317
3d81a9b2b60dace6cb5b5901e03284d55dc1c2e9	casting preemptive time petri nets in the development life cycle of real-time software	sequencing requirements;concurrent processes;linux rtai environment;state space methods;formal specification;concurrent computing;life cycle;coverage analysis;preemptive time petri net specification;real time;automatic testing;state space methods concurrency control formal specification formal verification linux petri nets real time systems software reliability;process architecture;real time operating system;automata;computer architecture;verification processes;time petri net;formal verification;casting;time sensitive oracle;computer experiment;state space;concurrency control;logic testing;state space analysis;linux rtai environment preemptive time petri nets development life cycle real time software real time tasking sets verification processes software life cycle concurrent processes process architecture sequencing requirements state space analysis real time operating system preemptive time petri net specification time sensitive oracle;linux;software life cycle;petri nets;real time tasking sets;real time software;software reliability;preemptive time petri nets;concurrent process;casting petri nets automata real time systems automatic testing logic testing timing concurrent computing computer architecture state space methods;support function;real time systems;development life cycle;timing	We describe a methodology for the construction of real-time tasking sets, which smoothly integrates a formal approach in both development and verification processes of the software life cycle. In the design stage, a timeline schema is used to specify concurrent processes with their dependencies and their expected temporal parameters. The schema is automatically translated into an equivalent preemptive time Petri net, which supports verification of the process architecture with respect to timeliness and sequencing requirements through state space analysis. The specification model drives the implementation stage enabling a disciplined coding of the process architecture on top of conventional primitives of a real-time operating system. At the same time, the preemptive Time Petri Net specification and the results of its state space analysis support functional testing enabling the construction of a time-sensitive Oracle and providing a metrics for coverage analysis. Computational experience in the Linux RTAI environment is reported to demonstrate the capability of the method to be effectively integrated in a practical approach.	functional testing;linux;petri net;process architecture;rtai;real-time clock;real-time operating system;real-time transcription;requirement;smoothing;software release life cycle;state space;timeline	Laura Carnevali;Luigi Sassoli;Enrico Vicario	2007	19th Euromicro Conference on Real-Time Systems (ECRTS'07)	10.1109/ECRTS.2007.86	embedded system;real-time computing;concurrent computing;computer science;operating system;distributed computing;programming language;software development process	SE	-42.89149966744573	31.164648920764705	77341
9b39c665a458dbf740e13cab40aa8a635ec9add5	suitable notification intensity: the dynamic awareness system	rule based;dynamic notification;online collaboration;task awareness;information overload;information flow;shared workspace	Being aware of others' activities has played a vital role in the success of online collaboration. This resulted in the emergence of many groupware systems that provide users with information about the activities of their collaborators in various manners. In virtually all current groupware systems, users are often overburdened by large amounts of unnecessary activity information. This happens because users are most of the time only interested in certain pieces of information for limited durations, while presently there exist no efficient mechanisms for automatically following a user's focus and adjusting the information flow directed at her/him. In this paper we present as a practical solution to this critical problem the dynamic awareness system, which extends the functionality of the BSCW shared workspace system. Key element of the dynamic awareness system is its rule-based inference mechanism to adjust the notification intensity, which reduces the information overload and indirectly allows users to better keep track of relevant events, as well as to manage more efficiently large amounts of shared information. We tested the effectiveness of the dynamic awareness system under real-life circumstances and describe the evaluation results.	collaborative software;emergence;existential quantification;information flow (information theory);information overload;logic programming;real life;workspace	Yao Wang;Wolfgang Gräther;Wolfgang Prinz	2007		10.1145/1316624.1316639	simulation;computer science;knowledge management;world wide web	HCI	-37.675985004571544	18.309564102655898	77684
05b847d0409f31ff1d784865c96975818881cb2c	uml-based web engineering - an approach based on standards		"""7.1 Overview UML-based Web Engineering (UWE, www.pst.ifi.lmu.de/ projekte/uwe) came up by the end of the nineties (Baumeister et al., 1999; Wirsing et al., 1999) with the idea to find a standard way for building analysis and design models of Web systems based on the then current methods The aim, which is still pursued, was to use a common language or at least to define metamodel-based mappings among the existing approaches (Koch and Kraus, 2003; Escalona and Koch, 2006). At that time the Unified Modeling Language (UML) which evolved from the integration of the three different modeling approaches of Booch, OOSE and OMT seemed to be a promising approach for system modeling. Since the early integration efforts, the UML became the """" lingua franca """" of (object-oriented) software engineering (Object Management Group, 2005). A prominent feature of UML is that it provides a set of aids for the definition of domain-specific modeling languages (DSL) – so called extension mechanisms. Moreover the newly defined DSLs remain UML-compliant, which allows the use of all UML features supplemented, e.g., with Web specific extensions. 144 Both the acceptance of the UML as a standard in the development of software systems and the flexibility provided by the extension mechanisms are the reasons for the choice of the Unified Modeling Language instead of the use of proprietary modeling techniques. The idea followed by UWE to adhere to standards is not limited to UML. UWE uses also XMI as model exchange format (in the hope of future tool interoperability enabled by a truly portable XMI), MOF for metamodeling, the model-driven principles given by OMG's Model-Driven Architecture (MDA) approach, the transformation language QVT, and XML. UWE is continuously adapting, on the one hand, to new features of Web systems , such as more transaction-based, personalized, context-dependent, and asynchronous applications. On the other hand, UWE evolves to incorporate the state of the art of software engineering techniques, such as aspect-oriented modeling, integration of model checking using Hugo/RT (Knapp et al., 2002, www.pst.ifi.lmu.de/projekte/hugo), and new model transformation languages to improve design quality. The remainder of this chapter is structured as follows: The features distinguishing UWE's development process, visual notation and tool support, are briefly outlined below. UWE's modeling techniques are discussed step by step in Sect. 7.2 by means of a simple online movie database case study. The UWE extensions of the UML metamodel are outlined in Sect. 7.3. UWE's model-driven …"""	aspect-oriented software development;asynchronous i/o;context-sensitive language;digital subscriber line;domain-specific language;domain-specific modeling;hgnc;internet movie database (imdb);interoperability;koch snowflake;meta-object facility;metamodeling;model checking;model transformation;model-driven architecture;model-driven integration;personalization;qvt;software engineering;software system;systems modeling;transformation language;uml-based web engineering;unified modeling language;xml metadata interchange	Nora Koch;Alexander Knapp;Gefei Zhang;Hubert Baumeister	2008		10.1007/978-1-84628-923-1_7	web application security;web development;web modeling;web design;web standards;web navigation;web intelligence;web 2.0;web testing	SE	-48.1708897538012	24.556320931630484	77859
9800c7ea5cca30b0808d3a1e41642e6e33bea41d	the bdip software architecture and running mechanism for self-organizing mas	agent architecture;multi-agent system;self-organization	As there are huge gaps between the local micro interactions among agents and the global macro emergence of self-organizing system, it is a great challenge to design self-organizing mechanism and develop self-organizing multi-agent system to obtain expected emergence. Policy-based selforganization approach is helpful to deal with the issue, in which policy is the abstraction of self-organizing mechanism and acts as the bridge between the local micro interactions and global macro emergence. This paper focuses on how to develop software agents in policy-based self-organizing multi-agent system and proposes a BDIP architecture of software agent. In our approach, policy is an internal component that encapsulates the self-organizing information and integrates with BDI components. BDIP agent decides its behaviors by complying with the policies and respecting BDI specifications. An implementation model and the running mechanism as well as corresponding decision algorithms for BDIP agents are studied. A case of self-organizing system is studied to illustrate our proposed approach and show its effectiveness.	algorithm;emergence;interaction;multi-agent system;organizing (structure);self-organization;software agent;software architecture	Yi Guo;XinJun Mao;Fu Hou;Cuiyun Hu;Jianming Zhao	2012		10.1007/978-3-642-32891-6_12	simulation;architecture;global macro;self-organization;software architecture;software agent;distributed computing;abstraction;multi-agent system;agent architecture;computer science	AI	-42.17283742744895	20.539447084637818	77913
2b6a32ba9b3b89467e28262f8b48cb2707baf21c	early foundations of formal modelling and language specification: vienna definition language (vdl) and vienna development method (vdm)	vienna development method		programming language specification;vhf data link;vienna development method	Heinz Zemanek	1994			programming language;vienna development method;programming language specification;computer science	Logic	-44.99383626308597	30.190501856240378	78027
221f5f75c022d540263ee507488cc2a4e2f85f67	collaborative verification-driven engineering of hybrid systems	control systems;robotics;mechanical engineering;formal verification;cyber physical system;safety;model driven engineering;hybrid system;vehicles;computer science	Hybrid systems with both discrete and continuous dynamics are an important model for real-world physical systems. The key challenge is how to ensure their correct functioning w.r.t. safety requirements. Promising techniques to ensure safety seem to be model-driven engineering to develop hybrid systems in a well-defined and traceable manner, and formal verification to prove their correctness. Their combination forms the vision of verification-driven engineering. Despite the remarkable progress in automating formal verification of hybrid systems, the construction of proofs of complex systems often requires significant human guidance, since hybrid systems verification tools solve undecidable problems. It is thus not uncommon for verification teams to consist of many players with diverse expertise. This paper introduces a verification-driven engineering toolset that extends our previous work on hybrid and arithmetic verification with tools for (i) modeling hybrid systems, (ii) exchanging and comparing models and proofs, and (iii) managing verification tasks. This toolset makes it easier to tackle large-scale verification tasks.	code refactoring;complex systems;correctness (computer science);formal verification;graphical user interface;hybrid system;key;model-driven architecture;model-driven engineering;natural deduction;redmine;requirement;traceability;undecidable problem;virtual distributed ethernet;web resource;wiki	Stefan Mitsch;Grant Olney Passmore;André Platzer	2014	Mathematics in Computer Science	10.1007/s11786-014-0176-y	model-driven architecture;simulation;system of systems;system of systems engineering;formal verification;software verification;computer science;systems engineering;runtime verification;robotics;programming language;cyber-physical system;intelligent verification;algorithm;functional verification;hybrid system	Logic	-44.35574621026154	30.94560744260389	78196
c878545dcc916c1b7c011a92391e5df1276a8cf9	an orchestrator for dynamic interconnection of software components	components;mobility;software engineering;software connectors;software component	Composing and orchestrating software components is a fundamental concern in modern software engineering. This paper addresses the possibility of such orchestration being dynamic, in the sense that the structure of component’s interconnection patterns can change at run-time. The envisaged approach extends previous work by the authors on the use of coalgebraic models for the specification of software connectors.	component-based software engineering;emoticon;haskell;interconnection;loose coupling;middleware;process calculus;prototype;run time (program lifecycle phase);unique identifier	Marco Antonio Barbosa;Luís Soares Barbosa	2007	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2007.01.053	software requirements specification;verification and validation;real-time computing;software sizing;software verification;computer science;package development process;backporting;software design;social software engineering;software framework;component-based software engineering;software development;software design description;operating system;software construction;programming language;resource-oriented architecture;mobile computing;software deployment;software requirements;software system	SE	-41.571993784813024	31.174371940070174	78249
641b77d7465e7ad1b9fafba92f86311a18289e31	verifying sequence and content for safety critical hypermedia systems	maintenance procedures;product safety;state based formal methods;process algebra specification;design methodology algebra carbon capture and storage documentation product safety safety devices formal verification robustness html xml;process algebra safety critical software program verification hypermedia system documentation;system documentation;program verification;design quality;safety properties;formal method;hypermedia;html;formal verification;design method;algebra;carbon capture and storage;safety critical software;xml;technical documentation systems;robustness;content verification;sequence verification;content verification safety critical hypermedia systems technical documentation systems maintenance procedures process algebra specification formal storyboards state based formal methods sequence verification;safety critical hypermedia systems;process algebra;documentation;formal storyboards;design methodology;safety devices	There is an increasing interest in the use of hypermedia for technical documentation systems. Where these systems are used in safety critical industries the design quality of the hypermedia product is of primary importance, since errors in presentation can cause errors in maintenance procedures, which in turn can cause malfunction of safety critical equipment. For this reason it is necessary to develop rigorous design methods which can offer guarantees of correctness. This paper extends previous work on this topic. The earlier work discussed a technique which allowed designers’ storyboards to be translated into a process algebra specification ‘formal storyboards’ allowing safety properties concerning sequence of presentation to be demonstrated. This technique was not applicable to the content of the presentation. This paper shows how the method may be combined with state based formal methods to provide a means of formal verification of the content as well.	correctness (computer science);formal methods;formal verification;hypermedia;process calculus;storyboard;technical documentation	Robert M. Newman	2000		10.1109/EURMIC.2000.874408	reliability engineering;computer science;systems engineering;database	EDA	-46.16372164413024	31.854496573051925	78498
65dc564d259bce606f783f44088b3aba009415c4	a light workflow management system using simple process models	dynamic change;workflow management;settore inf 01 informatica;management system;design and development;efficient algorithm;dynamic changes;modelling framework;process models;exception handling;workflow management system;workflow management systems;process model;petri nets;petri net	Workflow management systems are considereda hot technology. Nevertheless, up to now they havenot had the diffusion other packages such asproductivity tools, E-mail systems and groupwareplatforms have. We believe that this fact is due tothe many limitations of current workflow technology(weak support for changes; complex exception handlingmechanisms; limited openness to and integrability withother system components;...) and that radically newworkflow management systems should be designed anddeveloped in order to offer adequate products to themarket. In this paper, we outline the main innovativefeatures of the workflow management component of theMilano system making it highly flexible and adaptable.Particular attention is paid to its modellingframework, which is based on a class of net systemswell supported by efficient algorithms, and to theservices it offers to both workflow designers andactors. The most relevant aspects of the MILANOworkflow management system are also illustratedthrough a realistic example.	algorithm;concurrency (computer science);fail-safe;graphical user interface;hot spare;intelligent agent;java;knowledge acquisition;management system;mathematics of operations research;openness;password safe;performance;prototype;tcl	Alessandra Agostini;Giorgio De Michelis	2000	Computer Supported Cooperative Work (CSCW)	10.1023/A:1008703327801	workflow;xpdl;computer science;knowledge management;business process management;document management system;process modeling;database;windows workflow foundation;management;petri net;workflow management system;workflow engine;workflow technology	DB	-45.05228045418075	20.344996587120946	78558
5957e0a9ebb7004baf228aae6dfded6a3f677a99	toward formal description to metro services mechanism based on bigraph models	graph theory;rail traffic;service system;integrated circuit;computer model;biological system modeling;traffic engineering computing graph theory rail traffic;metro services mechanism bigraph bigraphical reactive system ubiquitous computing;bigraph;bigraphical reactive system;computational modeling;reactive rules formal description metro services mechanism bigraph models public traffic system urban rail transit system;logic gates;reactive system;mathematical model;ubiquitous computing;traffic engineering computing;face;metro services mechanism;logic gate;integrated circuits;logic gates computational modeling integrated circuits face ubiquitous computing biological system modeling mathematical model	The modern public traffic system provides more intelligence and efficiency services. These great requirements leading the complex services systems, such as the automatic fare collection in the urban rail transit system to convenient to passengers. In this paper, a novel method in a formal way is proposed to model and analyze the metro services mechanism by building bigraph models with a set of reactive rules, from the view point of the passenger. Different from traditional modeling methods, in these bigraph models, human beings are taken as a part of the system and the discussion is focused on the interactions between the human beings and the devices.	a-train;bigraph;complex system;dynamic dispatch;focal (programming language);formal methods;graphics;interaction;operating system;requirement;simulation;ubiquitous computing	Huawei Zhai;Weishi Zhang;Licheng Cui;Jinyu Shi;Hui Li	2011	2011 International Conference of Soft Computing and Pattern Recognition (SoCPaR)	10.1109/SoCPaR.2011.6089257	simulation;logic gate;computer science;graph theory;theoretical computer science;integrated circuit;ubiquitous computing	Robotics	-37.11377496831497	30.763890915279646	78669
bcb46d43d631a39dc2d82671394afcc42fcfb9ff	interfacing indigolog and oaa: a toolkit for advanced multiagent applications	low complexity;open agent architecture;agent programming language	In this paper we describe an interface library IGOAAlib that supports the development of Open Agent Architecture (OAA) agents using the IndiGolog agent programming language. OAA is a multiagent infrastructure that supports facilitated communication. IndiGolog is a high-level agent programming language based on logic that supports planning and allows complex agent behaviours to be specified. Full-fledged IndiGolog agents written using our interface library can be both reactive and proactive, thus overcoming one of the limitations of the OAA framework. The interface hides all of the low-level procedures that are used to communicate with the OAA system as well as OAA initialization, thereby leaving the IndiGolog programmer free to concentrate on the functionality of the agent. A multirobot mail delivery application developed using the library is presented.	accessibility;agent-based model;automated planning and scheduling;concurrency (computer science);download;high- and low-level;high-level programming language;icl;login;open agent architecture;programmer;prolog;robot;robotics;semantic web service;software agent	Alexei Lapouchnian;Yves Lespérance	2002	Applied Artificial Intelligence	10.1080/08839510290030507	computer science;theoretical computer science;distributed computing;programming language	AI	-41.86429628551876	18.309911621038683	78695
46fa700169489882c94b6ebbbcf9548a1d1c2497	stream processing components: isabelle/hol formalisation and case studies.		This set of theories presents an Isabelle/HOL formalisation of stream processing components introduced in Focus, a framework for formal specification and development of interactive systems. This is an extended and updated version of the formalisation, which was elaborated within the methodology “Focus on Isabelle” [6]. In addition, we also applied the formalisation on three case studies that cover different application areas: process control (Steam Boiler System), data transmission (FlexRay communication protocol), memory and processing components (Automotive-Gateway System).	communications protocol;flexray;formal specification;hol (proof assistant);isabelle;stream processing;theory	Maria Spichkova	2013	Archive of Formal Proofs		process control;stream processing;formal specification;programming language;formal methods;data transmission;communications protocol;flexray;hol;computer architecture;computer science	Embedded	-36.09672480226107	31.956373810974853	78838
dc8682c485bbf73cbfb7690781435d23d57b69b9	pr/t--net based seamless design of embedded real-time systems in applications and theory of petri ne	systeme temps reel;distributed system;high level petri net;systeme reparti;calculateur embarque;heterogeneous systems;red petri;embedded real time systems;synchronous language;specification language;langage synchrone;sistema repartido;design method;boarded computer;real time system;lenguaje especificacion;sistema tiempo real;petri net;langage specification;calculador embarque;reseau petri	During the last years we have been working towards a complete design method for distributed embedded real-time systems. The main characteristic of the methodology is that within the critical phases of analysis and synthesis the system under development is available in one unique model, that of extended Pr/T-Nets. Among several other reasons we have chosen a high-level Petri Net model in order to benefit from the multitude of analysis and synthesis methods for Petri Nets. Even though the methodology is based upon one common model, it nevertheless supports the modeling of heterogeneous systems using different specification languages. The methodology was introduced and described in several former publications. In this paper we therefore only give a brief overview and afterwards go into details of our recent work, namely the transformation of proper Pr/T-Net-models into synchronous languages, the partitioning of Pr/T-Nets and an OS-integrated execution engine for Pr/T-Nets.	embedded system;petri net;real-time transcription;seamless3d	Carsten Rust;Jürgen Tacken;Carsten Böke	2001		10.1007/3-540-45740-2_20	real-time computing;real-time operating system;design methods;specification language;computer science;artificial intelligence;operating system;programming language;petri net;algorithm	Embedded	-34.53101309126218	30.72769600234805	78950
dad953c4e58fb77d55272bb26c699ef247b80a25	designing a meta-model for a generic robotic agent system using gaia methodology	gaia;agent oriented software engineering;open systems meta model;multi robot systems;agent systems;meta model	The emergence of multi-agent systems in the past years has led to the development of new methodologies to assist in the requirements and architectural analysis, as well as in the design phases of such systems. Consequently, several Agent Oriented Software Engineering (AOSE) methodologies have been proposed. In this paper, we analyze some AOSE methodologies, including Gaia, which supports the architectural design stage, and some proposed extensions. We then use an adapted version of this methodology to design an abstract generic system meta-model for a multi-robot application, which can be used as a basis for the design of these systems, avoiding or shortening repetitive tasks common to most systems. Based on the proposed Generic Robotic Agent Meta-Model (GRAMM), two distinct models for two different applications are derived, demonstrating the versatility and adaptability of the meta-model. By adapting the Gaia methodology to the design of open systems, this work makes the designers’ job faster and easier, decreasing the time needed to complete several tasks, while at the same time maintaining a high-level overview of the system. 2012 Elsevier Inc. All rights reserved.	agent-oriented software engineering;emergence;gaia hypothesis;high- and low-level;metamodeling;multi-agent system;requirement;robot	Daniel Castro Silva;Rodrigo A. M. Braga;Luís Paulo Reis;Eugénio C. Oliveira	2012	Inf. Sci.	10.1016/j.ins.2012.01.029	metamodeling;real-time computing;simulation;systems design	AI	-44.11853960241974	22.318226523909708	79005
f877a8f5d90594be057137ccfa7cb04fecab3d31	multi-agent system for adaptation of distributed control system		A solution based on Multi-Agent Systems properties has been proposed. The presented structure is designed to Distributed Control System behaviour abstraction and encapsulation of the technical characteristics of its individual elements such as OPC (OLE for process control) servers. An ontology facilitating the creation of user interface for Multi-Agent System environment has been proposed. This ontology is based on a set of concepts and symbols understandable for the operator and the knowledge defining the hierarchical structure of object. Presented solution is not only a conception but it is a real, cross platform implementation based on the both Java and .Net programming platform. It practically shows how new programming solutions, tools and methodologies can be integrated and reused to solve real life, practical automation system problems.	.net framework;distributed control system;encapsulation (networking);java;multi-agent system;object linking and embedding;open platform communications;real life;user interface	Dariusz Choinski;Michal Senik	2012			networked control system	Robotics	-44.34383832807301	23.141012818523027	79016
67e20a44fa0f296d62d54a5999c20a4c0f98cb69	choreography conformance analysis: asynchronous communications and information alignment	conformational analysis;alignement;gestion informacion;information communication;intercambio informacion;verificacion modelo;service information;observable;behavioral analysis;metodo formal;data management;methode formelle;service web;verification modele;web service;program verification;transmision asincronica;formal method;communication information;verificacion programa;model checking;shared knowledge;echange information;asynchronous communication;information exchange;information management;analyse comportementale;alineamiento;comunicacion informacion;servicio informacion;protocol specification;asynchronous transmission;analyse information;analisis conductual;transmission asynchrone;modele donnee;information service;information system;gestion information;verification programme;information analysis;alignment;systeme information;servicio web;data models;sistema informacion	Web service choreography languages provide a way to describe the collaboration protocol of multiple services that exchange information in order to achieve a common goal. This description may be seen as a specification that should be respected by the joint behavior of the set of services implementing the choreography. Such a conformance requires that (i) the observable behavior of the implementation corresponds to the behavior described by the protocol specification, and (ii) the business information is properly managed, guaranteeing that the participants have a shared knowledge about it, according to what is specified in the choreography. In this paper we present a choreography conformance analysis approach that addresses both the behavioral correspondence and the business information management. The key features of the approach are the capability to deal with asynchronous interactions and the ability to model and analyse the data managed and exchanged in the protocol, thus providing more accurate verification results. We also present symbolic techniques based on these formalizations that can be used for model checking of the choreography conformance.	conformance testing;information management;interaction;model checking;observable;service choreography;web service	Raman Kazhamiakin;Marco Pistore	2006		10.1007/11841197_15	data management;computer science;asynchronous communication;database;distributed computing;information management;law;world wide web;computer security	SE	-40.24489691226608	24.67856389545147	79195
ed76639595866fe5af4fbcf92266ac22fabef50b	a testing framework for devs formalism implementations	devs standardized trace representation;devs implementation testing framework;devs tools;devs standardization	The Discrete-Event system Specification (DEVS) is a widely used formalism for discrete-event modelling and simulation. A variety of DEVS modelling and simulation tools have been implemented. Diverse implementations with platformspecific characteristics and often tailored to specific problem domains need to be tested to ensure their compliance with the precise and formal DEVS formalism specification. Such compliance allows for meaningful exchange and re-use of models. It also allows for the correct comparison of simulator implementation performance and hence of specific implementation optimizations. In this paper, we focus on testing “correctness” and “preciseness” of DEVS implementations and propose a testing framework. Our testing framework combines black-box and white-box testing approaches. We start with the proposal of a standard XML representation for eventand state-traces (also known as segments). We then systematically derive a suite of concrete test cases covering all possible DEVS constructs and their combinations. We apply our testing framework to PythonDEVS and DEVS++, two concrete implementations of the Classic DEVS formalism. Analysis of the test results reveals candidate items for improvement of the two tools. Finally, insights gained into DEVS standardization are discussed.	advice (programming);application domain;black box;category 1 cable;category 2 cable;correctness (computer science);devs;formal system;interoperation;oracle (software testing);problem domain;requirement;semantics (computer science);simulation;test case;tracing (software);white-box testing;xml	Xiaobo Li;Hans Vangheluwe;Yonglin Lei;Hongyan Song;Weiping Wang	2011			computer architecture;parallel computing;real-time computing;computer science	SE	-46.495356810193854	30.88672349382808	79393
eea617b2f610296d2c7f9c725c96764b8814070f	research on cpn model reduction focus on parallel tested behaviors		Nowadays parallel software system is very common and practical. However, it is difficult to test parallel software, because the state space of parallel software is very large. Therefore, a parallel model simplification method based on CPN (Color Petri Net) is proposed. Based on the original CPN, the CPN model for the tested behavior(Tested Behavior of CPN, TBoCPN) is proposed. The target of the test is described as the tested behavior. The relevant behavior is described as the behavior related to the tested behavior, then, the homogeneous concurrent branch group and the selection branch set are divided. Finally, the branches of the concurrent branch group and the selected branch set, which satisfied the condition of algorithm, are sequentially processed by the inhibitor arcs. The experiment shows that the reduction rate is at least 60%, and before and after the reduction, the full coverage test path generated by the tested behavior is not affected, thus proving that the method is an effective test method.	algorithm;coloured petri net;level of detail;software system;state space	Tao Sun;Wei Zhang;Xingjie Guo;Xiaoyun Wan	2017	2017 IEEE International Symposium on Parallel and Distributed Processing with Applications and 2017 IEEE International Conference on Ubiquitous Computing and Communications (ISPA/IUCC)	10.1109/ISPA/IUCC.2017.00126	software system;human–computer interaction;machine learning;petri net;software;state space;unified modeling language;computer science;homogeneous;test method;artificial intelligence	SE	-47.69472219439756	29.56488575617653	79641
2863bb0168f2b6c32b18c6f1908a1b01140c04d6	structuring feedback for groupware use: memory-based awareness	electrical capacitance tomography;memory based awareness;groupware;collaborative work;history;prototypes;user feedback;organizational memory;feedback collaborative software collaborative work electrical capacitance tomography monitoring displays electronic switching systems history atmosphere prototypes;feedback;group task;monitoring;displays;case memory prototype;electronic switching systems;groupware systems;atmosphere;awareness mechanisms groupware systems memory based awareness groupware system case memory prototype group task;awareness mechanisms;groupware system;collaborative software	Many awareness mechanisms in groupware systems provide a limited range of information. Awareness informatio however, benefit users in a wide range of system activities. We provide examples of such activities based on expe with users working with a groupware system in a real work setting. We present a model of awareness which incorp user feedback and activity information and implement a computerized organizational memory for capturing the fee relationships. The lowest level of memory that associates different user views and profiles with the group ta illustrated on the basis of a case memory prototype.	awareness;collaborative software;prototype	Gloria Mark;Alexander B. Bordetsky	1998		10.1109/HICSS.1998.653099	simulation;human–computer interaction;computer science;knowledge management;management;collaborative software	HCI	-38.50027897740867	18.4574194050698	79703
814a55c5b8a0e6d84afc68061386715aaf5d4e5f	analyzing interacting bpel processes	modelizacion;gestion entreprise;controlabilidad;formal model;red petri;processus metier;controllability;process verification and validation;firm management;process management;business process model;modelisation;controlabilite;business process modeling and analysis;proceso oficio;administracion empresa;petri nets;formal models in business process management;verification and validation;petri net;modeling;reseau petri;business process	This paper addresses the problem of analyzing the interaction between BPEL processes. We present a technology chain that starts out with a BPEL process and transforms it into a Petri net model. On the model we decide controllability of the process (the existence of a partner process, such that both can interact properly) and compute its operating guideline (a characterization of all properly interacting partner processes). A case study demonstrates the value of this technology chain.	business process execution language;computation;control flow analysis;data-flow analysis;interaction;nondeterministic algorithm;petri net;semantics (computer science);static program analysis;unreachable memory	Niels Lohmann;Peter Massuthe;Christian Stahl;Daniela Weinberg	2006		10.1007/11841760_3	simulation;computer science;engineering;management;petri net	Logic	-41.07153907341297	26.33268124814609	79709
07eb0f57ee9074aab129749ecb723e6ed8928b3d	hierarchical interface-based supervisory control of a flexible manufacturing system	modelizacion;hierarchical system;commande hierarchisee;architecture systeme;systeme evenement discret;interfaces;supervisory control;flexible manufacturing systems;controlabilidad;componente logicial;hierarchized structure;controllability;hierarchical systems;production system;atelier flexible;systeme hierarchise;systeme production;formal methods;simultaneidad informatica;composant logiciel;hierarchical control;structure hierarchisee;supervisory control theory;automaton;formal verification hierarchical interface based supervisory control flexible manufacturing system automata based interfaces controllability;sistema produccion;formal method;sistema acontecimiento discreto;modelisation;controlabilite;automata;sistema jerarquizado;discrete event system;concurrency;formal verification;flexible manufacturing;control jerarquizado;concurrent systems;state space method;methode espace etat;flexible manufacturing system;discrete event systems des;interfaces automata discrete event systems des formal methods hierarchical systems;automate;state space;industrial control;finite automata;software component;discrete event systems;arquitectura sistema;arquitectura modular;sistema flexible produccion;industrial control hierarchical systems discrete event systems flexible manufacturing systems controllability formal verification finite automata;exponential growth;system architecture;modeling;simultaneite informatique;modular architecture;supervision;estructura jerarquizada;architecture modulaire;metodo espacio estado;supervisory control flexible manufacturing systems automata discrete event systems manufacturing systems state space methods controllability control systems large scale systems scalability	Flexible manufacturing systems have long been touted as an application area for supervisory control theory. Unfortunately, due to the typical exponential growth of state space with the number of interacting subsystems, concurrent systems such as manufacturing applications have, for the most part, remained beyond the reach of existing supervisory control theory tools. This paper demonstrates how, by imposing a hierarchical, modular, interface-based architecture on the system, significant gains can be made in the size of applications that can be handled by supervisory control theory. We first review hierarchical interface-based supervisory control, providing the theory necessary to motivate the creation of well-defined automata-based interfaces between components. This architecture permits the verification of global safety (controllability) and nonblocking properties to be decomposed into a set of local checks, each of which only involves an individual component subsystem and its interface automata. The paper then provides a detailed description of how the theory can be applied to the design and verification of a flexible manufacturing system work cell. The work cell model is based on the Atelier Intere/spl acute/tablissement de Productique flexible manufacturing workcell, a system that has been previously studied in the literature with limited success.	automata theory;automaton;concurrency (computer science);control theory;flexible-fuel vehicle;interaction;modular programming;state space;time complexity	Ryan J. Leduc;Mark Lawford;Pengcheng Dai	2006	IEEE Transactions on Control Systems Technology	10.1109/TCST.2006.876635	control engineering;real-time computing;formal methods;computer science;engineering;control theory;automaton	Robotics	-34.57798017255762	30.494451922575866	79720
28806785ed23943c5c027fcac56bdefd48725726	combining the box structure development method and csp	communicating sequential processes;formal specification;formal verification;csp;fdr;abstract models;box structure development method;communicating sequential processes;formal analysis;formal verification;industrial software development;mathematical framework;model checker;specification translation	We combine the box structure development method (BSDM) by Mills et al. (1986) and communicating sequential processes (CSP) by Hoar (1985), with the goal of integrating them into an industrial software development environment. BSDM forms an ideal bridge between the actual system being developed and the abstract models used for formal analysis. CSP complements BSDM by providing the mathematical framework for formal verification, together with its model checker FDR. We present generic algorithms for translating specifications from BSDM into CSP, illustrate how they can be formally verified using FDR and summarise their effectiveness in practice.	algorithm;communicating sequential processes;formal verification;integrated development environment;model checking;software development;thinking outside the box	Philippa J. Hopcroft;Guy H. Broadfoot	2004	Proceedings. 19th International Conference on Automated Software Engineering, 2004.	10.1109/ASE.2004.10046	formal methods;genetic algorithm;formal verification;computer science;systems engineering;theoretical computer science;communicating sequential processes;formal specification;development environment;programming language	SE	-46.0183198434939	29.538767226327533	79904
abb5f9a627a50f0219d8997b75367c29a00b78a0	offering open hypermedia services to the www: a step-by-step approach for developers	spatial hypertext;web community;babylon system;web service;open hypermedia;web services;component model;open hypermedia systems;modular architecture;hypermedia services;web development	Hypermedia systems and more specifically open hypermedia systems (OHS) provide a rich set of implementations of different hypertext flavors such as navigational hypertext, spatial hypertext or taxonomic hypertext. Additionally, these systems offer component-based modular architectures and address interoperability between hypertext domains. Despite multiple efforts of integrating Web clients, a widespread adoption of OHS technology by Web developers has not taken place. In this paper it is argued that Web Services - which offer a component model for Web applications - can be integrated in OHSs. An architectural integration is proposed, a step-by-step process is outlined and an example of integration is provided. This very approach is aimed to benefit both worlds: the Web community with new rich hypermedia functionality that extends the current navigational hypermedia, and the OHS community by opening its tools and platforms to the many developer groups of the Web community.	component-based software engineering;hypermedia;hypertext;interoperability;oracle http server;system integration;www;web application;web developer;web service;world wide web	Nikos Karousos;Ippokratis Pandis;Siegfried H Reich;Manolis Tzagarakis	2003		10.1145/775152.775221	web service;hypertext transfer protocol;web development;web modeling;html;human–computer interaction;web standards;computer science;semantic web;web navigation;web page;database;multimedia;web 2.0;law;world wide web;web server	Web+IR	-48.166259627873195	20.989892898213768	79936
41fff237bd33fe5b066c7e5ad889b3334e352453	developing fault tolerant distributed systems by refinement	distributed system;error recovery;components;formal specification;fault tolerant;formal model;fault tolerant reactive systems;distributed processing;software fault tolerance;architectural level;formal model driven development;refinement;fault tolerant distributed systems;fault tolerant system;complex distributed systems;complex system;fault tolerance;reactive system;software fault tolerance distributed processing formal specification;refinement fault tolerance components architecture action systems;system components;system architecture;distributed fault tolerant systems fault tolerant distributed systems system components error recovery fault tolerance architectural level fault tolerant reactive systems formal model driven development complex distributed systems;architecture;distributed fault tolerant systems;action systems	Distributed systems are usually large and complex systems composed of various components. System components are subject to various errors. These failures often require error recovery to be conducted at architectural-level. However, due to complexity of distributed systems, specifying fault tolerance mechanisms at architectural level is complex and error prone. In this paper, we propose a formal approach to specifying components and architectures of fault tolerant distributed and reactive systems. Our approach is based on refinement in the action system formalism – a framework for formal model-driven development of distributed systems. We demonstrate how to specify and refine fault tolerant components and complex distributed systems composed of them. The proposed approach provides designers with a systematic method for developing distributed fault tolerant systems.	cognitive dimensions of notations;complex systems;distributed computing;fault tolerance;formal proof;formal specification;formal system;mathematical model;model checking;model-driven architecture;model-driven engineering;refinement (computing);stepwise regression;top-down and bottom-up design;type system	Elena Troubitsyna	2010	2010 Fifth International Conference on Software Engineering Advances	10.1109/ICSEA.2010.34	reliability engineering;complex systems;fault tolerance;real-time computing;computer science;distributed computing;programming language;systems architecture	SE	-42.338934890901314	32.30785169838386	79948
79ba243d150ff13db35e028da5f7a844978cda1f	components reuse for data-intensive business programs through an object-oriented architecture	object cross reference function;modelizacion;derivacion;entreprise;data intensive business program;aplicacion;reutilizacion;implementation;program design;specification;empresa;program transformation;abstraction;conception programme;transformation programme;abstraccion;reuse;modelisation;attribute propagation;ejecucion;bypass;transformacion programa;modulo programa;especificacion;object oriented;derivation;component reuse;firm;oriente objet;cross reference mechanism;c;module programme;application;modeling;orientado objeto;snapshot generation;domain specificity;concepcion programa;reutilisation;program module;object model	This article proposes an object-oriented specification architecture to support components reuse for data-intensive business programs. In the architecture, we augment the general object model for modeling the objects in a program. The architecture is developed through adopting a domain-specific approach to take advantage from the characteristics of data-intensive business programs. It provides graphical composition for interconnecting modules to compose a program. With the use of the architecture to design data-intensive business programs, designers are encouraged to compose a program from modules that are functionally cohesive and reusable. This maximizes the opportunities to reuse existing reusable modules and to discover new reusable modules.	algorithm;cap gemini sdm;data-intensive computing;electrical connection;executable;graphical user interface;os-tan;prototype;real life;software development process	Hee Beng Kuan Tan;Tok Wang Ling	1996	Journal of Systems and Software	10.1016/0164-1212(95)00060-7	reference architecture;real-time computing;simulation;systems modeling;object model;computer science;systems engineering;applications architecture;operating system;software engineering;reuse;solution architecture;program design language;abstraction;programming language;object-oriented programming;implementation;derivation;specification;business architecture	SE	-41.368959662897666	25.467502704828647	80130
0ebc7cf7f2d40038de8d0906d127173c87a93a93	collaborative version control in an agent-based hypertext environment	distributed system;systeme reparti;hipertexto;protocole transmission;multiprocessor;design and development;agent based;concurrent program;protocolo transmision;sistema repartido;computer supported collaborative work;object oriented;common lisp object system;lisp language;programa competidor;concurrent programs;oriente objet;lisp;multiprocesador;version control;orientado objeto;hypertexte;hypertext;programme concurrent;multiprocesseur;transmission protocol	"""| In this work we discuss a number of issues for the design of hypertext systems in an agent-basedmodel of computation. We examine how the \traditional"""" fundamental concepts which are at the basis of the design of hypertexts can be re-visited under a new perspective of collaborative expert agents. The paper presents how some principles of high-level concurrent programming are applied as new methodologies for the design and development of complex software, such as hypertext systems. By adopting an agent-based framework, we gain powerful control on version management that presents considerable di culties for the development of hypertext systems; a general distributed version control mechanism is applied, without signi cant di erences, both in single-user and in collaborative multiuser mode. In both cases, the underlying hypertext architecture is de ned in terms of computational agents interacting each other in order to accomplish common goals. In this paperwe present a rst-level prototype implemented in a concurrent object-oriented language, realized on the top of the Common Lisp Object System."""	agent-based model;common lisp;computation;concurrent computing;distributed version control;high- and low-level;hypertext;interaction;multi-user;prototype	Antonina Dattolo;Vincenzo Loia	1996	Inf. Syst.	10.1016/0306-4379(96)00008-7	real-time computing;simulation;computer science;artificial intelligence;operating system;lisp;database;programming language;computer security	AI	-38.575797717767514	24.762808913982276	80333
7029074df5225ab4fe6829b6c9c7cc6606e2ead9	automatic generation of correct web services choreographies and orchestrations with model checking techniques	web service;automatic generation;skeleton;automata;time factors;model checking;web services;xml;web services automata time factors xml computer science skeleton encoding simple object access protocol context aware services quality of service;timed automata;computer science;quality of service;simple object access protocol;verification and validation;encoding;context aware services;time constraint	In previous work we have presented the generation of WS-CDL and WS-BPEL documents. In this paper we show the unification of both generations. The aim is to generate correct WS-BPEL skeleton documents from WS-CDL documents by using the Timed Automata as an intermediary model in order to check the correctness of the generated Web Services with Model Checking Techniques. The model checker used is UPPAAL, a well known tool in theoretical and industrial cases that performs the verification and validation of Timed Automata. Note that our interest is focused on Web services where the time constraints play a critical role.	business process execution language;compiler description language;correctness (computer science);model checking;timed automaton;uppaal;unification (computer science);verification and validation;ws-security;web service	Gregorio Díaz;María-Emilia Cambronero;Juan José Pardo;Valentín Valero;Fernando Cuartero	2006	Advanced Int'l Conference on Telecommunications and Int'l Conference on Internet and Web Applications and Services (AICT-ICIW'06)	10.1109/AICT-ICIW.2006.53	web service;computer science;theoretical computer science;database;law;world wide web	Logic	-45.27887678551189	18.468589539847972	80397
5f158c21697e73cf97d5a7be15046a4fc6c1e420	a service-oriented middleware for building collaborative uavs	tecnologia industrial tecnologia mecanica;tecnologia electronica telecomunicaciones;collaborative uavs;service oriented computing;middleware;tecnologias;grupo a;unmanned aerial vehicles	For a while, Unmanned Arial Vehicles (UAVs) use was limited to military applications, however recently UAVs are also used for a wide range of civilian applications. Some of these UAV applications may involve multiple UAVs that must cooperate to achieve a common goal. This kind of applications is termed collaborative UAV applications. This paper investigates the collaborative aspects and challenges of multiple UAV systems. One of the main issues for multiple UAV systems is developing an effective framework to enable the development of software systems for collaborative UAV operations. One possible approach is to rely on service-oriented computing and service-oriented middleware technologies to simplify the development and operations of such applications. This paper discusses N. Mohamed · I. Jawhar · S. Lazarova-Molnar UAE University, Al Ain, United Arab Emirates N. Mohamed (B) College of Information Technology, UAEU, PO Box 15551, Al Ain, United Arab Emirates e-mail: nader.m@uaeu.ac.ae J. Al-Jaroodi University of Pittsburgh, Pittsburgh, USA how the service-oriented middleware approach can help resolve some of the challenges of developing collaborative UAVs. The paper also proposes a service-oriented middleware architecture that can satisfy the development and operations of such applications.		Nader Mohamed;Jameela Al-Jaroodi;Imad Jawhar;Sanja Lazarova-Molnar	2014	Journal of Intelligent and Robotic Systems	10.1007/s10846-013-9942-3	embedded system;simulation;computer science;engineering;service-oriented architecture;middleware;computer security	SE	-40.78993647481873	20.86774617518956	80505
f9612483320789e759625605438b47b5c6877bfc	model transformation specification and verification	formal specification;ucl;uml;specification;discovery;model transformation;theses;software architecture formal specification formal verification;conference proceedings;model driven development;quality improvement transformations flexible concise comprehensible and complete;model transformations;software architecture;specification model transformations uml;formal verification;digital web resources;model transformation in software development;specification and verification;ucl discovery;open access;software development;model transformation specification;ucl library;unified modeling language computational modeling transforms relational databases java argon refining;book chapters;open access repository;model driven development approach model transformation formal specification formal verification software development;ucl research	Model transformations are becoming increasingly important in software development, particularly as part of model-driven development approaches (MDD). This paper defines an approach for specifying transformations as constraints, and for verifying the correctness of these transformations.	constraint (mathematics);correctness (computer science);model transformation;model-driven architecture;model-driven engineering;software development;verification and validation	Kevin Lano;David J Clark	2008	2008 The Eighth International Conference on Quality Software	10.1109/QSIC.2008.38	unified modeling language;software architecture;formal verification;computer science;systems engineering;software development;software engineering;formal specification;database;programming language;specification	SE	-47.949104533676326	28.307867979503765	80526
5393e099956572453ce08fc4f22335508a52fc52	building an evaluation instrument for oo case tool assessment for unified modelling language support	school of no longer in use;electronics and computer science;object oriented programming;standardisation;computer aided software engineering;unified modelling language uml;object oriented;unified modelling language;case tool;simulation languages;software tools;instruments computer aided software engineering unified modeling language tellurium postal services chromium automatic testing automation software systems programming;simulation languages computer aided software engineering object oriented programming software tools;automation evaluation instrument oo case tool assessment unified modelling language support object oriented development practices rule extraction uml semantics document well formedness rules	The Unified Modelling L anguage (UML) as delivered in September 1997 offers the structure and dynamics of its modelling constructs developed in order to standardise different object oriented (OO) d evelopment practices. Represented as a language, UML covers some aspects addressed by any methodology and is expected to be accompanied by OO CASE tools through notation and implementation of the UML philosophy. This paper discusses the problem of OO CASE tools as methodology companions that encourage or enforce methodology support. The basis for an evaluation instrument has been developed in order to analyse how commercially available OO CASE tools support the UML. The evaluation instrument is based on extraction of a set of rules that are supposed to be followed in order to claim that the UML itself is being followed. The rules are extracted from the current UML Semantics document and its well-formedness rules. The evaluation instrument is tested against a few OO CASE tools in order to analyse how it can be used on a larger scale for assessing the level of automation and UML support embedded in the tools.	computer-aided software engineering;embedded system;unified modeling language	Radmila Juric;Jasna Kuljis	1999		10.1109/HICSS.1999.772814	uml tool;computer science;applications of uml;class diagram;shlaer–mellor method;programming language;object-oriented programming;node;computer-aided software engineering;use case points;object constraint language	Robotics	-47.857804264236755	28.274473015286606	80549
c6d2a2fc8d2f477f6dec14e4ca6eb697a9e89ed1	automated generation of agent behaviour from formal models of interaction	animated agent;coloured petri net;usability evaluation;formal model;user adaptation;formal models of interaction;animated agents;animated character;user manuals generation	We illustrate how a formal model of interaction can be employed to generate documentation on how to use an application, in the form of an Animated Agent. The formal model is XDM, an extension of Coloured Petri Nets that enables representing user-adapted interfaces, simulating their behaviour and making pre-empirical usability evaluations. XDM-Agent is a personality-rich animated character that uses this formal model to illustrate the role of interface objects and to explain how tasks may be performed; its behaviour is programmed by a schema-based planning followed by a surface generation, in which verbal and non-verbal acts are combined appropriately, the agent's 'personality' may be adapted to the user characteristics.	coloured petri net;database schema;documentation;extensible device metadata;formal language;mathematical model;norm (social);simulation;usability	Fiorella de Rosis;Berardina De Carolis;Sebastiano Pizzutilo	2000		10.1145/345513.345313	simulation;computer science;multimedia	HCI	-45.68139289788651	24.01739519435543	81004
38c1bd80d21695585bf8f1f94a3415e62d75d62d	modeling user behaviour aware websites with prml	web engineering;web design;user behaviour;pattern recognition	Adaptive websites usually change as effect of user navigational actions. Most current web engineering approaches (which consider personalization) allow to detect basic user browsing behaviour (e.g. user click on a link) but don’t consider the definition of (complex) behaviour events or user behaviour pattern recognition. In this paper, we use a method independent language called PRML to specify behaviour aware websites. PRML evolved out the experience of OO-H and was designed to be a generic personalization specification method that can be reused for different web design approaches. PRML allows the personalization when a complex behaviour event is triggered (i.e. a sequence of links) and also allows the definition and recognition (at runtime) of user behaviour patterns.	modeling language;partial-response maximum-likelihood;pattern recognition;personalization;run time (program lifecycle phase);web application;web design;web engineering	Irene Garrigós;Jaime Gómez	2006			user interface design;web modeling;web design;computer science;software engineering;web navigation;multimedia;internet privacy;web intelligence;web engineering;world wide web	Web+IR	-47.218208373789224	21.746582913195052	81179
2ea4b987b3ebabb625c37c6ce3b08c2e45b21004	o-p�: supporting the planning process using open planning process panels	automated planning;workflow support o p sup 3 planning process open planning process panels explicit models multipole courses of action multiple agents multiple courses of action air campaign planning process panel o plan visualization panel multiagent planning;mixed initiative;course of action;planning artificial intelligence;multi agent systems planning artificial intelligence;process planning visualization technology planning humans displays collaboration network synthesis intelligent systems intelligent agent tellurium;multi agent systems;computer supported co operative work;software component;multiagent planning	This paper introduces Open Planning Process Panels (O-p3). These panels are based on explicit models of the planning process and axe used to coordinate the development and evaluation of multiple courses of action. We describe the generic ideas behind O-P3 technology, a general methodology for building O-P3 interfaces and two applications based on O-P3 technology the Air Campaign Planning Process Panel (ACP3) and the O-Plan two-user mixedinitiative planning Web demonstration. This work has an impact on a number of important research areas outside planning, including Computer Supported Cooperative Work (CSCW) and workflow support.	agi-plan;authorization;automated planning and scheduling;computer-supported cooperative work;dalton (program);multi-agent system;pups/p3;requirement;the matrix	John Levine;Austin Tate;Jeff Dalton	2003	IEEE Intelligent Systems	10.1109/5254.889107	automated planning and scheduling;simulation;computer science;artificial intelligence;component-based software engineering;multi-agent system	Robotics	-41.1803195470339	18.309063823430936	81237
1cd7052fca440a076e1c9f81793591bdfa0b41da	system modeling in the cosma environment	modeling computer science hardware engines protocols automata distributed control control systems logic safety;rail traffic;programming environments;system modeling;temporal logic;traffic control;state machine;control system;braking;systems analysis;traffic control temporal logic systems analysis programming environments braking rail traffic;temporal logic analyzer system modeling cosma environment concurrent state machines paradigm distributed brake control system railway transport	The aim of this paper is to demonstrate how the COSMA environment can be used for system modeling. This environment is a set of tools based on Concurrent State Machines paradigm and is developed in the Institute of Computer Science at the Warsaw University of Technology. Our demonstration example is a distributed brake control system dedicated for a railway transport. The paper shortly introduces COSMA. Next it shows how the example model can be validated by our temporal logic analyzer.	algorithm;community climate system model;computer science;computer-aided software engineering;control system;finite-state machine;formal verification;level design;logic analyzer;programming paradigm;systems modeling;temporal logic;unified extensible firmware interface;usability;user interface	Wiktor B. Daszczuk;Waldemar Grabski;Jerzy Miescicki;Jacek Wytrebowicz	2017		10.1109/DSD.2001.952264	embedded system;systems analysis;real-time computing;simulation;systems modeling;temporal logic;computer science;control system;brake	Robotics	-36.70910497465126	31.551630735697202	81322
66ccb57ea09cbce0742b673f2bb10333a8295a29	hadesclipse - integrated environment for rules (tool presentation)		In the paper a presentation of HaDEsclipse is given. It is an environment for design and implementation of rule-based systems within the Semantic Knowledge Engineering (SKE) approach. It is build with the use of the Eclipse framework, integrating the previously developed components of the HaDEs environment. HaDEsclipse integrates modules for conceptual prototyping of rule bases, and a visual editor for logical design of extended decision tables that group rules working in similar context. It also allows for generating an executable form of the system, that can be later executed by an inference engine. While the SKE is targeted mainly at knowledge engineers, the use of the Eclipse framework makes the development easier for software engineers.	decision table;eclipse;executable;inference engine;knowledge engineer;knowledge engineering;rule-based system;software engineer;visual editor	Krzysztof Kaczor;Grzegorz J. Nalepa;Krzysztof Kutt	2013			software;eclipse;decision table;semantic memory;data mining;inference engine;executable;computer science	SE	-46.75600072906889	24.474382648012107	81407
40ef4e3c6be3a381c0ffc68d254dc96de72db3be	daisy: an object-oriented system for distributed artificial intelligence	distributed system;limit set;object oriented systems;object oriented;distributed artificial intelligence;speech act theory	This paper presents an object-oriented distributed system, called DAISY, for the development and experimentation of Distributed Artificial Intelligence systems and algorithms. This system is based on two programming levels: object level and agent level. Both the levels allow to define, implement and experiment systems. While the object level offers a large set of low level programming means (a large set of program constructs, a set of low level communication procedures, and so on), the agent level, which is implemented on the object level, offers a limited set of high level programming means (few program constructs, a fixed set of high level communication procedures derived by speech act theory and a fixed set of high level procedures to manage agent's knowledge). In particular, the paper shows the use of DAISY for modeling an airline reservation scenario and a manufacturing plant scenario.	daisy digital talking book;distributed artificial intelligence	Agostino Poggi	1994		10.1007/3-540-58855-8_22	limit set;computer science;artificial intelligence;machine learning;distributed computing;distributed object;object-oriented programming;artificial intelligence, situated approach	AI	-36.492212248171285	25.952477986205682	81536
6699c8754cc9215101a93673604fa1d1a36437c7	on the effective manipulation of digital objects: a prototype-based instantiation approach	artefacto;modelizacion;documento electronico;informacion numerica;theorie type;object oriented model;navegacion informacion;design and development;bibliotheque universitaire;navigation information;reutilizacion;digital library;information browsing;reuse;artefact;document electronique;modelisation;digital information;code reuse;biblioteca electronica;tipificacion;type checking;typing;object oriented;object manipulation;type theory;biblioteca universitaria;typage;oriente objet;information numerique;electronic library;modeling;orientado objeto;bibliotheque electronique;university library;electronic document;reutilisation	This paper elaborates on the design and development of an effective digital object manipulation mechanism that facilitates the generation of configurable Digital Library application logic, as expressed by collection manager, cataloguing and browsing modules. Our work aims to resolve the issue that digital objects typing information can be currently utilized only by humans as a guide and not by programs as a digital object type conformance mechanism. Drawing on the notions of the Object Oriented Model, we propose a “type checking” mechanism that automates the conformance of digital objects to their type definitions, named digital object prototypes. We pinpoint the practical benefits gained by our approach in the development of the University of Athens Digital Library, in terms of code reuse and configuration capabilities.	business logic;code reuse;conformance testing;digital library;object type (object-oriented programming);prototype;type system;universal instantiation;virtual artifact	Kostas Saidis;George Pyrounakis;Mara Nikolaidou	2005		10.1007/11551362_2	digital library;simulation;systems modeling;computer science;artificial intelligence;operating system;reuse;database;multimedia;programming language;object-oriented programming;type theory;algorithm	HCI	-41.620023193381606	25.07820176601961	81702
3351996eee9a3f438290d2df57a2c5ae7b5054b7	checking of models built using a graphically based formal modelling language	formal model;formal modelling;satisfiability;graphical models;model checking;side effect;modelling language;graphical model	RDT is a graphical formal modelling language in which the modeller works by constructing diagrams of the processes in their model which they then join together to form complete systems. Aside from the benefits which accrue as a side effect of building a formal model of a proposed system, these diagrammatic models can be useful as a means of communication between the development team and the users. However one of the greatest benefits of a formal model is that it can be subjected to rigorous examination to ensure that it satisfies properties required of the system. This paper describes the transformation used by the RDT toolset to generate Promela code (the input language of the SPIN model-checker) automatically from a model.	diagram;formal language;graphical user interface;modeller;mathematical model;model checking;modeling language;promela;remote digital terminal;spin model checker	Robert John Walters	2005	Journal of Systems and Software	10.1016/j.jss.2004.06.023	natural language processing;formal system;object language;computer science;theoretical computer science;graphical model;programming language;algorithm;effect system	SE	-41.165605663630444	28.044388226281445	81756
8c4fb80ce1d137cf961ce254f577b082e6e12d0e	fuzzy evaluation mechanism of trust chain under embedded trusted computing		This paper proposes a trust chain evaluation mechanism based on fuzzy theory under embedded trusted computing. Firstly, this method described the trusted computing, the trusted computing platform, embedded system, which showed the important position of the trust chain in dependable computing. Then, in the process of the entity evaluation of trust chain, according to the influencing factors of trust chain in the trusted computing, considering the indirect trust degree, completed the establishment of evaluation method of trusted computing model based on the fuzzy set theory. Finally, combined the fuzzy logic inference with the trust transitivity, we proposed a trust chain evaluation mechanism based on similarity, and introduced the time decay function and adaptive weight coefficient to give the trust updating model. Simulation experiment shows that the proposed method can effectively improve the reliability of trust chain evaluation in embedded trusted computing, which has good application value.	chain of trust;embedded system;trusted computing	Li Gang	2018	IJADS	10.1504/IJADS.2018.10008974	fuzzy logic;direct anonymous attestation;economics;chain of trust;fuzzy set;trusted computing;inference;transitive relation;distributed computing	ECom	-36.839796106375296	20.014257225885096	81897
b3e2308a096b7ff60a74481898f17d81f076efd3	formal specification and verification of task time constraints for real-time systems	verification;observer based model checking;formal specification;time property patterns;task;rts;mde;time petri net;time constraint	Model-Driven Engineering enables to assess a system’s model properties since the early phases of its lifecycle and to improve iteratively these models according to the verification results. Safety critical real-time systems have stringent requirements related to the specification and verification of system’s task-level time constraints. The common formal methods used to assess these properties for design models rely on a translation of the user models into formal verification languages like Time Petri Net and on the expression of the required properties using Timed LTL (Linear Temporal Logic)/CTL (Computation Tree Logic) or μ-calculus. However, these logics are mainly used to assess safety and liveness properties. Their capability for expressing time related properties is more limited and can lead to combinatorial state space explosion problems during model checking. In addition, they are mainly concerned with symbolic time event-level properties without quantitative time tolerance aspects. This contribution focuses on a formal specification and verification method for system’s task-level time constraints (including synchronization, coincidence, exclusion, precedence, sub-occurrence and causality) in both finite and infinite time scope. It proposes a method to translate task time constraints that cannot be assessed by common tools to verifiable time property specifications, which are composed of a set of verifiable time property patterns. These time property patterns are quantitative and independent of both the design modeling language and the verification language as soon as it provides timed elements, making the translation method reusable with different tools. Then, observer-based model checking for Time Petri Nets is used to verify these time property patterns. This contribution analyses the computational complexity and the method’s performance for the various patterns. This synchronization properties’ specification and verification methods have been integrated in a time property verification framework for UML-MARTE safety critical real-time systems.	causality;computation tree logic;computational complexity theory;formal methods;formal specification;formal verification;linear temporal logic;liveness;model checking;model-driven engineering;model-driven integration;modeling and analysis of real time and embedded systems;petri net;property dualism;real-time clock;real-time computing;real-time locating system;real-time operating system;real-time transcription;requirement;state space;structural pattern;system time;unified modeling language	Ning Ge;Marc Pantel;Xavier Crégut	2012		10.1007/978-3-642-34032-1_16	real-time computing;verification;formal methods;formal verification;computer science;formal specification;high-level verification;runtime verification;programming language;intelligent verification;algorithm;functional verification	SE	-42.79272515476998	30.71119506770968	82141
fdf8da6cad2e443280845663f2fd5211fa2d5316	multi-agent framework for remote diagnostics	automotive engineering;remote diagnostics;automobiles;multi agent system;multi agent framework;computer architecture;multi agent systems;intelligent agents;automotive vehicles;engines;monitoring;intelligent agents remote diagnostics multi agent framework automotive vehicles;batteries;intelligent agent;traffic engineering computing automobiles multi agent systems;traffic engineering computing;vehicles;vehicles engines computer architecture batteries monitoring multiagent systems automotive engineering;multiagent systems	A multi-agent framework to remote diagnostics with the emphasis on automotive vehicles is discussed. An overview of existing work on intelligent agents is given, and key features of the multi-agent framework are listed. Two real-world illustrations of the proposed multi-agent system are provided.	elegant degradation;intelligent agent;multi-agent system;particle swarm optimization;simulation	Danil V. Prokhorov	2010	IEEE Congress on Evolutionary Computation	10.1109/CEC.2010.5586043	embedded system;computer science;artificial intelligence;engine;multi-agent system	AI	-38.264459864407605	22.11044857841248	82502
1473f404ad2938de94e6d0ac46e2e5b1772c985c	programmable electronic system design & verification utilizing dfm	verification;developpement logiciel;software testing;concepcion sistema;logiciel a securite critique;system design;desarrollo logicial;security systems;safety critical software;software development;systeme securite;design verification;systeme electronique programmable;verificacion;software design;dynamic flowgraph methodology;conception systeme	The objective of this paper is to demonstrate the use of the Dynamic Flowgraph Methodology (DFM) during the design and verification of programmable electronic safety-related systems. The safety system consists of hardware as well as software. This paper explains and demonstrates the use of DFM to verify the hardware and application software design for safety issues. The outcome of the design verification is used to define the necessary diagnostic capabilities that are essential to guarantee the correct functioning of the safety system. The paper also demonstrates how DFM can be used as an application software test tool.	design for manufacturability	Michel Houtermans;George E. Apostolakis;Aarnout Brombacher;Dimitrios Karydas	2000		10.1007/3-540-40891-6_24	verification;software verification;engineering;software design;software development;software engineering;software testing;systems design	EDA	-42.112022309972666	27.267322651964665	82529
b029a76cac96a57f0eeffeebd8071b22d99a9b39	formal analysis of uml 2.0 activities using graph transformation systems	verification;activity diagram;graph transformation;agg;dynamic semantics;formal analysis	Graph transformation is a general visual modeling language which is suitable for stating the dynamic semantics of the designed models formally. We present a highly understandable yet precise approach to formally define the behavioral semantics of UML 2.0 Activity diagrams by using graph transformation. In our approach we take into account control flow and data flow semantics. Our proposed semantics is based on token-like semantics and traverse-to-completion. The main advantage of our approach is automated formal verification and analysis of UML Activities. We use AGG to design Activities and we use our previous approach to model checking graph transformation system. Hereby, designers can verify and analyze designed Activity diagrams. Since workflow modeling is one of the main application areas of the Activities, we use our proposed semantics for modeling and verification of workflows to illustrate our approach.	graph rewriting;unified modeling language	Vahid Rafe;Adel Torkaman Rahmani;Reza Rafeh	2010	International Journal of Software Engineering and Knowledge Engineering	10.1142/S0218194010004918	verification;activity diagram;computer science;theoretical computer science;formal semantics;database;programming language;operational semantics;denotational semantics	SE	-43.351210657019664	28.833228818403107	82530
c8200e4baf7771df79815274e99d20387b35aedd	safe rapid prototyping of object-oriented database applications	application functions;mosaico;formal specification;functional verification;software prototyping;application software;prototypes;user requirements safe rapid prototyping object oriented database applications mosaico integrated environment applications design formal specification correct specification conceptual schema application functions executable prototype conceptual model design language tql type and query language semantic verification functional verification fidelity;formal specifications;object oriented database applications;type and query language;bridges;conceptual model;fidelity;safe rapid prototyping;correct specification;process design;query languages;query languages software prototyping safety software reliability object oriented databases formal specification formal verification project support environments type theory;tql;conceptual schema;rapid prototyping;formal verification;design language;integrated environment;type theory;safety;project support environments;user requirements;humans;object oriented databases;object oriented database;executable prototype;applications design;semantic verification;software reliability;object oriented modeling;computer errors;prototypes object oriented databases application software object oriented modeling software prototyping formal specifications bridges process design humans computer errors	"""In this paper, we present Mosaico, an integrated environment conceived to support the design and specification of object-oriented database applications. Mosaico assists the designer in producing a formal and correct specification of the application domain in the form of a conceptual schema, a conceptual model of the application functions, and, finally, an executable prototype of the database application. The conceptual model ofthe database application is constructed by using the design language TQL++ (Type and Query Language+ +). The resultant TQL+ + specification is semantically verified based on the theory underlying TQL+ +. Furthermore, through rapid prototyping, the TQL++ specifi cation can be functionally verified. Semantic verification guarantees the correctness of the specification within the realm of the formal theory of the language. However, it does not guarantee the 'lfdelity"""" of the specification to the real world requirements (i.e.. what the users really wants). Rapid prototyping and functional Verification is a mean to bridge that gap."""	application domain;comparison of command shells;conceptual schema;correctness (computer science);executable;formal verification;prototype;query language;rapid prototyping;requirement;resultant	Michele Missikoff;M. Toiati	1994		10.1109/IWRSP.1994.315896	computer science;systems engineering;formal specification;database;programming language	DB	-47.55440902780285	28.104142533731487	82778
3c3793c58f61776a74f5ff3bd735131a56aa21bc	logic and compositional verification of hybrid systems - (invited tutorial)	discrete state-transitions;railway control system;systematic hybrid systems analysis;hybrid system;air traffic control;discrete dynamic;compositional verification;hybrid systems analysis study;continuous dynamic;hybrid systems verification tool;physical-chemical process control	Hybrid systems are models for complex physical systems and have become a widely used concept for understanding their behavior. Many applications are safety-critical, including car, railway, and air traffic control, robotics, physical-chemical process control, and biomedical devices. Hybrid systems analysis studies how we can build computerised controllers for physical systems which are guaranteed to meet their design goals. The continuous dynamics of hybrid systems can be modeled by differential equations, the discrete dynamics by a combination of discrete state-transitions and conditional execution. The discrete and continuous dynamics interact to form hybrid systems, which makes them quite challenging for verification. In this tutorial, we survey state-of-the-art verification techniques for hybrid systems. In particular, we focus on a coherent logical approach for systematic hybrid systems analysis. We survey theory, practice, and applications, and show how hybrid systems can be verified in the hybrid systems verification tool KeYmaera. KeYmaera has been used successfully to verify safety, reactivity, controllability, and liveness properties, including collision freedom in air traffic, car, and railway control systems. It has also been used to verify properties of electrical circuits.	coherence (physics);control system;formal verification;hybrid system;key;liveness;robotics	André Platzer	2011		10.1007/978-3-642-22110-1_4	real-time computing;simulation;computer science;algorithm;hybrid system	Logic	-38.29952279468704	31.329484401479824	82814
a35b715b76ad8f528ce0da15eaec2c00a5b03be3	a multiport diagram for batch system modeling. methodology and implementation	object oriented model;programming language;system modeling;behavior modeling;simulation;system identification;batch process;object modeling approach;physical model;modeling;model simulation;object oriented paradigm;object model	This article presents a new object-oriented model structure, entitled multiport diagram, which has been developed to deal with the hybrid nature of batch systems and the heterogeneity of knowledge (theoretical and experimental). The object-oriented paradigm of the multiport diagram is described by the Willem’s behavioral modeling formalism which brings a reliable and suitable mathematical framework, independent of any programming language. The proposed modeling procedure is based on object-modeling and system identification techniques. It is made up of five main steps : the hierarchical decomposition of the process into module classes, the modules modeling, their interconnection into a multiport diagram, its implementation into a simulation platform and its calibration. An application to a simple batch system is detailed throughout the paper to illustrate the elaboration of the multiport diagram. Its implementation has been supported by the physical modeling language Modelica c © and its simulation has been performed in the environments Dymola c © and Matlab c ©.	batch processing;behavioral modeling;diagram;dymola;evert willem beth;interconnection;matlab;modeling language;programming language;programming paradigm;requirement;semantics (computer science);simulation;software portability;system identification;systems modeling	T. Bastogne	2004	Simulation Modelling Practice and Theory	10.1016/j.simpat.2004.06.003	real-time computing;simulation;systems modeling;communication diagram;computer science;theoretical computer science;machine learning;class diagram;modeling language	EDA	-36.57400933680859	27.18741671013993	82952
1c0772991811e8918b7c328afc90129e5286d41d	managing incentives in social computing systems with pringl		Novel web-based socio-technical systems require incentives for efficient management and motivation of human workers taking part in complex collaborations. Incentive management techniques used in existing crowdsourcing platforms are not suitable for intellectuallychallenging tasks; platform-specific solutions prevent both workers from comparing working conditions across different platforms as well as platform owners from attracting skilled workers. In this paper we present PRINGL, a domain-specific language for programming complex incentive strategies. It promotes re-use of proven incentive logic and allows composing of complex incentives suitable for novel types of socio-technical systems. We illustrate its applicability and expressiveness and discuss its properties and limitations.	adaptive system;circuit complexity;crowdsourcing;domain-specific language;expressive power (computer science);platform-specific model;precondition;programming model;social computing;sociotechnical system;web application	Ognjen Scekic;Hong Linh Truong;Schahram Dustdar	2014		10.1007/978-3-319-11746-1_30	simulation;knowledge management;management science;world wide web	HCI	-44.930293392386204	20.247581151525953	83069
d3130236c7a03a94394acc6c832b6bcdc0798a0e	architecture and software implementation of a quantum computer model		This paper considers the principles of architecture models of quantum calculators. It describes the existing problems of construction and implementation of their work, as well as ways to overcome these problems. The distinction model of the relevant modules in its composition is achieved. Withdrawal functionality number of three parts modules, their graphics (interface) components, which are produced as a result of differentiation of the model into separate modules included in its composition. We describe the interface of the model and place it in the auxiliary modules and libraries.	numerical weather prediction	Victor Potapov;Sergei Gushansky;Vyacheslav Guzik;Maxim Polenov	2016		10.1007/978-3-319-33622-0_6	multilayered architecture;enterprise architecture framework;reference architecture;software architecture;space-based architecture;computer architecture;architecture tradeoff analysis method;computing;applications architecture;theoretical computer science;component-based software engineering;software development;software design description;software construction;hardware architecture;software architecture description;view model;resource-oriented architecture;systems architecture;software system;computer engineering	Arch	-33.83215958830581	28.044288310890607	83130
4af74e608ba93f3e6095e716cc47e62077b0cdd0	open technologies for monitoring systems aimed at disaster risk reduction	diy;disaster;flood;reduction;risk;oshw;istsos;foss;weather station	This research is spearheading the integration of Free and Open Source Software (FOSS) and Open Source Hardware (OSHW) in the field of agri-meteorology applications to disaster risk reduction, flood and droughts. A Do-It-Yourself weather station based on OSHW standards has been developed from local sources in Sri Lanka, reporting by SMS to tank/reservoir managers when rainfall is higher than 10mm/h. These weather stations are soon going to be reprogrammed to report to istSOS, a FOSS web-based Sensor-Observation-Service compliant system, which will collate live reporting of rainfall every hour and before if intensities are dimmed worrying for flood risks. This is both a scientific, technological, and practical challenge toward a very low cost real time disaster risk notification system in places where climate, economy and maintenance supports are themselves other challenges.	notification system;open-source hardware;open-source software;sensor observation service;web application	Massimiliano Cannata;Yann Chemin;Milan Petar Antonovic;Lahiru Wijesinghe;Vivien Deparday	2016	PeerJ PrePrints	10.7287/peerj.preprints.2132v1	disaster;simulation;reduction;risk;computer security	ML	-34.002507984280996	19.465479902251825	83153
3991132812949610038a43fee85f9b07e83760c7	on graphs in conceptual engineering design	engineering design;conceptual design;graph rewriting;background knowledge;use case;knowledge base	This paper deals with knowledge-based computer aided design. A novel method giving additional support for conceptual design is presented. In this method, a designer first specifies the functional requirements and the structure of the designed object based on use cases and function graphs. Then a prototype design is derived from these requirements. Subsequently, the designer checks the fulfilment of certain consistency rules and engineering norms by calling a constraint checker. This checker uses the background knowledge stored in graph structures and the reasoning mechanism provided by the graph rewriting system PROGRES. An example of designing a swimming pool illustrates the proposed methodology.	computer-aided design;engineering design process;functional requirement;graph rewriting;object-based language;pool (computer science);prototype	Janusz Szuba;Agnieszka Ozimek;Andy Schürr	2003		10.1007/978-3-540-25959-6_6	computer science;theoretical computer science;engineering drawing;algorithm;graph rewriting	EDA	-46.505729001745436	24.77592853030839	83492
03f2443958cbf4c3ff69ac95a1f7c7742bbab044	language integration for model formalization	verification;object petri net;object recognition;object oriented model;life cycle;uml2;biological system modeling;unified modeling language petri nets;semantics;delta modulation;verification uml2 object diagram sequence diagram object petri net;denotational semantic;servers;sequence diagram language integration model formalization denotational semantics state transition languages uml diagrams correctness object petri net models object diagram object signature;unified modeling language;object petri nets;object diagram;petri nets;sequence diagram;unified modeling language object oriented modeling servers semantics biological system modeling object recognition delta modulation;object oriented modeling;state transition	UML is often formalized by means of a denotational semantics based on state-transition languages. The obtained models are afterwards verified to prove the UML diagrams correctness. We propose, in this paper, an approach to initialize object Petri net models at any time of the system life cycle starting from UML diagrams. The OPNs marking regarding objects is mainly deduced from the sequence diagram. The object diagram is used to provide the object signature. A case study is given to illustrate the approach.	correctness (computer science);denotational semantics;item unique identification;object diagram;petri net;sequence diagram;state transition table;system lifecycle;uml state machine;unified modeling language	Thouraya Bouabana-Tebibel	2011	2011 IEEE International Conference on Information Reuse & Integration	10.1109/IRI.2011.6009576	sequence diagram;object diagram;natural language processing;unified modeling language;biological life cycle;delta modulation;verification;communication diagram;uml tool;computer science;theoretical computer science;applications of uml;cognitive neuroscience of visual object recognition;class diagram;semantics;programming language;petri net;server;object constraint language	Robotics	-44.84914996108616	27.60133488227906	83532
572a2b1222890e1210ea4123447c74a34e8a0e2c	precise semantics of emf model transformations by graph transformation	model transformation;graph transformation;model driven software development;eclipse modeling framework	Model transformation is one of the key activities in model-driven software development. An increasingly popular technology to define modeling languages is provided by the Eclipse Modeling Framework (EMF). Several EMF model transformation approaches have been developed, focusing on different transformation aspects. To validate model transformations wrt. functional behavior and correctness, a formal foundation is needed. In this paper, we define EMF model transformations as a special kind of typed graph transformations using node type inheritance. Containment constraints of EMF model transformations are translated to a special kind of EMF model transformation rules such that their application leads to consistent transformation results only. Thus, we identify a kind of EMF model transformations which behave like algebraic graph transformations. As a consequence, the rich theory of algebraic graph transformation can be applied to these EMF model transformations to show functional behavior and correctness. We illustrate our approach by selected refactorings of simplified statechart models.	code refactoring;correctness (computer science);eclipse modeling framework;graph rewriting;linear algebra;model transformation;model-driven engineering;model-driven integration;modeling language;software development;state diagram	Enrico Biermann;Claudia Ermel;Gabriele Taentzer	2008		10.1007/978-3-540-87875-9_4	computer science;theoretical computer science;algorithm;graph rewriting	PL	-45.12757064986551	27.064028751860008	83706
7bb6d8b12a45805df9c23600959cedc39e8ae564	autoabstract: problem statement and hypothetical solutions	automated code abstraction;program diagnostics;software tools finite state machines formal specification program diagnostics program testing reverse engineering;software tool;formal specification;state based specifications;reverse engineering automatic testing data mining information analysis performance evaluation computer science concrete proposals software testing;finite state machines;program testing;reverse engineered x machine;autoabstract project;test generation;software tools;reverse engineered x machine autoabstract project automated code abstraction state based specifications test generation software tool;reverse engineering;epsrc	Automated abstraction of code into state-based specification and test generation (AutoAbstract) is a project funded by EPSRC. The aim of the project is to devise methods and a tool to abstract out specifications from the code using some hints from the developer. These specifications will be in the form of X-machines. It is assumed that these hints are available in the form of incomplete specifications and are refined using reverse-engineered X-machines. Finally, a method will be developed to generate concrete test cases from the refined X-machines and the tool will be updated accordingly. The main theme of my PhD lies within the AutoAbstract project. This PhD extended abstract will contain the technical challenges involved in the project followed by the parts of the work involved in the project that are linked to my interests. The proposed solutions to these parts will also be discussed	reverse engineering;test case;x-machine	Shaukat Ali	2006	Testing: Academic & Industrial Conference - Practice And Research Techniques (TAIC PART'06)	10.1109/TAIC-PART.2006.4	reliability engineering;computer science;systems engineering;software engineering	SE	-46.537650786468376	29.788436592618137	83748
11542860ae27033f092b431799a843d9fec364c1	stochastic object-based graph grammars	object based graph grammar;stochastic automata networks;asynchronous system;model checking;graph grammar;stochastics automata network;state space;visual language;stochastic analysis;message passing;asynchronous distributed system;markov chain	Object-Based Graph Grammar (OBGG) is a formal visual language suited to th e specification of asynchronous distributed systems based on message passing. Model-checking of OBGG models is currently supported and a series of case studies have b een developed. However, in many situations one has to evaluate non-functional aspects like availability and performance of the system under consideration. In such cases, a stoch stic analysis of the system is desired. This paper is a first contribution to the stochastic analy sis of OBGG models. OBGG models with occurrence rates associated to rules are translate d to S ochastic Automata Networks (SAN). SAN is a Markov Chain equivalent formalism ha ving as advantage its modularity in terms of representation and a compact mathematical so lution, allowing the analysis of models with larger state space.	automaton;distributed computing;formal system;graph rewriting;markov chain;message passing;model checking;object-based language;state space;visual language	Odorico Machado Mendizabal;Fernando Luís Dotti;Leila Ribeiro	2007	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2007.03.020	asynchronous system;model checking;stochastic process;markov chain;message passing;computer science;state space;theoretical computer science;machine learning;stochastic grammar;programming language;algorithm	SE	-36.57377807738412	30.20255213353414	84093
a6af564ad1b9ecd2cdb52b977c29d2b04ab0eb74	ante: agreement negotiation in normative and trust-enabled environments	artigo em livro de atas de conferencia internacional;ciencias da computacao e da informacao	Research on negotiation and task allocation has been in the multi-agent systems realm since its inception as a research field. More recently, social aspects of agenthood have received increasing attention, namely developing on the fields of normative and trust systems. The integration of these different research contributions will allow to build robust applications for electronic agreement negotiation, aiming at their acceptability and application in industry. The ANTE1 framework is the corollary of an ongoing long-term research project that encompasses three main agreement technologies: negotiation [3], normative environments [1], and computational trust [5]. Although ANTE has been targeting the domain of B2B electronic contracting, it was conceived as a more general framework having in mind a wider range of applications. This paper describes a demonstration showing the application of the ANTE framework to an agent-based automatic electronic contracting domain.	agent-based model;computation;computational trust;multi-agent system;service-level agreement	Henrique Lopes Cardoso;Joana Urbano;Pedro Brandão;Ana Paula Rocha;Eugénio C. Oliveira	2012		10.1007/978-3-642-28786-2_33	psychology;public relations;management;social psychology	AI	-43.03812383470756	19.162581686011134	84218
43637227c7fb62fa2b54ee23835c22726286e772	incremental development of real-time requirements: the light control case study	incremental development;renemen t;780101 mathematical sciences;real time;embedded system;control system;requirement engineering;system development;formal specication;280302 software engineering;real time systems	System requirements frequently change while the system is still under development. Usually this means going back and revising the requirements specification and redoing those development steps already completed. In this article we show how formal requirements can be allowed to evolve while system development is in progress, without the need for costly redevelopment. This is done via a formalism which allows requirements engineering steps to be interleaved with formal development steps in a manageable way. The approach is demonstrated by a significant case study, the Light Control System.	control system;formal methods;formal system;real-time transcription;requirement;requirements engineering;software requirements specification;system requirements	Graeme Smith;Colin J. Fidge	2000	J. UCS	10.3217/jucs-006-07-0704	real-time computing;incremental build model;computer science;control system;software engineering;iterative and incremental development	SE	-43.539818842639825	30.83231283667876	84239
f48d39825d6ad773f4b1cb4ed2aeb527b12d73ce	modeling and analysis of multi-agent systems using petri nets	structure analysis;multi agent systems;petri nets;discrete event dynamic system;multi agent system;intelligent agent;petri net;indexing terms	The development of theoretical-based methods for the assessment of multi-agent systems properties is of critical importance. This work investigates methodologies for modeling, analysis and design of multi-agent systems. Multi-agent systems are regarded as discrete-event dynamic systems and Petri nets are used as a modeling tool to assess the structural properties of the multi-agent system. Our methodology consists of defining a simple multi-agent system based on the abstract architecture for intelligent agents. The abstract architecture is modeled using Petri nets and structural analysis of the net provides an assessment of the interaction properties of the multi-agent system. Deadlock avoidance in the multi-agent system is considered and it is evaluated using liveness and boundedness properties of the Petri net model.	deadlock;dynamical system;intelligent agent;liveness;multi-agent system;petri net;structural analysis	Jose R. Celaya;Alan A. Desrochers;Robert J. Graves	2009	JCP	10.4304/jcp.4.10.981-996	real-time computing;simulation;computer science;artificial intelligence;multi-agent system;distributed computing;process architecture;petri net	AI	-36.527283920235156	29.22471046704653	84326
1458fca82d24abf50858a15084b3d0d735a9c0cf	verification of hierarchical artifact systems	verification;temporal logic;business process management;data centric workflows	Data-driven workflows, of which IBM's Business Artifacts are a prime exponent, have been successfully deployed in practice, adopted in industrial standards, and have spawned a rich body of research in academia, focused primarily on static analysis. The present work represents a significant advance on the problem of artifact verification, by considering a much richer and more realistic model than in previous work, incorporating core elements of IBM's successful Guard-Stage-Milestone model. In particular, the model features task hierarchy, concurrency, and richer artifact data. It also allows database key and foreign key dependencies, as well as arithmetic constraints. The results show decidability of verification and establish its complexity, making use of novel techniques including a hierarchy of Vector Addition Systems and a variant of quantifier elimination tailored to our context.	concurrency (computer science);foreign key;quantifier (logic);static program analysis;vector addition system	Alin Deutsch;Yuliang Li;Victor Vianu	2016		10.1145/2902251.2902275	real-time computing;verification;temporal logic;computer science;business process management;data mining;database;programming language	DB	-41.88262210337311	31.330442814011732	84493
fe1b42bfef2e828ffc9cdc7d6019c48d4522c35f	formal methods for embedded systems co-design: the fordesign project.	embedded system;formal method		embedded system;formal methods	Luís Gomes;João Paulo Barros;Anikó Costa;Rui Pais;Filipe Moutinho	2005			embedded system;computer science	EDA	-45.87003723593699	30.817907843543484	84589
2e7e2f9013d3a8bb70a88834a3d32c95bf49f961	code generation for event-b	doctoralthesis;event b;modelling system by stepwise reﬁnement;reﬁnement calculus;informatics engineering specialty in software engineering;faculdade de ciencias exatas e da engenharia;jml;design by contract;designby contrac;eventb2java;java	Event-B is a modelling language and a formal methods approach for correct construction of software. This paper presents our work on code generation for Event-B, including the definition of a syntactic translation from Event-B to JML-annotated Java programs, the implementation of the translation as the EventB2Java tool, and two case studies on the use of EventB2Java. The first case study is on implementing an Android application with the aid of the EventB2Java tool, and the second on testing an Event-B specification of the Tokeneer security-critical system. Additionally, we have benchmarked our EventB2Java tool against two other Java code generators for Event-B.	b-method;code generation (compiler);critical system;formal methods;java modeling language	Victor Rivera;Néstor Cataño;Tim Wahls;Camilo Rueda	2015	International Journal on Software Tools for Technology Transfer	10.1007/s10009-015-0381-2	computer science;design by contract;software engineering;java modeling language;programming language;java;algorithm	SE	-44.820153229919235	30.454971401269518	84599
cfbd209719d91547bd24694e3eca25626ad4c189	capsule reviews		The paper concentrates on the implementation of the signal control logic using the so-called statecharts model where dynamic properties are verified through the states method. The paper illustrates how some physical traffic lights control systems can be described with statecharts and how various components needed to make up the control systems become more evident. For example, statecharts enable better description of hierarchies, concurrency and timing specifications. The traffic lights control systems discussed include the eight-phase, six-phase and two-phase traffic light systems. The paper represents and analyzes using statecharts, an urban traffic network controller where nine intersections are considered. Since it is hard to represent all concurrent states together, the paper proposes concurrent state graphs where all concurrent states are modeled in complex statecharts. The concurrent state graph generates 17 nodes where each node consists of 9 elements corresponding to the 9 intersections of the urban traffic network. The urban traffic lights controller is then implemented. Concurrent state graphs are a convenient method to simultaneously represent all concurrent states in a complex system.	complex system;concurrency (computer science);control system;network interface controller;two-phase commit protocol	Fairouz Kamareddine	2012	Comput. J.	10.1093/comjnl/bxs118		Embedded	-37.360870992791064	30.006064781090597	84735
51d393f5ea50ec1be2b9e9b299769871c4712682	negotiating agents: from full autonomy to dynamic degrees of delegation	autonomous agent;degrees of delegation;negotiation;artificial agents	The modularization of negotiating agents as proposed by the C-IPS approach provides a sound base for a concept that we call dynamic degrees of delegation. Agents following this concept enable their users at runtime to delegate particular subsets of decisions to their artificial agents. We extend our specification and implementation of fully autonomous agents to capture this concept. We have successfully implemented such a system for application in a sociological experiment.	autonomous agent;autonomous robot;autonomy;run time (program lifecycle phase)	Diemo Urbig;Kay Schröter	2005		10.1145/1082473.1082676	computer science;knowledge management;artificial intelligence;autonomous agent;distributed computing;computer security;negotiation	AI	-42.05182653128001	19.53923795061372	84757
1785e094666484327ef4bdb7b54defc21d29588b	third international workshop on graph and model transformations	graph transformations;model transformation;graph transformation;model driven development;model transformations;model driven software development	Model transformation is an emerging paradigm used in model-driven software development. Graph transformations deal with rewriting operations on graphs, and as such can serve as a foundation for constructing model transformation language, tools, and systems. This workshop, the 3rd in a series, investigates the connection between graph and model transformations and intends to bring together interested researchers and practitioners from the two fields.	graph (discrete mathematics);graph operations;graph rewriting;model transformation language;model-driven architecture;model-driven engineering;programming paradigm;software development	Gabor Karsai;Gabriele Taentzer	2008		10.1145/1370175.1370244	computer science;theoretical computer science;graph;algorithm;graph rewriting	SE	-45.40283817428109	27.06012871886899	84786
1884c3774501483b3544379e851ea56310e70ab7	evolutionary layout: preserving the mental map during the development of class models	class diagram;graph drawing;a priori knowledge;graph grammar;uml class diagrams;evolutionary algorithms;layout metrics	It is vital for any developer to keep track of changes during his project. Thus, it is common practice to take static snapshots of single class diagrams. But to preserve the mental map, the layout of a class diagrams sequence is necessary.Therefore, we present in this paper requirements to layout a sequence of class diagrams and an approach for a layout algorithm to fulfill them. Our main idea was to see a sequence of class diagrams as the evolution of one graph over time. We expressed the graph's evolution via a graph transformations sequence and enriched this with the concept of node aging. We extended also the well-known spring-embedder layout algorithm to layout single graphs from this new sequence with the concept of layout pattern to integrate a-priori-knowledge. The resulting algorithm has been integrated into the AGG-Tool, an environment for Attributed Graph Grammars, and produced good results on various class diagrams and general graph grammars.	algorithm;anti-grain geometry;class diagram;force-directed graph drawing;graph rewriting;mental mapping;requirement;whole earth 'lectronic link	Susanne Jucknath-John;Dennis Graf;Gabriele Taentzer	2006		10.1145/1148493.1148526	lattice graph;a priori and a posteriori;directed graph;null graph;graph property;computer science;clique-width;theoretical computer science;machine learning;evolutionary algorithm;class diagram;voltage graph;graph;moral graph;graph drawing;story-driven modeling;graph rewriting	SE	-44.79053847517303	26.416814285281735	84852
924675886c638e63a9e371bea557bb30a9951318	a requirements description language plsc for probabilistic branches and three-stage events	visual languages requirements description language plsc language live sequence chart probabilistic branches stage events chart elements probabilistic systems measure theory probability theory graphical presentation textual presentation message sequence chart;probabilistic three stage events;visual languages formal specification probability;probabilistic three stage events probabilistic systems plsc probabilistic branches;probabilistic systems;plsc;probabilistic logic markov processes animals syntactics random processes;probabilistic branches	The language of Live Sequence Chart (LSC), a multi-modal extension of MSC, introduces the distinction between mandatory and possible on the level of the whole chart and for the chart elements. While the LSC still extend the MSC qualitatively, when it comes to capturing the quantitative behaviors, the deficiency emerges. As for the probabilistic systems, i.e., systems that exhibit probabilistic aspects, probabilistic properties are considered as the most important requirements and need to be captured quantitatively. To address this, we propose a requirements description language called pLSC. Supported by the measure theory and the probability theory, the language pLSC describes the interactions quantitatively to suit the probabilistic systems from two dimensions of probabilistic branches and three-stage events. The paper introduces the graphical and textual presentation of the pLSC.	angular defect;behavior model;computer;executable;formal grammar;graphical user interface;interaction;modal logic;model checking;requirement;semantics (computer science);statistical model;stochastic process;system requirements;tracing (software)	Jinyu Kai;Huaikou Miao;Honghao Gao	2014	15th IEEE/ACIS International Conference on Software Engineering, Artificial Intelligence, Networking and Parallel/Distributed Computing (SNPD)	10.1109/SNPD.2014.6888714	natural language processing;probabilistic ctl;probabilistic relevance model;computer science;theoretical computer science;machine learning;database;probabilistic logic;probabilistic argumentation;algorithm;divergence-from-randomness model	SE	-36.591931430820125	30.294300626074932	85032
09382ac66eb5e5cfab75d31127e793c9dd435583	an approach for reverse engineering of relational databases	object oriented models;object oriented model;object oriented methods;formal specification;specifying software;software engineering formal specification object oriented methods relational databases;software maintenance;logic;natural languages;relational database;software engineering;design optimization;semantic understanding;research and development;reverse engineering relational databases object oriented modeling object oriented databases design optimization software maintenance research and development logic modems natural languages;application intent object oriented models reverse engineering relational databases natural language object modeling technique omt models specifying software semantic understanding;natural language;object modeling technique;omt models;application intent;modems;relational databases;object oriented databases;object oriented modeling;reverse engineering	A process for reverse engineering of relational databases is proposed. Object-oriented models provide a natural language for facilitating the re-engineering process. An object-oriented model can describe the existing software, the reverse-engineered semantic intent, and the forward-engineered new system. The Object Modeling Technique (OMT) notation for modeling data is adopted. Graphical OMT models are intuitive and provide a rigorous basis for specifying software. A more robust process than advanced in the literature is proposed. Guidelines for coping with design optimizations and unfortunate implementation decisions are provided. The process emphasizes analysis of candidate keys rather than primary keys. Three sources for information are incorporated: schema, observed patterns of data, and the semantic understanding of application intent. >	relational database management system;reverse engineering	William J. Premerlani;Michael R. Blaha	1993		10.1109/WCRE.1993.287769	relational database;computer science;systems engineering;software engineering;database;natural language;programming language	DB	-48.2400636962025	27.556806393702566	85049
69e39265d1537951dac99b323c2ed4e37503bc21	exploiting reusable organizations to reduce complexity in multiagent system design	multiagent organizations;multiagent system;cooperative robotics;conceptual framework;design methodologies;organization design	Organization-based Multiagent Systems are a promising way to develop complex multiagent systems. However, it is still difficult to create large multiagent organizations from scratch. Multiagent organizations created using current AOSE methodologies tend to produce ad-hoc designs that work well for small applications but are not easily reused. In this paper, we provide a conceptual framework for designing reusable multiagent organizations. It allows us to simplify multiagent organization designs and facilitate their reuse. We formalize the concepts required to design reusable organization-based multiagent services and show how we can compose those services to create larger, more complex multiagent systems. We demonstrate the validity of our approach by designing an application from the cooperative robotics field.	agent-based model;agent-oriented software engineering;hoc (programming language);multi-agent system;online and offline;plasma cleaning;robotics;separation of concerns;systems design;verification and validation	Walamitien H. Oyenan;Scott A. DeLoach;Gurdip Singh	2009		10.1007/978-3-642-19208-1_1	systems engineering;engineering;knowledge management;management science	AI	-43.128985342430745	22.228656148224935	85128
7f834c60214b0c1d903c7ba66433de599febf1c6	autonomic workflow management in agent-based structural health monitoring systems using graph theory	graph theory;workflow management;agent based;autonomous computing;software agents;structural health monitoring	This paper presents an approach towards autonomic workflow management within a distributed, agent-based structural health monitoring system. This monitoring system is currently being developed at the Institute of Computational Engineering. Its global aim is to support the involved human experts in monitoring safety-relevant civil infrastructures by an artificial organization of several cooperating software agents. For the purpose of managing the workflow, Graph Theory --suitable to mathematically represent discrete distributed systems --is utilized by self-controlling software agents. To this end, software agents are regarded as distributed, self-contained entities and capable of making independent decisions. However, by applying the Graph Theory, and in particular Petri Nets, for controlling software agents, the agents just carry out instructions of a “centralized planning capability” that provides workflow specifications but cannot act independently. Thus, a layered approach is outlined allowing benefits from both the independent agent nature and the advantages of centralized planning.	autonomic computing;graph theory	Kay Smarsly;Karlheinz Lehner;Dietrich Hartmann	2006			computer science;systems engineering;knowledge management;distributed computing;workflow management system;workflow engine;workflow technology	DB	-40.798105493584515	20.340005969283787	85607
fbddf851aabbfefae6e9901efe22e9e6fd723031	performance analysis using petri nets	discrete event dynamic system;discrete event system;markov model;performance analysis;petri net;manufacturing system	The purpose of this paper is to focus on the implementation issues associated with using Petri nets for the performance analysis of discrete event dynamic systems while demonstrating several applications in manufacturing systems. Practical modeling issues will be discussed and several applications will be presented that illustrate the advantages and limitations of this methodology. These issues lead to the definition of several research problems in Petri nets for performance analysis.	petri net;profiling (computer programming)	Alan A. Desrochers	1992	Journal of Intelligent and Robotic Systems	10.1007/BF00314698	real-time computing;simulation;stochastic petri net;discrete event dynamic system;computer science;machine learning;control theory;process architecture;markov model;petri net	Robotics	-36.44877356410354	29.20203518533365	85655
c2344b6c07e13b6d64dcf57ba5fd2fdba8d5699f	stepwise design of bpel web services compositions: an event_b refinement based approach	web service composition	Several web services compositions languages and standards are used to describe different applications available over the web. These languages are essen- tially syntactic ones, their descriptions remain informal and are based on graphical notations. They do not offer any guarantee that the described services achieve the goals they have been designed for. The objective of this paper is twofold. First, it fo- cusses on the formal description, modelling and validation of web services compo- sitions using the Event B method. Second, it suggest a refinement based method that encodes the BPEL models decompositions. Finally, we show that relevant proper- ties formalized as Event B properties can be proved. A tool encoding this approach is also available.		Idir Aït-Sadoune;Yamine Aït Ameur	2010		10.1007/978-3-642-13273-5_4	web modeling;computer science;data mining;database;programming language;world wide web	EDA	-45.91008378892912	25.629963834687388	85669
d5e74c7064b9b73a99988b8565ba48c61018f31b	model driven engineering for building automation, a research agenda	multi paradigm modelling;code generation model optimization model verification target platforms cbd causal block diagram statechart devs domain specific language discrete event system specification mde development process building automation applications research agenda model driven engineering;program verification;building automation;multi paradigm modelling building automation model driven engineering;dsl buildings automation computational modeling mathematical model hardware lighting;specification languages;building management systems;model driven engineering;discrete event systems;program compilers;specification languages building management systems discrete event systems program compilers program verification	This paper introduces a Model Driven Engineering (MDE) development process for building automation applications. Currently, those applications are often written for Programmable Logic Controllers (PLCs) in one of the supported modeling languages such as structured text, ladder diagrams and grafcets. The consequences of this approach are that (1) PLC experts are needed to develop the application, (2) it is difficult to verify the application's correctness and (3) when introducing other technologies such as embedded micro controllers, even more experts are needed. This paper proposes an MDE development process that addresses these problems. The use of a domain specific language eliminates the need for PLC experts, and developers can concentrate on the development of the building automation application. Models of the system or a transformation of those models to Discrete Event System Specification (DEVS), State chart, or Causal Block Diagram (CBD) formalisms can be used to verify, simulate and optimize the application based on user needs. In a last step, the code for the target platforms can be generated directly from the verified and optimized models.	automatic taxonomy construction;automation;causal filter;component-based software engineering;correctness (computer science);devs;domain-specific language;embedded system;logic programming;model-driven engineering;modeling language;programmable logic device;simulation;state diagram;structured text	Philip Luyckx;Peter Hellinckx;Hans Vangheluwe	2013	2013 Eighth International Conference on P2P, Parallel, Grid, Cloud and Internet Computing	10.1109/3PGCIC.2013.83	real-time computing;simulation;computer science;systems engineering	EDA	-43.29447670051673	32.237921399093786	85837
98fa766f758e114d9fe3d1f07d6420bc828025da	object-oriented simulation of systems with sophisticated control	agent applications;system dynamics;simulation;nested models;object oriented simulation;object oriented programming;object oriented;computer simulation	Object-oriented programming is a suitable technique for representation of concepts and so is convenient for description of (computer) simulation models, as the description can be near to that of simulated systems. Dynamics of simulated systems is often subject to complex control rules with their support being one or more elements belonging to the same system. The description of behaviour of such elements needs often objectoriented representation of concepts that are applied in the control. These concepts belong to a ‘world viewing’ that is ontologically quite different from that used in the description of the simulated system. An extreme case is a simulation of a system that contains a controlling element that itself applies simulation for anticipating future consequences of the element decision. This paper is dedicated to application of languages that are not only object oriented but also process oriented and block oriented. Some existing and prepared applications are presented too.	algol 60;academy;algorithm;compiler;complex systems;computer science;computer simulation;global optimization;information processing;international ergonomics association;mathematical optimization;pedagogical agent;programmer;programming language;silesian library;silva rerum;simula;simulation language;system programming;theory	Eugene Kindler;Ivan Krivý	2011	Int. J. General Systems	10.1080/03081079.2010.539975	computer simulation;simulation;computer science;theoretical computer science;distributed computing;object-oriented programming	HPC	-36.21827257363294	27.243671973205675	86164
ed900c39429b855a6176e8cb7a64d845e7fd6a6a	lightweight formal verification in real world, a case study		To security oriented large-scale projects, formal verification is widely used to assure the satisfaction of claimed security properties. Although complete formal verification and validation requires a great amount of time and resources, applying lightweight formal methods to partial specifications reduces the required efforts to a convenient amount, while can still uncover sensitive software design problems. This paper describes our experience of applying lightweight formal verification to the authentication system of webinos, a substantial cross-device software infrastructure developed in a large scale EU funded project. The paper details the approach, the properties analysed, the lessons learned and concludes with possible recommendations for practitioners and designers about how to use lightweight formal verification in real world projects.	authentication;formal methods;formal verification;software design;verification and validation	Andrea S. Atzeni;Tao Su;Teodoro Montanaro	2014		10.1007/978-3-319-07869-4_31	real-time computing;verification;simulation;formal methods;software verification;computer science;systems engineering;formal specification;database;runtime verification;functional verification	SE	-44.79039306113732	31.59597246626785	86182
17eb8c8465a53aaeb6f9a5d012a3d86b80de9325	integration of informal and formal development of object-oriented safety-critical software: a case study with the key system	industrial case study;formal specification;publikationer;konferensbidrag;object oriented;safety critical software;artiklar;rapporter	Abstract   The KeY system allows integrated informal and formal development of object oriented Java software. In this paper we report on a major industrial case study involving safety-critical software for computation of a particular kind of railway time table used by train drivers. Our case study includes formal specification of requirements on the analysis and the implementation level. Particular emphasis in our research is put on the challenge of how authoring and maintenance of formal specifications can be made easier. We demonstrate that the technique of  specification  patterns implemented in KeY for the language OCL yields significant improvements.		Richard Bubel;Reiner Hähnle	2003	Electr. Notes Theor. Comput. Sci.	10.1016/S1571-0661(04)80806-5	software requirements specification;formal methods;formal verification;computer science;formal specification;programming language;object-oriented programming	PL	-45.20865186750141	29.468504433989064	86218
dbe317a0324c3a6b6a1488dbe70f2b8180857157	formal specification and verification of the kernel functional unit of the osi session layer protocol and service using ccs	fault localization;debugging;formal specification;calculus of communicating systems;temporal logic;mutation analysis;critical slicing;kernel function;testing;satisfiability;formal method;faults;dynamic program slicing;formal reasoning;static program slicing;protocol specification;failures;process algebra;verification and validation;formal specification and verification;validation and verification	"""This paper describes an application of formal methods to protocol specification, validation and verification. Formal methods can be incorporated in protocol design and testing so that time and resources are saved on implementation, testing, and documentation. In this paper we show how formal methods can be used to write the control sequence, i.e. pseudo code, which can be formally tested using automated support. The formal specification serves as a blueprint for a correct implementation with desired properties.As a formal method we chose a process algebra called """"plain"""" Calculus of Communicating Systems (CCS). Our specific objectives were to: 1) build a CCS model of the Kernel Functional Unit of OSI session layer service: 2) obtain a session protocol specification through stepwise refinement of the service specification; and 3) verify that the protocol specification satisfies the service specification. We achieved all of our objectives. Verification and validation were accomplished by using the CCS's model checker, the Edinburgh Concurrency Workbench (CWB). We chose plain CCS because of itssuccinct, abstract, and modular specifications, strong mathematical foundation which allows for formal reasoning and proofs, and existence of the automated support tool which supports temporal logic. The motivation for this work is: 1) testing the limits of CCS's succinct notation; 2) combining CCS and temporal logic; and 3) using a model-checker on a real-life example."""	blueprint;calculus of communicating systems;communications protocol;documentation;execution unit;formal methods;formal specification;formal verification;kernel (operating system);model checking;osi model;process calculus;pseudocode;real life;refinement (computing);stepwise regression;temporal logic;top-down and bottom-up design;verification and validation;workbench	Milica Barjaktarovic;Shiu-Kai Chin;Kamal Jabbour	1996		10.1145/229000.226325	verification and validation;formal methods;formal verification;computer science;theoretical computer science;formal specification;database;programming language;language of temporal ordering specification	SE	-46.373402354976506	30.999668754339492	86309
2aa3c5eb2b298c3ee93f7602f6624745dddf0558	modelling and visualizing agent conversations	conversations;coloured petri net;multi agent system;conversation protocols;agent communication languages;agent communication language;petri nets;petri net;conversation monitoring and visualising	Although the notion of conversations has been discussed for some time as a way in which to provide an abstract representation of extended agent message exchange, there is still no consensus established concerning how to use these abstractions effectively. This paper describes a layered approach based on coloured Petri Nets that can be used for modelling complex, concurrent conversations among agents in a multi-agent system. The approach can be used both to define simple conversation protocols and to define more complex conversation protocols composed of a number of simpler conversations. With this method it is possible (a) to capture the concurrent characteristics of a conversation, (b) to capture the state of a conversation at runtime, and (c) to reuse conversation structures for the processing of multiple concurrent messages.	coloured petri net;defense in depth (computing);emoticon;multi-agent system;prototype;run time (program lifecycle phase)	Mariusz Nowostawski;Martin K. Purvis;Stephen Cranefield	2001		10.1145/375735.376297	natural language processing;computer science;artificial intelligence;multi-agent system;petri net	AI	-37.83959957736085	29.44988327288547	86407
835e8a91e8908334ffa61ca462b6c5e915c016a4	automatically testing interactive applications using extended task trees	software testing;automatic testing;test data generation;state machine;formal semantics;automatic generation;input output;interactive application;user behaviour;model based testing;user interaction	Abstract Task trees are common notations used to describe the interaction between a user and an interactive application. They contain valuable information about the expected user behaviour as well on the expected software reactions and, thus, they can be used to support model-based testing. In this paper, a method for automatically generating test data from task trees is introduced. The task tree notation is extended to support operational profile specification. The user behaviour is automatically extracted from such extended trees as a probabilistic finite input–output state machine, thanks to formal semantics defined for this purpose for the task tree operators. The resulting probabilistic machine can then be used to generate test data simulating the user behaviour. This simulation can be performed using Lutess, a testing environment developed for synchronous software. The translation of the user interaction model into a Lutess description is explained and experimental results are reported.	binary tree;hoc (programming language);human–computer interaction;model-based testing;semantics (computer science);test data generation	Laya Madani;Ioannis Parissis	2009	J. Log. Algebr. Program.	10.1016/j.jlap.2009.01.005	input/output;test data generation;model-based testing;computer science;theoretical computer science;formal semantics;database;software testing;finite-state machine;programming language;graphical user interface testing	Theory	-34.78468777930374	28.502723958554714	86489
e48413860b10a75dc31a5f2324608f446c29b7ec	modeling and analysis of multi-agent systems based on π-calculus	modelizacion;distributed system;commerce electronique;topology;multiagent system;electronic commerce;architecture systeme;systeme reparti;comercio electronico;formal specification;multi agent system;analisis sistema;securite;systeme critique;logiciel a securite critique;topologie;pi calculus;simultaneidad informatica;intelligence artificielle;sistema reactivo;topologia;dynamical system;specification formelle;modelisation;systeme dynamique;especificacion formal;concurrency;sistema repartido;critical system;concurrent systems;algebra proceso;pi calculo;pi calcul;safety critical software;safety;algebre processus;reactive system;systeme reactif;system analysis;deadlock;interbloqueo;artificial intelligence;arquitectura sistema;analyse systeme;inteligencia artificial;interblocage;sistema dinamico;system architecture;sistema multiagente;process algebra;seguridad;modeling;simultaneite informatique;electronic trade;systeme multiagent;modeling and analysis	Dynamic architecture of multi-agent systems (MAS) is very important for the critical systems. As the existing formal specifications cannot describe the dynamic architecture of MAS, while π-calculus is specially suited for the description and analysis of concurrent systems with dynamic or evolving topology, a formal approach using π-calculus is presented to describe MAS. π-calculus can describe the interactions among agents and permit their analysis for some key properties, e.g. deadlock, bisimilarity. By constructing a MAS model in electronic commerce, the modeling process using π-calculus are illustrated.	bisimulation;concurrency (computer science);critical systems thinking;deadlock;e-commerce;interaction;multi-agent system;π-calculus	Fenglei Liu;Zhenhua Yu;Yuanli Cai	2005		10.1007/11596448_60	e-commerce;process calculus;systems modeling;π-calculus;concurrency;reactive system;computer science;artificial intelligence;deadlock;dynamical system;multi-agent system;formal specification;system analysis;programming language;operations research;algorithm;systems architecture	AI	-39.13881638387481	25.11186539022246	86553
9f6a4caa8fea8ebbfcfc991783e6f60c9db704b0	a model-based approach for integrating third party systems with web applications	distributed application;developpement logiciel;modelizacion;distributed system;interfase usuario;legacy software;base donnee;systeme reparti;red www;user interface;service orientation;conceptual analysis;reseau web;database;service web;base dato;model based approach;web service;analisis conceptual;orientado servicio;modelisation;logiciel patrimonial;sistema repartido;internet;desarrollo logicial;logicial herencia;software development;party system;architecture basee modele;world wide web;interface utilisateur;oriente service;analyse conceptuelle;modeling;model driven architecture;servicio web;service oriented;arquitectura basada modelo	New Web applications are rapidly moving from stand-alone systems to distributed applications that need to interoperate with third party systems, such as external Web services or legacy applications. In most cases, this integration is not properly addressed by current Web Engineering proposals, that either achieve it only at one single level (user interface, process, code or data), or assume the existence of a central conceptual model, something which is not always true in a service-oriented scenario. This paper presents a model-based framework that provides concepts and mechanisms for facilitating the high-level integration of Web applications with third party systems, allowing the manipulation of the external entities of such systems as native elements of our models.	distributed computing;entity;high- and low-level;interoperability;service-oriented device architecture;user interface;web application;web engineering;web service	Nathalie Moreno;Antonio Vallecillo	2005		10.1007/11531371_57	web service;web modeling;the internet;simulation;systems modeling;computer science;software development;database;web engineering;user interface;law;world wide web;legacy system;mashup	Web+IR	-40.33917740386529	24.454227379222335	86559
e2cab0ed0cd75b037bf35cfbca054f4d1f5308c1	agent-oriented control in real-time computer games	agent based;agent oriented programming;real time computing;computer game	We introduce a new methodology that allows to apply techniques and methods from agent-oriented programming (AOP) to computer games. To this end, we introduce an underlying model based on agents, controllable entities, and an agents-entities-relation. Then we elaborate on a method how to steer several controllable entities through an environment with a single agent. Finally, we show how AOP can be used to implement several agents based on the method.	pc game;real-time transcription	Tristan M. Behrens	2009		10.1007/978-3-642-14843-9_17	simulation;computer science;artificial intelligence;distributed computing	Embedded	-38.22661491498101	29.05446472384303	86647
f1ec11743181dd2559adaa9c46ccdd24c94270cb	behavior composition optimization	behavior composition problem;automatic synthesis	The behavior composition problem involves the automatic synthesis of a controller that is able to “realize” (i.e., implement) a desired target behavior specification by suitably coordinating a set of already available behaviors. While the problem has been thoroughly studied, one open issue has resisted a principled solution: if the target specification is not fully realizable, is there a way to realize it “at best”? In this doctoral work, we look at quantitative and qualitative ways to address this question.	program optimization	Nitin Yadav	2013			simulation;computer science;artificial intelligence	AI	-37.75464060033428	27.977998260070013	86705
c308bdad8ff6d5ff11e2643cddd8c6b2616902d1	towards a programming language for services computing	semantic web service;distributed system;programming language;service orientation;data type;web service;semantic web services;object oriented programming languages;software development;object orientation;language design;programming languages	Services Computing is emerging as a new discipline. The acceptance of web services technology stems from the fact that services enable easy integration and interoperation of enterprise level distributed systems. However, currently software developers are forced to translate business level service requirements and encode them into programs using low level abstractions such as objects. We propose to introduce language constructs for Service Oriented Programming that would enable raising programming abstractions from objects to services.	apl;distributed computing;encode;interoperation;programming language;requirement;service-oriented programming;services computing;software developer;web service	Arun Kumar;D. Janaki Ram	2008		10.1145/1367497.1367702	service-oriented programming;web service;fourth-generation programming language;first-generation programming language;protocol;very high-level programming language;business process execution language;language primitive;programming domain;data type;reactive programming;computer science;component-based software engineering;software development;ws-policy;service-oriented architecture;database;programming paradigm;services computing;inductive programming;fifth-generation programming language;programming language theory;programming language;object-oriented programming;object-orientation;world wide web;second-generation programming language	PL	-47.228949608123145	19.305702036715378	86741
9b8f93e20c47ab240ef34274e9ff3a0940bc35a4	model refactorings as rule-based update transformations	developpement logiciel;model based reasoning;raisonnement base sur modele;sistema experto;mise a jour;lenguaje uml;rule based;transformacion;base connaissance;model transformation;langage modelisation unifie;actualizacion;desarrollo logicial;unified modelling language;software development;base conocimiento;transformation;systeme expert;updating;knowledge base;expert system	A model refactoring is a model transformation that preservers some behavioral properties of a model. Equally important, a model refactoring should only affect a previously chosen subset of the source model. In this paper, we discuss how to define and execute model refactorings as rule-based transformations. We also present an experimental tool to execute these transformations.	algorithm;archive;benchmark (computing);code refactoring;diagram;extrapolation;imperative programming;logic programming;maude system;meta-object facility;metamodeling;model transformation;object constraint language;open-source software;postcondition;precondition;programming language;python;rewriting;sms language;traceability;transformation language;unified modeling language;unique identifier;xml metadata interchange	Ivan Porres	2003		10.1007/978-3-540-45221-8_16	transformation;unified modeling language;knowledge base;computer science;artificial intelligence;software development;model-based reasoning;expert system;algorithm	SE	-41.90201097419913	25.109008264956053	86774
7770440424d4636021d6888ce720483ab23d342a	verification of web service flows with model-checking techniques	web services web and internet services concrete fault detection runtime search engines collaboration application software software systems yarn;software model checking;spin model checker web service flows verification model checking techniques software technology internet distributed collaborations publicly shared network resources software model checking technology web services flow language;web service;information services;software engineering;internet;model checking;information services internet software engineering	Web service is an emerging software technology to use remote services in the Internet. As it becomes pervasive, some “language” to describe Web service flows is needed to combine existing services flexibly. The flow essentially describes distributed collaborations and is not easy to write and verify, while the fault that the flow description may contain can only be detected at runtime. The faulty flow description is not desirable because a tremendous amount of publicly shared network resources are consumed. The verification of the Web service flow prior to its execution in the Internet is mandatory. This paper proposes to use the software model-checking technology for the verification of the Web service flow descriptions. For a concrete discussion, the paper adapts WSFL (Web Services Flow Language) as the language to describe the Web service flows, and uses the SPIN model-checker for the verification engine. The experiment shows that the software model-checking technology is usable as a basis for the verification of WSFL descriptions.	internet;model checking;pervasive informatics;promela;run time (program lifecycle phase);spin model checker;specification language;subject matter expert turing test;verification and validation;web services flow language;web service;world wide web	S. Nakajima	2002		10.1109/CW.2002.1180904	web service;model checking;web application security;verification and validation;web development;web application;web modeling;the internet;business process execution language;web mapping;web design;software verification;web standards;computer science;component-based software engineering;operating system;ws-policy;service-oriented architecture;software construction;web page;software as a service;database;distributed computing;ws-i basic profile;web 2.0;law;world wide web;universal description discovery and integration;information system	Security	-46.30935010807136	18.373564513516545	86896
7f1d89ee90f1ddb3e2eae82a3b8186dda5e7f54b	leadsto: a language and environment for analysis of dynamics by simulation	modeling and simulation;multi agent system	This paper presents the language and software environment LEADSTO that has been developed to model and simulate dynamic processes in terms of both qualitative and quantitative concepts. The LEADSTO language is a declarative order-sorted temporal language, extended with quantitative means. Dynamic processes can be modelled by specifying the direct temporal dependencies between state properties in successive states. Based on the LEADSTO language, a software environment was developed that performs simulations of LEADSTO specifications, generates simulation traces for further analysis, and constructs visual representations of traces. The approach proved its value in a number of research projects in different domains.	declarative programming;simulation;tracing (software)	Tibor Bosse;Catholijn M. Jonker;Lourens van der Meij;Jan Treur	2005		10.1007/11550648_15	declarative programming;computer science;artificial intelligence;dynamical system;multi-agent system;modeling and simulation;specification;algorithm	SE	-37.37942839800506	28.561787884161532	86991
35708b74958625c27b9012cd9d202b32329fa7f0	a method and tool for wide audience requirements elicitation and rapid prototyping for mobile systems	prototipificacion rapida;top down method;methode descendante;consumidor;iterative method;technical information;sobrecarga;project management;informatique mobile;markets;mercado;top down;consommateur;integration information;fourniture information;specification;conceptual analysis;sistema complejo;requirements elicitation;analisis conceptual;information delivery;metodo iterativo;entrega informacion;information integration;planificacion;rapid prototyping;construction system;systeme complexe;especificacion;complex system;consumer;methode iterative;metodo descendente;surcharge;execution environment;requirement engineering;marche;case tool;integracion informacion;gestion projet;sistema construccion;planning;information system;planification;analyse conceptuelle;informacion tecnica;mobile systems;mobile computing;overload;mobile application;systeme information;domain specificity;systeme construction;gestion proyecto;information system development;prototypage rapide;sistema informacion;information technique;product development	In recent years, consumer oriented information systems development has become increasingly important matter, as more and more complex information systems are targeted towards consumer markets. We argue that developing IS for non-organizational users creates new problems, which IS and requirement engineering (RE) community should attend to. First of all, the elicitation of requirements becomes more difficult as usually consumers do not explicitly know what they want, and it is difficult for them to express their ideas. To support different views of product development, project management and design, the method should present requirements in a ‘rich enough’ way to avoid overloading management, but in the same time giving designers the detailed information they need. Furthermore, to facilitate iterative requirements development the method should allow for rapid development of prototypes from designs. To support these goals we have constructed an enhanced requirements elicitation and mobile system construction method and its support environment within Metaedit+ Meta CASE tool. We based our method on Critical Success Chains (CSC) method, which supports top-down approach for planning, but also provides for wide participation of IS customers to get rich information. CSC aggregates the results of many individual interviews into meaningful graphical models of what is critically important about a potential system. In our work, CSC is extended with customer segmentation and lead user concepts from marketing. The high level results of CSC are turned into mobile applications running in Symbian platform by using a novel domain specific method that supports generation of executable environments from specifications.	computer-aided software engineering;executable;function overloading;graphical model;high-level programming language;information system;iterative method;metaedit+;mobile app;new product development;rapid prototyping;requirement;requirements elicitation;requirements engineering;software development process;symbian;top-down and bottom-up design	Matti Rossi;Tuure Tuunanen	2004		10.1007/978-3-540-30466-1_58	planning;project management;requirements management;simulation;consumer;computer science;information integration;requirements elicitation;top-down and bottom-up design;iterative method;mobile computing;management;specification;information system;new product development	HCI	-40.39641416565227	23.951734232072685	86999
c726834a89b5fc0ddb1ae1472d38ebe44009e15f	towards formal analysis of multi-paradigm model transformations	informatica movil;modelizacion;verification of transformations;patron conception;formal specification;informatique mobile;validacion;programming environment;reutilizacion;multi paradigm modeling;analisis forma;lenguaje visual;metodo formal;methode formelle;patron concepcion;model transformation;analisis automatico;modele multiple;reuse;formal method;specification formelle;modelisation;medio ambiente programacion;especificacion formal;automatic analysis;visual languages;metamodel;metamodele;object oriented;metamodelo;langage visuel;multimodel;codigo movil;design pattern;mobile code;analyse automatique;analysis patterns;architecture basee modele;oriente objet;validation;design patterns;pattern analysis;formal analysis;modelo multiple;mobile computing;modeling;orientado objeto;model driven architecture;code mobile;analyse forme;environnement programmation;reutilisation;arquitectura basada modelo	The Multi-Paradigm Modeling (MPM) approach of model-based development emphasizes the specification of a system by multiple models. We use transformations to automatically transform, integrate and synchronize models. Verification and validation of model transformations are fundamental issues: we need to express what a valid model is and how a valid model transformation may transform the models otherwise, we have to analyze each transformed model individually, which makes it difficult to automate the process of using models. We have formally analyzed various model transformations in several case studies and industrial projects. From this experience, we have distilled the frequently recurring techniques and solutions, referred to as Model Transformation Analysis (MTA) methods. These instances, similarly to design patterns in object-oriented programming, define special constructions as solutions for recurring problems that arise when one implements a model transformation. Moreover, MTA methods contain special techniques and language features that should be taken into account when one designs a model transformation framework or a model transformation language. We hope that MTA methods may be the basis of automated formal analysis techniques of model transformations. This paper contributes the concept and instances of MTA methods and provides a case study based on an industrial project of mobile application development. With this real-world example, we want to demonstrate the role and use of MTA methods. The case study is implemented in Visual Modeling and Transformation System (VMTS), which is a tool that realizes the MPM concept to provide a model and model transformation-based environment for software development.	material point method;mobile app;model transformation language;model-driven engineering;programming paradigm;software development;verification and validation;visual modeling	Márk Asztalos;István Madari;László Lengyel	2010	Simulation	10.1177/0037549709343545	metamodeling;software design pattern;systems modeling;computer science;artificial intelligence;formal specification;reuse;design pattern;programming language;object-oriented programming;mobile computing;algorithm	SE	-42.484935018929015	26.077576005259	87057
24a4abb3d7e82a1f1c9f277543dca8c812b4c540	multiagent ai implementation techniques: a new software engineering trend	modelizacion;multiagent system;adquisicion del conocimiento;tolerance aux pannes logiciel;fault tolerant;ingenierie connaissances;agent modeling;software systems;software fault tolerance;intelligence artificielle;ingenieria logiciel;acquisition connaissance;software engineering;modelisation;conceptual design;design and implementation;knowledge acquisition;genie logiciel;artificial intelligence;inteligencia artificial;ingenierie simultanee;ingenieria simultanea;software design;sistema multiagente;modeling;concurrent engineering;systeme multiagent;knowledge engineering	We present techniques for design and implementation of software systems with AI and concurrent S.E. techniques. The stages of conceptualization, design and implementation are defined by AI methods. Software systems are proposed to be designed through knowledge acquisition, specification, and multiagent implementations. Multi-agent implementations are proposed to facilitate a fault tolerant software design methodology, applying our recent research that has lead to fault tolerant AI systems. A particular approach to and an AI formulation of designing fault free and fault tolerant software is presented, which is based on the agent models of computation. Design with objects and a novel multi-kernel approach is presented. A system is defined by many communicating pairs of kernels, each defining a part of the system, as specified by object level knowledge acquisition. An overview to agent morphisms and algebras are presented and applied to the design.	agent-based model;conceptualization (information science);fault tolerance;fault-tolerant software;knowledge acquisition;model of computation;software design;software engineering;software system	Cyrus F. Nourani	1998		10.1007/3-540-64582-9_737	fault tolerance;systems modeling;computer science;artificial intelligence;software design;knowledge engineering;conceptual design;software fault tolerance;concurrent engineering;software system	AI	-38.775695454961514	24.527818905154724	87747
7a45ae14c29067c1cc4269052bdda8f997364740	integrating component tests to system tests	automatic generation;embedded system;test case generation;model checking;system integration;instrument development;black box testing	During the verification phase in component-oriented approaches to (embedded) system development component tests are generally followed by system tests, often using different testing specifications and environments. Thus, when integrating components in the overall system, the actual implementation platform may differ from the development platform, leading to a deviation in the component behavior. This raises the issue of testing the functionality of a component integrated in a larger system without the use of an – instrumented – development platform, allowing to perform glass-box-testing. We show how a test case of a component can be transformed into a black-box test case of the overall system, allowing to deduce the validity of the test case of the component from the validity of the test case of the system. To mechanize the transformation, we provide a formalization of test cases and their integration in component networks in WS1S, and apply the Mona model checker based on this formalization to automatically generate system test cases from component test cases.	black box;black-box testing;embedded system;model checking;system testing;test case;unit testing;white-box testing	Bernhard Schätz;Christian Pfaller	2010	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2009.12.040	model checking;real-time computing;white-box testing;computer science;test suite;system under test;programming language;test script;test case;test management approach;system integration	SE	-44.32921680714628	32.29554346649149	87938
003a68f76afc828cbc18cfbb626c7575b8754c91	using use cases in executable z	formal specification;concurrent constraint resolution use cases executable z informal method requirements specification formal notation black box test evaluation computation model;computer aided software engineering system testing unified modeling language humans concurrent computing computational modeling encoding instruments software engineering graphics;concurrent constraint;program testing;specification languages;program testing formal specification specification languages;use case;black box testing	Use Cases are a wide-spread informalmethod for specifying the requirements of a technical system in the early development phase. Z is a formalnotation which aims to support, beside others, the specification of early requirement s. In this paper, we develop a representation of Use Cases in Z and apply it to several examples. Our focus is on instrumenting the formalization for black-box test evaluation in Executable Z, a computation model and implementation for Z based on concurrent constraint resolution	black box;black-box testing;executable;instrumentation (computer programming);model of computation;requirement	Wolfgang Grieskamp;Markus Lepper	2000		10.1109/ICFEM.2000.873811	use case;b-method;software requirements specification;formal methods;specification language;white-box testing;computer science;z notation;software engineering;system requirements specification;formal specification;programming language;language of temporal ordering specification	SE	-45.982881868639964	31.15023589925399	87996
2fbc9872ac14c959fc35c01779cc3df21130b72f	semantic positioning - an innovative approach for providing location-based services based on the web of data	location based services;semantic positioning;linked data;mobile networks;restaurant recommender service semantic positioning location based services web of data geometric spatial data proactive lbs linking open data cloud lod cloud semantic features openmobilenetwork live crowd sourcing platform static mobile network topology dynamic mobile network topology positioning enabler semantic lbs services spatial geofences;network topology;semantics ieee 802 11 standards ontologies mobile communication network topology mobile computing accuracy;linked data location based services semantic positioning mobile networks network topology;mobile computing;cloud computing;mobile computing cloud computing	Conventional positioning approaches for Location-based Services (LBS) such as those provided by Google and Apple, are solely driven by geometric spatial data. Especially in proactive LBS scenarios, in which users are notified as soon as they reach a certain area, locations are mostly defined by geofences and do not incorporate any further information from the semantics of the location, such as the points of interest in the vicinity or more detailed information about the district the user is in. Leveraging LBS with the extensive pool of interconnected data in the Linking Open Data (LOD) Cloud will improve the LBS experience and will enable the development of sophisticated proactive services. In this paper, we present a Semantic Positioning Platform that enhances classic positioning methods by semantic features. This platform utilizes the OpenMobileNetwork, which is a Live Crowd sourcing Platform providing static as well as dynamic mobile network topology data based on the principles of Linked Data. It further uses the Positioning Enabler that enables persistent user background tracking and subscription to Semantic LBS Services. The Semantic Positioning approach allows LBS providers to locate users with respect to the semantics of their position instead of defining spatial geofences. As a proof-of-concept, a Restaurant Recommender Service is presented and its applicability is evaluated.	crowdsourcing;geo-fence;global positioning system;linked data;location-based service;network topology;point of interest;push technology;recommender system;social semantic web;world wide web	Abdulbaki Uzun;Mohamed Salem;Axel Küpper	2013	2013 IEEE Seventh International Conference on Semantic Computing	10.1109/ICSC.2013.53	semantic computing;cloud computing;computer science;location-based service;linked data;data mining;database;internet privacy;hybrid positioning system;mobile computing;world wide web;computer security;network topology	DB	-35.81959207959221	18.436663027260735	88006
a37087f742b719ae2713f3390cb3460eb7c23831	extending profiles with stereotypes for composite concepts	developpement logiciel;langage modelisation;tool support;lenguaje uml;langage modelisation unifie;metamodel;metamodele;modelling language;lenguaje modelizacion;metamodelo;desarrollo logicial;unified modelling language;software development;architecture basee modele;stereotype;software process modelling;mdd;language design;estereotipo;model driven architecture;sp metamodel;process modelling languages;arquitectura basada modelo	This paper proposes an extension of the UML 2.0 profiling mechanism. This extension facilitates a language designer to introduce composite concepts as separate conceptual and notational elements in a modelling language. Composite concepts are compositions of existing concepts. To facilitate the introduction of composite concepts, the notion of stereotype is extended. This extension defines how a composite concept can be specified and added to a language's metamodel, without modifying the existing metamodel. From the definition of the stereotype, rules can be derived for transforming a language element that represents a composite concept into a composition of language elements that represent the concepts that constitute the composite. Such a transformation facilitates tool developers to introduce tool support for composite concepts, e.g., by re-using existing tools that support the constituent concepts. To illustrate our ideas, example definitions of stereotypes and transformations for composite concepts are presented.	metamodeling;profile (uml);profiling (computer programming);stereotype (uml);unified modeling language;usability	Dick A. C. Quartel;Remco M. Dijkman;Marten van Sinderen	2005		10.1007/11557432_17	natural language processing;metamodeling;unified modeling language;computer science;systems engineering;engineering;artificial intelligence;software development;software engineering;stereotype;algorithm	DB	-46.087524728928535	25.56125057634095	88104
97f3cd6e37f557440cbe9a23e0d5b64eb71024fe	a road condition service based on a collaborative mobile sensing approach		Road pavement conditions influence the daily lives of both drivers and passengers. Anomalies in road pavement can cause discomfort, increase stress, cause mechanical failures in vehicles and compromise safety of road users. Detecting and surveying road condition/anomalies requires expensive and specially designed equipment and vehicles, that cost considerable amounts of money, and require specialized workers to operate them. As an alternative, an emergent sensing paradigm is being discussed as a promising mechanism for collecting large-scale real-world data. In this paper we describe our experience on the design, implementation and deployment of a cloud based road anomaly information management service, that combines Collaborative Mobile Sensing and data-mining approaches, to provide a practical solution for detecting, identifying and managing road anomaly information. Additionally, we identify technical challenges and propose guidelines that may help to improve this type of services and applications.	anomaly detection;cloud computing;data acquisition;data mining;data redundancy;emergence;heuristic;itil;information management;machine learning;mobile device;money;open-source software;programming paradigm;relevance;requirement;sensor;smartphone;software deployment;software system;technical standard;type of service;urban computing;user-generated content	João Soares;Nuno Silva;Vaibhav Shah;Helena Rodrigues	2018	2018 IEEE International Conference on Pervasive Computing and Communications Workshops (PerCom Workshops)	10.1109/PERCOMW.2018.8480346	distributed computing;information management;software deployment;risk analysis (engineering);cloud computing;computer science;data acquisition;designed equipment;compromise;data processing	Mobile	-34.24766599757184	19.4313732855323	88117
0d69388735306e1a3c1a6c07da321c737811d6c3	comas: a consensus multi-agent based system	multi agent system consensus group decision making;consensus multi agent based system;detectors;protocols;consensus;multi agent system;biological system modeling;agent communication comas consensus multi agent based system group decision making intelligent systems ontology;agent communication;ontologies artificial intelligence;computer architecture;support system;multi agent systems;computational modeling;comas;group decision support systems;agent based system;intelligent systems;intelligent system;ontologies;group decision making;ontologies artificial intelligence group decision support systems multi agent systems;ontologies computational modeling computer architecture biological system modeling intelligent systems protocols detectors;system architecture;ontology	In group decision making problems is common the necessity of achieving a consensus before making a decision. Many consensus reaching processes have been introduced in the literature but not many intelligent systems have finally been implemented to deal with such processes. In this contribution an initial prototype of a consensus support system supported on a multi-agent paradigm is presented, showing the system architecture (set of agents, behaviours and relationships) and a preliminary ontology to represent the problem knowledge and used for the agent communication.	agent-based model;multi-agent system;programming paradigm;prototype;systems architecture	Francisco Mata;Pedro J. Sánchez;Iván Palomares;Francisco J. Quesada;Luis Martínez-López	2010	2010 10th International Conference on Intelligent Systems Design and Applications	10.1109/ISDA.2010.5687223	communications protocol;detector;group decision-making;consensus;computer science;knowledge management;ontology;artificial intelligence;multi-agent system;data mining;uniform consensus;computational model	Robotics	-40.5486299916301	18.4656296729437	88427
142c2825db9b07dfb1270c8361dfd2da21f0fecd	trustworthy refactoring via decomposition and schemes: a complex case study		Widely used complex code refactoring tools lack a solid reasoning about the correctness of the transformations they implement, whilst interest in proven correct refactoring is ever increasing as only formal verification can provide true confidence in applying tool-automated refactoring to industrialscale code. By using our strategic rewriting based refactoring specification language, we present the decomposition of a complex transformation into smaller steps that can be expressed as instances of refactoring schemes, then we demonstrate the semi-automatic formal verification of the components based on a theoretical understanding of the semantics of the programming language. The extensible and verifiable refactoring definitions can be executed in our interpreter built on top of a static analyser framework.		Dániel Horpácsi;Judit Köszegi;Zoltán Horváth	2017		10.4204/EPTCS.253.8	theoretical computer science;real-time computing;extensibility;code refactoring;correctness;semantics;formal verification;interpreter;rewriting;specification language;computer science	PL	-43.19747798753492	29.059101956811833	88930
d24a1e0fb1daaf263ecf1949c8f853aa7011a216	using control-flow patterns for specifying business processes in cooperative environments	relational data;reference model;scientific workflow;process reference modeling;specification language;scientific workflows;process specification language;control flow;business process management;process algebra;petri net;business process;control flow patterns	The representation and execution of business processes have generated some important challenges in Computer Science. An important related concern is the choosing of the best formal foundation to specify processes behavior, mainly representing control-flow patterns in cooperative environments. The first contribution of this research is the complete definition of the Navigation Plan Definition Language (NPDL) as an alternative for business process managing in cooperative environments. The second contribution is a complete implementation of control-flow patterns using NPDL. These control-flow patterns have been proposed by Aalst's group. Our experience in applying suggestion of Aalst's group to use control-flow patterns as a basis for comparison among control-flow specification languages shows that this comparison method is feasible and the results are useful. The simplicity of NPDL representations shows the advantages of NPDL as a process specification language. NPDL uses a declarative specification (similar to process algebra) to describe the workflow and adds new operators to compensate for the limitations of process algebra and Petri nets. NPDL also increases the modeling flexibility by allowing the reuse of process expressions in relational data-base systems.	addressing mode;business process;computer science;control flow;database;discriminator;high-level programming language;petri net;plan 9 from bell labs;process specification language;process calculus	Kelly Rosa Braghetto;João Eduardo Ferreira;Calton Pu	2007		10.1145/1244002.1244270	process calculus;reference model;specification language;relational database;computer science;knowledge management;artifact-centric business process model;business process management;artificial intelligence;software engineering;process modeling;database;business process model and notation;business process;process mining;programming language;control flow;business process discovery;business process modeling;petri net;language of temporal ordering specification	DB	-44.47758429386527	25.85805790514153	89240
c809a09b4ea1fa6bdec3f623407bd3e050e9d592	model and heuristic technique for efficient verification of component-based software systems	deadlock state;livelock state;state space methods;reachable state;software systems large scale systems formal verification explosions power system modeling software design system recovery cognitive informatics state space methods computer science;livelock state component based software systems efficient verification heuristic technique model networking high computing power state explosion problem formal verification interleaved behaviors asynchronously sent actions state based properties deadlock state reachable state;component based systems;cognitive informatics;heuristic programming;software systems;compositional verification;object oriented programming;state based properties;component based software;component based software systems;high computing power;large scale;formal verification;system recovery;interleaved behaviors;heuristic technique;software reusability;networking;state explosion problem;model;explosions;asynchronously sent actions;computer science;state explosion;power system modeling;software design;efficient verification;large scale systems;software reusability formal verification heuristic programming object oriented programming	With the rapid growth of networking and high-computing power, the demand of larger and more complex software systems has increased dramatically. To deal with the complexity in designing large-scale complex software systems, the concept of component-based software design has gained popularity recently. However, in pursuing a component-based approach there are obstacles to be overcome. One of them is the state-explosion problem in the formal verification of large-scale component-based systems. In this paper, we introduce a modeling mechanism and a set of heuristic rules to facilitate the verification of component-based software systems. Our heuristic techniques are much weaker than current theories useful for the compositional verification. More significantly, our technique can eliminate the interleaved behaviors caused by asynchronously sending actions. Therefore, our technique provides a much more powerful means for the compositional verification of asynchronous processes. Our technique can efficiently analyze several state-based properties: deadlock, reachable, and livelock state. The experimental results show a significant improvement in the analysis of large-scale component-based systems.	heuristic;software system	Jeffrey J. P. Tsai;Eric Y. T. Juan	2002		10.1109/COGINF.2002.1039283	real-time computing;computer science;theoretical computer science;distributed computing;functional verification	SE	-42.596483391204316	31.456349387069015	89391
53804ed3ed8f419cf13d7761540f539b210d886a	formal requirements-based programming for complex systems	verification;formal requirements based programming;formal methods validation verification;computer languages;formal specification;information systems;formal models;formal model;hubble space telescope;formalism;program verification computers;system requirements;goddard space flight center;code generation;formal methods;natural language computers;natural languages;robotics;formal validation;computing complexity;hubble robotic servicing mission;orbital robotics;software engineering;formal method;computer programs;requirements;computer programming;applications programs computers;formal verification;general methods;aerospace computing;complex system;systems analysis;nasa goddard space flight center;natural language;aerospace robotics;java programming language;nasa computer science information systems natural languages orbital robotics space missions humans software engineering computer languages;space missions;complex systems;system development;validation;humans;mathematical tractability;computer science;program compilers;program compilers formal verification formal specification systems analysis large scale systems aerospace computing aerospace robotics;nasa;large scale systems;formal verification formal requirements based programming complex systems computing complexity system development formal models system requirements code generation mathematical tractability hubble robotic servicing mission nasa goddard space flight center formal validation	"""Computer science as a field has not yet produced a general method to mechanically transform complex computer system requirements into a provably equivalent implementation. Such a method would be one major step towards dealing with complexity in computing, yet it remains the elusive """"holy grail"""" of system development. Currently available tools and methods that start with a formal model of a system and mechanically produce a provably equivalent implementation are valuable but not sufficient. The """"gap"""" that such tools and methods leave unfilled is that the formal models cannot be proven to be equivalent to the system requirements as originated by the customer. For the classes of complex systems whose behavior can be described as a finite (but significant) set of scenarios, we offer a method for mechanically transforming requirements (expressed in restricted natural language, or appropriate graphical notations) into a provably equivalent formal model that can be used as the basis for code generation and other transformations. While other techniques are available, this method is unique in offering full mathematical tractability while using notations and techniques that are well known and well trusted. We illustrate the application of the method to an example procedure from the Hubble Robotic Servicing Mission currently under study and preliminary formulation at NASA Goddard Space Flight Center."""	code generation (compiler);complex systems;computer science;formal language;mathematical model;natural language;requirement;system requirements	James L. Rash;Michael G. Hinchey;Christopher A. Rouff;Denis Gracanin	2005	10th IEEE International Conference on Engineering of Complex Computer Systems (ICECCS'05)	10.1109/ICECCS.2005.47	complex systems;simulation;formal methods;computer science;systems engineering;engineering;artificial intelligence;operating system;software engineering;natural language;programming language;computer engineering	Robotics	-47.24163203883512	30.121519645937777	89422
3e6b907a0cd6b262d788e2957d4e6b0f6f0bd509	abstract state machine models for basic service-oriented architectures	service composition;formal model;telecommunication services service oriented architectures abstract state machines web services;abstract state machine;service orientation;probability density function;service management;service oriented architectures;web service;data mining;system on a chip;web services finite state machines petri nets process algebra software architecture;service model;service oriented architecture web services algebra engineering management petri nets concrete distributed computing computer networks ip networks electronic mail;software architecture;finite state machines;computational modeling;monitoring;web services abstract state machine models service oriented architectures service foundations service composition service management service monitoring service oriented engineering process algebras petri nets formal model esb style web rest like web ims based telecommunication services;abstract state machines;service oriented computing;web services;telecommunication services;petri nets;service oriented architecture;process algebra;petri net	Service-oriented computing research activities focus on service foundations, service composition, service management and monitoring, and service-oriented engineering. While the precise definition of service foundations including an appropriate general service model is still an open research issue, event and process algebras, Petri nets, and abstract state machines (ASMs) are commonly considered as suitable candidates for developing such a formal model. In this paper, we consider how a basic ASM-based service-oriented architecture (SOA) model can be refined in different ways to capture fundamental properties of the three most common SOA approaches: ESB-style Web, REST-like Web, and IMS-based telecommunication services.	abstract state machines;information management system (ims);mathematical model;open research;petri net;process calculus;refinement (computing);service composability principle;service-oriented architecture;service-oriented device architecture;service-oriented software engineering;system on a chip;world wide web	Markus Kirchberg	2008	2008 IEEE Asia-Pacific Services Computing Conference	10.1109/APSCC.2008.21	web service;computer science;service-oriented architecture;database;distributed computing;finite-state machine;law;petri net;abstract state machines	SE	-38.4357865866042	28.244125618751774	89580
b729238705293639ba4b199abdaafe909f643c38	a reference model for requirements engineering	requirements engineering reference model software engineering artifacts;formal specification;reference model;systems analysis;requirement engineering;reachability analysis formal specification systems analysis;reachability analysis;vocabulary software engineering power engineering and energy application software programming logic grounding control systems control system synthesis	The Reference Model of Gunter et al., 2000, provides a framework for describing and analyzing key software engineering artifacts and their properties. In this paper we propose a reification of this framework in which behaviour is explicitly trace-based. We find that this benefits the formalism in adding structure in ways which are meaningful and practical from an engineering viewpoint. In particular, we develop notions of points of introduction and reachability in the new framework, and show how they strengthen the properties of the Reference Model.	reachability;reference model;reification (knowledge representation);requirements engineering;semantics (computer science);software engineering	Jon G. Hall;Lucia Rapanotti	2003		10.1109/ICRE.2003.1232749	domain analysis;systems analysis;requirements analysis;reference model;formal methods;information engineering;search-based software engineering;computer science;systems engineering;engineering;function model;software development;requirement;feature-oriented domain analysis;software engineering;formal specification;functional specification;requirements engineering;programming language;functional requirement;software requirements	SE	-48.11636211293852	28.289508092565544	89661
53fde0d5690475707df3060470fbc786ca36b338	decm, a user oriented formalism for high level discrete event specifications of real-time systems	control systems;formal specification;discrete event dynamic system;production system;formal specifications;control system;levels of abstraction;mathematical model;production systems;discrete event dynamic systems;discrete event;real time systems	In this paper, we present DECM (Discrete Event Calculus Model), an original discrete event mathematical model for the specification of control systems at a high level of abstraction. Because the concept of event is more natural for nonspecialists than the concept of state, the proposed model is centered on the latter concept. This in turn permits the expression of asynchronous behavior without relying on the classical concept of state. In addition, DECM-based formalism offers an explicit representation of time that allows the use of timed simulations for the validation of formal specifications. This formalism is illustrated on a real-world industrial example.	real-time operating system;real-time transcription;semantics (computer science)	Jean-Luc Paillet;Norbert Giambiasi	2002	Journal of Intelligent and Robotic Systems	10.1023/A:1015548507922	discrete mathematics;real-time computing;discrete event dynamic system;computer science;control system;artificial intelligence;theoretical computer science;discrete system;formal specification;control theory;production system	Robotics	-36.691042580037106	29.662926158673674	89834
4e43cbf9449311e7b140b3ab4a513a934a357020	formalizing and integrating the dynamic model for object-oriented modeling	analytical models;algebraic specification;algebraic specifications;object oriented programming algebraic specification specification languages formal specification;consistency checks;functional models;object oriented model;formal specification;concurrent computing;formal model;object oriented modeling formal specifications unified modeling language specification languages analytical models software engineering graphical models iso standards concurrent computing;iso standards;behavior simulation;dynamic model;formal specifications;graphical notation;object oriented programming;development process;software engineering;specification language;graphical models;consistency checks dynamic model object oriented modeling object modeling technique object oriented development functional models object model algebraic specifications specification language lotos graphical notation behavior simulation;object oriented;specification languages;object modeling technique;model integration;unified modeling language;consistency checking;functional model;system development;design;object oriented development;behavior;object oriented modeling;lotos;object model;requirements analysis	The Object Modeling Technique (OMT), a commonly used object-oriented development technique, comprises the object, dynamic, and functional models to provide three complementary views that graphically describe different aspects of systems. The lack of a well-defined semantics for the integration of the three models hinders the overall development process, particularly during the design phase. Previously, we formalized the object model in terms of algebraic specifications. However, the algebraic specifications only capture the static, structural aspects of a system. They do not explicitly describe the behavior, which is critical for system development especially for the design phase. It is necessary to formalize the dynamic model in terms of the structural descriptions in order to specify and verify the system behavior using rigorous techniques. This paper presents a well-defined formal model for both the object and dynamic models and their integration. The formal model is described in terms of a well-known specification language, LOTOS. Formalization of the graphical notation enables numerous automated processing and analysis tasks, such as behavior simulation and consistency checks between levels of specifications.		Betty H. C. Cheng;Enoch Y. Wang	2002	IEEE Trans. Software Eng.	10.1109/TSE.2002.1027798	concurrent computing;computer science;systems engineering;theoretical computer science;formal specification;programming language;object-oriented programming	SE	-47.86635871112711	27.868631890166068	89866
de7d247dd53b1893f8d008c79ecc41190b5fecb6	exploration games for uml software design	thesis or dissertation;uml;state machines;games;software design	The Unified Modeling Language (UML) has become the standard language for the design of object-oriented software systems over the past decade. Even though there exist various tools which claim to support design with UML, their functionality is usually focused on drawing UML diagrams and generating code from the UML model. The task of choosing a suitable design which fulfils the requirements still has to be accomplished by the human designer alone. The aim of this thesis is to develop concepts for UML design tools which assist the modeller in improving the system design and requirements incrementally. For this approach a variant of formal games called exploration games is introduced as underlying technique. Exploration games can be defined on the basis of incomplete and imprecise UML models as they occur frequently in practice. The designer repeatedly plays an exploration game to detect flaws or incompleteness in the design and its specification, which are both incorporated in the game definition. At any time the game definition can be incremented by the modeller which allows him to react to the discoveries made during a play and experiment with new design solutions. Exploration games can be applied to UML in different variants. For each variant must be specified how the UML diagrams are used to set up the game and how the semantic variation points of UML should be interpreted. Furthermore some parts of the game definition may not be contained in the UML model and have to be provided separately. The emphasis of this thesis is on game variants which make use of UML diagrams for modelling system behaviour, especially state machines and activity diagrams. A prototypical implementation demonstrates how the concepts developed in this thesis can be put into practice. The tool supports the user in defining, playing and incrementing a game. Moreover it can compute winning strategies for the players and may act as opponent of the modeller. As example a game variant based on UML state machines has been implemented. The architecture that has been chosen for the tool leaves room for extension by additional game variants and alternative algorithms.	activity diagram;algorithm;existential quantification;modeller;open world;requirement;software design;software system;systems design;uml state machine;uml tool;unified modeling language	Jennifer Tenzer	2006			simulation;uml state machine;uml tool;computer science;systems engineering;software engineering;applications of uml;software construction;diagramming software	SE	-46.32618201862269	28.577783430452403	90103
17f5297dc3d315521f29d3248ab68a6e1e719526	comparison of three model transformation languages	atlas transformation language;transformation model;model transformation;graph transformation;graph grammar;abstract syntax;target language	In this paper we compare three model transformation languages: 1) Concrete syntax-based graph transformation (CGT) which is our emerging model transformation language, 2) Attributed Graph Grammar (AGG) representing traditional graph transformation, and 3) Atlas Transformation Language (ATL) representing model transformation. Our case study is a fairly complicated refactoring of UML activity models. The case study shows that CGT rules are more concise and requires considerably less effort from the modeler, than with AGG and ATL. With AGG and ATL, the transformation modeler needs access to and knowledge of the metamodel and the representation in the abstract syntax. In CGT rules on the other hand, the transformation modeler can concentrate on the familiar concrete syntax of the source and target languages.	atlas transformation language;abstract syntax;anti-grain geometry;attributed graph grammar;code refactoring;compiler;graph rewriting;metamodeling;model transformation language;parse tree;unified modeling language	Roy Grønmo;Birger Møller-Pedersen;Gøran K. Olsen	2009		10.1007/978-3-642-02674-4_2	natural language processing;computer science;linguistics;programming language	NLP	-47.55104952030335	25.95742274168597	90108
72577b875efe90ef204213c5d17f619c4eb00a61	applying sdl to formal analysis of security systems	developpement logiciel;offre service;security properties;communication system;formal specification;protocole transmission;securite;systeme critique;logiciel a securite critique;metodo formal;methode formelle;sistema complejo;specification language;observador;sistema reactivo;formal method;specification formelle;especificacion formal;protocolo transmision;observateur;lenguaje descripcion;message sequence chart;critical system;systeme complexe;complex system;criptografia;desarrollo logicial;cryptography;safety critical software;software development;safety;secure system;reactive system;systeme reactif;communication protocol;cryptographie;lenguaje especificacion;formal analysis;seguridad;proposals;observer;langage specification;diagramme sequence message;langage description;description language;transmission protocol	Nowadays, it is widely accepted that critical systems have to be formally analyzed to achieve well-known benefits of formal methods. To study the security of communication systems, we have developed a methodology for the application of the formal analysis techniques commonly used in communication protocols to the analysis of cryptographic ones. In particular, we have extended the design and analysis phases with security properties. Our proposal uses a specification notation based on MSC, which can be automatically translated into a generic SDL specification. This SDL system can then be used for the analysis of the desired security properties, by using an observer process schema. Apart from our main goal of providing a notation for describing the formal specification of security systems, our proposal also brings additional benefits, such as the study of the possible attacks to the system, and the possibility of reusing the specifications produced to describe and analyze more complex systems.	application programming interface;complex systems;cryptography;distributed computing;embedded system;exception handling;formal methods;formal specification;functional design;interoperability;pattern language;rational tau;refinement (computing);rework (electronics);simple directmedia layer	Javier López;Juan J. Ortega;José M. Troya	2003		10.1007/3-540-45075-0_18	complex systems;formal methods;specification language;reactive system;computer science;cryptography;software development;formal specification;programming language;computer security;observer;message sequence chart;algorithm	Security	-40.16162174804935	25.797136833464613	90542
084c3c3b41c5d57bca88442b82b1acb9357edc06	cellular automata for distributed computing: models of agent interaction and their implications	agent interaction;multi agent system;distributed processing;distributed computing;agent communication;configuration space;large scale;multi agent systems;large scale systems multi agent systems cellular automata distributed processing;parallel threshold ca cellular automata distributed computing agent interaction large scale multiagent system autonomous reactive agent interagent communication sequential ca asynchronous ca;distributed computing large scale systems multiagent systems mathematical model automata artificial intelligence open systems laboratories computer science;cellular automata;large scale systems	"""We propose cellular automata (CA) based models as a useful mathematical idealization for modeling large-scale distributed computing in general, and large-scale multi-agent systems (MAS), in particular. The classical CA need to be modified in several important respects, in order to become an appropriate abstraction for a broad class of large-scale MAS made of autonomous reactive agents. We argue that thus generalized CA can capture many important MAS properties at the level of agent ensembles and their long-term global behavior patterns. In this paper, we focus on the issue of inter-agent communication in CA. We propose sequential CA as the first step towards the genuinely asynchronous CA as the ultimate CA-based abstraction for MAS insofar as the model of inter-agent communication is concerned. We then compare and contrast certain configuration space properties of simple threshold sequential CA with the corresponding properties of parallel, perfectly synchronous simple threshold CA. Specifically, we show that the possibility of """"looping"""" in parallel threshold CA is solely due to the unrealistic assumption of perfect inter-agent communication synchrony."""	automata theory;autonomous robot;cellular automaton;complex system;distributed artificial intelligence;distributed computing;global serializability;inter-process communication;mathematical model;multi-agent system;network automaton;parallel computing	Predrag T. Tosic	2005	2005 IEEE International Conference on Systems, Man and Cybernetics	10.1109/ICSMC.2005.1571639	configuration space;computer science;artificial intelligence;theoretical computer science;multi-agent system;distributed computing	Robotics	-40.1582573589689	20.64545584671614	90568
22f3ddca1eeb76136bb5eaecbf0f276daa8dda41	an object-oriented approach to formally analyze the uml 2.0 activity partitions	computacion informatica;uml 2 0;temporal logic;grupo de excelencia;model checking;object oriented;ciencias basicas y experimentales;activity partitions;object oriented approach;object petri nets;object diagram;object oriented analysis and design;petri net;sequence diagram	Nowadays, UML is the de-facto standard for object-oriented analysis and design. Unfortunately, the deficiency of its dynamic semantics limits the possibility of early specification analysis. UML 2.0 comes to precise and complete this semantics but it remains informal and still lacks tools for automatic validation. The main purpose of this study is to automate the formal validation, according a value-oriented approach, of the behavior of systems expressed in UML. The marriage of Petri nets with temporal logics seems a suitable formalism for translating and then validating UML state-based models. The contributions of the paper are threefold. We first, consider how UML 2.0 activity partitions can be transformed into Object Petri Nets to formalize the object dynamics, in an object-oriented context. Second, we develop an approach based on the object and sequence diagram information to initialize the derived Petri nets in terms of objects and events. Finally, to thoroughly verify if the UML model meets the system required properties, we suggest to use the OCL invariants exploiting their association end constructs. The verification is performed on a predicate/transition net explored by model checking. A case study is given to illustrate this methodology throughout the paper.	unified modeling language	Thouraya Bouabana-Tebibel;Mounira Belmesk	2007	Information & Software Technology	10.1016/j.infsof.2006.10.007	sequence diagram;object diagram;object-oriented analysis and design;model checking;temporal logic;uml tool;computer science;systems engineering;software engineering;applications of uml;database;programming language;object-oriented programming;petri net;algorithm;object constraint language	SE	-43.89312337399895	28.122504398786894	90889
1a270394d9421abbcd4a56c2ff41bf3a6ce2308a	design and implementation of b2bi collaboration workflow tool based on j2ee	gestion integrada;modelizacion;gestion integree;gestion entreprise;groupware;legacy software;modele entreprise;execution time;corporate strategy;componente logicial;surveillance;xml language;real time;processus metier;real time monitoring;firm management;integrated management;composant logiciel;langage java;modelo empresa;business process model;modelisation;business model;logiciel patrimonial;vigilancia;monitoring;design and implementation;real function;execution environment;logicial herencia;temps reel;fonction reelle;software component;tiempo real;workflow;proceso oficio;temps execution;administracion empresa;lenguaje java;monitorage;tiempo ejecucion;monitoreo;legacy system;collecticiel;modeling;funcion real;langage xml;lenguaje xml;business process;modeling tool;java language	In this paper, the business process was easily modeled by distin-guishing between the business process and work logic. Based on this model, B2Bi collaboration Workflow modeling tool, which facilitates collaboration, was designed and implemented. The collaboration workflow modeling tool consists of 3 components; business process modeling tool, execution engine and monitoring tool. First, a business process modeling tool is used to build a process map that reflects the business logic of an application in a quick and accurate manner. Second, an execution engine provides a real-time execution environment for business process instance. Third, a monitoring tool provides a real-time monitoring function for the business process that is in operation at the time. In addition to this, it supports flexibility and expandability based on XML and J2EE for the linkage with the legacy system that was used previously, and suggests a solution for a new corporate strategy and operation.		Chang-Mog Lee	2006		10.1007/11751632_109	real-time computing;business domain;computer science;artifact-centric business process model;business process management;operating system;process modeling;database;business process model and notation;process management;business process;event-driven process chain;process mining;business process discovery;business rule;business process modeling;legacy system;workflow engine;business activity monitoring;strategic management	EDA	-41.2630834645763	24.021168265637744	90908
06e10c43429e2d1a2c4245debb73f6ebb9b62a65	incremental symbolic conformance testing from uml marte sequence diagrams: railway use case	railways;timing constraints;unified modeling language object oriented programming railways;testing unified modeling language component architectures connectors delay;uml marte sequence diagrams;model transformation;object oriented programming;symbolic execution;conformance testing;unitary test cases incremental symbolic conformance testing uml marte sequence diagrams component based systems data information flows abstract manner system requirements top down approach incremental testing framework timing constraints;unified modeling language;conformance testing uml marte sequence diagrams timing constraints model transformation symbolic execution	When component-based systems are large and complex, one faces systems of systems, where interactions are mostly data-information flows. Examples include transport systems. A major issue in the production of such systems is the so-called emergent behaviors. These behaviors are more likely to appear within a bottom-up approach, where components are first produced and then gathered together to form the targeted system. The alternative approach is a top-down one: the system is specified as a whole in an abstract manner, and then individual components are built in away that their assemblage satisfies the system requirements. Therefore, by construction, emergence is better mastered because the system behaviors are specified a priori. In the scope of a top-down approach, we present an incremental testing framework, where the system requirements, involving timing constraints, are specified operationally as UML MARTE sequence diagrams. We use symbolic techniques to analyze the requirements and deduce unitary test cases for components integrating the system. We apply our approach on a railway use case.	bottom-up proteomics;component-based software engineering;conformance testing;correctness (computer science);digital footprint;emergence;entity;interaction;modeling and analysis of real time and embedded systems;papyrus;partial order reduction;plug-in (computing);requirement;sequence diagram;symbolic execution;system of systems;system requirements;test case;top-down and bottom-up design;unified modeling language	Boutheina Bannour;Christophe Gaston;Arnault Lapitre;Jose Pablo Escobedo	2012	2012 IEEE 14th International Symposium on High-Assurance Systems Engineering	10.1109/HASE.2012.18	reliability engineering;unified modeling language;real-time computing;computer science;systems engineering;applications of uml;conformance testing;programming language;object-oriented programming	SE	-42.032792685421384	29.792370937257733	91085
9d959c503b611f150b11681ca6972480830602f7	extending gaia with agent design and iterative development	complex system;agent based system	Agent-oriented methodologies are an important means for constructing agent-based systems in a controlled repeatable form. However, agent-oriented methodologies have not received much acceptance in industrial environments, which can be partially explained by drawbacks in current agent-oriented methodologies, mainly in terms of applicability and comprehensiveness. Specifically, Gaia, one of the most cited methodologies, does not consider agent design, nor exhibits an iterative methodological process. On the other hand, Gaia is based on organisational abstractions (which makes it suitable to cope with the design of complex systems) and possesses a simple methodological process whose neutrality makes it suitable for extensions. In this paper, we extend Gaia in two directions: we incorporate an agent design phase, and we enhance the methodological process with the use of iterations.	agent architecture;agent-based model;architectural pattern;complex systems;entity;executable;gaia hypothesis;ingenias;iteration;iterative and incremental development;iterative method;legacy system;modeling language;multi-agent system;object-based language;parallel computing;requirement;subsumption architecture;world-system	Jorge Gonzalez-Palacios;Michael Luck	2007		10.1007/978-3-540-79488-2_2	simulation;systems engineering;engineering;management science	AI	-42.91445157094269	21.835820341102117	91452
0305e46a66bb5550569c009b40d3576e05425e9b	onto2mas: an ontology-based framework for automatic multi-agent system generation	generators;prototypes;multi agent systems;capability maturity model;unified modeling language;ontologies;programming	Multi-Agent Systems (MASs) have received muchattention in recent years because of their advantages on modelingcomplex distributed systems. Current modeling languages andmethodologies that support the construction of such systemsrequire the use of different tools to complete their design, development, and deployment. However, the development of MASsremains a complicated task, which demands time and specialprogramming skills. This paper proposes a framework, calledOnto2MAS, to provide developers an automatic generation ofMASs, based on an ontology to assist the easy definition of agentsinteraction and knowledge. With Onto2MAS, the complexityof the development process of MASs is reduced and an easyway to design uniform communication, messages exchanging, and generation of new knowledge in the system is provided. Todemonstrate the efficiency of our approach, we also present theresults of the experimental tests that we conducted with a firstimplementation of Onto2MAS, called OnToJade.	apache jena semantic web framework;complex systems;distributed computing;jade;modeling language;multi-agent system;open-source software;requirement;software deployment;system generation	Corentin Donzelli;Solomon Asres Kidanu;Richard Chbeir;Yudith Cardinale	2016	2016 12th International Conference on Signal-Image Technology & Internet-Based Systems (SITIS)	10.1109/SITIS.2016.67	unified modeling language;programming;simulation;computer science;ontology;artificial intelligence;operating system;machine learning;multi-agent system;data mining;database;prototype;capability maturity model	Robotics	-43.02424852847925	22.5020839859122	91614
97de09e54df40b3420acb7764f579c48e37ee9ad	a framework for managing the solution life cycle of event-driven pervasive applications	distributed system;ciclo desarrollo;systeme reparti;calculateur embarque;identificacion por radiofrecuencia;logistique;life cycle;componente logicial;reutilizacion;pervasive computing;gestion evenement;component composition;composant logiciel;identification par radiofrequence;reuse;sistema reactivo;informatica difusa;sistema repartido;logistics;informatique diffuse;event management;logiciel libre;boarded computer;software component;cycle developpement;reactive system;systeme reactif;radio frequency identification;software libre;supply chain;gestion aconticimiento;reusable component;software reuse;calculador embarque;reutilisation;open source software;logistica;open source	Event-driven, embedded applications that embody the composition of many disparate components are emerging as an important class of pervasive applications. For such applications, realizing solutions often requires a breadth of expertise. Consequently, managing the solution life cycle can be a very complex, time-intensive process. In this paper, we present a framework that eases the complexity of managing the life cycle of event-driven, pervasive solutions. We call this framework Rapid Integrated Solution Enablement or RISE. Component composition and software reuse are two central concepts of RISE, where solutions are graphically composed from reusable components using a visual editor. We describe the RISE architecture and discuss an initial prototype implementation that leverages open source technologies, such as Eclipse. Additionally, we illustrate the e cacy of RISE with an example solution for RFID supply chain logistics.	code reuse;eclipse;embedded system;event-driven architecture;event-driven finite-state machine;event-driven programming;logistics;open-source software;pervasive informatics;prototype;radio-frequency identification;visual editor	Johnathan M. Reason;Han Chen;ChangWoo Jung;Sunwoo Lee;Danny C. Wong;Andrew Kim;SooYeon Kim;JiHye Rhim;Paul B. Chou;KangYoon Lee	2006		10.1007/11802167_49	radio-frequency identification;logistics;embedded system;biological life cycle;simulation;reactive system;computer science;component-based software engineering;operating system;reuse;supply chain;ubiquitous computing	HCI	-39.74960782529099	24.37724363585777	91832
ea0f43e7f19288c5e25bec1f57f20219c8d8f1e6	refinement based modeling of workflow applications using uml activity diagrams	graph theory;workflow applications;specification;diagrams;unified modeling language diagrams graph theory large scale systems;refinement uml ad;unified modeling language educational institutions subscriptions abstracts buildings software conferences;unified modeling language;design patterns;process refinement graphs workflow applications uml activity diagrams stepwise refinement technique complex systems refinement based modelling approach formal support;proof;design patterns progressive development workflow applications refinement uml ad specification proof;large scale systems;progressive development	Specifying a complex system, such as workflow applications, is a difficult task, which can not be done in one step. The stepwise refinement technique. facilitates the understanding of complex systems by dealing with the major issues before getting involved in the details. This papers presents a refinement based modelling approach of workflow Applications using UML Activity Diagrams. The proposed approach allows an incrementally developing more and more detailed models, preserving correctness in each step. We provide formal support for building process refinement graphs that are completely proved correct. We illustrate, as well, the proposed technique through an example of workflow application specified by our developed tool supporting the approach. This tool assists the developer in the task of refinement steps.	activity diagram;complex system;complex systems;correctness (computer science);refinement (computing);stepwise regression;top-down and bottom-up design;uml state machine;unified modeling language	Ahlem Ben Younes;Yousra Bendaly Hlaoui;Leila Jemni Ben Ayed;Rahma Jlassi	2013	2013 IEEE 37th Annual Computer Software and Applications Conference Workshops	10.1109/COMPSACW.2013.57	unified modeling language;software design pattern;uml tool;computer science;systems engineering;graph theory;diagram;theoretical computer science;applications of uml;proof;database;refinement;programming language;specification;workflow management system;workflow technology	Visualization	-46.61509919012007	28.15669879520778	91845
d83a6643581212824c635f1cd319853a3adeca00	co-transformation of graphs and type graphs with application to model co-evolution	graph transformation;model migration;meta model evolution	Meta-modeling has become the key technology to define do– main-specific modeling languages in model-driven engineering. Since do– main-specific modeling languages often change quite frequently, concepts are needed for the coordinated evolution of their meta-models as well as of their models, and possibly other related artifacts. In this paper, we present a new approach to the co-transformation of graphs and type graphs and show how it can be applied to model co-evolution. This means that models are specified as graphs while model relations, especially type-instance relations, are defined by graph morphisms specifying type conformance of models to their meta-models. Hence, meta-model evolution and accompanying model migrations are formally defined by co-transformations of instance and type graphs. In our approach, we clarify the type conformance of co-transformations, the completeness of instance graph transformations wrt. their type graph modifications, and the reflection of type graph transformations by instance graph transformations. Finally, we discuss strategies for automatically deducing instance graph transformation rules from given type graph transformations.	conformance testing;eclipse;evolution;graph (discrete mathematics);graph rewriting;hartmut neven;metamodeling;metaobject;model-driven architecture;model-driven engineering;modeling language;run time (program lifecycle phase);type inference;type system	Gabriele Taentzer;Florian Mantz;Yngve Lamo	2012		10.1007/978-3-642-33654-6_22	lattice graph;combinatorics;discrete mathematics;universal graph;null model;graph product;null graph;graph property;computer science;clique-width;forbidden graph characterization;comparability graph;mathematics;voltage graph;graph;modular decomposition;programming language;partial k-tree;graph operations;algorithm;graph rewriting	PL	-44.85061068259278	26.748638628431863	91943
6c8b79b4ae0aa459372a22fb210938e1a0536b96	an abstract gfsm model for optimal and incremental conformance testing of web services	incremental development;protocols;formal specification;black box service implementation;contracts;testing;gfsm;graph traversal;web service;data mining;guarded finite state machine;formal method;optimal conformance testing;guarded finite state machine optimal conformance testing incremental conformance testing web services black box service implementation chinese postman traversal algorithm minimum cost test sequences protocol specification gfsm;finite state machines;conformance testing;minimum cost test sequences;web service conformance testing;incremental conformance testing;chinese postman traversal algorithm;data dependence;web services;protocol specification;testing web services contracts protocols observability subscriptions information management scalability availability formal specifications;graph traversal web service conformance testing guarded finite state machine;finite state machine;web services conformance testing finite state machines formal specification;data models	Web service conformance testing checks the correctness of a black box service implementation, and it is the basis of other testings. An efficient formal method for conformance testing is the Chinese Postman traversal algorithm [2] that can find minimum-cost test sequences.However, the applicability of this algorithm is in question if data dependences are present in the protocol specification. Also, it suffers from the limited observability problem which is not uncommon in web services. Despite its optimality, the traversal algorithm does not take advantages of the special patterns in web service interfaces observed by developers. To address these issues, we propose an abstract GFSM (Guarded Finite-State Machine) model that unifies and augments the commonly used Moore and Mealy machines with dataflows. Using this abstract model, we formalize the conditions under which the tours with complete data and control coverage are guaranteed, and address the limited observability problem using the equivalence of Moore and Mealy machines. Furthermore, we propose a Recursive Descent traversal algorithm that explores the inverse operation pattern of web services to facilitate incremental development of web services.	black box;conformance testing;correctness (computer science);dijkstra's algorithm;finite-state machine;formal methods;iterative and incremental development;mealy machine;prototype;recursion (computer science);recursive descent parser;repeatability;route inspection problem;tree traversal;turing completeness;web service	Li Li;Wu Chou	2009	2009 IEEE International Conference on Web Services	10.1109/ICWS.2009.97	web service;real-time computing;computer science;operating system;database;distributed computing;finite-state machine;programming language;law	SE	-40.73233484790742	27.345388698725262	92030
f5ab325cd0b6ce60a097eb2fd3980fc2532d7cdc	static analysis with paragraph vector for malware detection	k nearest neighbor algorithm;machine learning;malware;paragraph vector;support vector machine;static analysis	Malware damages computers and the threat is a serious problem. Malware can be detected by pattern matching method or dynamic heuristic method. However, it is difficult to detect all new malware subspecies perfectly by existing methods. In this paper, we propose a new method which automatically detects new malware subspecies by static analysis of execution files and machine learning. The method can distinguish malware from benignware and it can also classify malware subspecies into malware families. We combine static analysis of execution files with machine learning classifier and natural language processing by machine learning. Information of DLL Import, assembly code and hexdump are acquired by static analysis of execution files of malware and benignware to create feature vectors. Paragraph vectors of information by static analysis of execution files are created by machine learning of PV-DBOW model for natural language processing. Support vector machine and classifier of k-nearest neighbor algorithm are used in our method, and the classifier learns paragraph vectors of information by static analysis. Unknown execution files are classified into malware or benignware by pre-learned SVM. Moreover, malware subspecies are also classified into malware families by pre-learned k-nearest. We evaluate the accuracy of the classification by experiments. We think that new malware subspecies can be effectively detected by our method without existing methods for malware analysis such as generic method and dynamic heuristic method.	assembly language;computer;experiment;feature vector;heuristic;hex dump;k-nearest neighbors algorithm;machine learning;malware analysis;natural language processing;pattern matching;static program analysis;support vector machine	Yuta Nagano;Ryuya Uda	2017		10.1145/3022227.3022306	support vector machine;computer science;machine learning;data mining;malware;world wide web;static analysis	ML	-35.14490942692978	23.127050044582585	92046
e852f3fa213879c536894bb095e2254d046283e8	modeling agents and agent systems	basic property;different name;present agent definition;basic consensus;existing model;formal definition;different approach;multiagent system;core model;agent system	In present agent definitions, we often find different names and definitions for similar concepts. Many works on multiagent systems use abstract and informal descriptions to introduce the topic. Even books on multiagent systems often lack a formal definition or use a selfcontained formalism. Our goal is to present a universal and formal description for agent systems that can be used as a core model with other existing models as special cases. This core model allows clear specification of agent systems and their properties. Design decisions are made explicitly and, by that, become a mean of comparison for different approaches. The proposed definitions for single- and multiagent systems address all basic properties while leaving space for extensions and can thus be used to talk about concepts using a homogeneous notation. The comparisons of our definition to existing models show that the most-cited descriptions can be expressed with our formalism which shows that there is a basic consensus on fundamental properties of agent systems.		Theodor Lettmann;Michael Baumann;Markus Eberling;Thomas Kemmerich	2011	Trans. Computational Collective Intelligence	10.1007/978-3-642-24016-4_9	computer science;knowledge management;artificial intelligence;management science	ECom	-41.98137659810805	21.746398948886455	92361
9d037c5b155aa00ae2c5ef6f54f1ca4b521b0be5	a brief history of computing	software quality;brief history;cmmi software process improvement;key discipline;fundamental area;concise manner;key topic;helpful pedagogical element;comprehensive book;casual reader;computer science student;latest key development;software process improvement;chapter summary;broad-ranging text;computer science;computing field;software engineering	ion Abstraction simplifies complexity by modelling classes and removing all unnecessary detail. All essential detail is represented, and non-essential information is ignored Polymorphism Polymorphism is behaviour that varies depending on the class in which the behaviour is invoked. Two or more classes may react differently to the same message. The same name is given to methods in different subclasses, i.e. one interface and multiple methods 9.4 Object-Oriented Languages 133		Gerard O'Regan	2012		10.1007/978-1-4471-2359-0	computer science;artificial intelligence;algorithm	AI	-47.51572707254114	24.548895048964546	92482
8172a730329729968b8001ea27e1a79f7ca759d5	a domain-specific metamodel for multimedia processing systems	tratamiento datos;modelizacion;graphic method;traitement signal;system engineering;entrada salida;ciclo desarrollo;asynchronous event driven controls;object oriented methods;formal specification;multimedia;life cycle;graphical language;media signal processing;validacion;gestion evenement;systems engineering;data processing;traitement donnee;flux donnee;flujo datos;object oriented programming;data engineering;classification;conceptual framework;multimedia systems;systems engineering and theory;sistema reactivo;process design;media content;input output;modelisation;object oriented programming configuration management data flow computing formal specification multimedia systems;graphical models;visual languages;metamodel;methode graphique;metamodele;object oriented;metamodelo;langage visuel;signal processing;event management;homogeneous interface;visual language;ingenierie systeme;metaobjet;cycle developpement;reactive system;dataflow networks domain specific metamodel multimedia processing systems object oriented programming system engineering data objects media content synchronous data processing asynchronous event driven controls configuration mechanism life cycle state model homogeneous interface media signal processing;systeme reactif;graphical model;metodo grafico;architecture basee modele;oriente objet;data flow computing;validation;metaobjeto;multimedia processing systems;life cycle state model;graph model;gestion aconticimiento;signal processing algorithms;data flow;metamodeling;visual languages dataflow graphs modeling multimedia systems object oriented methods systems engineering;procesamiento senal;modeling;orientado objeto;configuration management;clasificacion;data objects;model driven architecture;reflection;dataflow graphs;object oriented modeling;synchronous data processing;domain specificity;lenguaje grafico;langage graphique;object oriented paradigm;dataflow networks;arquitectura basada modelo;entree sortie;domain specific metamodel	In this paper, we introduce 4MPS, a metamodel for multimedia processing systems. The goal of 4MPS is to offer a generic system metamodel that can be instantiated to describe any multimedia processing design. The metamodel combines the advantages of the object-oriented paradigm and metamodeling techniques with system engineering principles and graphical models of computation. 4MPS is based on the classification of multimedia processing objects into two main categories: Processing objects that operate on data and controls, and Data objects that passively hold media content. Processing objects encapsulate a method or algorithm. They also include support for synchronous data processing and asynchronous event-driven Controls as well as a configuration mechanism and an explicit life cycle state model. Data input to and output from Processing objects is done through Ports. Data objects offer a homogeneous interface to media data, and support for metaobject-like facilities such as reflection and serialization. The metamodel can be expressed in the language of graphical models of computation such as the Dataflow Networks and presents a comprehensive conceptual framework for media signal processing applications. 4MPS has its practical validation in several existing environments, including the author's CLAM framework.	algorithm;complex systems;computer port (hardware);dataflow;domain-specific language;event-driven finite-state machine;executable;experiment;goto;graphical model;metamodeling;metaobject;model of computation;programming paradigm;reflection (computer programming);requirement;scheduling (computing);semantics (computer science);serialization;signal processing;software development;systems engineering;systems modeling;visual language;vocabulary;way to go	Xavier Amatriain	2007	IEEE Transactions on Multimedia	10.1109/TMM.2007.902885	metamodeling;real-time computing;data processing;computer science;theoretical computer science;operating system;signal processing;graphical model;programming language;object-oriented programming;algorithm	DB	-39.324070550699176	26.487741701125213	92810
562ff25f2d0d552884772b79f461f937ce6bdeb9	a framework for enforceable specification of extended transaction models and transaction workflows	model specification;recoverability;successions;transaction dependencies;breakpoints;workflows;transaction model specification;serializability;extended transactions	A variety of extensions to the traditional (ACID) transaction model have resulted in a plethora of extended transaction models (ETMs). Many of these ETMs are application-specific , i.e., they are designed to provide correctness guarantees adequate for a particular application, but not others. Similarly, an application-specific ETM may impose restrictions that are unacceptable in one application, yet required in another. To define new ETMs, to determine whether an ETM is appropriate for an application, and to integrate ETMs to produce new ETMs, we need a framework for ETM specification and reasoning. In this paper, we describe such a framework. Our framework supports implementation-independent specification of ETMs described in terms of dependencies between transactions. Dependencies are specified using dependency descriptors . Unlike other transaction specification frameworks, dependency descriptors use a common set of primitives, and areenforceable, i.e., can be evaluated at any time during transaction execution to determine whether issued operations violate ETM specifications. We discuss specifications of (i) structure dependencies between transaction states, and (ii) correctness dependencies for serializability, various cooperative and temporal correctness criteria, and recoverability. We give ETM specification examples for a telecommunications application illustrating the definition of a new application-specific ETM using our framework.	acid;autonomous robot;breakpoint;correctness (computer science);dependency grammar;nested transaction;requirement;scheduling (computing);serializability;software system;throughput;transaction processing	Dimitrios Georgakopoulos;Mark F. Hornick	1994	Int. J. Cooperative Inf. Syst.	10.1142/S0218215794000144	workflow;real-time computing;distributed transaction;computer science;data mining;database;breakpoint;serializability;specification	DB	-40.59378861638617	28.54955608300375	92871
8af91eca6868baad3adfc0386e81ba29610c22e9	open systems design using agent interactions		As software requirements grow increasingly complex, the need to connect to and re-use existing, tested software, grows with it. Open systems, such as the Internet, aid this process by connecting together software services provided by a range of organisations, and the distributed nature of the system allows the services to be regularly updated and improved. Applications can be deployed within the open systems that opportunistically attempt to make use of the best functionality available at any one time. Agent-based systems have been proposed as an ideal way to implement such applications, due to their flexibility and distributed control. However, a balance must be kept between acting opportunistically and ensuring that each application operates to the standards demanded by the application requirements. Determining whether an application will perform to its requirements necessitates justifying the design decisions made in creating it. Our goal is to provide application developers with the means to create justified designs for opportunistic applications. The main contribution of this thesis is a software engineering methodology, agent interaction analysis, based on a set of independently valuable techniques we have developed. The first of these is a novel approach to modelling applications as being instantiated by a set of agent interactions, allowing such applications to be described with minimal restrictions on their implemented structure. Second, we provide a technique, based on design patterns, for comparing mechanisms for instantiating parts of multi-agent system. Finally, we provide an approach to more detailed analysis and comparison of coordination mechanisms.	interaction;open system (systems theory);systems design	Simon Miles	2004			simulation;systems engineering;engineering;operations management	HCI	-42.8749831851548	20.57673668668606	92962
fe92448251d29e990f12789d968b6ee6a9ba0052	rule-mitigated collaboration technology	electronic meeting system;protocols;groupware;synchronous asynchronous;collaborative work;collaboration collaborative work iris computer networks space technology humans rail to rail outputs application software computer architecture multimedia databases;client server architecture;selected works;application software;asynchronous collaboration;m net synchronous meeting environment;collaboration;rro;client server systems;application program interface;object oriented programming;computer networks;object oriented programming application program interfaces groupware protocols client server systems;computer architecture;rail to rail outputs;application program interfaces;multimedia databases;formal meeting protocol;electronic meeting systems;application programming interfaces;rule mitigated collaboration technology;bepress;cscw;humans;space technology;coauthored artifacts;iris;object based client server architecture;m net synchronous meeting environment rule mitigated collaboration technology collaboration formal meeting protocol electronic meeting systems coauthored artifacts application programming interfaces object based client server architecture;discussion threads;scope;project planning	Carl K. Chang, Alexei Vorontsov, Jia Zhang, Francis Quek University of Illinois at Chicago { ckchang, avoronts, jzhang ] @eecs.uic.edu The design of an appropriate paradigm for collaboration ultimately stands or falls on the question of whether human users are able to cooperate effectively with it. In this work, we begin with a paradigm of interaction in which human collaborators have shown themselves facile. This paradigm is based on the formal meeting protocol commonly known as parliamentary procedure or Robert’s Rules of Order (RRO). These rules are at the same time descriptive and prescriptive of effective meeting behavior. Electronic meeting systems, likewise, have to manage time and communicative resources, maintain logs, and produce artifacts that constitute the fruit of the collaboration. The technology disclosed here facilitates the generation of coauthored artifacts (documents, designs, project plans, etc.) as the direct outcome of the collaborative process. The efficacy of rulemitigated collaboration technology is based on four major components: an extended parliamentary procedure rule set, a scoping policy and set of application programming interfaces, an object-based client-server architecture, and an M-Net synchronous meeting environment.	algorithm;application programming interface;client–server model;francis;object-based language;programming paradigm;robert;scope (computer science);server (computing)	Carl K. Chang;Alexei Vorontsov;Jia Zhang;Francis K. H. Quek	1999		10.1109/FTDCS.1999.818796	simulation;human–computer interaction;computer science;world wide web	HCI	-38.59322597733046	18.48352091566999	93040
1832e55f510e07454147deb4ba43d07ff264c6c6	model-driven gui & interaction design using emulation	mobile;formal model;user interface;formal modelling;journal article;formal method;interactive system;gui;computer science;interaction design	This paper introduces a model-driven emulator for the interaction and GUI design of complex interacting systems. It allows systems that are engineered using formal methods and modelling to be tested with users before the final implementation. The user interface requirements are also specified in a formal model, which can be tested manually and automatically as required.	emulator;formal methods;graphical user interface;interaction design;mathematical model;model-driven architecture;model-driven integration;requirement	Annika Hinze;Judy Bowen;Yuting Wang;Robi Malik	2010		10.1145/1822018.1822061	simulation;formal methods;human–computer interaction;computer science;software engineering;formal specification	HCI	-47.21074310113516	28.726368967037008	93074
89bd583679ace0f90ca1f858f331043d77d1fad3	type checking for protocol role enactments via commitments	agent typing;social relationships;static and dynamic type checking;commitments;commitment-based interaction protocols	This work presents a commitment-based agent typing system. Type checking is done dynamically when an agent enacts a commitment-based protocol role: verification checks if the agent meets the requirements displayed by the role it means to enact. An example implementation in the 2COMM4JADE framework is provided. 2COMM4JADE is based on the Agent and Artifact meta-model and exploits JADE and CArtAgO, by using CArtAgO artifacts in order to reify commitment protocols.	jade;metamodeling;requirement;type system	Matteo Baldoni;Cristina Baroglio;Federico Capuzzimati;Roberto Micalizio	2018	Autonomous Agents and Multi-Agent Systems	10.1007/s10458-018-9382-3	typing;computer science;distributed computing;exploit	AI	-42.18631517532992	19.681619455648345	93614
313c2df41a9105405610aadd6e14f5926a63a7b7	malicious detection based on relieff and boosting multidimensional features		—Aiming at the problem of large overhead and low accuracy on the identification of obfuscated and malicious code, a new algorithm is proposed to detect malicious code by identifying multidimensional features based on ReliefF and Boosting techniques. After a disassembly analysis and static analysis for the clustered malicious code families, the algorithm extracts features from four dimensions: two static properties (operation code sequences and bytecode sequence) and two features (system call graph and function call graph) which combines the semantic features to reflect the behaviour characteristic of the malware, and then selects important feature vectors based on Relief. Finally, ensemble learning is carried out, and the decision result is boosted based on weighted voting according to accuracy for a different feature analysis. It has been proven by experiment and comparison that the algorithms have a much higher accuracy of the testing dataset with low overhead.	algorithm;boosting (machine learning);call graph;cluster analysis;code;disassembler;ensemble learning;experiment;feature extraction;feature selection;intrusion detection system;malware;n-gram;opcode;overhead (computing);program slicing;rough set;sensor;static program analysis;system call	Yangxia Luo	2015	JCM	10.12720/jcm.10.11.910-917	pattern recognition	ML	-35.57262696821754	23.0675718424657	93947
3704e55126bd70250fb81bfa2cf45f15a7aabd47	an uml activities diagrams translation into event b supporting the specification and the verification of workflow application models - from uml activities diagrams to event b	activity diagram	This paper exposes the transformation of UML activity diagrams into Event B for the specification and the verification of parallel and distributed workflow applications. With this transformation, UML models could be verified by verifying derived event B models. The design is initially expressed graphically with UML and translated into Event B. The resulting model is then enriched with invariants describing dynamic properties such as deadlock freeness, livelock freeness and reachability. The approach uses activity diagrams metamodel.	activity diagram;automated theorem proving;deadlock;graphical model;invariant (computer science);metamodeling;reachability;refinement (computing);semantics (computer science);uml state machine;unified modeling language;verification and validation	Leila Jemni Ben Ayed;Najet Hamdi;Yousra Bendaly Hlaoui	2010			real-time computing;communication diagram;activity diagram;systems modeling language;uml tool;computer science;applications of uml;class diagram;database;programming language	SE	-43.42363845820997	28.80661091845649	93965
18f2f145492bea43075844c0dcc740159a1da12f	esbmcqtom: a bounded model checking tool to verify qt applications		We propose a simplified version of the Qt framework, called as Qt Operational Model, which is integrated into the Efficient SMT-based Context-Bounded Model Checking tool, for verifying actual Qt-based applications. Experimental results show that our proposed approach can be effectively and efficiently applied to verify Qt-based real-world applications from consumer electronics.	model checking;qt (software);simultaneous multithreading;verification and validation	Mário Garcia;Felipe R. Monteiro;Lucas C. Cordeiro;Eddie Batista de Lima Filho	2016		10.1007/978-3-319-32582-8_6	real-time computing;programming language;algorithm	Logic	-42.11404335611444	31.457719339995737	94069
ecf2996edc445529e681e149c8add54457c41280	critical evaluation of paradigms for modelling integrated supply chains	benchmarking;decision support tool;oil refinery;agent based model;dynamic model;equation based models;supply chain;agent based models;process systems engineering	Contemporary problems in process systems engineering often require model-based decision support tool. Among the various modelling paradigms, equation-based models and agent-based models are widely used to develop dynamic models of systems. Which is the most appropriate modelling paradigm for a supply chain? In this paper, we seek to address this important question through a well-structured benchmarking process. First, we demonstrate that in the space of models, ’equations’ and ’agents’ are concepts of a different order, the former referring to the system description elements in the model while the latter emphasises the model elements. Thus conceptually, the two paradigms are not mutually exclusive. Next, in a case study different dynamic models of an oil refinery supply chain are developed, using different tools and approaches. By performing detailed experiments with two different models, it is demonstrated that the models are equivalent when compared using model definition, numerical results and recommended decisions. However, the modelling process itself is different and results in different model structures. By analysing the effort required to expand the models, allowing new scenarios to be tested, and reuse of model components, we identify the strengths of the two paradigms in the context of supply chain modelling.	agent-based model;decision support system;experiment;mutual exclusion;numerical analysis;process architecture;programming paradigm;systems engineering	Koen H. van Dam;Arief Adhitya;Rajagopalan Srinivasan;Zofia Lukszo	2009	Computers & Chemical Engineering	10.1016/j.compchemeng.2009.01.023	oil refinery;simulation;systems engineering;engineering;management science;supply chain;benchmarking	SE	-41.864511735585054	21.86831971251393	94215
cb16c522fb23b8b7f324c314ebcd6f19299e9fc6	an integrated mda approach with sysml and uml	system engineering;systems engineering principals;formal specification;system modeling;uml 2 1 1;unified modeling language systems engineering and theory hardware software tools embedded system design engineering control systems microprogramming vehicles poles and towers;embedded systems development;logical units integrated mda sysml embedded systems development uml 2 1 1 systems modeling language systems engineering principals system analysis system design;embedded system;hardware architecture;embedded systems;software architecture;system design;integrated mda;unified modeling language;system analysis;unified modeling language embedded systems formal specification software architecture;requirements traceability;systems modeling language;logical units;sysml	During embedded systems development, decisions must be made regarding which portions of the system will be implemented in software, hardware, firmware etc. The latest version of UML (UML 2.1.1), and the Systems Modeling Language, (SysML) now enable embedded systems developers to more closely model their systems. Systems engineering principals, can also aid this process. Consequently, essential aspects of systems engineering issues such as concurrency, hardware architecture, and requirements traceability can be applied to embedded systems. This paper proposes a method for analyzing and designing a system into logical units so that the allocation process can be successfully completed. Constraints and elements can be traced to and reflected in the generated code.	concurrency (computer science);embedded system;firmware;requirement;requirements traceability;software development process;systems modeling language;systems engineering;unified modeling language	Matthew Clayton Hause;Francis Thom	2008	13th IEEE International Conference on Engineering of Complex Computer Systems (iceccs 2008)	10.1109/ICECCS.2008.21	real-time computing;system of systems;systems modeling language;uml tool;computer science;systems engineering;applications of uml;hardware architecture;east-adl;systems development life cycle;computer engineering;systems design	Embedded	-48.08075274467211	31.913866466251086	94276
33c4d607e627ea7a8fb9af36c442f73a059cfcdd	an explicit method for decoupled distributed solvers in an equation-based modelling language	model generation;modelica;datorsystem;computer systems;transmission line element method;distributed solvers	The Modelica language offers an intuitive way to create object-oriented models. This makes it natural also to use an object-oriented solver, where each sub-model solves its own equations. Doing so is possible only if sub-models can be made independent from the rest of the model. One way to achieve this is to use distributed solvers by separating sub-models with transmission line elements. This offers robust and predictable simulations, simplified model debugging and natural parallelism. It also makes it possible to use different time steps and solver algorithms in different parts of the model to achieve an optimal trade-off between performance and accuracy. The suggested method has been implemented in the Hopsan simulation environment. Different modelling techniques for taking advantage of the distributed solver approach are explained. Finally, three example models are used to demonstrate the method.	algorithm;debugging;explicit and implicit methods;hopsan;modeling language;parallel computing;simulation;solver;transmission line	Robert Braun;Petter Krus	2014		10.1145/2666202.2666212	computational science;simulation;computer science;theoretical computer science	AI	-37.58637055849139	28.641081582309575	94283
a13a1671a4bcccf36abfe201001892d0ed0f3794	intelligent agents viii		We contend that, at least in the first stages of definition of the early and late requirements, the software development process should be articulated using knowledge level concepts. These concepts include actors, who can be (social, organizational, human or software) agents, positions or roles, goals, and social dependencies for defining the obligations of actors to other actors. The goal of this paper is to instantiate this claim by describing how Tropos, an agent-oriented software engineering methodology based on knowledge level concepts, can be used in the development of a substantial case study consisting of the meeting scheduler problem.	agent-oriented software engineering;intelligent agent;knowledge level;requirement;scheduling (computing);software development process	Piotr J. Gmytrasiewicz;Christine L. Lisetti	2002		10.1007/3-540-45448-9	intelligent agent;human–computer interaction;computer science	SE	-43.360540397997276	20.97625484731318	94332
8028540c25227b5695d9b530da2dd03b022dd1b8	a conceptual and formal framework for the integration of data type and process modeling techniques	modeling technique;formal model;integrable model;abstract data type;data type;graph transformation;conceptual framework;transition systems;process model;system architecture	Abstract   A conceptual framework for the integration of data type and process modeling techniques, called integration paradigm, has been presented by the authors in previous papers already. The aim of this paper is to give a short review of this conceptual framework and to present a formal model for the integration paradigm. The formal model for the four layers, called data type, data states and transformations, processes and system architecture layers respectively, is based on an integration of abstract data types and structured transition systems. This formal model can be instantiated by all kinds of basic and integrated modeling techniques. Algebraic high-level nets, attributed graph transformation, an integration of  Z  with statecharts, and some diagram techniques of UML are discussed on the conceptual level. As instantiation of the formal model, a well-known CCS sender specification, place/transition nets, algebraic high-level nets and attributed graph transformation are presented in this paper, while instantiations of other modeling techniques will be discussed elsewhere.	process modeling	Hartmut Ehrig;Fernando Orejas	2001	Electr. Notes Theor. Comput. Sci.	10.1016/S1571-0661(04)00173-2	idef1x;data modeling;conceptual model;data type;data model;computer science;conceptual model;theoretical computer science;process modeling;data mining;conceptual framework;programming language;abstract data type;systems architecture	PL	-44.61820727684796	26.090541880750823	94354
a0f3fd7b7a96c4ed090718eeece681b21dcac1a5	un processus de développement en spirale pour la simulation multi-agents		The general framework of our project is the development of a simulation environment for complex systems with an agent-based approach. The main goal is to define and implement an evolutionary and generic platform. This paper describes an application of our research in this area, by presenting a development process adapted to this kind of issue. Because of the non-determinist part of the tackled domain, and the agent-approach which is yet in its infancy, a spiral-based methodology seems the appropriate solution to successfully tackle this issue. On the other way, implementing such applications needs a well-suited environment. In such a frame, Smalltalk and uppers levels which have been developed on the top was a very interesting candidate to investigate, as it offers a wide variety of common mechanisms to build both agents and simulation tools. MOTS-CLÉS : méthodologie en spirale, modélisation de systèmes, simulation, Smalltalk.	agent-based model;complex systems;linear algebra;simulation;smalltalk	Rémy Courdier;Pierre Marcenac;Sylvain Giroux	1998	L'OBJET		simulation;engineering;artificial intelligence;algorithm	Robotics	-42.5210889168589	22.077539764351567	94440
439d74130cd345aae2a37d5b25373fd6c6d8c375	causal behavioural profiles - efficient computation, applications, and evaluation	causal behavioural profiles;formal methods;structural decomposition;concurrency;order relations;structural decompositions;behavioural abstraction;optionality;exclusiveness;causality	Analysis of behavioural consistency is an important aspect of software engineering. In process and service management, consistency verification of behavioural models has manifold applications. For instance, a business process model used as system specification and a corresponding workflow model used as implementation have to be consistent. Another example would be the analysis to what degree a process log of executed business operations is consistent with the corresponding normative process model. Typically, existing notions of behaviour equivalence, such as bisimulation and trace equivalence, are applied as consistency notions. Still, these notions are exponential in computation and yield a Boolean result. In many cases, however, a quantification of behavioural deviation is needed along with concepts to isolate the source of deviation. In this article, we propose causal behavioural profiles as the basis for a consistency notion. These profiles capture essential behavioural information, such as order, exclusiveness, and causality between pairs of activities of a process model. Consistency based on these profiles is weaker than trace equivalence, but can be computed efficiently for a broad class of models. In this article, we introduce techniques for the computation of causal behavioural profiles using structural decomposition techniques for sound free-choice workflow systems if unstructured net fragments are acyclic or can be traced back to Sor T-nets. We also elaborate on the findings of applying our technique to three industry model collections.	bisimulation;business process;causality;computation;directed acyclic graph;process modeling;software engineering;time complexity;turing completeness;verification and validation	Matthias Weidlich;Artem Polyvyanyy;Jan Mendling;Mathias Weske	2011	Fundam. Inform.	10.3233/FI-2011-614	discrete mathematics;formal methods;causality;concurrency;computer science;theoretical computer science;machine learning;mathematics;causal consistency;programming language;algorithm;statistics	SE	-43.15241610282243	28.39954973310077	94701
997f5508b9ef7332b38f47ec2f6159ab3c710bf2	trust shaping: adapting trust establishment and management to application requirements in a service-oriented grid environment	modelizacion;confiance;haute performance;architecture systeme;ciclo desarrollo;psychologie sociale;life cycle;service orientation;distributed computing;service web;trust model;web service;orientado servicio;service utilisateur;grid;modelisation;confidence;confianza;rejilla;psicologia social;cycle developpement;alto rendimiento;grille;calculo repartido;arquitectura sistema;social psychology;oriente service;servicio usuario;user service;system architecture;modeling;high performance;calcul reparti;domain specificity;servicio web;service oriented	In this paper, an approach for establishing and managing trust among the interaction partners (i.e. users, nodes and/or services) in a service-oriented Grid environment is presented. The approach is based on a flexible trust model and system architecture for collecting and managing multidimensional trust values. Both identity and behaviour trust of the interaction partners are considered, and different sources are used to determine the overall trust value of an interaction partner. A proposal for establishing the first trust between interaction partners is made, and the possibility to continuously monitor the partners’ behaviour trust during an interaction is provided. The proposed trust architecture can be configured to the domain specific trust requirements by the use of several separate trust profiles covering the entire lifecycle of trust establishment and management.	noise shaping;requirement;service-oriented device architecture	Elvis Papalilo;Thomas Friese;Matthew Smith;Bernd Freisleben	2005		10.1007/11590354_6	web service;web of trust;biological life cycle;simulation;systems modeling;trust anchor;computer science;confidence;grid;world wide web;computer security;computational trust;systems architecture	HPC	-40.07464118056511	23.578399913878123	94713
03a05dfb5a73322845121f024a3a1be3647398f1	a knowledge-based framework for software evolution control	software evolution;knowledge base	An exhaustive software description is required for better understanding and analysis of different impacts of intended change. A change applied on a software artefact can propagate its impact on several other components of whole system. This impact can be considered from structural, qualitative, functional, logical, or behavioural point of view. In this article, we describe a Knowledge-Based System encompassing a large set of knowledge describing exhaustively software application targeted by change. This knowledge set is built in reference to a proposed Generic Software Model for Software Evolution. As a knowledgebased system, it manages a rule repository of application knowledge (Fact-Base) in interaction with a Rule-Base aiming at including rules destined to better handling of the future changes. A framework for better change impact analysis of software applications is first generally presented to demonstrate afterwards in detail how it can be used to control change impact propagation throughout different links between concerned software artefacts. RÉSUMÉ. Une description exhaustive de logiciels est nécessaire pour une meilleure compréhension et une analyse des différents impacts des modifications. Une modification appliquée sur un artefact logiciel peut propager son impact sur plusieurs autres composants de l’ensemble du système. Cet impact peut être considéré d’un point de vue structurel, qualitatif, fonctionnel, logique, ou comportemental. Dans cet article, nous décrivons un système à base de connaissances qui englobe un large ensemble de connaissances décrivant de façon exhaustive les applications logicielles visées par le changement. Cet ensemble est construit en référence à un modèle générique pour l’évolution des logiciels. En tant que système à base de connaissances, il gère un répertoire de règles relatives à l’application en cours (Fact-Base), en interaction avec une base des règles incluant celles destinées à la gestion des futurs changements. Un cadre pour une meilleure analyse de l'impact des changements de logiciels est d’abord globalement présenté, il est ensuite démontré en détail comment il peut être utilisé pour le contrôle de la propagation de l'impact des modifications à travers les différents liens existant entre les artefacts logiciels concernés par le changement en cours.	bibliothèque de l'école des chartes;council for educational technology;knowledge-based systems;linear algebra;list of minor characters in the matrix series;software evolution;software propagation;visual artifact;vue	Adeel Ahmad;Henri Basson;Laurent Deruelle;Mourad Bouneffa	2009			art;art history;algorithm;cartography	Security	-43.505129923314676	25.09473819505014	94715
6cc6b59f1516f68c138850cd58389787e909aa3b	towards an approach for debugging mas through the analysis of acl messages	agent platform;distributed system;debugging;communication process;puesta a punto programa;multiagent system;systeme reparti;multi agent system;proactive service;intelligence artificielle;sistema complejo;debogage;proceso comunicacion;processus communication;sistema repartido;sevicio proactivo;systeme complexe;complex system;artificial intelligence;inteligencia artificial;intencion;sistema multiagente;intention;service proactif;systeme multiagent	Multi-agent systems (MAS) are a special kind of distributed systems in which the main entities are autonomous in a proactive sense. These systems are special distributed systems because of their complexity and hence their unpredictability. Agents can spontaneously engage in complex interactions, guided by their own goals and intentions. When developing such kinds of system, there are many problems the developer has to face. All these problems make it virtually impossible to totally debug a quite complex multi-agent system (i.e. a MAS in which hundreds or even thousands of agents are involved). In this article we present a debugging tool we have developed for the JADE agents platform. Hence, it is a FIPA technology based tool and seeks to alleviate typical debugging problems derived from distribution and unpredictability.	debugging	Juan A. Botía Blaya;Juan Manuel Hernansaez;Antonio F. Gómez-Skarmeta	2004		10.1007/978-3-540-30082-3_22	embedded system;complex systems;simulation;computer science;artificial intelligence;multi-agent system;debugging	NLP	-38.801599574743705	19.937841295205455	94723
17a4e0e8628e8e0ca8347bf2ad58dc772a127ce5	implementation of hybrid automata in scicos	graph theory;continuous time;mathematics computing;automata mathematical model automatic control differential equations computational modeling open source software control system synthesis integrated circuit interconnections clocks linear systems;algorithm analysis;formal model;modeling and simulation;time varying systems;differential equation;heterogeneous data;state machine;time varying systems automata theory control engineering computing differential equations digital simulation graph theory mathematics computing;standard model;phase transition;model checking;graph representation;hybrid system;scicos automaton block;automata theory;control engineering computing;hybrid automata;differential equations;scilab open source software;model of computation;hybrid continuous time dynamical systems hybrid automata scicos automaton block state machine differential equation graph representation modeling simulation environment scilab open source software;hybrid continuous time dynamical systems;modeling simulation environment;embedded computing;digital simulation	Hybrid automaton is a standard model for describing a hybrid system. A hybrid automaton is a state machine augmented with differential equations and is generally represented by a graph composed of vertices and edges where vertices represent continuous activities and edges represent discrete transitions. Modeling a hybrid automaton with large number of vertices may be difficult, time-consuming and error prone using standard modules in modeling and simulation environments such as Scicos. In this paper, we present the new Scicos automaton block used for modeling and simulation of hybrid automata.	cognitive dimensions of notations;dummy variable (statistics);dynamical system;finite-state machine;graph (discrete mathematics);graphical user interface;hybrid automaton;hybrid system;scicos;simulation;stateflow;usability;vertex (geometry);vertex (graph theory);zero crossing	Masoud Najafi;Ramine Nikoukhah	2007	2007 IEEE International Conference on Control Applications	10.1109/CCA.2007.4389334	block cellular automaton;nested stack automaton;discrete mathematics;büchi automaton;continuous spatial automaton;computer science;theoretical computer science;two-way deterministic finite automaton;continuous automaton;deterministic automaton;distributed computing;mobile automaton;timed automaton;pushdown automaton;hybrid system	Robotics	-35.67320803241373	30.969301245212574	95354
383e992ee012f78630f4fef2f8c2493bececa85d	application of modified coloured petri nets to modeling and verification of sdl specified communication protocols	coloured petri net;model checking;communication protocol	In order to simplify simulation and verification of SDL specified communication protocols, we introduce modified coloured Petri nets called hierarchical timed typed nets (HTT-nets). A method for translation from SDL into HTT-nets is presented. A tool SPV (SDL protocol verifier) including a translator from SDL into HTT-nets, as well as means for editing, simulating, visualizing and verifying the net models, is described. For verification, the tool SPV uses a model-checking method. As case studies, we apply the tool SPV to RE-protocol [4], ATMR protocol [10] and i-protocol [5].		Valery A. Nepomniaschy;Gennady I. Alekseev;Victor S. Argirov;Dmitri M. Beloglazov;Alexandre V. Bystrov;Eugene A. Chetvertakov;Tatiana G. Churina;Sergey P. Mylnikov;Ruslan M. Novikov	2007		10.1007/978-3-540-74510-5_31	model checking;communications protocol;real-time computing;computer science;distributed computing;algorithm	Logic	-34.30347322716356	31.719689895159366	95386
d41f6a917ef9c2da25172344aa05efb06c4ef6a9	recovering conceptual models from web applications	conceptual modeling;uwa;conceptual model;web applications;levels of abstraction;ubiquitous web applications;design;semantic relations;documentation;reverse engineering;design methodology	This paper proposes a reverse engineering approach for abstracting conceptual user-centered models from existing Web applications to re-document them at a high level of abstraction and from a user perspective.The recovered models are specified by referring to the Ubiquitous Web Application (UWA) design methodology. UWA models are able to describe the structure of the application contents, the semantic relations among contents, the different views on contents the application offers to users, and the navigation paths and the navigation nodes used to present contents to users.The approach exploits existing reverse engineering methods and tools to extract fine grained structural information from the analyzed applications and abstracts UWA models from them.The architecture of a tool to support the reverse engineering approach is described and the results from some preliminary experiments are discussed.	experiment;high-level programming language;reverse engineering;user-centered design;web application	Giuseppe A. Di Lucca;Damiano Distante;Mario Luca Bernardi	2006		10.1145/1166324.1166351	web modeling;computer science;conceptual model;operating system;database;programming language;world wide web	Web+IR	-47.315868232239204	21.25579471289175	95390
28d8537f7c78aba02d39852339ed3c1a8273c2b8	using jason to implement a team of gold miners	practical reasoning;bdi agents	Jason[2, 3] is an agent platform based on an extension of an agent-oriented programming language called AgentSpeak [5]. The language is inspired by the BDI architecture [6], hence based on notions such as goals, plans, beliefs, intentions, etc. One of the existing software engineering methodologies which is appropriate fore this type of agents is the Prometheus methodology [4]. Below, we describe the ongoing work on designing aJasonteam for the CLIMA-VII Contest (the Gold Miners scenario), using preliminary diagrams generated using the Prometheus methodology.	agent-oriented programming;agentspeak;diagram;jason;programming language;prometheus;software development process;software engineering;vii	Rafael H. Bordini;Jomi Fred Hübner;Daniel M. Tralamazza	2006		10.1007/978-3-540-69619-3_18	simulation;engineering;knowledge management;artificial intelligence	SE	-43.25061356120535	22.527712854191712	95423
b58a20182eb96a7a2ca3013b5ea2e217d8be15d4	a context-aware dialog model for multi-device web development	open-source development environment;multi-device web development;mbui technique;context-aware dialog model;step-wise method;user interfaces;ui model;context change;model-based user interface design;development method;ui code generation process;dialog;navigation	Model-Based User Interface Design (MBUID) consists of a step-wise method that structures the development of User Interfaces (UIs) based on models. According to this method, developers focus on creating a UI model, that is an abstract representation of it, and delegate the UI code generation process to automatic tools that take into account platform peculiarities. This paper explores the applicability of MBUI techniques to context-aware Service Front Ends (SFEs), i.e. UIs of web services that react to context changes. For this purpose, it introduces a context-aware dialog model that captures the adaptable behavior of a UI depending on variations of the context of use, a standard-based notation to represent it, and an open-source development environment that supports this development method.	web development;dialog	Javier Rodríguez Escolar	2013		10.1145/2480296.2480341	simulation;human–computer interaction;computer science;dialog system;world wide web	NLP	-48.055216280564146	22.636335094326444	95596
5cd0a61f5d4ede7ab2d14c4da96a6c259e19965c	ivam: implicit variant modeling and management for automotive embedded systems	automotive electronics;design engineering;embedded systems;graph theory;mechanical engineering computing;dse;ivam;pb solver techniques;automotive embedded systems;design space exploration;electric-and-electronic architecture functionality;electronic control units;functional variant analysis;functional variant modeling;global business knowledge;graph-based approach;group selection;implicit variant modeling-and-management;linear constraints;local technical expert knowledge;task graph functionalities	In this paper, we propose a graph-based approach for the modeling and efficient analysis of functional variants of a car's electric and electronic (E/E) architecture functionality by combining local technical expert knowledge with global business knowledge. Starting with a variants system specification including a set of task graphs, linear constraints on binary variables are specified for their alternative selection as well as the selection of groups of alternatives called application groups. These constraints may stem from a certain domain knowledge, e.g., entertainment or power train domain, or global constraints. The typically vast space of resulting possible combinations of different selections of alternative behaviors will be termed variant space and those satisfying the set of formulated constraints valid variants. An important result of this paper is that the set of variants, and especially the set of valid variants, do not need to be modeled or stored explicitly but rather implicitly. Nevertheless do we show that using state-of-the-art PB solver techniques, we may determine the set of valid variants very efficiently. Each of these valid variants may subsequently be used as a candidate for design space exploration (DSE) in order to optimize also the mapping of the corresponding task graph functionalities to a final optimized E/E architecture. A real-world case study is provided to demonstrate the capabilities and efficiency of the presented approach on implicit variant modeling and analysis.	design space exploration;embedded system;non-functional requirement;software system;solver;systems integrator	Sebastian Graf;Michael Glaß;Dominic Wintermann;Jürgen Teich;Christoph Lauer	2013	2013 International Conference on Hardware/Software Codesign and System Synthesis (CODES+ISSS)		simulation;computer science;theoretical computer science;algorithm	EDA	-48.25081293744064	30.13106961450882	95731
7ff168c7ad85f4bdc6761dcf95c8475c7451f581	automated analysis of timing information in uml diagrams	unified modeling language;diagrams;embedded systems;formal verification;promela semantics;uml diagrams;uml formalization framework;automated formal analysis;electronically controlled steering system;embedded systems;timing information	This work introduces an approach to adding timing information to UML diagrams for modeling embedded systems. In order to perform automated formal analysis of these UML diagrams with timing information, we extend a previously developed UML formalization framework to provide Promela semantics for the timing elements of the UML diagrams. The paper describes the application of our approach to an electronically controlled steering system obtained from one of our industrial collaborators.	ase;compiler;diagram;embedded system;graphical model;liveness;model checking;promela;requirement;software engineering;system requirements;uml state machine;unified modeling language	Sascha Konrad;Laura A. Campbell;Betty H. C. Cheng	2004	Proceedings. 19th International Conference on Automated Software Engineering, 2004.	10.1109/ASE.2004.10041	unified modeling language;real-time computing;communication diagram;formal verification;systems modeling language;uml tool;computer science;systems engineering;diagram;theoretical computer science;applications of uml;class diagram;shlaer–mellor method;programming language;node	SE	-43.791072547102324	31.27100544073967	95741
e3c697ab0e1f78c818e89f166123ba34724045c7	generalizing the compositions of petri nets modules	llamas;composition mechanism;system design and verification;high level petri nets;modularity;standardization	Modularity is a mandatory principle to apply Petri nets to real world-sized systems. Modular extensions of Petri nets allow to create complex models by combining smaller entities. They facilitate the modeling and verification of large systems by applying a divide and conquer approach and promoting reuse. Modularity includes a wide range of notions such as encapsulation, hierarchy and instantiation. Over the years, Petri nets have been extended to include these mechanisms in many different ways. The heterogeneity of such extensions and their definitions makes it difficult to reason about their common features at a general level. We propose in this article an approach to standardize the semantics of modular Petri nets formalisms, with the objective of gathering even the most complex modular features from the literature. This is achieved with a new Petri nets formalism, called the LLAMAS Language for Advanced Modular Algebraic Nets (LLAMAS). We focus principally on the composition mechanism of LLAMAS, while introducing the rest of the language with an example. The composition mechanism is introduced both informally and with formal definitions. Our approach has two positive outcomes. First, the definition of new formalisms is facilitated, by providing common ground for the definition of their semantics. Second, it is possible to reason at a general level on the most advanced verification techniques, such as the recent advances in the domain of decision diagrams.	decision problem;diagram;encapsulation (networking);entity;petri net;semantics (computer science);universal instantiation	Alexis Marechal;Didier Buchs	2015	Fundam. Inform.	10.3233/FI-2015-1171	computer science;theoretical computer science;modularity;process architecture;petri net;standardization;algorithm	AI	-38.51460998272525	27.18509239297037	95747
ac34f055e7726da3ccda3b2ca2b0c0331af6dc65	a visual approach to xml document design and transformation	document structure;graph grammars hypermedia markup languages multimedia computing context sensitive grammars;hypermedia markup languages;xml vocabulary multidimensional systems internet multimedia systems tree graphs computer science software systems information systems software engineering;multimedia computing;context sensitive grammars;graph grammar;context sensitive graph grammar xml document design document transformation visual approach multimedia document structures;xml document;graph grammars	This paper presents a visual approach to the representation and validation of multimedia document structures specified in XML and transformation of one structure to another. The underlying theory of our approach is a context-sensiti ve graph grammar formalism. The paper demonstrates the conciseness and expressiveness of the graph grammar formalism. An example XML structure is provided and its graph grammar representation, validation and transformation to a multimedia representation are presented.	formal grammar;formal system;graph (discrete mathematics);graph rewriting;random geometric graph;semantics (computer science);synchronized multimedia integration language;visual programming language;vocabulary;xhtml;xml tree	Kang Zhang;Da-Qian Zhang;Yi Deng	2001		10.1109/HCC.2001.995279	well-formed document;natural language processing;xml validation;xml encryption;simple api for xml;xml;streaming xml;computer science;document type definition;document structure description;xml framework;extended affix grammar;xml schema;database;document schema definition languages;programming language;adaptive grammar;xml schema editor;sgml	Web+IR	-46.41563777357878	20.897505876321922	95861
9c14dff05f51226b78f2e9c36012f17769f20c34	ballroom etiquette:  a case study for norm-governed multi-agent systems	autonomous dancer agent;finite state machine;institutional statein;associated norm;logic programming language;norm-governed multi-agent systems;case study;ongoing work;interaction protocol;ballroom etiquette;alternative approach;normative system	We present a case study which describes a ballroom as a social institution with autonomous dancer agents together with sets of norms and conventions that coordinate the behaviour of the participants. We provide a representation for the interaction protocols as finite state machines and a new way of formalising the associated norms in a logic programming language. Furthermore, we report on recent and ongoing work on an architecture for normative systems of this kind which allows agents to dynamically download interaction protocols and operational norms to guide their behaviour. Finally, we outline an alternative approach for representing the institutional state in a virtual, distributed fashion in the agents’ private belief stores.	autonomous robot;download;finite-state machine;interaction protocol;programming language	Dorian Gaertner;Keith L. Clark;Marek J. Sergot	2006		10.1007/978-3-540-74459-7_14	simulation;computer science;artificial intelligence;communication	AI	-42.289923334769504	19.52477195831332	95911
751942ad771ee6a12f5fefaf0f0b4a53d3af27d4	mobile interfaces for building control surveyors	front end;mobile user interfaces;mobile device;heterogeneous environment;interactive method;mobile interfaces;of research and development;public administration	The problem of integrating heterogeneous back-end platforms used in public administration has been widely addressed in a number of research and development projects. In such a complex and heterogeneous environment, application of the SOA paradigm can be particularly beneficial. However, in some application domains – such as the Building Control Administration – there is an additional requirement: integration of heterogeneous front-end platforms – including access through mobile devices. In this paper, a new method of creating adaptable mobile user interfaces for applications based on SOA services is described. In the adaptation process the displayed content is adjusted, the best way of presenting content is selected and interaction methods are adapted to the capabilities of the particular mobile device. Therefore, it is possible to easily make any service accessible on any mobile device – which is of great importance to the Building Control Administration surveyors that operate out of office, directly in the construction field.	ada semantic interface specification;application domain;business logic;middleware;mobile device;programming paradigm;service-oriented architecture;user interface	Jacek Chmielewski;Krzysztof Walczak;Wojciech Wiza	2010		10.1007/978-3-642-16283-1_7	mobile search;simulation;mobile web;human–computer interaction;engineering;multimedia;mobile computing	HCI	-48.14962018410426	20.871558433504045	96055
5e071e3109c23446b612580a1ae02cca0d91d51b	logical model for administration policy specification	distributed system;approximation algorithm;recurrence relations;deontic logic;standardisation;multiprogrammed parallel system;complex system;probabilistic analysis;sequential selection;focal point;maximum subset sum;knapsack	The administration system has as its mission the management and the control of distributed systems to which it is associated. Administration policies are very important to study so that managers can specify and represent complex systems in order to automate systems administration. In general, administration policies within large distributed systems are very complex, since technical and social models and policies vary considerably from one management model to another.Indeed, often every organisation has its own administration policies regarding to its objectives. Furthermore, the focal point for standardisation and research on management of networks and distributed system, is the modelling and the management of communication resources while the definition and the specification of administration policies is too often partially or full ignored. In this paper, the main objective is the design of a logical model for specification of administration policies using defeasible deontic logic.	complex systems;computation;defeasible reasoning;deontic logic;distributed computing;focal (programming language);logical data model;natural language;system administrator	Nacira Guerroudji	1995		10.1145/1122018.1122059	computer science;operations management;theoretical computer science;algorithm	DB	-38.150271946413916	19.671797332665285	96166
d09ad959a7e70ca2bcb62b2d723e39a542bce0d1	performance measurement of multiagent systems: towards dependable mas	performance measure;multiagent system;simulation;dynamic environment;performance measurement;multiagent systems	In this paper we discuss an inherent problem of multiagent systems (MAS), the validation of desired behavior of an agent as well as a MAS. MAS can adapt their behaviors to a dynamic environment. By the ability of adapting to a variety of changes in the environment, it becomes very hard to ensure that the systems always show an intended behavior on behalf of its owner. We present here a simulation-based approach that allows validating the behavior of MAS. The simulations runs are used to evaluate the MAS in the application domain. By varying simulation settings, changes in the environment can be tested, and thus the dynamic abilities of the MAS are evaluated. If required and enough time is available, different possible sequences of changes can be tested. Thus a confidence value for the trust in the MAS, that it will behave efficient and desired in the real application context, can be defined.	agent-based model;application domain;context (computing);intelligent agent;multi-agent system;simulation;user error	Ingo J. Timm;René Schumann	2009			performance measurement;real-time computing;simulation;computer science;engineering;knowledge management;multi-agent system	AI	-39.39480286617143	21.043237503479073	96188
02776865e5c79dbce72e642a54d4a712a639b7ef	special section of sosym dedicated to 50 years of petri nets		Very few concepts of computer science are so closely linked to the names of their creators as Petri nets are to their inventor Carl Adam Petri. More than 50 years ago, in June 1962, he laid the foundation for a modeling technique that has been continuously worked on ever since. With his stable foundation, numerous and broadly applicable concepts and techniques, special cases, generalizations and adaptations, Petri nets are used in a variety of fields inside and outside computer science. Just as finite automata and their numerous variants are the formal basis formanymodeling languages for sequential systems, Petri nets are a basic and precise description of essential concepts and phenomena of discrete distributed systems, which implicitly or explicitly influencedmany customdesigned modeling languages. Efficient techniques for proving and checking relevant properties of a systemmodel can be transferred from Petri nets to other modeling languages. The same is true for information and results on those properties that cannot be ascertained or require a very high algorithmic effort. Thus, results of Petri net theory are relevant in many areas where the name “Petri” is not explicitly mentioned. Vice versa, new and custom-designed problems are often easier to analyze and solve in the more general context of Petri nets. This was the impetus for discussing the basic concepts of Petri nets and highlight current fields of successful application in this special section. In their introductory article “The concepts of Petri nets”, Jörg Desel and Wolfgang Reisig show that there is more to	algorithm;automata theory;computer science;distributed computing;finite-state machine;modeling language;petri net	Robert B. France;Bernhard Rumpe	2014	Software & Systems Modeling	10.1007/s10270-014-0439-8	modeling language;theoretical computer science;petri dish;petri net;generalization;versa;finite-state machine;computer science	Logic	-36.8254669656078	25.25961947781057	96297
51e23afe25c0a04938e3e6edfed885b39a6594a6	using invariant detection mechanism in black box inference	formal verification;software component;integration testing;state machine	The testing and formal verification of black box software components is a challenging domain. The problem is even harder when specifications of these components are not available. An approach to cope with this problem is to combine testing with learning techniques, such that the learned models of the components can be used to explore unknown implementation and thus facilitate testing efforts. In recent years, we have contributed to this approach by proposing techniques for learning parameterized state machine models and then use them in the integration testing of black box components. The major problem in this technique left unaddressed was the selection of parameter values during the learning process. In this paper, we propose to use an invariant detection mechanism to select values in the learning process, thus refining model inference and testing approach. Initial experiments with small examples yielded positive results.	black box;component-based software engineering;experiment;finite-state machine;formal verification;integration testing;software testing	Muzammil Shahbaz;Roland Groz	2007			component-based software engineering;algorithmic learning theory;active learning (machine learning);integration testing;machine learning;parameterized complexity;formal verification;inference;pattern recognition;computer science;artificial intelligence;computational learning theory	SE	-43.918727725063405	30.054042779507554	96304
e80e71c201a6206f496928d1dfa623bc8a16ba11	state-based versus event-based specifications for information systems: a comparison of b and eb3	formal specification;management system;data integrity;b;formal method;event based paradigm;eb 3;state based paradigm;information system;point of view;process algebra	This paper compares two formal methods, B and eb3, for specifying information systems. These two methods are chosen as examples of the state-based paradigm and the event-based paradigm, respectively. The paper considers four viewpoints: functional behavior expression, validation, verification, and evolution. Issues in expressing event ordering constraints, data integrity constraints, and modularity are thereby considered. A simple case study is used to illustrate the comparison, namely, a library management system. Two equivalent specifications are presented using each method. The paper concludes that B and eb3 are complementary. The former is better at expressing complex ordering and static data integrity constraints, whereas the latter provides a simpler, modular, explicit representation of dynamic constraints that are closer to the user’s point of view, while providing loosely coupled definitions of data attributes. The generality of these results from the state-based paradigm and the event-based paradigm perspective are discussed.	automated theorem proving;book;construction and analysis of distributed processes;data integrity;data validation;emoticon;entity;error detection and correction;formal language;formal methods;formal verification;gnutella2;guard (computer science);human-readable medium;information system;invariant (computer science);language of temporal ordering specification;linear algebra;loose coupling;model checking;postcondition;precondition;process calculus;programming paradigm;refinement (computing);requirement;transition system;turing completeness;user requirements document	Benoît Fraikin;Marc Frappier;Régine Laleau	2005	Software & Systems Modeling	10.1007/s10270-005-0083-4	reliability engineering;process calculus;formal methods;computer science;data integrity;formal specification;management system;database;programming language;information system;algorithm	SE	-43.001355345160306	28.092149394275378	96382
0a9b0ef86153261e3983342562ff5179b8701b79	coping with semantic variation points in domain-specific modeling languages		Even if they exhibit differences, many DomainSpecific Modeling Languages (DSMLs) share elements from their concepts, notations and semantics. StateCharts is a wellknown family of DSMLs that share many concepts but exhibit notational differences and many execution semantics variants (called Semantic Variation Points – SVPs –). For instance, when two conflicting transitions in a state machine are enabled by the same event occurrence, which transition is fired depends on the language variant (Harel original StateCharts, UML, Rhapsody, etc.) supported by the execution tool. Tools usually provide only one implementation of SVPs. It complicates communication both between tools and end-users, and hinders the co-existence of multiple variants. More generally, Language Workbenches dedicated to the specification and implementation of eXecutable Domain-Specific Modeling Languages (xDSMLs) often do not offer the tools and facilities to manage these SVPs, making it a time-consuming and troublesome activity. In this paper, we describe a modularized approach to the operational execution semantics of xDSMLs and show how it allows us to manage SVPs. We illustrate this proposal on StateCharts.	apple rhapsody;communications protocol;concurrency (computer science);concurrent computing;domain-specific language;domain-specific modeling;executable;finite-state machine;hard coding;lattice problem;metamodeling;programming language;semantic mapper;spatial variability;unified modeling language	Florent Latombe;Xavier Crégut;Julien DeAntoni;Marc Pantel;Benoît Combemale	2015			real-time computing;computer science;database;programming language	PL	-40.72148086592266	28.538502799364913	96475
1e523de840dfc72f027a7001a74a096d6bdc875d	simphony: an integrated environment for construction simulation	templates;simulation model;statistics;vents;investments;energy management;knowledge management;animation;testing;construction industry	This paper discusses Simphony as an integrated environment for building special purpose simulation tools for modeling construction systems. Simphony provides various services that enable the developer to easily control different behaviors in the developed tool such as simulation behaviors, graphical representation, statistics, and animation. These services allow building flexible and user-friendly tools in a relatively short time. The developed tools (templates) then provide the building blocks that a user (construction engineer) can use to create simulation models for different construction domains without the need for a deep background in simulation techniques. The services available for the developer are discussed and examples of their use are illustrated. Samples of the tools developed with Simphony are also reviewed to highlight some of their features.	comparison of command shells;graphical user interface;simulation;usability	Simaan M. AbouRizk;Yasser Mohamed	2000			simulation;human–computer interaction;computer science;systems engineering;engineering;simulation modeling	Graphics	-35.39833548302726	26.28148639147294	96649
5b66d16de0b8e74cb3c3068ea40233193a6c162f	testability of a swarm robot using a system of systems approach and discrete event simulation	distributed system;robot sensing systems;agent in the loop simulation;extensible markup language;sos;mobile robot;simulation framework;system of systems;virtual agents swarm robot system of systems discrete event system specification extensible markup language agent in the loop simulation cooperative systems mobile robot;mobile robots;robotics;swarm robot;software engineering;discrete event system;cooperative systems;hardware in the loop;synchronization;xml cooperative systems discrete event simulation mobile robots multi robot systems software engineering;state space;discrete event system specification;multi robot systems;xml;system analysis;system testing discrete event simulation modeling xml robot sensing systems analytical models cooperative systems mobile robots orbital robotics embedded software;swarm robotics;system science testability of a swarm robot using a system of systems approach and discrete event simulation rochester institute of technology ferat sahin hosking;devs;virtual environment;continuation method;devs discrete event simulation system of systems cooperative systems hardware in the loop swarm robotics;matthew r;virtual agents;data transfer;virtual agent;groundscout;data models;discrete event simulation	A system of systems (SoS) simulation framework using discrete event system specification (DEVS) and data encoded with Extensible Markup Language (XML) tags is presented to support agent-in-the-loop (AIL) simulations for large, complex, and distributed systems. AIL simulations provide a necessary step in maintaining model continuity methods to achieve a greater degree of accuracy in systems analysis. A system of systems approach enables the simulation and analysis of these independent and cooperative systems by concentrating on the data transferred among systems instead of determining global state spaces. A mobile robot is deployed as a real agent working cooperatively with virtual agents to form a robotic swarm in an example threat detection scenario. The swarm robot's performance is tracked and the emergent swarm behavior is also evaluated.	apple sos;consensus dynamics;devs;distributed computing;emergence;intelligent agent;markup language;mobile robot;scott continuity;simulation;swarm robotics;system of systems;threat (computer);xml	Matthew R. Hosking;Ferat Sahin	2010	2010 5th International Conference on System of Systems Engineering	10.1109/SYSOSE.2010.5544074	mobile robot;embedded system;real-time computing;xml;simulation;computer science;artificial intelligence;devs;robotics	Robotics	-39.307744668982	18.876389130544535	96822
5248f70a9b7c9cdcdb2829a33fddaf533a6e95c5	ecosystems computing: introduction to biogeographic computation		The main issue to be presented in this paper is based on the premise that Nature computes, that is, processes information. This is the fundamental of Natural Computing. Biogeographic Computation will be presented as a Natural Computing approach aimed at investigating ecosystems computing. The first step towards formalizing Biogeographic Computation will be given by defining a metamodel, a framework capable of generating models that compute through the elements of an ecosystem. It will also be discussed how this computing can be realized in current computers.	computation;computer;ecosystem;metamodeling;natural computing	Rodrigo Pasti;Fernando José Von Zuben;Leandro Nunes de Castro	2011	IJNCR	10.4018/jncr.2011100104	computer science;theoretical computer science;algorithm	HPC	-45.24205508165226	22.06832263809875	96960
21f447b33481b42a2ddf05b458272eeab6fd4d6a	a formal development and validation methodology applied to agent-based systems	serveur institutionnel;archive institutionnelle;system design;agent based system;open access;archive ouverte unige;cybertheses;institutional repository	This paper presents first a formal development methodology that enables a specifier to add complexity progressively into the system design, and to formally validate each step wrt client’s requirements. Second, the paper describes the application of this methodology to agent-based systems, as well as development guidelines that help the specifier during the development of such systems. System’s functionality, agent decomposition, agent interactions, actual communications means, are progressively considered. The methodology and the development guidelines are presented through an agent market place example.	agent-based model;complexity;expressive power (computer science);formal methods;formal specification;hennessy–milner logic;interaction;java;refinement (computing);requirement;stepwise regression;systems design;top-down and bottom-up design;universal quantification	Giovanna Di Marzo Serugendo	2000		10.1007/3-540-47772-1_22	simulation;data mining;systems design	AI	-40.51576315412047	27.76177843886459	97116
27e9aec2a6b79b65eb00dedbb26fc6fda30136e8	clover: an optimized repository for customizable learning objects		"""Despite reusability being a Learning Objects (LO) core feature, sometimes they demand modifications to fit the new use context. This adaptation process must be easy and rapid. However, several LO are produced in a way that changes need to be done at source code, requiring technical knowledge. Guided Customization (GC) aims at enabling the user to execute adaptations without this requirement. It allows changes at interface level, which simplifies customization of some resource aspects. LO with GC strategy are named Customizable Learning Objects (CLO). However, when CLO and their Customized Versions (CV) are stored like a package of files in a traditional Learning Object Repository (LOR), duplications are scattered throughout the repository, since different CV of same CLO have common unchanged files. This paper presents a proposal of repository that avoids this replication. Considering that CLO executable and media files (images, audios and videos) are the ones which consume more space in repository, repository evaluation demonstrates that in """"worst case scenario"""" (all media files are replaced on customization) the proposal behaves like a traditional LOR concerning disk space consumption. In the """"best case scenario"""" (no media file is replaced) the proposed approach proves more efficient, whereas it shares unchanged media."""	best, worst and average case;centralisation;color light output;disk space;executable;worst-case scenario	Jose Wallison F. da Silva;Cidcley Teixeira de Souza;Maria de Fatima C. de Souza	2017	2017 IEEE 17th International Conference on Advanced Learning Technologies (ICALT)	10.1109/ICALT.2017.114	personalization;learning object;database;worst-case scenario;metadata;source code;computer science;executable;reusability	Robotics	-47.17954307609907	22.334240193201005	97117
6f8d533d567c9681181e502614ecfa2c8d8b7af3	case study: implementing a web based auction system using uml and component-based programming	encapsulation;developpement logiciel;medium frequency;multiagent system;object oriented programming specification languages distributed object management;systeme intelligent;intelligent agents web based auction system uml component based programming unified model language highly maintainable system reusable components methodofbidding identity verification function registrationgood;certification;red www;design engineering;unified model language;behavioral analysis;highly maintainable system;uml;lenguaje uml;sistema inteligente;best practice;reseau web;composant logiciel;langage modelisation unifie;consumer electronics;object oriented programming;registrationgood;diagramme sequence;functional programming;computer aided software engineering;intelligent agents;internet;moyenne frequence;design and implementation;programmation base sur modele;frecuencia media;specification languages;desarrollo logicial;agent intelligent;unified modelling language;best practices;analyse comportementale;software development;methodofbidding;distributed object management;unified modeling language;subasta;intelligent system;software component;certificacion;intelligent agent;bidding;world wide web;analisis conductual;component based programming;profitability;model based programming;enchere;agente inteligente;computer science;identity verification function;reusable component;sistema multiagente;reusable components;use case;sequence diagram;object oriented modeling;buildings;web based auction system;systeme multiagent;computer aided software engineering unified modeling language object oriented modeling consumer electronics encapsulation computer science design engineering best practices buildings functional programming	This paper presents a case study highlighting the best practices for designing and building a web-based auction system using UML (Unified Model Language) and component-based programming. We use the Use Case, Class, Sequence, and Component Diagrams offered by UML for designing the system. This enables new functions to be added and updated easily. Our implementation, with its basis in componentbased programming, enabled us to develop a highly maintainable system with a number of reusable components: the MethodofBidding (the bidder can bid at three different frequencies fast, medium or leisurely), the Certification (Identity verification function), and the RegisterGood (Product entry function) Components. Further, the system uses intelligent agents that permit fair help to bidders participating in auctions and at the same time achieve maximum profit for the seller. The design and implementation environment, along with the tools used, provide excellent support for the successful development of the system.	algorithm;best practice;class diagram;component diagram;component-based software engineering;diagram;formal specification;information engineering;intelligent agent;internet;object-z;rational rose;sequence diagram;software bug;specification language;unified model;unified modeling language;use case diagram;web application	Frederick T. Sheldon;Kshamta Jerath;Young-Jik Kwon;Young-Wook Baik	2002		10.1109/CMPSAC.2002.1044554	unified modeling language;simulation;computer science;systems engineering;engineering;artificial intelligence;operating system;software engineering;applications of uml;database;programming language;computer security;intelligent agent	Networks	-41.070714791952994	25.58920078163863	97484
314d55dff6b9562133b0dcc30d9f6e50954f5042	a compositional model to reason about end-to-end qos in stochastic reo connectors	continuous ime markov chains;haslab haslab uminho;reo;coordination language;compositional semantic model;article letter to editor;quality of service	In this paper we present a compositional semantics for the channel-based coordination language Reo that enables the analysis of quality of service (QoS) properties of service compositions. For this purpose, we annotate Reo channels with stochastic delay rates and explicitly model data-arrival rates at the boundary of a connector, to capture its interaction with the services that comprise its environment. We propose Stochastic Reo Automata as an extension of Reo automata, in order to compositionally derive a QoS-aware semantics for Reo. We further present a translation of Stochastic Reo Automata to Continuous-Time Markov Chains (CTMCs). This translation enables us to use third-party CTMC verification tools to do an end-to-end performance analysis of service compositions. As a case study of industrial strength, we consider the ASK system. Particularly, we present an analysis of the CTMC derived from the Stochastic Reo model of the ASK system. In addition, we discuss to what extent Interactive Markov Chains (IMCs) can serve as an alternative semantic model for Stochastic Reo. We show that the compositionality of IMCs cannot specify the behavior of Stochastic Reo.	amplitude-shift keying;automata theory;automaton;eclipse;electroconvulsive therapy;end-to-end principle;markov chain;markov property;mathematical model;prism (surveillance program);processing delay;quality of service;semiconductor industry;simulation;software propagation;stochastic process;time complexity;virtual synchrony	Young-Joo Moon;Alexandra Silva;Christian Krause;Farhad Arbab	2014	Sci. Comput. Program.	10.1016/j.scico.2011.11.007	natural language processing;quality of service;computer science;theoretical computer science;reo coordination language;programming language;algorithm	Embedded	-36.46802995265059	30.962197336521527	97565
25629e3dde56aaca56c751b2e5ddef8f9034c608	the incremental development of correct specifications for distributed systems	distributed system;incremental development;formal method;community networks	Provably correct software can only be achieved by basing the development process on formal methods. For most industrial applications such a development never terminates because requirements change and new functionality has to be added to the system. Therefore a formal method that supports an incremental development of complex systems is required. The project CoCoN (Provably Correct Communication Networks) that is carried out jointly between Philips Research Laboratories Aachen and the University of Oldenburg takes results from the ESPRIT Basic Research Action ProCoS to show the applicability of a more formal approach to the development of correct telecommunications software. These ProCoS-methods have been adapted to support the development of extensible speciications for distributed systems. Throughout this paper our approach is exempliied by a case study how call handling software for telecommunication switching systems should be developed. keywords: extension of existing formal methods, combination of methods, incremental development	complex systems;correctness (computer science);distributed computing;electronic switching system;formal methods;iterative and incremental development;requirement	Stephan Kleuker;Hermann Tjabben	1996		10.1007/3-540-60973-3_103	formal methods;incremental build model;computer science;iterative and incremental development;programming language	SE	-45.51815978878382	29.648326012962013	97613
2b40a526a0e331b5b2b05df5cca76c32c2f36707	towards an abstract recursive agent	1 2 4 agent representation and specification formalisms;da6 industrial control scheduling embedded systems	Current business trends, policy markets, production requirements, etc., have created the need for integrating pre-existing Multi Agent Systems (MAS). In the agent-specialized literature, we have found very little work about agent architectures and methodologies that allow us to carry out recursive and dynamic analysis, design, and implementation of MASs. Several difficult challenges for automated systems can be tackled by giving full meaning to the agent concept: adopting a recursive definition of agents and allowing for the dynamic creation of agents by the agents themselves. In this work, we propose a definition of an abstract recursive agent and an initial formalization of its behaviour in terms of the behaviour of its constituent agents.	abstraction layer;agent architecture;autonomous robot;bottom-up parsing;complex systems;emergence;entity;interaction;machine perception;multi-agent system;operational definition;principle of abstraction;recursion;recursion (computer science);recursive definition;requirement;top-down and bottom-up design;whole earth 'lectronic link	Adriana Giret;Vicent J. Botti	2004	Integrated Computer-Aided Engineering	10.3233/ica-2004-11206	real-time computing;simulation;computer science	AI	-42.401987827614	21.493078824618873	98040
8ae85569b534f4a8f080e1eae4efed873850c0d4	guidelines for formal domain modeling in event-b	domain model;protocols;event b formal methods domain modeling;vehicles protocols context safety computational modeling;systems analysis formal specification formal verification;formal specification;event b;computer model;formal methods;domain modeling;domain protocol event b formal domain modeling tool proof system refinement mechanisms formal verification process domain assumption;formal method;computational modeling;formal verification;systems analysis;safety;temporal properties;vehicles;context	"""In this paper, we explore the possibility to use Event-B as a formal domain modeling tool. We identify the areas where domain modelers can struggle and present some guidelines to avoid these pitfalls. We mainly address three questions about domain modeling: what to specify, how to refine, and how to verify. We discuss the strategy to express domain assumptions, protocols, time, and temporal properties. We also analyze the refinement and proof system of Event-B in this realm. We advocate small incremental steps and alternative refinement mechanisms, such as """"observation levels. """" We find animation a very helpful activity to complement the verification process."""	b-method;deadlock;domain model;domain-specific modeling;fairness measure;liveness;normal accidents;proof calculus;refinement (computing)	Atif Mashkoor;Jean-Pierre Jacquot	2011	2011 IEEE 13th International Symposium on High-Assurance Systems Engineering	10.1109/HASE.2011.47	formal methods;computer science;theoretical computer science;software engineering;domain model;programming language;algorithm	Embedded	-40.83251144632602	29.560812609302427	98091
2983188e4e34f2ab18b8b9bfa6c7f95d6d2376d7	foreword: programming language interference and dependence	computacion informatica;ucl;discovery;theses;conference proceedings;digital web resources;ucl discovery;ciencias basicas y experimentales;open access;matematicas;ucl library;book chapters;open access repository;grupo a;ucl research	Interference and dependence are closely related concepts, the first being the observable phenomenon connected to the second. Interference essentially means that behavior of some parts of a dynamic system may influence the behavior of other parts of the same system. Dependence instead specifies the relation between the semantics of sub-components of a dynamic system. Discovering, measuring and controlling interference is essential in many aspects of modern computer science, in particular in security, program analysis and verification, debugging, systems specification, model checking, program manipulation, program slicing, reverse engineering, data mining, distributed databases, and systems biology. In all these fields, dependency and interference play a key role in designing suitable abstractions or in partitioning complex systems into simpler ones. Reasoning about dependency and interference requires theories, models, and semantics , as well as algorithms and tools for their analysis. The series of Programming Language Interference and Dependence (PLID) workshops has been devoted, since 2004, to promote and spreading cutting-edge research in this field, with a particular emphasis on unpublished results with great impact on a theoretical basis. PLID2007 was particularly successful, and it constituted the ideal forum where publishing a call for papers for a special issue on programming language interference and dependence, not necessarily restricted to PLID2007 contributions. We selected six contributions by leading researchers in the field, from many expressions of interest, some of them presented at the PLID2007 workshop, which took place at the The Technical University of Denmark, 21 August, 2007. The selected papers focus on foundational aspects of dependency and interference with applications in language based security, database management systems, and program slicing. The paper of Ana Almeida Matos and Jan Cederquist stuidies information flows that occur in distributed programs in presence of code mobility. This is a key problem in language based security. The authors introduce interesting new forms of security leaks that are introduced by code mobility which can be checked by means of a type and effect system for enforcing security, which is validated into an expressive calculus of mobile code. The contribution of Geoffrey Smith and Rafael Alpízar attacks the problem termination in security checking in presence of random assignments. This is a difficult and important problem in language based security which requires advanced mathematical models for being solved. The au	algorithm;ana (programming language);code mobility;complex systems;computer science;computer security;data mining;debugging;distributed database;dynamical system;effect system;interference (communication);jan dietz;language-based security;mathematical model;model checking;observable;program analysis;program slicing;programming language;reverse engineering;statistical interference;systems biology;theory	David J Clark;Roberto Giacobazzi;Chunyan Mu	2011	Mathematical Structures in Computer Science	10.1017/S0960129511000168	computer science;artificial intelligence;mathematics;operations research	PL	-36.8661041407586	25.23272514697615	98269
d8f51096f74afa612b821c1d77f38460bdf6d4aa	the role of the environment in agreement technologies	norm;trust;organization;argumentation;settore inf 01 informatica;articulo;agreement technologies;environment;semantic;negotiation	The notion of Multi-Agent System environment is currently considered as a mediating entity, functioning as enabler but possibly also as a manager and constrainer of agent actions, perceptions, and interactions. In this paper, we analyze how the environment could be a first class abstraction to support the building, the development and the management of Agreements in decentralized and open systems between autonomous agents. To this aim we analyze the synergies between the environment and the foundational dimensions of agreement technologies such as semantics, norms, organizations, argumentation & negotiation, trust.	autonomous agent;autonomous robot;first-class function;interaction;multi-agent system;synergy;trust metric	Estefania Argente;Olivier Boissier;Carlos Carrascosa;Nicoletta Fornara;Peter McBurney;Pablo Noriega;Alessandro Ricci;Jordi Sabater-Mir;Michael Ignaz Schumacher;Charalampos Tampitsikas;Kuldar Taveter;Giuseppe Vizzari;George A. Vouros	2012	Artificial Intelligence Review	10.1007/s10462-012-9388-1	computer science;organization;knowledge management;natural environment;trustworthy computing;negotiation;norm	AI	-43.04612815804382	19.242150109827673	98305
6175e34f0f6bcf74971b8f96b6dcadafade10468	a formal model for component-based embedded software development	software;functional view;formal specification;refinement rule component based embedded software development formal specification model formal verification model formal composition model syntactical view functional view qos view synchronization view;formal model;application software;component;functional properties;refinement rule;connector;contracts;synchronization view;object oriented programming;computer industry;program verification;syntactical view;embedded system;formal verification model;connectors;embedded systems;non functional properties;component based embedded software development;contract;embedded software embedded system contracts connectors programming application software safety costs software quality computer industry;software quality embedded systems formal specification object oriented programming program verification;non functional properties component contract connector embedded software;safety;formal specification model;formal composition model;fires;programming;software quality;qos view;embedded software	This paper presents a formal model for specification, verification, and composition of component-based embedded software. We describe how components are specified from the syntactical view, functional view, QoS view and synchronization view. The refinement rules for functionality, QoS, and synchronous behavior are defined for the verification purpose. And a lightweight composition method is provided for the purpose of composition.	component-based software engineering;conformance testing;correctness (computer science);embedded software;embedded system;formal language;formal specification;markov chain;mathematical model;model transformation;object composition;qml;quality of service;refinement (computing);software development;systems architecture;twisted pair;usability	Changde Li;Xingshe Zhou;Yunwei Dong;Zhiwen Yu	2009	2009 International Conference on Embedded Software and Systems	10.1109/ICESS.2009.51	contract;embedded system;programming;application software;real-time computing;embedded software;computer science;formal specification;component;programming language;software quality	Embedded	-41.893118371406516	31.765608692649458	98341
65cd370fd10aeccc5f00e02e00e36846026f0518	an engineering approach to cooperating agents for distributed information systems	distributed system;knowledge based system;agent based;agent modeling;cooperative agents;multi agent;distributed information systems;real world application;distributed information system;cooperating knowledge based systems;manufacturing industry	This paper presents a multi-agent model of a distributed information system, using what is described as an engineering approach to real world application environment. The objective is to define, using proven ideas in the industrial context, the agent-based behaviour of the distributed system, which must operate correctly and effectively in an error-prone environment. Issues such as stability, robustness and scalability have also been addressed, along with some new ideas on a high-level communication strategies, as distinct from protocol-based communications. The work is being carried out under the DREAM theme at Keele, an earlier version of the approach having been successfully applied to agent-based manufacturing in an international project called HMS, in which some of the world’s major manufacturing industries participated.	agent-based model;cognitive dimensions of notations;distributed computing;health management system;high- and low-level;information system;multi-agent system;scalability	S. Misbah Deen	2005	Journal of Intelligent Information Systems	10.1007/s10844-005-0863-x	simulation;computer science;knowledge management;artificial intelligence;knowledge-based systems;manufacturing	Robotics	-42.75567961745808	21.13005419414878	98346
f7ba7487f079b4b58a6781a53791305866febd51	transforming state-based models to p systems models in practice	ant colony;p system;biological systems;machine model	We present an automatic practical transformation of Communicating X-machines to Population P Systems. The resulting compiler is able to take as input a Communicating X-machine model written in an appropriately designed language (XMDL) and produce a Population P System in another notation (PPSDL). The latter contains only transformation and communication rules. However, the user can further enhance the models with more rules that deal with the reconfiguration of structure of the network of cells. XMDL, PPSDL and their accompanied compilers and animators are briefly presented. The principles of transformations and the transformation templates of the compiler are discussed. We use an example model of a biological system, namely an ant colony, to demonstrate the usefulness of this approach.	p system	Petros Kefalas;Ioanna Stamatopoulou;George Eleftherakis;Marian Gheorghe	2008		10.1007/978-3-540-95885-7_19	computer science;artificial intelligence;theoretical computer science;algorithm	SE	-36.255095263121746	27.298971330124903	98427
f0933612018c3ae7c71661478f1fb5d32a722e2f	designing cooperating multi-agent systems — an extended design methodology		Within production systems various control decisions have to be taken to ensure a proper system behavior in a distributed but consistent way. Multi-agent systems can be considered as an efficient implementation mean for distributed control architectures. However, an agent-based control system cannot be implemented in a single moment, following a one-shot approach, within a complex production system. To overcome this problem this paper is presenting a step wise engineering approach for agent-based control systems to design multi-agent systems solving special control problems and combining them in an appropriate way to a larger agent-based control system.	agent-based model;data validation;distributed control system;multi-agent system;production system (computer science);stepwise regression;systems modeling language	Jacek Zavisa;Arndt Lüder;Ambra Calá	2018	2018 IEEE Industrial Cyber-Physical Systems (ICPS)	10.1109/ICPHYS.2018.8387668	control engineering;design methods;unified modeling language;engineering;multi-agent system;control system	Robotics	-41.61370752723262	22.33681087467231	98520
02801d4fac32cfa64354a1346fc565086f097dba	applied system simulation: a review study	simulation experiment;level of detail;applications of simulation;system analysis;verification and validation;system simulation;application of simulation;simulation model;trace driven simulation;discrete event simulation	This paper deals with a tutorial study of applied system simulation. We present the applications of system simulation, simulation types, and elaborate on discrete-event simulation, DES. Then we explain the level of details needed in a simulation model. We investigate the signi®cance of simulation experiments and explain in detail the standard methodology used in the development of a simulation model. The steps include: problem formulation and planning, system abstraction, resource estimation, system analysis, veri®cation and validation, and implementation. Finally, we present a detailed case study using SIMSCRIPT II.5 simulation language. Ó 2000 Elsevier Science Inc. All rights reserved.	automated planning and scheduling;experiment;simscript ii.5;simulation language;system simulation;system analysis	Balqies Sadoun	2000	Inf. Sci.	10.1016/S0020-0255(99)00079-1	computer simulation;computational science;dynamic simulation;verification and validation of computer simulation models;verification and validation;simulation;computer science;discrete event simulation;level of detail;simulation modeling;system analysis	AI	-35.64411177694201	27.315173999806944	98576
19c451ef6f3fb6d6f909bf7527ee2f06fa46607a	modularization of model transformations through a phasing mechanism	transformation languages;phasing mechanism;rule based;model transformation;internal transformation composition;modularity	In recent years a great effort has been devoted to understanding the nature of model transformations. As a result, several mechanisms to improve model transformation languages have been proposed. Phasing has been mentioned in some works as a rule scheduling or organization mechanism, but without any detail. In this paper, we present a phasing mechanism in the context of rule-based transformation languages. We explain the structure and the behavior of the mechanism, and how it can be integrated in a language. We also analyze how the mechanism promotes modularity, internal transformation composition and helps to solve usual transformation problems. Besides, we show several examples of application to illustrate the usefulness of the mechanism.	interoperability;karp's 21 np-complete problems;logic programming;metamodeling;model transformation language;qvt;scheduling (computing);tefkat;tracing (software);two-phase commit protocol	Jesús Sánchez Cuadrado;Jesús García Molina	2008	Software & Systems Modeling	10.1007/s10270-008-0093-0	rule-based system;computer science;artificial intelligence;modularity;algorithm	AI	-43.389330331305004	23.745996787914073	98729
3e3b6e5417789bef59bf725074e52c37a109f792	integrating a mas and a pandemonium: the open-source framework akira	multiagent system;pandemonium;multiagent systems;open source	The open-source framework AKIRA integrates Multiagent and Pandemonium elements. We describe the main components of the framework, showing that the hybrid nature of the Agents, having symbolic and connectionist features, permits to model many functionalities such as implicit communication and coordination.	agent-based model;connectionism;open-source software;pandemonium!;software agent	Giovanni Pezzulo;Gianguglielmo Calvi;Rino Falcone	2005		10.1145/1082473.1082727	real-time computing;simulation;computer science;knowledge management;artificial intelligence;multi-agent system	AI	-41.66818362782767	20.214436548908377	98788
0d3192c41d63ad0433cd89716fa1e93139b30bd3	efficient design of system test: a layered architecture	layered architecture;system level functional test patterns;complex embedded systems;functional testing;automatic test pattern generation;embedded system;magnetic materials;design specifications;automatic test pattern generation logic testing high level synthesis embedded systems;test environment;computer architecture;embedded systems;high level synthesis;research and development;automotive applications;automotive applications system test layered architecture design specifications system level functional test patterns complex embedded systems high level parts test environment;unified modeling language;logic testing;system testing;high level parts;system testing unified modeling language embedded system automotive applications international collaboration magnetic materials computer architecture embedded software research and development design methodology;system test;embedded software;design methodology	Startingfrom the idea of a general methodologl. to transform design specifications into system level functional tesf patterns for complex embedded systems, w propose a layered architecture as basis of such process. The architecture aims at strongly simpli$ving the test design, allowing the test engineer to concenhate on the high level parts of the system and wrapping all the complexity of the test environment. The results are then verified on a complex case study of automotive applications.	deployment environment;embedded system;high-level programming language;system testing;test design;test engineer;wrapping (graphics)	Andrea Baldini;Alfredo Benso;Paolo Prinetto;Sergio Mo;Andrea Taddei	2002		10.1109/TEST.2002.1041848	embedded system;computer science;systems engineering;engineering;system testing;computer engineering	EDA	-47.96246635264797	32.27802686692819	98861
cd3f846b933a21e6b65e17b1d069d3c387846d35	a practical assessment of formal specification approaches for data abstractions	developpement logiciel;ciclo desarrollo;formal specification;life cycle;methode;ingenieria logiciel;abstract data type;specification programme;etat machine;software engineering;methode algebrique;desarrollo logicial;algebraic method;type abstrait;software development;data abstraction;cycle developpement;genie logiciel;tipo abstracto;metodo algebraico;program specification;metodo;method;especificacion programa	Formal methods capable of precisely describing the properties and the externally provided functionality of abstract data types (ADTs) continue to be a major area of theoretical and practical research, mainly in the preimplementation phases of the software life cycle. We describe an assessment of these methods and discuss various issues related to every method and several extensions developed to tackle the inherent limitations of the methods in various scopes. The methods are presented along with application examples and are compared and contrasted using a set of criteria including comprehensibility, minimality, ease of construction, and executability.	formal specification	K. P. Ventouris;Panayiotis E. Pintelas	1992	Journal of Systems and Software	10.1016/0164-1212(92)90094-Z	biological life cycle;method;computer science;artificial intelligence;software development;software engineering;formal specification;programming language;abstract data type;algorithm	SE	-42.719321486186246	26.653216121332854	98892
64cb274f7d8c5c25d04c8dabe29e30e684e991f2	data flow between tools: towards a composition-based solution for learning design	data flow validation;electronic learning;protocols;design automation;composition based solution;data flow management;learning design;data flow between tools;ims learning design;service automation;computer architecture;system intervention;software tools data flow analysis;animation;data visualization;data flow analysis;software tools;data flow automation;cognitive load;data flow;proposals;data flow validation data flow between tools composition based solution learning design ims learning design specification system intervention data flow management service automation data flow automation;design automation concrete data visualization proposals computer architecture electronic learning protocols animation;concrete;ims learning design specification	Data flow between tools cannot be specified using the current IMS Learning Design specification (LD). Nevertheless by specifying this data flow between tools, several degrees of activity automation may augment the system intervention opportunities for data flow management. Service automation, data flow automation and data flow validation may enhance the continuity of the learning design realization, reduce the student's cognitive load and obtain system-support for error prone situations. In this paper a novel approach based on the composition of LD and a standard workflow technology is proposed. Unlike other current approaches, our approach maintains interoperability with both LD and workflow standards. Then an architectural solution based on the composition approach is presented.	cognitive dimensions of notations;dataflow architecture;interoperability;scott continuity	Luis Palomino Ramírez;Alejandra Martínez-Monés;Miguel L. Bote-Lorenzo;Juan I. Asensio-Pérez;Yannis A. Dimitriadis	2007	Seventh IEEE International Conference on Advanced Learning Technologies (ICALT 2007)	10.1109/ICALT.2007.110	anime;data flow diagram;communications protocol;simulation;concrete;computer science;operating system;data-flow analysis;database;cognitive load;world wide web;data visualization	EDA	-48.08067659562656	27.995366592044263	98907
48dd84e681ad6c6f83509c7f7f56ac60d1773091	design patterns for policy-based service engagements	hurricanes delta modulation computer science usa councils scientific computing processor scheduling vocabulary conferences grid computing atmospheric modeling;business perspective policy based service engagements contractual arrangement virtual organization;commitments;multiagent system;policies;hospitals;object oriented programming;policy based service engagements;business perspective;service engagements;computational modeling;contractual arrangement;chromium;multiagent systems design patterns service engagements policies commitments;qualifications;virtual organization;business;design pattern;scientific computing;design patterns;technical report;organizations;discharges;multiagent systems	Service engagements arise commonly in business and scientific computing. A service engagement is characterized by autonomous parties coming together in a contractual arrangement to share resources or carry out tasks for one another. Recent work shows how to model service engagements in an interactive manner and at a high level. This work formalizes the atoms of a service engagement as commitments among the participants, to be created and manipulated as the engagement progresses. Further, it scopes the commitments of an engagement in a (virtual) organization, and specifies how the policies of the participants affect their interactions. This paper contributes design patterns for service engagements formulated in terms of roles, commitments, and allied concepts. Each pattern reflects a distinct element of a service engagement from a business perspective and highlights exactly where policies apply. This enables the perspicuous, reusable specification of service engagements.	autonomous robot;computational science;design pattern;high-level programming language;interaction;virtual organization (grid computing)	Yathiraj B. Udupi;Munindar P. Singh	2008	2008 IEEE Workshop on Policies for Distributed Systems and Networks	10.1109/POLICY.2008.38	simulation;knowledge management;operations management;service design;business	HCI	-42.811457754815116	18.746222147535885	98971
54c69a305187103962cbf2a4033e690bb648ce73	on observing and constraining active systems	systeme base agent;distributed system;multiagent system;systeme reparti;sistema activo;composant logiciel;systeme actif;active system;sistema repartido;agent based system;software component;sistema multiagente;systeme multiagent	While agents have emphasised the notion of active software components, they are not likely to be the only active components in agent-based systems. In this paper, we first discuss the general notion of active system, and show how it relates with the issue of the consistent observation of distributed and heterogeneous multi-component systems. Then, we introduce the concept of boundary interface as a methodological abstraction for the engineering of active systems, which allow observer agents to be provided with three different kind of consistent system views, featuring observable, controlled, and constrained consistency,	agent-based model;component-based software engineering;observable	Gianluca Moro;Mirko Viroli	2000		10.1007/3-540-44539-0_3	simulation;computer science;artificial intelligence;component-based software engineering;distributed computing;programming language	Robotics	-39.51997577851176	24.395756617834902	99035
0963064b05250e7aaf277591220bd89bbfec4736	mercurio: an interaction-oriented framework for designing, verifying and programming multi-agent systems	multi agent system	This is a position paper reporting the motivations, the starting point and the guidelines that characterise the MERCURIO project proposal, submitted to MIUR PRIN 2009. The aim is to develop formal models of interactions and of the related support infrastructures, that overcome the limits of the current approaches by explicitly representing not only the agents but also the computational environment in terms of rules, conventions, resources, tools, and services that are functional to the coordination and cooperation of the agents. The models will enable the verification of interaction properties of MAS from the global point of view of the system as well as from the point of view of the single agents, due to the introduction a novel social semantic of interaction based on commitments and on an explicit account of the regulative rules.	computation;interaction;multi-agent system;point of view (computer hardware company)	Matteo Baldoni;Cristina Baroglio;Federico Bergenti;Antonio Boccalatte;Elisa Marengo;Maurizio Martelli;Viviana Mascardi;Luca Padovani;Viviana Patti;Alessandro Ricci;Gianfranco Rossi;Andrea Santi	2010			position paper;management science;multi-agent system;computer science	AI	-42.837385780285416	20.059282224490417	99076
a140745ceb153f05ec85d6702623bfa177c86efd	formal designs for embedded and hybrid systems	formal methods;tcoz;hybrid system;timed hybrid systems	The design of embedded and hybrid systems requires powerful mechanisms for modeling data, state, concurrency and real-time behaviour. The first part of this paper illustrates a powerful design notation Timed Communicating Object Z (TCOZ) that has both channel based and sensor/actuator based interfaces. We believe that TCOZ is well suited for presenting more complete and coherent design models for complex embedded and hybrid systems. However, the challenge is how to analyze and check these models with tools support. One effective approach is to project (transform) the design models into multiple domains, then to use existing specialized tools in those domains to perform the checking and analyzing tasks. The second part of this paper demonstrates one particular projection from TCOZ designs to Timed Automata (TA) models so that TA model checkers can be used to check time related properties.	coherence (physics);concurrency (computer science);embedded system;high-level programming language;hybrid system;level design;model checking;object-z;real-time transcription;state (computer science);timed automaton;wang tile	Jin Song Dong;Ping Hao;Brendan P. Mahony	2005	International Journal of Software Engineering and Knowledge Engineering	10.1142/S0218194005002117	real-time computing;formal methods;computer science;theoretical computer science;programming language;algorithm;hybrid system	Embedded	-39.798474876130626	31.858993019194553	99089
3b777bb7def8418102b3616f4d4121021241532d	a uniform framework for the formal specification and verification of information flow security	formale spezifikationstechnik;possibilitatstheorie;informationsfluss	In this thesis, we elaborate a uniform basis for the systematic investigation of possibilistic information flow properties. These properties are suitable for specifying security requirements formally such that they can be verified with mathematical rigor. We analyze the variety of known properties, propose new ones, and develop techniques that simplify their verification. To this end, we introduce MAKS, a uniform framework for the investigation of information flow properties. The two basic ideas underlying MAKS are: firstly, to separate application specific aspects of an information flow property from more application-independent aspects and, secondly, to express the latter aspects by assembling primitive building blocks. This modular representation provides a basis for reducing complex reasoning about information flow properties to reasoning about conceptually simpler building blocks. Following this approach, we analyze several information flow properties from the literature, elaborate their advantages and disadvantages, and derive a taxonomy of these properties. In this process, we discover several novel information flow properties that constitute improvements of known ones. Moreover, we exploit the modular representation for developing verification techniques for information flow properties. In particular, we derive unwinding results that reduce the verification of information flow properties to the verification of simpler unwinding conditions. We also derive compositionality results that support the verification task to the verification of the individual system components. The applicability of our results is demonstrated by several examples and also by a complex case study from the area of language-based security. #N#Die vorliegende Arbeit prasentiert einen Ansatz zur systematischen Untersuchung possibilistischer Informationsflusseigenschaften. Diese Klasse von Eigenschaften eignet sich fur die formale Spezifikation von Sicherheitsanforderungen hinsichtlich Vertraulichkeit und Integritat und ermoglicht es, solche Anforderungen mit mathematischer Genauigkeit zu beweisen. Die aus der Literatur bekannten Informationsflusseigenschaften werden in der Arbeit eingehend analysiert und verglichen, neue Eigenschaften werden synthetisiert, und es werden Verifikationstechniken fur Informationsflusseigenschaften vorgeschlagen.		Heiko Mantel	2003		10.22028/D291-25715	computer science;artificial intelligence;algorithm	Security	-40.01676479363585	27.240133410741766	99444
8871241b268615a5309434e20ab6a089863ec896	using meta-modelling and graph grammars to process gpss models	graph transformation;automatic generation;agriculture and food sciences;graph grammar;discrete event;meta model	This paper discusses the benefits of combining metamodelling and graph transformations to automatically generate modelling tools for simulation formalisms. In metamodelling, formalisms are modelled in their own right at a meta-level within an appropriate meta-formalism. A meta-model processor uses this information to automatically generate tools to process –create, edit, check, optimize, transform and generate simulators for– the models in the described formalism. We propose the representation of (meta-)models as graphs, and subsequently specify model manipulations as graph grammars. We also present AToM3, A Tool for Multi-formalism and Meta-Modelling which implements these concepts. As an example, we show how to build a meta-model for the popular process interaction discrete event language GPSS in AToM3. From this meta-model, AToM3 automatically generates a visual tool to build GPSS models. We also define a graph grammar to generate textual code for the HGPSS simulator from the graphically specified GPSS models.	gpss;graph rewriting;metamodeling;semantics (computer science);simulation	Juan de Lara;Hans Vangheluwe	2002			natural language processing;computer science;clique-width;theoretical computer science;machine learning;graph;graph rewriting	SE	-34.44799186116441	25.384357494503245	99474
3a0395131072e1ab61b4cd280511b546898f8d3f	programming multi-agent systems	commitments;multi agent system;knowledge management;semantics;bdi;coordination	PROMAS (Programming Multi-Agent Systems) is an AgentLink technical forum that aims to bring together the researchers and practitioners from both academia and industry to discuss the problems related to the development of multi-agent systems and to evaluate the existing proposals and results. The specific focus of this technical forum is on agent-oriented programming languages and tools that can effectively and efficiently support the implementation of multi-agent systems. This paper provides an overview of the main contributions and conclusions derived from the first two editions of PROMAS technical forum.	multi-agent system	Mehdi Dastani;Jorge J. Gómez-Sanz	2005	Knowledge Eng. Review	10.1017/S0269888905000482	computer science;knowledge management;artificial intelligence;belief–desire–intention software model;semantics;management science	AI	-42.478823640863965	18.904984059136332	99717
af08786d6a7f4dd6e25da51358c01fda4cd88556	verification and evaluation of computer and communication systems		Our society is increasingly reliant on complex networking systems, consisting of several components that operate in a distributed and concurrent fashion, exchange data that may be highly sensitive, and are implemented with a mix of open and closed-source code. In this talk, we will present a broad overview of techniques and tools to automate the modelling and verification of networking software systems. We will focus mainly on the model learning paradigm, originally proposed in artificial intelligence, to automatically build an automaton model of a running system in a black-box fashion — purely via interactions with the running system.	artificial intelligence;automaton;black box;concurrent computing;distributed computing;interaction;programming paradigm;software system	Saddek Bensalem;Simon Bliudze;Bruno Monsuez	2018		10.1007/978-3-030-00359-3	engineering physics;computer-mediated communication;computer science	OS	-41.497546066359305	20.96020624409137	99720
5c13b1dfa115e3a53530bd3c540e7347fa5a88db	embedding ergonomic rules as generic requirements in a formal development process of interactive software		This paper presents a formal framework for the development of interactive software that bridges the gap between ergonomic knowledge and software design. It builds upon previous work on formal notations and proposes an integrated development process from requirements to model-based execution. It also embeds ergonomic knowledge in requirements, and proposes a way to formally represent them and to prove their fulfilment over a detailed formal specification of the interactive software.	estimation of signal parameters via rotational invariance techniques;formal specification;graphical model;human factors and ergonomics;petri net;requirement;run time (program lifecycle phase);software design;temporal logic	Philippe A. Palanque;Christelle Farenc;Rémi Bastide	1999			human–computer interaction;software;human factors and ergonomics;computer science;embedding	SE	-43.92650509662935	31.569171799160724	99865
0e453bb16c69b135988c84580aae9153c597a776	an optimised design for agent capability reuse	optimised design;reusable information systems;optimisation;8903 information services;object oriented methods;software reusability cooperative systems object oriented methods software agents;component based systems;presses;system components agent capability reuse optimised design reusable information systems system design component based systems object oriented systems self organising ability;school of engineering and science;respubid19703;software agents;self organising ability;object oriented systems;mathematical model presses equations intelligent agent buildings redundancy;agents;redundancy;optimisation multi agents agents capability reuse;cooperative systems;mathematical models;system design;agent based system;software reusability;intelligent agent;mathematical model;system components;agent capability reuse;information system;capability reuse;0806 information systems;buildings;multi agents	In spite of the rising demands for reusable information systems, current designs are still insufficient in providing efficient reusable mechanisms for system design. One of the major problems hindering the development of information reuse in most traditional systems, which include component-based systems and object-oriented systems, is the lack of the self-organising ability among the system components or subsystems. The emergence of intelligent agent-based technology is able to solve the problems plaguing many traditional systems. In this paper we introduce an optimised design for agent-based systems, which is able to provide an efficient process for agent capability reuse. An experimental program is developed to evaluate the performance of the proposed design.	agent-based model;cpu cache;cartesian closed category;component-based software engineering;emergence;information system;intelligent agent;internationalized domain name;self-organization;systems design	Hao Lan Zhang;Clement H. C. Leung;Xinghuo Yu;Jing He	2010	2010 IEEE/WIC/ACM International Conference on Web Intelligence and Intelligent Agent Technology	10.1109/WI-IAT.2010.154	real-time computing;simulation;computer science;artificial intelligence;software agent;mathematical model;intelligent agent	Robotics	-40.39556702295404	19.35978906828128	99924
95a6ad753f8e012e97784a84f58da3ddd72b04ed	a logic-based infrastructure for reconfiguring applications	reconfiguration;outil logiciel;reconfiguracion;software tool;multiagent system;performance monitoring;componente logicial;agent based;programming environment;surveillance;cooperation;software management;declarative langage;langage declaratif;composant logiciel;logical programming;sistema complejo;component based software;cooperacion;medio ambiente programacion;vigilancia;systeme complexe;monitoring;programmation logique;complex system;agent intelligent;software component;intelligent agent;coordinacion;agente inteligente;monitorage;logic programs;sistema multiagente;monitoreo;herramienta software;programacion logica;supervision;lenguaje declarativo;gestion logiciel;environnement programmation;systeme multiagent;coordination	This paper proposes the DALI Multiagent System, which is a logic programming environment for developing agent-based applications, as a tool for component-based software management based on coordination. In particular we show the usefulness of the integration between DALI and the agent-based Lira system, which is a Light-weight Infrastructure for Reconfiguring Applications. We argue that using intelligent agents for managing component-based software systems makes it possible to: (i) perform monitoring and supervision upon complex properties of a system, such as for instance performance; (ii) perform global reconfigurations dynamically through the cooperation of intelligent agents.	agent-based model;component-based software engineering;integrated development environment;intelligent agent;logic programming;multi-agent system;software project management;software system	Marco J Castaldi;Stefania Costantini;Stefano Gentile;Arianna Tocchio	2003		10.1007/978-3-540-25932-9_2	embedded system;simulation;computer science;artificial intelligence;control reconfiguration;component-based software engineering;programming language;intelligent agent;cooperation	AI	-39.38235281921836	24.236734356262414	99973
6b3ac150d6ff7d1969b653cccc943793d7ad5d28	generating commercial web applications from precise requirements and formal specifications	web based applications;application framework;formal specification;user interface;model based approach;automated reasoning;data model;formal verification;user requirements;proof of correctness	We present a new model-based approach that we are using to build commercial webbased applications. The user requirements together with a data model are formally specified in a graphical notation using the CREATIV toolset. The specification may be checked by animation before being automatically translated to Perfect notation. The Perfect Developer toolset uses automated reasoning to generate formal proofs of correctness. It then generates C++ or Java code which, in conjunction with an application framework also written in Perfect, forms the complete application including the HTML user interface. The whole process provides a rapid turnaround from new requirements to a formally-verified application.	application framework;automated reasoning;buffer overflow;business models for open-source software;c++;concurrency (computer science);correctness (computer science);cross-site scripting;data model;first-order logic;formal specification;formal verification;graphical user interface;html;java;perfect developer;reasoning system;relational model;requirement;user requirements document;web application;well-formed element;workbench	David Crocker;John H. Warren	2005			web application;formal verification;data model;computer science;theoretical computer science;user requirements document;formal specification;database;automated reasoning;programming language;user interface	SE	-44.82295071977044	30.0711054729765	100027
642abe9a0cdea4ab18ad12bfaf20f6c5133da385	a classification scheme of erroneous behaviors for human error probability estimations based on simulator data	unsafe act;simulator data;human error probability;human reliability analysis	Because it has been indicated that empirical data supporting the estimates used in human reliability analysis (HRA) is insufficient, several databases have been constructed recently. To generate quantitative estimates from human reliability data, it is important to appropriately sort the erroneous behaviors found in the reliability data. Therefore, this paper proposes a scheme to classify the erroneous behaviors identified by the HuREX (Human Reliability data Extraction) framework through a review of the relevant literature. A case study of the human error probability (HEP) calculations is conducted to verify that the proposed scheme can be successfully implemented for the categorization of the erroneous behaviors and to assess whether the scheme is useful for the HEP quantification purposes. Although continuously accumulating and analyzing simulator data is desirable to secure more reliable HEPs, the resulting HEPs were insightful in several important ways with regard to human reliability in off-normal conditions. From the findings of the literature review and the case study, the potential and limitations of the proposed method are discussed.	cellular automaton;human error	Yochan Kim;Jinkyun Park;Wondea Jung	2017	Rel. Eng. & Sys. Safety	10.1016/j.ress.2017.01.022	reliability engineering;simulation;human error;statistics;categorization;data extraction;data mining;classification scheme;human reliability;computer science	ML	-35.6477453560412	19.40475708405603	100115
24c20d4542f73181028841742134b26846f560a0	strong and weak contract formalism for third-party component reuse	wheel braking system strong contract formalism weak contract formalism third party component reuse safety contract notion safety related information software components reuse safety critical systems out of context reusable components satisfaction notion refinement check dominance check composition check;contracts safety context timing standards wheels monitoring;object oriented programming;engineering and technology;teknik och teknologier;software reusability object oriented programming safety critical software;component reuse;safety critical software;software reusability	Our aim is to contribute to bridging the gap between the justified need from industry to reuse third-party components and skepticism of the safety community in integrating and reusing components developed without real knowledge of the system context. We have developed a notion of safety contract that will help to capture safety-related information for supporting the reuse of software components in and across safety-critical systems. In this paper we present our extension of the contract formalism for specifying strong and weak assumption/guarantee contracts for out-of-context reusable components. We elaborate on notion of satisfaction, including refinement, dominance and composition check. To show the usage and the expressiveness of our extended formalism, we specify strong and weak safety contracts related to a wheel braking system.	bridging (networking);component-based software engineering;critical system;formal system;refinement (computing);semantics (computer science);shortest seek first;specification language;third-party software component;video synopsis	Irfan Sljivo;Barbara Gallina;Jan Carlson;Hans A. Hansson	2013	2013 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)	10.1109/ISSREW.2013.6688921	reliability engineering;computer science;systems engineering;engineering;software engineering;programming language;object-oriented programming	SE	-42.74650841601917	29.2741683103566	100168
cbe4cce2187c97d5e595f0dca6e42b0b58b2fe7b	compositional branching-time measurements		Formal methods are used to increase the reliability of software and hardware systems. Methods such as model checking, verification and testing are used to search for design and coding errors, integrated in the process of system design. Beyond checking whether a system satisfies a particular specification, we may want to measure some of its quantitative properties. Earlier works on system measurements suggest extending model checking techniques to measure quantitative artifacts, based on weights associated with the transitions of a transition system. Other works allow counting while performing model checking or runtime verification. This paper presents a simple and efficient compositional measuring framework based on quantitative state testers. The framework allows combining multiple measures, such as distance and power consumption, using a variety of functions, such as min, max, and average. This supports calculation of interesting compound measures that quantitatively characterize a system’s behavior.	artifact (software development);formal methods;model checking;multistage interconnection networks;runtime verification;systems design;transition system	Radu Grosu;Doron A. Peled;C. R. Ramakrishnan;Scott A. Smolka;Scott D. Stoller;Junxing Yang	2014		10.1007/978-3-642-54848-2_8	model checking;coding (social sciences);software;runtime verification;transition system;branching (version control);theoretical computer science;systems design;formal methods;computer science	SE	-40.19093967218076	30.37693550891514	100537
4d7f0f6e49fc40788316c98670a5978abfe3946a	regulatory issues and recommendations associated with use of high resolution drone detect & avoid (d&a) including for 5g applications		This paper discusses some key issues and operational characteristics of a commercial drone based Du0026A, and makes recommendations in regards to future spectral opportunities and regulatory framework that meet the technical performance needs of high resolution Detect u0026 Avoid (Du0026A) function for small UAVs (unmanned aerial vehicle).		Reza Arefi;Richard D. Roberts;Mark E Davis	2018	2018 IEEE 29th Annual International Symposium on Personal, Indoor and Mobile Radio Communications (PIMRC)	10.1109/PIMRC.2018.8580868	real-time computing;computer science	Arch	-33.71739909824392	21.734434020708424	100613
9f6647fe6f97b6eb6f73994972f184cc4a26eaca	certifying airport security regulations using the focal environment	modelizacion;teoria demonstracion;theorie preuve;formal specification;proof theory;metodo formal;methode formelle;parameterization;air transportation;program verification;parametrizacion;formal method;specification formelle;modelisation;airport;especificacion formal;transport aerien;transporte aereo;verificacion programa;object oriented;oriente objet;aeropuerto;verification programme;modeling;orientado objeto;parametrisation;aeroport	We present the formalization of regulations intended to ensure airport security in the framework of civil aviation. In particular, we describe the formal models of two standards, one at the international level and the other at the European level. These models are expressed using the Focal environment, which is also briefly presented. Focal is an object-oriented specification and proof system, where we can write programs together with properties which can be proved semi-automatically. We show how Focal is appropriate for building a clean hierarchical specification for our case study using, in particular, the object-oriented features to refine the international level into the European level and parameterization to modularize the development.	airport security;focal (programming language)	David Delahaye;Jean-Frédéric Étienne;Véronique Donzeau-Gouge	2006		10.1007/11813040_4	parametrization;simulation;formal methods;computer science;proof theory;formal specification;programming language;computer security;algorithm	Crypto	-41.53944667504823	26.992617551189152	100629
9e94973503632d4eb8f8c104db9d496363007133	specifying rules for electronic auctions	formal parameter;configurable marketplace;precise specification;auction mechanism;design space;auction rule;specifying rule;auction description language;core activity;auction design;new possibility;electronic auction	We examine the design space of auction mechanisms and identify three core activities that structure this space. Formal parameters qualifying the performance core activities enables precise specification of auction rules. This specification constitutes an auction description language that can be employed in the implementation of configurable marketplaces. The specification also provides a framework for organizing previous work and identifying new possibilities in auction design.	organizing (structure)	Peter R. Wurman;Michael P. Wellman;William E. Walsh	2002	AI Magazine		simulation;combinatorial auction;computer science;auction theory	HCI	-45.248321160545835	19.31505107168682	100656
49c8a48dedb270ca3a1e2885884d8e59de1f8f5f	agents and artefacts for multiple models co-evolution: building complex system simulation as a set of interacting models	modeling and simulation;p2p;simulation techniques;software engineering;computer network;complex system;simulation technique;multiple model;complex systems;interaction model;modelling and simulation;coordination model;tools and environments	Complex systems simulations generally involve the interaction of different scientific fields. Human economies, ecosystems or dynamic computer networks such as P2P are good examples. Since models and simulators already exist in those fields, designing the simulation as a society of interacting and co-evolving models appears attractive. Beyond the technical issues to make different simulators cooperate, the challenges are to make the co-evolution design and implementation easier for the users that rarely know intricate modelling and simulation tools, and to facilitate the collaboration of different experts. Agents and artefacts (A&A) paradigm simplifies the design and the implementation of a society of interacting and co-evolving models. That is, the addition, the removal or the interchange of models require less effort. Contrary to classical approaches, we have built a decentralized co-evolution architecture based upon A&A and a data-driven coordination model. In this article, beyond the architecture presentation, we focus on the benefit provided by A&A used for multiple models co-evolution.	complex system;complex systems;ecosystem;evolution;interaction;peer-to-peer;programming paradigm;simulation	Julien Siebert;Laurent Ciarletta;Vincent Chevrier	2010		10.1145/1838206.1838279	complex systems;verification and validation of computer simulation models;simulation;human–computer interaction;computer science;systems simulation;peer-to-peer	Metrics	-42.3493164128378	21.81718870750089	100682
fe9ff37a43c80018c849b474416b80be88cfc040	a platform for agent behavior design and multi agent orchestration	developpement logiciel;agent platform;modelizacion;dependencia dato;lenguaje programacion;distributed system;outil logiciel;besoin de l utilisateur;interfase usuario;interfaz grafica;groupware;data dependency;software tool;design tool;multiagent system;sistema experto;systeme reparti;multi agent system;programming language;design and development;graphical interface;agent based;user interface;rule based system;exigence usager;exigencia usuario;base connaissance;abstraction;necesidad usuario;intelligence artificielle;specification programme;abstraccion;modelisation;sistema repartido;user need;levels of abstraction;desarrollo logicial;user requirement;software development;agent technology;dependance donnee;user requirements;langage programmation;graphic user interface;agent systems;artificial intelligence;base conocimiento;coordinacion;interface utilisateur;inteligencia artificial;systeme expert;sistema multiagente;software specification;herramienta software;control dependence;program specification;collecticiel;modeling;interface graphique;especificacion programa;systeme multiagent;coordination;knowledge base;expert system	Agents show considerable promise as a new paradigm for software development. However for wider adoption and deployment of agent technology, powerful design and development tools are needed. Such tools should empower software developers to cater agent solutions more efficiently and at a lower cost for their customers with rapidly changing requirements and differing application specifications. In this paper, an agent orchestration platform that allows the developers to design a complete agent-based scenario through graphical user interfaces is presented. The scenario produced by the platform is a rule based system in contrast to the existing systems where agents are coded through a programming language. In this way, the platform provides a higher level of abstraction to agent development making it easier to adapt to rapidly changing user requirements or differing software specifications. The system is highly transportable and interoperable. The platform helps to design a multi-agent system either from scratch, or by adapting existing distributed systems to multi agent systems. It contains tools that handle the agent system design both at the macro level, that is, defining the interaction between agents and at the micro level which deals with internal design of agents. Agent behaviour is modeled as a workflow of basic agent behaviour building blocks (such as receiving a message, invoking an application, making a decision or sending a message) by considering the data and control dependencies among them, and a graphical user interface is provided to construct agent behaviours. The platform allows agent templates to be constructed from previously defined behaviours. Finally through a Scenario Design Tool, a multi-agent system is designed by specifying associations among agents. The scenario is stored in a knowledge base by using the Agent Behaviour Representation Language (ABRL) which is developed for this purpose. Finally to be able to demonstrate the execution of the system on a concrete agent platform, we mapped the ABRL rules to JESS and executed the system on JADE. This work is supported by the European Commission’s IST Programme, under the contract IST-2000-31050 Agent Academy.	apl;academy;agent-based model;apache xerces;database;dependence analysis;design tool;distributed computing;gaia hypothesis;graphical user interface;interaction;interoperability;jade;java;knowledge base;level design;multi-agent system;ontology (information science);programming language;programming paradigm;programming tool;protégé;requirement;resource description framework;rule-based system;scenario (computing);semantics (computer science);software deployment;software developer;software development;systems design;user requirements document	Gokce Laleci;Yildiray Kabak;Asuman Dogac;Ibrahim Cingil;Serkan Kirbas;Ali Yildiz;Siyamed S. Sinir;Özer Özdikis;Ovgu Ozturk	2004		10.1007/978-3-540-30578-1_14	embedded system;simulation;systems engineering;engineering;autonomous agent;multi-agent system;intelligent agent	AI	-40.3445793720658	24.33619940221769	100713
42f1253a5c5aa75dc6110770513b39950ab0e331	from uml class diagrams to owl ontologies: a graph transformation based approach		Models are placed by modeling paradigm at the center of development process. These models are represented by languages, like UML the language standardized by the OMG which became necessary for development. Moreover the ontology engineering paradigm places ontologies at the center of development process, in this paradigm we find OWL (the description language adopted by a great community of users) the principal language for knowledge representation. The bridging between UML and OWL appeared on several regards such as the classes and associations. In this paper, we propose an approach based graph transformation and registered in the MDA architecture for the automatic generation of OWL ontologies from UML class diagrams. The transformation is based on transformation rules; the level of abstraction in these rules is close to the application in order to have usable ontologies.	bridging (networking);diagram;graph rewriting;knowledge representation and reasoning;ontology (information science);ontology engineering;programming paradigm;sms language;unified modeling language;web ontology language	Aissam Belghiat;Mustapha Bourahla	2012			uml tool;ontology (information science);theoretical computer science;class diagram;applications of uml;graph rewriting;unified modeling language;computer science	AI	-46.12861062897158	23.49932309883621	101035
0f4bb5921b3f75aa8aacfe007773a90d40909bf2	interplay: horizontal scale-up and transition to design in scenario-based programming	developpement logiciel;distributed system;iterative process;proceso concepcion;systeme reparti;design process;systeme grande taille;red petri;diagramme etat;simultaneidad informatica;large scale system;sistema reactivo;preparacion serie fabricacion;scenario;refinement method;proceso iterativo;processus iteratif;concurrency;sistema repartido;diagrama estado;argumento;desarrollo logicial;software development;script;reactive system;systeme reactif;state diagram;process planning;methode raffinement;petri net;preparation gamme fabrication;simultaneite informatique;metodo afinamiento;reseau petri;sistema gran escala;processus conception	"""We describe InterPlay, a simulation engine coordinator that supports cooperation and interaction of multiple simulation and execution tools, thus helping to scale up the design and development cycle of reactive systems. InterPlay involves a number of related ideas. In the first, we concentrate on the interobject design approach involving live sequence charts (LSCs) and its support tool, the play-engine, enabling multiple play-engines to run in cooperation. This makes possible the distributed design of large-scale systems by different teams, as well as the refinement of parts of a system using different play-engines. The second idea concerns combining the interobject approach with the more conventional intraobject approach, involving, for example, statecharts and Rhapsody. InterPlay makes it possible to run the play-engine in cooperation with Rhapsody, and is very useful when some system objects have clear and distinct internal behavior, or in an iterative development process where the design is implementation-oriented and the ultimate goal is to end up with an intraobject implementation. Finally, we have expanded the play-engine's ability to delegate some of the system's functionality to complex GUIs. This enables beneficial interaction with """"smart"""" GUIs that have built-in behavior of their own, and which are more naturally implemented in code"""	apple rhapsody;chart;iterative and incremental development;iterative method;refinement (computing);simulation	Dan Barak;David Harel;Rami Marelly	2003	IEEE Transactions on Software Engineering	10.1007/978-3-540-27755-2_2	state diagram;simulation;design process;concurrency;reactive system;computer science;artificial intelligence;scenario;software development;iterative and incremental development;petri net	SE	-38.75126050418454	25.35195909697176	101095
b841f14b2906087fc1c61b373a046c23b8c5e941	complete composition operators for ioco-testing theory	manuals;specification merging ioco model based testing decomposition;decomposition;standards;ioco;testing;automata;computational modeling;specification merging;testing context complex systems standards manuals computational modeling automata;complex systems;model based testing;specification method ioco testing theory input output conformance program testing;program testing formal specification;context	We extend the theory of input-output conformance with operators for merge and quotient. The former is useful when testing against multiple requirements or views. The latter can be used to generate tests for patches of an already tested system. Both operators can combine systems with different action alphabets, which is usually the case when constructing complex systems and specifications from parts, for instance different views as well as newly defined functionality of a~previous version of the system.	action algebra;complex systems;conformance testing;patch (computing);requirement;view (sql)	Nikola Benes;Przemyslaw Daca;Thomas A. Henzinger;Jan Kretínský;Dejan Nickovic	2015	2015 18th International ACM SIGSOFT Symposium on Component-Based Software Engineering (CBSE)	10.1145/2737166.2737175	complex systems;model-based testing;white-box testing;computer science;theoretical computer science;software engineering;conformance testing;functional testing;automaton;software testing;decomposition;programming language;computational model;algorithm	SE	-47.34532032197741	28.861289917143587	101281
d7269c6b1387e1fe2c2aa9293342ab45f678eafa	the devs-driven modeling language: syntax and semantics definition by meta-modeling and graph transformation	graphical modeling;graph transformation;meta modeling;devs;ddml	This paper presents the syntax and semantics of the DEVS-Driven Modeling Language (DDML), a simulation modeling formalism that combines visual modeling, discrete event simulation and formal analysis. The use of visual notations makes DDML highly communicable. Simulation and formal analysis are combined for verification, validation, and accreditation of models to ensure high integrity models. DDML is inspired by the Discrete Event System Specification (DEVS) formalism as its operational semantics adopts the DEVS simulation protocol. We present the definition of the syntaxes and semantics of DDML using meta-modeling and graph transformation techniques.	devs;graph rewriting;metamodeling;modeling language	Ufuoma Bright Ighoroje;Oumar Maïga;Mamadou Kaba Traoré	2012			natural language processing;computer science;theoretical computer science;devs;modeling language;sp-devs;programming language;operational semantics	NLP	-44.02830055785867	27.01416326113778	101422
f20fbb3c84025e6bb71fcff1be2d3472bb928c9d	a process for context-based technology evaluation: examples for the evaluation of web services technology	processing element;context aware services web services context software engineering business technology management service oriented architecture asynchronous communication web and internet services command and control systems;software performance evaluation internet;software performance evaluation;web service;web service technology context based technology evaluation;internet;competence development	This paper describes a process for evaluating the fitness of a technology within its anticipated specific context. The process includes hands-on experimentation with the technology to achieve a greater understanding of its implications as well as early competence development of the people conducting the experiments. Experiments use narrowly focused model problems to sustain or refute hypotheses about the examined technologies. This paper also includes examples of process elements for the evaluation of Web services technology.	experiment;hands-on computing;isis;interoperability;situated;web service	Grace A. Lewis;Lutz Wrage	2006	Fifth International Conference on Commercial-off-the-Shelf (COTS)-Based Software Systems (ICCBSS'05)	10.1109/ICCBSS.2006.2	web service;web application security;web development;web modeling;web standards;computer science;systems engineering;knowledge management;ws-policy;service-oriented architecture;services computing;web intelligence;world wide web	SE	-44.62250112389523	19.595841277096426	101539
9599d2b8c01f7ef8be954c4e6160a1a7b374cee4	multi-agent negotiation of virtual machine migration using the lightweight coordination calculus	openknowledge;multi agent systems;virtual machines;lightweight coordination calculus;autonomic computing	LCC is a Lightweight Coordination Calculus which can be used to provide an executable, declarative specification of an agent interaction model. In this paper, we describe an LCC-based system for specifying the migration behaviour of virtual machines in a datacentre. We present some example models, showing how they can be used to implement different policies for the machine allocation and migration. We then describe a practical implementation of the system which can directly execute the LCC specifications.	agent-based model;bandwidth (signal processing);data center;executable;interaction;portable document format;simulation;system migration;virtual machine	Paul Anderson;Shahriar Bijani;Alexandros Vichos	2012		10.1007/978-3-642-30947-2_16	real-time computing;simulation;computer science;virtual machine;artificial intelligence;multi-agent system;distributed computing;autonomic computing	PL	-39.40961060635571	22.8471277979129	101566
4496b5de4ae7f7dda611482ff38de9d06e454b83	ensuring containment constraints in graph-based model transformation approaches	mof;model transformation;graph transformation;emf;modeling language;formal method	Within model driven software development, model transformation has become a key activity. A number of transformation approaches for metamodel-defined modeling languages have been developed in the past years and are going to be established in research and industry. None of these have made it to a standard yet. There is a demand for correct model transformation in various senses. Formal methods are helpful for showing correctness issues of model transformations. As one approach, graph transformation has been applied to the field of model transformation and is a perspective for achieving provable correct model transformations. We show in this paper, thatcontainment associations as proposed by the OMG are an integral part of MOF-based languages and imply a couple of constraints which must be ensured in model transformation approaches. Based on a double-pushout approach to graph transformation, conditions are stated that ensure these containment constraints. This is an important step for achieving formal transformation semantics for modeling languages based on MOF, or specifically EMF.	correctness (computer science);double pushout graph rewriting;eclipse modeling framework;floor and ceiling functions;formal methods;meta-object facility;metamodeling;model transformation;model-driven engineering;modeling language;provable security;software development	Christian Krause;Holger Lewin;Gabriele Taentzer	2007	ECEASST	10.14279/tuj.eceasst.6.52	theoretical computer science;data mining;algorithm	DB	-45.15794943607117	27.328744937608537	101742
1f7edb65405db72d7e197a0392d2a295c0688e81	a generic approach to the recognition and analysis of sketched diagrams using context information		Recent decades have shown the rise of diagrammatic representation of information. In computer sciences, for example, general purpose diagrammatic notations like the UML are an everyday tool nowadays, and can even be considered as common knowledge. Also the advent of domain-specific languages (DSLs) can be observed. On the other hand, the research field of sketching is becoming popular, due to advances in processing speed and input hardware. Also, fields of application are evident, e.g. drawing of diagrams. The term sketching means to have a user draw something and have the computer interpret the drawing in some appropriate way. The advantage of sketching over traditional WIMP-based user interfaces (window, icon, menu, pointing device) is a more natural and intuitive way of interaction with the computer. This thesis presents DSKETCH, an approach to sketching of diagrams. The idea is that the user first draws a diagram, and then DSKETCH derives the syntactic and semantic information conveyed in the drawing. The semantic information can be used for subsequent processing. The approach is fully generic, i.e., it is not tailored to a specific diagram language. There is a prototypically implemented system which serves as proof-of-concept. As an example, the user draws a class diagram from the UML. The system then derives the semantics of the diagram, and creates skeleton class files. The user can subsequently create an actual implementation with these skeletons. Reaching this goal depends on two subsequent stages, applied after the user is finished drawing. The first is recognition, which means to identify the single shapes that make the complete diagram. The other step is analysis, which means to inspect each shape in the context of other shapes, thus being able to derive a syntactical structure first, and the semantics afterward. Recognition is subject to much current research in the field of sketching. Still, no satisfying solution could be found yet. State-of-the-art approaches mostly constrain the user and impose restrictions regarding how to draw. Thus, the task of recognition is simplified to a point where it becomes bearable, but the user is forced to concentrate on his drawing style. Analysis, on the other hand, is rarely discussed in publications on sketching. However, analysis should be an important aspect of approaches to iii iv sketching, as the user is usually not interested in recognized shapes, but in the semantics of the diagram. The approach presented in this thesis marks improvements, both for recognition and for analysis. The core idea of the recognition is to avoid a featurebased approach for high-level recognition, as features impose severe restrictions on which drawings can be recognized. Instead, a set of independent models is created, all of which contain information gained from low-level processing. Furthermore, multiple representations of the same stroke in different models are possible. This has a positive effect on recognition, because it removes the task of low-level processing to decide for a suitable representation without any context knowledge. High-level recognition itself is then based on composition of primitives to complete shapes. In general, the presented approach to recognition does not constrain the user in the ways shown by previous work in the field. Analysis builds upon the DIAGEN framework, which allows for generation of WIMP-based diagram editors from specifications. The generated editors allow for checking syntax and semantics of the diagrams created by the user. The concept of DIAGEN is based on the formal approach of graph transformation, which results in a powerful and reliable diagram analysis. In this thesis it is shown how this approach can be transferred to sketching. The most distinct result is that ambiguities can be reliably solved by extensive use of context information gained from syntax checking. Ambiguities naturally arise from hand-drawing, which is inevitably sloppy and imprecise. Furthermore, it has proven valuable to explicitly model ambiguities in the analysis process. Also, diagram language-specific output can be generated as a result from the analysis as motivated above with the example of class diagrams. The prototypical implementation is applied to six different diagram languages, all of which exhibit different characteristics regarding visual appearance, syntax, and semantics. Among the six languages there are statecharts from the UML, and a GUI builder as a representative of DSLs. Many further diagram languages are conceivable as well. An empirical user study evaluates recognition rates and performance of the prototype. It proves that the system is both accurate and powerful. The contribution of this thesis lies both in the recognizer and the analysis. The recognizer allows for multiple representations of the same stroke at the same time, and is capable of identifying shapes from a complete drawing without prior assignment of strokes to shapes. The analysis is based on a formal approach. Ambiguities are solved automatically based on the syntactic structure of the diagram language. Therefore, ambiguities are explicitly modeled for the analysis.	class diagram;computer science;domain-specific language;finite-state machine;graph rewriting;graphical user interface builder;high- and low-level;information;input device;pointing device;programming language;prototype;unified modeling language;usability testing;wimp (computing)	Florian Brieler	2010				AI	-47.64562206052008	23.922274058641953	101869
d65c88ef1e368c42c8916dcf56ae7ebc20f7ef5d	an approach towards the development life-cycle of agent-based production control applications	high level petri net;formal specification;holonic manufacturing systems;life cycle;agent based;intelligent manufacturing systems;collaborative automation scenario;formal validation;collaborative automation scenario agent based production control application development life cycle high level petri net based approach formal specification industrial production system manufacturing component identification formal validation;intelligent control;software agents;formal verification;production control;agent based production control application development life cycle;conferenceobject;production control new products catalog formal specifications manufacturing automation petri nets encapsulation electrical equipment industry manufacturing industries production systems virtual manufacturing;industrial production system;high level petri net based approach;software requirements and specifications;petri nets;software agents formal specification formal verification intelligent control intelligent manufacturing systems petri nets production control;industrial production systems;manufacturing component identification;manufacturing control systems	"""This paper discusses a new approach to the development life-cycle of agent-based production control applications, from the design to the operation, based in a catalogue of high-level Petri nets. The high-level Petri net-based approach facilitates the conception, definition and formal specification of an """"encapsulation process"""" in industrial production systems. The catalogue includes elements for the identification of manufacturing components, the development of agent-based control units, the formal validation of the models and the formal specification of complete collaborative automation scenarios"""	agent-based model;code generation (compiler);control system;encapsulation (networking);formal specification;high- and low-level;library (computing);petri net;real-time locating system;refinement (computing);simulation	Paulo Leitão;Armando W. Colombo	2005	2005 IEEE Conference on Emerging Technologies and Factory Automation	10.1109/ETFA.2005.1612582	biological life cycle;formal verification;computer science;systems engineering;engineering;artificial intelligence;software agent;formal specification;programming language;petri net;intelligent control;manufacturing engineering	Robotics	-41.678671142676166	22.906212977817212	101908
37c03bcec3b09664ef960e590f6cbdc60ccc6bce	spades: a system for parallel-agent, discrete-event simulation		However, the simulation technology in use by, and designed for, the AI community often fails to take advantage of much of the work in the larger simulation community to produce stable, repeatable, and efficient simulations. I present SPADES (SYSTEM FOR PARALLEL-AGENT DISCRETE-EVENT SIMULATION) as a simulation substrate for the AI community. SPADES focuses on the agent as a fundamental simulation component. The “thinking time” of an agent is tracked and reflected in the results of the agents’ actions. SPADES supports and manages the distribution of agents across machines while it is robust to variations in network performance and machine load. SPADES is not tied to any particular simulation and is a powerful new tool for creating simulations for the study of AI.	network performance;spades;simulation	Patrick Riley	2003	AI Magazine			AI	-37.025907354881205	20.85865879703594	102027
d61c438698bd42fd38b6331f169c6164963d3ddb	automated refinement of policies for network management	policy making;microprocessors;relation algebra;network management policy based management model driven engineering;semantics;model transformation;mobile computer;computer architecture;levels of abstraction;policy based management;business;unified modeling language;physical cell identification automated refinement network management policy based management event condition action policies refinement process;model driven engineering;joining processes;event condition action;network management;mobile computing;mobile network;telecommunication network management;joining processes unified modeling language semantics computer architecture microprocessors business mobile computing	Policy-based management is a flexible approach for the management of networks as policies make context-sensitive and automated decisions. For their effective development it is desired to specify policies at a high level of abstraction initially and to refine them until they are represented in a machine-executable way. We present an approach that uses models to specify event-condition-action (ECA) policies at different abstraction layers and that uses model transformations to refine them in an automated way. A relational algebra is used to formally validate the models and define the semantics of the refinement process. One benefit of the approach is the automated policy refinement at runtime. Changes at the high-level models are automatically reflected in their low-level implementation through refinement. This allows to manage a system at a high level of abstraction. The approach is applied to the network management domain and demonstrated with policies for physical cell identification (PCI) in a mobile network. It can also be applied to other domains and supports a flexible number of abstraction layers.	abstraction layer;code generation (compiler);context-sensitive grammar;diagram;documentation;event condition action;executable;graphical user interface;high- and low-level;high-level programming language;parse tree;prototype;refinement (computing);relational algebra;run time (program lifecycle phase);software development	Raphael Romeikat;Bernhard Bauer;Henning Sanneck	2011	The 17th Asia Pacific Conference on Communications	10.1109/APCC.2011.6152849	computer science;systems engineering;theoretical computer science;database	SE	-45.42237971170889	23.5505978404559	102200
62aba862b5069aa70638922e48f923ad47019f34	norm reasoning services	articulo;artifacts;agents;support;model;services;organizations;norms;multiagent systems	Norms are used in open Multi-Agent Systems as a formal specification of deontic statements aimed at regulating the actions of agents and the interactions among them. In this paper, we propose a set of services facilitating the development of both non-normative and normative agents for norm-governed MAS. Specifically, we propose to provide agents with norm reasoning services. These services will help agent designers/developers to programme agents that consider norm reasoning without having to implement the needed mechanisms to reason about norms by themselves. This article shows how these services perform as well as the results of the experiments that we conducted to evaluate their performance.	algorithm;deontic logic;experiment;formal specification;interaction;simulation	Natalia Criado;Jose M. Such;Vicent J. Botti	2014	Information Systems Frontiers	10.1007/s10796-013-9444-7	service;support;computer science;organization;knowledge management;artificial intelligence;software agent;multi-agent system;management science;norm	AI	-43.039780027926554	19.25175610657543	102315
f69c878e87dcdc72811a55fcd2cb9f74056e0d22	the entity - connection approach to modelling and simulation	decomposition;representa tions;iconic interfaces;graphical model;modelling and simulation	To cope with the huge complexity of many simulation programs, a series of description, implementation and documentation tools have been invented to support the whole software development process. The tools range from simulation model specification and documentation languages, through program generators, to knowledge-based advanced simulation environments or model management systems. Most of these tools transform meta-information about the model into a code in an existing simulation language. Little attention is, however, paid to the question which concepts of a computer simulation language are appropriate to support metaprogramming (i.e. module combination, alteration, replication etc.). In this paper a modular concept for a discrete event simulation	computer simulation;documentation;metaprogramming;simulation language;software development process	Georg Ch. Pflug;Michael Prohaska	1990	Simulation	10.1177/003754979005500404	simulation;computer science;engineering;artificial intelligence;theoretical computer science;operating system;graphical model;decomposition;programming language;algorithm;simulation language	SE	-36.429186763402676	27.12643744297917	102360
ff74d8e5f375bf3f3e96897ff159b3b8777e0331	towards autonomically-capable processes: a vision and potentially supportive methods		Process-aware information systems have a significant potential to support both systems and humans in various processes by partially or completely automating certain activities. However, greater adoption and inclusion are currently hindered by the cost of ownership and significant investments due to the burdens associated with the design, modeling, implementation, testing, optimization, manual adaptation, variant management, and exception handling for processes, besides the general administrative system management costs. While purely autonomic processes would ideally not require any human interaction, this chapter describes a vision for autonomically-capable processes, where processes are practically supported by the system in such a way that they reduce the human interaction burdens by being contextaware and exhibiting certain self-configuration, self-adaptation, self-optimization, and self-healing capabilities. Various cross-cutting aspects and issues requiring consideration in order to address these challenging capabilities are discussed, and potentially useful methods and techniques towards achieving the vision are highlighted. Furthermore, an example system targeted at one domain that exhibits these capabilities to some degree is used to illustrate how a combination of various techniques can be synergistically applied to a system to support incremental autonomic capabilities for processes.	autonomic computing;exception handling;information system;mathematical optimization;software testing;synergy;systems management;total cost of ownership	Roy Oberhauser;Gregor Grambow	2017		10.1007/978-3-319-52181-7_4	autonomic computing;architecture;risk analysis (engineering);information system;exception handling;management science;web service;systems management;business process management;engineering	AI	-45.08326315667259	21.18593893578805	102428
09e8298f42ddd8c5ce98488881fe5dff0db5f901	modeling, analysis, synthesis, and performance evaluation of multioperational production systems with hybrid timed petri nets	intervalo tiempo;manufacturing systems;in process inventory;deposito en curso;complexite;topology;evaluation performance;metodo analisis;systeme evenement discret;performance evaluation;analisis sistema;sistema hibrido;work capacity;system modeling;red petri;model analysis;teoria sistema;evaluacion prestacion;systeme invariant;production system;complejidad;topologie;systeme production;complexity analysis;complexity;sistema complejo;invarying system;satisfiability;buffer system;time interval;sistema produccion;p invariants complexity analysis discrete and continuous components hybrid timed petri nets htpns modules multioperational production systems;capacite travail;topologia;sistema invariante;sistema amortiguador;sistema acontecimiento discreto;p invariants;multioperational production systems;methode analyse;discrete event system;performance analysis production systems petri nets object oriented modeling mathematical model power system modeling topology automatic control student members associate members;time petri net;systeme complexe;systems theory;complex system;system synthesis;analysis method;synthese systeme;theorie systeme;work in process;discrete event systems;hybrid system;sintesis sistema;system analysis;coaccion capacidad;invariante;analyse systeme;contrainte capacite;hybrid timed petri nets htpns;encours de fabrication;machine tools;petri nets;discrete event systems manufacturing systems petri nets machine tools;systeme tampon;capacity constraint;petri net;discrete event systems hybrid timed petri nets random topology production systems complexity multioperational production systems fundamental multiproductive machine multiassembly modules multidisassembly modules system constraints satisfaction performance evaluation manufacturing systems;buffer capacity;discrete and continuous components;modules;invariant;capacidad trabajo;reseau petri;systeme hybride;intervalle temps	Hybrid timed Petri nets (HTPNs) are derived to study random topology and complexity multioperational production systems where parts of one type follow the same route to produce a final product. Each production system is first decomposed into a fundamental multiproductive machine, multiassembly and multidisassembly modules, followed by derivation of their corresponding HTPN models. The overall system HTPN model is obtained via individual module synthesis, satisfying system constraints. Individual module and overall HTPN models nodes (places and transitions) are calculated. Individual module and overall system model invariants are derived mathematically. Performance and possible tradeoffs due to varying operational constraints (buffer capacity, work in process, machine utilization, backlog, etc.) are investigated through extensive simulations. Results show the applicability of the proposed methodology and justify its modeling power and generality.	constraint satisfaction;mathematical optimization;performance evaluation;petri net;production system (computer science);simulation;writer invariant	George J. Tsinarakis;Nikos Tsourveloudis;Kimon P. Valavanis	2006	IEEE Transactions on Automation Science and Engineering	10.1109/TASE.2005.857655	complex systems;computer science;engineering;artificial intelligence;control theory;mathematics;petri net;algorithm	EDA	-36.03364865546441	29.30752159431396	102446
c2afa94164a771fe20fcebf4b26f4893c686cf92	applying model checking to bpel4ws business collaborations	model checking;web services;bpel4ws	Web services are a very appropriate communication mechanism to perform distributed business processes among several organisations. These processes should be reliable, because a failure in them can cause high economic losses. In this work we propose a framework for the verification of business processes, called VERBUS. Its aim is to help the designer to find errors in specifications at design time, thus increasing their reliability. Contrary to verification frameworks previously proposed for business processes, VERBUS is a modular an extensible framework, in the sense that it is not tied to specific process definition languages or verification tools. This is achieved with the definition of an intermediate formalism that disconnects definition languages from verification tools. In this paper we present VERBUS, and its prototype, that integrates the BPEL4WS definition language and the Spin and SMV verification tools.	business process execution language;extensibility;mathematical model;model checking;prototype;spin;semantics (computer science);web service	Jesús Arias-Fisteus;Luis Sánchez Fernández;Carlos Delgado Kloos	2005		10.1145/1066677.1066866	web service;model checking;computer science;artifact-centric business process model;operating system;software engineering;database;runtime verification;programming language;world wide web;intelligent verification;functional verification	SE	-46.146574540461806	19.605071498754956	102623
2f3b8d76fb7beda3a7c9d1a233339b50c20fa25c	formal verification in a component-based reuse methodology	petri nets formal verification software reusability;design process;model checking formal verification component based reuse methodology design processes component based system level design methodology timed petri net model;theoretical framework;component based systems;timed petri nets;reuse;time petri net;formal verification;model checking;ip;software reusability;datavetenskap datalogi;computer science;petri nets;connected component;formal verification logic process design hardware large hadron collider analytical models circuit simulation performance analysis design engineering design automation;design methodology	There is an important trend towards design processes based on the reuse of predesigned components. We propose a formal verification approach which smoothly integrates with a component based sys tem-level design methodology. Once a timed Petri Net model corre sponding to the interface logic has been produced the correctness of the system can be formally verified. The verification is based on the interface properties of the connected components and on abstract models of their functionality, without assuming any knowledge regarding their implementation. We have both developed the theo retical framework underlying the methodology and implemented an experimental environment using model checking techniques.	component-based software engineering;connected component (graph theory);correctness (computer science);embedded system;formal verification;level design;model checking;petri net;smoothing;third-party software component	Petru Eles;Zebo Peng;Daniel Karlsson	2002		10.1145/581199.581235	reliability engineering;real-time computing;computer science;systems engineering	EDA	-41.66071261712162	32.16254580945184	102653
60605474b04c3bdc452ae977c9c60fcfe115baa2	zfdss : a formal development support system based on the liberal approach			formal methods	Abdullah Mohd Zin	1993				Robotics	-45.62974241945083	30.30989536156215	102725
e84b39db2fa907ff77860f479054a7e12b16c7d1	scenario networks: specifying user interfaces with extended use cases	sistema interactivo;metodo adaptativo;interfase usuario;behavioral analysis;user interface;lenguaje uml;orientation relationship;relacion orden;simultaneidad informatica;ordering;langage modelisation unifie;methode adaptative;context of use;interface reseau;systeme conversationnel;construction graphe;relation ordre;network interfaces;concurrency;adaptive behaviour;interactive system;unified modelling language;analyse comportementale;adaptive method;interface utilisateur;analisis conductual;simultaneite informatique;use case;graph construction;construccion grafo	In this paper, we present the rationale and the baseline of a notation which can be used on its own or as an extension to standard UML to facilitate specification of an interactive system’s global execution context (GEC). The GEC graph is a visual construction consisting of (a) nodes, which represent interaction scenarios, and (b) directed links, which represent scenario relationships designating alternate execution, concurrency, ordering, and set-oriented relationships between two scenario nodes. The technique is particularly useful for specifying adaptable and adaptive behaviours across interaction platforms, contexts of use and target user communities. In the paper, we demonstrate the application of the technique using a file-exchange application which runs on a portable device such as a PDA and implements a lightweight ftp process to connect to a server wirelessly and offer standard ftp functionality (get/put/delete).	baseline (configuration management);concurrency (computer science);design rationale;emoticon;interaction design;interactivity;mobile device;personal digital assistant;server (computing);unified modeling language	Demosthenes Akoumianakis;Ioannis Pachoulakis	2005		10.1007/11573036_46	use case;unified modeling language;simulation;concurrency;order theory;computer science;network interface;operating system;programming language;user interface;algorithm	HCI	-38.192870202578796	26.179594262969854	103020
c123adec87bf8a85338a189319d65198b35b58ff	migration of sequential systems to parallel environments by reverse engineering	computacion informatica;dependence analysis;design and development;migration;numerical aerodynamic simulation;production system;grupo de excelencia;design recovery;design and implementation;ciencias basicas y experimentales;phase analysis;control dependence;parallel processing;sequential systems;reverse engineering;knowledge base;program dependence graph	Migration of code from sequential environments to parallel processing environments is often done in an ad hoc manner. We present a reverse engineering method to facilitate systematic migration of code from sequential to parallel processing environments. The approach includes a three-phase method and the design and development of a reverse engineering toolkit (RETK), which serves to establish a working model for the method. The method consists of three phases: analysis, synthesis and transformation. The analysis phase uses a new design recovery technique. The synthesis phase is comprised of processes that compute the data and control dependences by using the design abstractions produced by the analysis phase to construct the program dependence graph. The transformation phase consists of processes that require knowledge-based analysis of the program and dependence information produced by the analysis and synthesis phases, respectively. Design recommendations for parallel environments are the key output of the transformation phase. The main components of RETK are an information extractor, a dependence analyser and a design assistant that implement the processes of the analysis, synthesis and transformation phases, respectively. The design and implementation of the design assistant using C Language Interface Production System (CLIPS) are described. In addition, experimental results of applying the method to test programs by RETK are presented. The results include analysis of a Numerical Aerodynamic Simulation (NAS) benchmark program. By combining research in reverse engineering, dependence analysis and knowledge-based analysis, the method provides a systematic approach for code migration from sequential to parallel environments.	reverse engineering	Ravi Erraguntla;Doris L. Carver	1998	Information & Software Technology	10.1016/S0950-5849(98)00060-3	parallel processing;knowledge base;real-time computing;simulation;computer science;human migration;engineering;theoretical computer science;software engineering;database;production system;programming language;reverse engineering;dependence analysis	SE	-33.956031737900574	28.802667479798316	103082
bd2274a7a8abec72c79cd9e118125925cec05717	component-based abstraction refinement for timed controller synthesis	game theory;uppaal tiga;timing game;clocks;real time;timed controller synthesis;abstraction refinement;data mining;timed game solver;incremental;game theory control system synthesis distributed control;controller synthesis;automata;computational modeling;distributed real time environments;safety requirements;control system synthesis;component based abstraction refinement;synchronization;partial composition real time controller synthesis abstraction refinement incremental;games;on the fly;control system synthesis real time systems automatic control refining open systems computer science synchronization artificial intelligence distributed control safety;partial composition;uppaal tiga component based abstraction refinement timed controller synthesis distributed real time environments safety requirements timed game solver;distributed control;real time systems	We present a novel technique for synthesizing controllers for distributed real-time environments with safety requirements. Our approach is an abstraction refinement extension to the on-the-fly algorithm by Cassez et al. from 2005. Based on partial compositions of some environment components, each refinement cycle constructs a sound abstraction that can be used to obtain under- and over-approximations of all valid controller implementations. This enables (1) early termination if an implementation does not exist in the over-approximation, or, if one does exist in the under-approximation, and (2) pruning of irrelevant moves in subsequent refinement cycles. In our refinement loop, the precision of the abstractions incrementally increases and converges to all specification-critical components. We implemented our approach in a prototype synthesis tool and evaluated it on an industrial benchmark. In comparison with the timed game solver UPPAAL-Tiga, our technique outperforms the nonincremental approach by an order of magnitude.	algorithm;approximation;automata theory;benchmark (computing);computation;computational model;heuristic (computer science);high- and low-level;microsoft outlook for mac;modality (human–computer interaction);model checking;prototype;real-time clock;real-time computing;refinement (computing);relevance;requirement;solver;state space;subnetwork;texas instruments graphics architecture;text simplification;uppaal	Hans-Jörg Peter;Robert Mattmüller	2009	2009 30th IEEE Real-Time Systems Symposium	10.1109/RTSS.2009.14	games;game theory;synchronization;real-time computing;simulation;computer science;distributed computing;automaton;computational model	Embedded	-39.05815941054132	30.03882237548882	103702
3e72922a00fc1d988d1047be92f192bc2260c160	towards visual type theory as a mathematical tool and mathematical user interface		A visual type theory is a cognitive tool that has much in common with language, and may be regarded as an exceptional form of spatial text adjunct. A mathematical visual type theory called NPM has been under development that can be viewed as an early-stage project in mathematical knowledge management and mathematical user interface development. We discuss in greater detail the notion of a visual type theory, report on progress towards a usable mathematical visual type theory, and discuss the outlook for future work on this project.	agda;chart;cognition;compcert;computer science;conformity;coq (software);digital subscriber line;experiment;formal language;glyph;graph (discrete mathematics);human–computer interaction;interoperability;isabelle;mathematical knowledge management;mathematical software;microsoft outlook for mac;middleware;operability;organizing (structure);point of view (computer hardware company);programming language theory;programming paradigm;proof assistant;type theory;user interface;user interface design;npm	Lucius Schoenbaum	2016			human–computer interaction;computer science;artificial intelligence;mathematics	HCI	-47.39524760301785	24.674611503487956	103708
6ef1783486da787ac8193dc98c7e82166513f83d	new technical services using the component model for applications in heterogeneous environment	distributed application;modelizacion;carte a puce;distributed system;smart card;reseau social;adaptability;adaptabilite;transaction management;systeme reparti;gestion transaccion;securite;componente logicial;articulo;heterogeneous environment;new technical services using the component model for applications in heterogeneous environment;composant logiciel;portability;adaptabilidad;modelisation;social network;sistema repartido;innovation;smart cards;heterogeneidad;execution environment;portabilite;algorithme reparti;safety;software component;component model;algoritmo repartido;innovacion;seguridad;distributed algorithm;modeling;red social;portabilidad;heterogeneity;gestion transaction;heterogeneite	Nowadays, execution environments of applications are more and more heterogeneous: from powerful servers to smart cards. In order to assume the heterogeneity and the portability of applications, the component–based model has emerged as a model to develop new distributed applications. Thus, these applications are built as an assembly of interchangeable software blocks. Nevertheless, the gain of adaptability that comes from the use of component does not stretch to non-functional services (such as transaction management, security, etc). So, we suggest complementing the existing solution by facilitating the adaptability of non-functional services to their environment. Therefore, we propose to design a non-functional service as composition of small components. Besides, it is possible to supply the most appropriate version of a non-functional service to an application. So, in our approach, the application is composed by assembling both business components and non-functional components.	component-based software engineering	Colombe Hérault;Sylvain Lecomte;Thierry Delot	2004		10.1007/11553762_10	smart card;distributed algorithm;simulation;computer science;operating system;distributed computing;computer security	HPC	-40.7414311681557	24.02470465437324	103953
bf15e4b921ca7f47b5d189dd68d393da731c073c	sat-based bounded model checking for deontic interleaved interpreted systems	mainstream approach;reactive system;train controller problem;sat-based bounded model checking;multi-agent system;art solution;typical communication scenario;bounded model checking;verification approach	We propose a bounded model checking (BMC) method for the verification of multi-agent systems' (MASs). The MASs are modelled by deontic interleaved interpreted systems, and specifications are expressed in the logic $\sc{RTECTLKD}$. The verification approach is based on the state of the art solutions to BMC, one of the mainstream approaches in verification of reactive systems. We test our results on a typical communication scenario: train controller problem with faults.	model checking	Bozena Wozna;Andrzej Zbrzezny	2012		10.1007/978-3-642-30947-2_54	real-time computing;computer science;theoretical computer science;algorithm	Logic	-40.04791825330782	31.549925678457104	104190
88f1d011845c0b3487a9f52a8b866935f043fe38	towards formal modeling of e-contracts	contract negotiation formal e contract modeling emerging b2b technologies automated e contract management contract drafting technology infrastructure electronic exchange contract related messages it community governance structures interorganisational interactions deontic constraint specification deontic consistency verification temporal constraints estimates temporal consistency scheduling visualisation concepts role windows time maps decision support tools;electronic commerce;decision support tool;formal specification;contracts technology management consumer electronics job shop scheduling visualization distributed processing companies windows management information systems australia;temporal logic;contracts;data visualisation;temporal constraints;internet;governance structure;open systems;data visualisation electronic commerce internet contracts formal specification open systems temporal logic	The emerging B2B technologies allow for more automated management of e-contracts including contr act drafting, negotiation and monitoring. As technology infrastructure becomes available for electronic exc hange of contracts and contract-related messages, the IT community is becoming more interested in modeling o f contracts as governance structures for many interorganisational interactions. This paper presents our initial ideas for formal modeling of e-contracts. This includes specificatio n f deontic constraints and verification of deontic con sistency associated with roles in a contract, precise modeli ng of temporal constraints/estimates and verification of temporal consistency of an e-contract, and finally scheduling of the required actions. The paper also introduces visualisation concepts such as role wind ows and time maps and describes how they could be used a decision support tools during contract negotiation.	contract management;decision support system;deontic logic;design by contract;interaction;map;microsoft windows;naruto shippuden: clash of ninja revolution 3;online and offline;outsourcing;scheduling (computing);semantics (computer science);technical drawing;window function	Olivera Marjanovic;Zoran Milosevic	2001		10.1109/EDOC.2001.950423	e-commerce;contract management;the internet;temporal logic;computer science;systems engineering;knowledge management;artificial intelligence;operating system;software engineering;data mining;formal specification;database;open system;law;computer security;data visualization	PL	-44.86264804364742	18.26176901150805	104242
5450c614cbd5091625c2758874aff3e6b6d55df9	specifying executable platform-independent models using ocl	action language;levels of abstraction;declarative languages;platform independent model;model driven architecture	Model-driven architecture  aims at describing a system using a platform-independent model in sufficient detail so that the full implementation of the system can be generated from this model and a platform model. This implies that the platform-independent model must  describe the static structure as well as the dynamic behavior of the system.#R##N#We propose a declarative language for describing the behavior of platform-independent models based on a hybrid notation that uses graphical elements as well as textual elements in the form of OCL code snippets. Compared to existing approaches based on action languages  it is situated at a higher level of abstraction and, through a clean separation of modifier operations and query operations, simplifies the comprehension of the behavioral aspects of the platform-independent system.	executable;object constraint language	Pierre Kelsen;Elke Pulvermüller;Christian Glodt	2008	ECEASST	10.14279/tuj.eceasst.9.101	natural language processing;action language;computer science;artificial intelligence;theoretical computer science;programming language	NLP	-44.86112035254997	26.3549920505308	104355
ededb527a34b480773babf2caf20b3560c825e37	predictable real-time software synthesis	timed systems;design process;real time;formal methods;program synthesis;formal method;time petri net;time domain;timed automata;software synthesis;process algebra;real time systems	Formal theories for real-time systems (such as timed process algebra, timed automata and timed petri nets) have gained great success in the modeling of concurrent timing behavior and in the analysis of real-time properties. However, due to the ineliminable timing differences between a model and its realization, synthesizing a software realization from a model in a predictable way is still a challenging research topic. In this article, we tackle this problem by solving a set of sub-problems. The solution is based on the theoretical results for property prediction proposed in Huang et al. (2003, Real-time property preservation in approximations of timed systems. In: Proceedings of 1st ACM and IEEE international conference on formal methods and models for codesign. IEEE Computer Society, Los Alamitos, pp 163–171) and Huang (2005, Predictability in real-time system design. PhD thesis, Eindhoven University of Technology, The Netherlands), where quantitative property relations are established between two absolute/relative “close” real-time systems. This theory basically implies that if two systems are “close”, they enjoy “similar” properties. These results cannot be directly applied in practice though, because a model and its realization typically have infinitely large absolute and relative timing differences. We show that this infinite time gap can be bridged through a sequence of carefully constructed intermediate time domains. Then the property-prediction results can be applied to any pair of adjacent time domains in the sequence. Consequently, real-time properties of the implementation can be predicted from the model. We propose two parameterized hypotheses to characterize the timing differences in the sequence and to guide a correctness-preserving design process. It is shown that these hypotheses can be incorporated in a concrete tool set. We demonstrate the feasibility of the predictable synthesis approach through the design of a railroad crossing system.	approximation;automata theory;correctness (computer science);emoticon;formal methods;petri net;process calculus;real-time clock;real-time computing;real-time transcription;sid meier's railroad tycoon;systems design;timed automaton;timing closure	Jinfeng Huang;Jeroen Voeten;Henk Corporaal	2007	Real-Time Systems	10.1007/s11241-007-9013-6	process calculus;real-time computing;simulation;formal methods;design process;time domain;computer science;operating system;programming language;algorithm	Embedded	-38.95721096234439	32.021216492276544	104468
849010b27f99e98ff7cca84567d48acab6d772b3	a framework for unambiguous and extensible specification of dsmls for cyber-physical systems	domain specific modeling languages;formal specification;semantics mathematical model solid modeling unified modeling language abstracts syntactics computational modeling;formal semantics;simulation languages embedded systems formal specification;embedded systems;simulation languages;model based design method dsml specification domain specific modeling languages cyber physical system cps formal specification formula fixed point logic language structural semantics behavioral semantics bond graph language;bond graph language formal specification domain specific modeling languages formal semantics;bond graph language	Increased emphasis on developing model-based design methods for Cyber-Physical Systems (CPS) brings new challenges to the specification of domain specific modeling languages (DSML) and the integration of heterogeneous CPS components.Since CPS are composed of tightly integrated physical and computational components, the modeled domains include both physical and computational systems.Formal specification of physical and computational languages as well as their integration remains an interesting challenge.In this paper we introduce a formal logic based framework for formal specification and simulation, that is supported by the fixed-point logic language FORMULA.As a representative case study, we define both the structural and behavioral semantics for a bond graph language, and demonstrate the reusability and extensibility provided by the approach by extending the language to support hybrid dynamics.	abstract syntax;automata theory;conformance testing;cyber-physical system;declarative programming;differential algebraic equation;directory services markup language;documentation;domain-specific language;domain-specific modeling;embedded software;executable;extensibility;formal specification;formula language;gme of deutscher wetterdienst;hybrid system;least fixed point;linear algebra;metamodeling;model checking;model-driven engineering;modeling language;operational semantics;rapid prototyping;reference implementation;semantic mapper;simulation;well-formed element	Gabor Simko;David Lindecker;Tihamer Levendovszky;Ethan K. Jackson;Sandeep Neema;Janos Sztipanovits	2013	2013 20th IEEE International Conference and Workshops on Engineering of Computer Based Systems (ECBS)	10.1109/ECBS.2013.30	natural language processing;embedded system;formal language;formal methods;formal semantics;action semantics;object language;specification language;formal verification;syntax;computer science;domain-specific language;theoretical computer science;formal semantics;formal specification;ontology language;modeling language;programming language;operational semantics;programming language specification;language of temporal ordering specification;computational semantics	Embedded	-40.428879935103375	30.740706676865056	104473
82b15e53223462df72984d9a8a067f3e5bb9e189	agent-based tactics for goal-oriented requirements elaboration	institutional repositories;realizabilidad;systems;multiagent system;logica temporal;exigence;formal specification;goal orientation;fedora;orientado agente;componente logicial;agent based;temporal logic;logic;goal oriented requirements engineering;composant logiciel;systematique;intelligence artificielle;air transportation;requirement;goals to agents software components temporal logic requirements engineering alternative agent assignments;oriente agent;agent logiciel;software engineering;vital;software components;requirements engineering;input output;software agents;formal verification;aerospace control;sistematica;monitoring;permission;goals to agents;humans taxonomy permission aerospace control software safety proposals monitoring logic documentation air transportation;software safety;requirement engineering;taxonomy;software component;exigencia;genie logiciel;realizability;alternative agent assignments;artificial intelligence;design;agent oriented;humans;software agents formal specification temporal logic formal verification;inteligencia artificial;vtls;sistema multiagente;proposals;ingenieria informatica;logique temporelle;ils;realisabilite;documentation;systeme multiagent	Goal orientation is an increasingly recognized paradigm for eliciting, structuring, analyzing and documenting system requirements. Goals are statements of intent ranging from high-level, strategic concerns to low-level, technical requirements on the software-to-be and assumptions on its environment. Achieving goals require the cooperation of agents such as software components, input/output devices and human agents. The assignment of responsibilities for goals to agents is a critical decision in the requirements engineering process as alternative agent assignments define alternative system proposals.The paper describes a systematic technique to support the process of refining goals, identifying agents, and exploring alternative responsibility assignments. The underlying principles are to refine goals until they are assignable to single agents, and to assign a goal to an agent only if the agent can realize the goal.There are various reasons why a goal may not be realizable by an agent, e.g., the goal may refer to variables that are not monitorable or controllable by the agent. The notion of goal realizability is first defined on formal grounds; it provides a basis for identifying a complete taxonomy of realizability problems. From this taxonomy we systematically derive a catalog of tactics for refining goals and identifying agents so as to resolve realizability problems. Each tactics corresponds to the application of a formal refinement pattern that relieves the specifier from verifying the correctness of refinements in temporal logic.Our techniques have been used in two case studies of significant size; excerpts are shown to illustrate the main ideas.	component-based software engineering;correctness (computer science);goal programming;high- and low-level;input/output;intelligent agent;output device;programming paradigm;refinement (computing);requirement;requirements engineering;software documentation;system requirements;taxonomy (general);temporal logic;verification and validation	Emmanuel Letier;Axel van Lamsweerde	2002		10.1145/581339.581353	reliability engineering;computer science;systems engineering;engineering;component-based software engineering;software engineering;requirements engineering;programming language;management	SE	-39.96363683676229	23.767680206446002	104490
1992d9e5275f90f9334fcd1d7f44eb110fefa069	slice-based formal specification measures - mapping coupling and cohesion measures to formal z		This paper demonstrates that existing slice-based measures can reasonably be mapped to the field of state-based specification languages. By making use of Z specifications this contribution renews the idea of slice-profiles and derives coupling and cohesion measures for them. The measures are then assessed by taking a critical look at their sensitiveness in respect to modifications on the specification source. The presented study shows that slice-based coupling and cohesion measures have the potential to be used as quality indicators for specifications as they reflect the changes in the structure of a specification as accustomed from their program-related pendants.	cohesion (computer science);data dependency;formal specification;microsoft outlook for mac;quantum number;real life;specification language	Andreas Bollin	2010				SE	-42.94764734523449	28.78341968284456	104543
3cd630531e58fedf25f1c4c3323a14c307591573	towards a general framework for modelling roles	multi agent system;programming language;004;roles organizations object orientedmodelling multi agent systems security;object oriented modelling;meta model	Role is a widespread concept, it is used in many areas like MAS, Programming Languages, Organizations, Security and OO modelling. Unfortunately, it seems that the literature is not actually able to give a uniform definition of roles, there exist several approaches that model roles in many different (or even opposite) ways. In this draft we start to define a meta-model for roles. Our aim is to build a formal framework through which we can describe different roles appeared in the literature or implemented in up and running computer systems. In particular we give a new definition of role’s foundation introducing sessions, which are a formal instrument to talk about role’s states and we show how sessions may be useful to model many different role’s accounts. keywords: Roles, Organizations, Object Oriented Modelling, Multi-Agent Systems, Security.	existential quantification;lecture notes in computer science;metamodeling;multi-agent system;semantics (computer science);springer (tank)	Valerio Genovese	2007			simulation;computer science;knowledge management;management science	AI	-44.081162102779864	19.87333858878968	104611
303c790d8070687200b1bca5e32d3df2a95d36a3	labyrinth, an abstract model for hypermedia applications. description of its static components	design model;design tool;multimedia;computer software development;information technology;user needs information;hypertext hypermedia;multimedia materials;hypermedia models;systems and information theory;hypermedia;heterogeneous information;abstraction mechanisms;events;control version;security;models;alignment;document delivery;information theory	Abstract   In information technology, models are abstract devices to represent the components and functions of software applications. When a model is general and consistent, it represents a useful design tool to unambiguously describe the application. Traditional models are not suitable for the design of hypermedia systems and, therefore, specific design models and methodologies are needed. In the present article, the requirements for such models are analysed, an overview of the characteristics of the existing models for hypermedia applications is made and an abstract model fulfilling the analysed requirements is presented. The model, called Labyrinth, allows 1) the design of platform-independent hypermedia applications; 2) the categorisation, generalisation and abstraction of sparse unstructured heterogeneous information in multiple and interconnected levels; 3) the creation of personalisations (personal views) in multiuser hyperdocuments for both groups and individual users and 4) the design of advanced security mechanisms for hypermedia applications.	hypermedia	Paloma Díaz;Ignacio Aedo;Fivos Panetsos	1997	Inf. Syst.	10.1016/S0306-4379(97)00028-8	human–computer interaction;information theory;computer science;theoretical computer science;database;multimedia;information technology;statistics	OS	-45.926782047461124	22.47781325446478	104680
9d117d84c34698536484e9d217a3433b1f1e74fc	muse - an interactive networked multimedia applications specification environment with e-lotos translator	distributed system;systeme reparti;systeme interactif;multimedia;graphical interface;information technology;technologie information;interaction network;multimedia application;computer network;synchronisation;sistema repartido;complex system;interactive system;synchronization;sincronizacion;information system;tecnologia informacion;systeme information;sistema informacion	This work presents MUSE, a graphical environment for modeling interactive networked multimedia applications. Through an advanced graphic interface and a new high-level authoring model, it is possible to create complex systems in a fast and intuitive way. The authoring model proposed in this work and adopted by the environment deals with media objects distributed in a computer network, allowing the definition of acceptable presentation delay thresholds and altemative media objects. Due to the large expressiveness of the model, however, specifications with logical and temporal inconsistencies may be generated. For this reason, the tool also provides E-LOTOS specifications, which may be used to analyze and verify the temporal requirements defined by the author.	e-lotos;muse	Luciano Paschoal Gaspary;Maria Janilce Bosquiroli Almeida	1998		10.1007/BFb0054230	synchronization;simulation;human–computer interaction;computer science;operating system;database;distributed computing;multimedia;information technology	HPC	-36.40249292621336	24.74655156681051	104688
1b27df187995a1b81ebf471fbf262ca27ff273f8	analyzing conflicts and dependencies of rule-based transformations in henshin		Rule-based model transformation approaches show two kinds of non-determinism: (1) Several rules may be applicable to the same model and (2) a rule may be applicable at several different matches. If two rule applications to the same model exist, they may be in conflict, i.e., one application may disable the other one. Furthermore, rule applications may enable others leading to dependencies. The critical pair analysis (CPA) can report all potential conflicts and dependencies of rule applications that may occur during model transformation processes. This paper presents the CPA integrated in Henshin, a model transformation environment based on the Eclipse Modeling Framework (EMF).	critical pair (logic);eclipse modeling framework;model transformation;rule 90	Kristopher Born;Thorsten Arendt;Florian Heß;Gabriele Taentzer	2015		10.1007/978-3-662-46675-9_11	computer science;theoretical computer science;data mining;algorithm	SE	-43.95137785644443	28.04462183615063	105076
4e6ea83ea68b8d42a1c5174197d5353453701722	formal methods integration in software engineering	cal;mda;aadl;formal specification;uml;pvs;real time;functional properties;development process;software engineering;formal method;mde;intermediate language;marte;formal language;real time systems;software engineering method	This paper presents an extract from our works on a software engineering method for avionic real-time systems [3], the C-Method, which covers the whole software lifecycle thanks to a seamless process, and integrates formal methods in its process. Because distributed, real-time and embedded (DRE) systems have safety critical concerns, they require the use of formal languages (that allow non-ambiguous and rigorous specifications) in order to be able to prove their non-functional properties. Therefore, the “C-Method” relies on the use of formal languages in the earliest steps of the system specification and on the use of semi-formal languages in the analysis, design and programming steps. The fundamental question is how to integrate several languages with different levels of formalization and abstraction. The previous software engineering methods were based on a single language or notation, so they did not address this issue. In order to make the transitions more continuous between semi-formal and formal specifications, we have introduced in the development process what we call “intermediate” languages (+CAL and Why), that are easy to manipulate but directly linked to a formal language (TLA+ for +CAL, Why for PVS).	algorithm;architecture analysis & design language;cal;code generation (compiler);concurrency (computer science);embedded system;formal language;formal methods;formal specification;intermediate representation;model transformation;modeling and analysis of real time and embedded systems;real-time clock;real-time computing;real-time transcription;seamless3d;semiconductor industry;software development process;software engineering;tla+	Isabelle Perseil;Laurent Pautet	2009	Innovations in Systems and Software Engineering	10.1007/s11334-009-0115-2	formal system;unified modeling language;formal language;real-time computing;formal methods;formal verification;computer science;systems engineering;formal specification;programming language;intermediate language;software development process	SE	-43.020406753114536	30.763782203158865	105200
3a4d4592703a1e5852c450a451dd8f2d14ae9b39	a comparative study of synthesis methods for discrete event controllers	model specification;temporal logic;controller synthesis;automata;discrete event system;discrete event systems;petri net;discrete event;net condition event systems	The purpose of this paper is to illustrate and compare some of the existing synthesis methods for discrete event controllers. We do this by means of examples which might provide greater insight on the descriptive power of the methods, and their capabilities for handling various types of speciications.		Luz E. Pinzon;Hans-Michael Hanisch;Mohsen A. Jafari;Thomas O. Boucher	1999	Formal Methods in System Design	10.1023/A:1008740917111	real-time computing;discrete event dynamic system;temporal logic;computer science;artificial intelligence;discrete system;automaton;event tree;petri net;specification	EDA	-36.42013886490713	29.379904245502548	105202
1264d982fdff4bf2a82bfe7ac7ca980e954e95b6	functional integrity of mas through the dynamics of the agents' population	analytical models;control systems;convergence;multi agent system;functional integration;system analysis and design;tellurium;multiagent systems problem solving convergence communication channels tellurium system analysis and design analytical models;autonomy;software agents;cooperative systems;population level;computer science;open multi agent systems;communication channels;autonomy open multi agent systems functional integrity population level;functional integrity;problem solving;multiagent systems	In open multi-agent systems, i.e. systems in which agents of different kinds may join or leave the system, the problem of functional integrity seems to be of vast importance. The thesis discussed in this paper is that the number of agents in a multi-agent system can be an important characteristic of its dynamics and, in particular, constitute a base for evaluation of its functional integrity at a population level. Certain mechanisms which allow for controlling the number of agents- preserving their autonomy-have been also proposed.		Krzysztof Cetnarowicz;Grzegorz Dobrowolski;Marek Kisiel-Dorohinicki;Edward Nawarecki	1998		10.1109/ICMAS.1998.699235	computer science;systems engineering;artificial intelligence;distributed computing	ECom	-40.206557109673106	19.625816259669357	105279
ad46efdd1a4d0df34f7e5cdf9a01acd8c055d91c	automated testing in practice: the highway tolling system	automated testing;formal specification	In this paper we study the application of automated test derivation and execution based on formal specifications. The object of testing is the Payment Box (PB) of the Highway Tolling System, a device which handles electronic payments. Challenges of testing the PB are the transaction speed, parallelism and encryption. We describe a methodology for automated testing and apply this methodology to test the PB. We conclude that automation of the test process is feasible and beneficial, and evaluate our techniques, theory and tools for automated testing.	encryption;parallel computing;test automation	René G. de Vries;Axel Belinfante;Jan Feenstra	2002		10.1007/978-0-387-35497-2_17	reliability engineering;systems engineering;engineering;transport engineering	SE	-45.25324821945763	29.833427654926837	105313
11ef5e9832e2c3017ef5f97a752a4b355be7947b	abstractions in actor and activity modeling.		ions in Actor and Activity Modeling Matthias Wester-Ebbinghaus, Daniel Moldt University of Hamburg, Department of Informatics Vogt-Kölln-Straße 30, D-22527 Hamburg {wester,moldt}@informatik.uni-hamburg.de Abstract: In this paper we argue that actor-centered models are well suited for sociotechnical systems of systems (like enterprise and especially cross-enterprise scenarios). Results can especially be drawn from the field of multi-agent system modeling. However, existing approaches reveal a lack of possibilities for switching between different levels of abstraction. This does not only concern more or less abstract models for a given situation (model abstraction), but also to have models with actors of varying granularity, including individual as well as collective actors (actor abstraction). We present a modeling approach that addresses both these aspects. It is based on the core concepts of actors and activities and especially the concept of a collective actor is emphasized. For supporting different levels of model abstraction, we present multiple modeling techniques. The semantic core of all models is based on high-level Petri nets, although this is hidden for the more abstract models. In this paper we argue that actor-centered models are well suited for sociotechnical systems of systems (like enterprise and especially cross-enterprise scenarios). Results can especially be drawn from the field of multi-agent system modeling. However, existing approaches reveal a lack of possibilities for switching between different levels of abstraction. This does not only concern more or less abstract models for a given situation (model abstraction), but also to have models with actors of varying granularity, including individual as well as collective actors (actor abstraction). We present a modeling approach that addresses both these aspects. It is based on the core concepts of actors and activities and especially the concept of a collective actor is emphasized. For supporting different levels of model abstraction, we present multiple modeling techniques. The semantic core of all models is based on high-level Petri nets, although this is hidden for the more abstract models.	actor model;high- and low-level;informatics;multi-agent system;petri net;principle of abstraction;sociotechnical system;system of systems;systems modeling	Matthias Wester-Ebbinghaus;Daniel Moldt	2011			actor model and process calculi	SE	-44.32889540791121	20.453853909165467	105439
6f7dd5cff26e5319b7bfe9d38b8fe32a2feb8408	experience report in developing and applying a method for self-organisation to agile manufacturing	self organisation;distributed system;semiconductor optical amplifiers;selforganising system;semiconductor optical amplifiers assembly systems robot kinematics service robots design methodology;design process;management system;design and development;self adjusting systems agile manufacturing distributed processing;distributed processing;agile manufacturing;self adjusting systems;service robots;software architecture self organisation self management development methodology;serveur institutionnel;experience report;software architecture;electronic and computer engineering;archive institutionnelle;design and implementation;lessons learned;open access;adaptive system;metaself;assembly systems;selfadaptive system;development methodology;archive ouverte unige;cybertheses;self management;metaself agile manufacturing selfadaptive system selforganising system distributed system;institutional repository;robot kinematics;design methodology	The design and implementation of distributed, self-organising and self-adaptive systems are challenging. This article details our experience gained during the development of self-organising assembly systems, which provide solutions for user-friendly agile manufacturing systems. More specifically, we describe how both a development method for self-organising systems, called MetaSelf, and the above particular application were progressively shaped, each influencing the other.	adaptive system;agile software development;self-organization;usability	Giovanna Di Marzo Serugendo;Regina Frei	2010	2010 Fourth IEEE International Conference on Self-Adaptive and Self-Organizing Systems	10.1109/SASO.2010.24	software architecture;simulation;design process;design methods;agile unified process;agile usability engineering;computer science;artificial intelligence;adaptive system;management system;robot kinematics	Robotics	-40.702004558399835	19.120391456654023	105633
6da39901aa5476c5fb1c7a21bbbdd949f42c064c	integrating molecular modeling tools and virtual reality engines: an architecture for a highly immersive molecular modeling (himm) environment	electrical capacitance tomography;adaptive design;molecular modeling;molecular configurations chemistry computing virtual reality user interfaces software engineering object oriented programming;molecular configurations;chemistry computing;prototypes;virtual reality engines computer architecture electrical capacitance tomography prototypes object oriented modeling data structures biochemistry computer science geometry;geometry;virtual reality;object oriented programming;software engineering;computer aided molecular modeling;prototype object oriented adapter design virtual reality engines highly immersive molecular modeling environment software architecture computer aided molecular modeling;computer architecture;software architecture;object oriented adapter design;engines;object oriented;data structures;highly immersive molecular modeling environment;computer science;prototype;user interfaces;virtual reality engines;object oriented modeling;biochemistry	A software architecture for the integration of computer aided molecular modeling (CAMM) tools and virtual reality (VR) engines is presented. This approach has been chosen in order to provide with minimal effort a flexible Highly Immersive Molecular Modeling (HIMM) environment. The HIMM environment is build from readily available objects, that is CAMM tools and VR engines. Following the object oriented adapter design approach objects can be easily added or exchanged. A prototype has been implemented to estimate strength and limitations of the HIMM architecture.	computational chemistry;molecular modelling;prototype;software architecture;virtual reality	Robert C. Drees;Jürgen Pleiss;Rolf D. Schmid;Dieter Roller	1998		10.1109/CGI.1998.694289	simulation;human–computer interaction;computer science;virtual reality;prototype;programming language;object-oriented programming;computer graphics (images)	Visualization	-34.666588893046764	25.200149332076855	105744
58fccb03083d72daa1fc598ce7242ead819121b7	a uml profile for knowledge-based systems modelling	knowledge based systems modelling;knowledge based system;knowledge transfer approach;uml;conceptual model;java expert system shell;object oriented programming;production rule representation;standardisation;modelling framework;unified modeling language knowledge based systems context modeling knowledge engineering knowledge transfer problem solving medical services prototypes java expert systems;executable modelling framework;uml profile;unified modelling language;unified modeling language knowledge based systems knowledge representation object oriented programming;unified modeling language;platform specific model;knowledge transfer;production rule representation uml knowledge based systems modelling knowledge engineering knowledge transfer approach conceptual model unified modelling language model driven architecture executable modelling framework health care java expert system shell;knowledge representation;model driven architecture;knowledge based systems;problem solving;production rule;qa76 computer software;expert system;health care;knowledge engineering	The Knowledge engineering (KE) techniques are essentially based on the knowledge transfer approach, from domain experts directly to systems. However, this has been replaced by the modelling approach which emphasises using conceptual models to model the problem-solving skill of the domain expert. This paper discusses extending the Unified Modelling Language by means of a profile for modelling knowledge-based system in the context of Model Driven Architecture (MDA) framework. The profile is implemented using the executable Modelling Framework (XMF) Mosaic tool. A case study from the health care domain demonstrates the practical use of this profile; with the prototype implemented in Java Expert System Shell (Jess). The paper also discusses the possible mapping of the profile elements to the platform specific model (FSM) of Jess and provides some discussion on the Production Rule Representation (FRR) standardisation work.	executable;expert system;java;jess;knowledge engineering;knowledge-based systems;mda framework;model-driven architecture;ncsa mosaic;platform-specific model;problem solving;production rule representation;profile (uml);prototype;subject-matter expert;systems modeling;transfer-based machine translation;unified modeling language;xmf	Mohd Syazwan Abdullah;Richard F. Paige;Chris Kimble;Ian D. Benest	2007	5th ACIS International Conference on Software Engineering Research, Management & Applications (SERA 2007)	10.1109/SERA.2007.36	natural language processing;unified modeling language;computer science;systems engineering;knowledge management;artificial intelligence;knowledge-based systems	SE	-46.6348083036019	23.994690398013656	105972
faa8b87f4d9554162615930c0064fbee05d6b5bb	iterative refinement of specification for component based embedded systems	iterative refinement;component based systems;behavior modeling;embedded system;quality system;validation;specification refinement;embedded software;reverse engineering	The current practice of component based engineering raises concerns in industry when the specification of proprietary components suffers from inaccuracy and incompleteness. Engineers face difficulties in producing quality systems when they lack knowledge of the interoperability of components. In order to address this issue, we present a novel framework for iterative refinement of specification for component based systems. The novelty is the use of a preliminary behavioral model as a source for triggering refinement iterations. Moreover, it exploits rigorous formal techniques to achieve high-level system validation as an integral part of the refinement procedure. The framework has been evaluated on an automotive system in which the embedded software control units were developed by third-party vendors. The final results produced an improved formal system specification that identified several behaviors that were previously unknown.	behavioral modeling;embedded software;embedded system;floor and ceiling functions;formal methods;formal system;high- and low-level;interoperability;iteration;iterative method;iterative refinement;refinement (computing)	Muzammil Shahbaz;K. C. Shashidhar;Robert Eschbach	2011		10.1145/2001420.2001454	behavioral modeling;reliability engineering;real-time computing;quality management system;embedded software;computer science;systems engineering;formal specification;refinement;reverse engineering	Embedded	-45.18053964599792	31.576005920180847	106070
8951795654430054452b2962cc4435e8f1a226e9	a description method for multi-agent simulation model utilizing typical action patterns of agents		Recently, there are various proposals on tool for multi-agent simulation. However, in such simulation tools, analysts who do not have programming skill spend a lot of time to develop programs because notation of simulation models is not defined sufficiently and programming language is varied on tools. To solve this problem, a programming environment that defines the notation of simulation model based on graph representation is proposed. However, in this environment, we still need to write programs about a flow of event and contents of agents’ action and effect. So, we propose a description method for multi-agent simulation model utilizing typical action patterns of agents. In this method, users write about designs of contents of event based on typical action patterns which are “interrogative (4W1H) and verbs”, and designs of a flow of event. In this paper, we executed experiments that compare time needed for examinees to generate programs by a conventional method and our programming environment. Experimental result shows the time to generate programs by utilizing our programming environment less than that by utilizing a conventional one.	action potential;agent-based model;experiment;graph (abstract data type);integrated development environment;programmer;programming language;simulation	Taiki Enomoto;Gou Hatakeyama;Masanori Akiyoshi;Norihisa Komoda	2008			systems engineering;computer science;simulation;threaded fastener;mechanical engineering	AI	-34.8029646887004	24.572498972022778	106383
d2e86b7537f7024e60449128410625a44d3d1210	cadira: an object-oriented platform for modelling molecules and analyzing simulzations	molecular simulation;programming language;software platform;object oriented;molecular modelling	Abstract   Based on the implementation of a high-level programming language, we have built a software platform which incorporates analysis of molecular simulations, molecular modelling and symbolic calculations.		Jacques Gabarro-Arpa;Marc Le Bret;A. Marcouyoux	1997	Computers & Chemistry	10.1016/S0097-8485(96)00036-8	molecular modelling;computational science;chemistry;computer science;theoretical computer science;programming language;object-oriented programming	ML	-34.65425419423814	26.195370782420717	106519
cd719f3e20b3648720f790218abba50a6fd7083f	verifying normative behaviour via normative mechanism design	concrete specification language;complexity issue;specific normative behaviour;multi-agent system;normative mechanism design;normative concept;formal setting;essential component;individual agent;multi-agent environment;associated problem	The environment is an essential component of multi-agent systems and is often used to coordinate the behaviour of individual agents. Recently many languages have been proposed to specify and implement multi-agent environments in terms of social and normative concepts. In this paper, we first introduce a formal setting of multi-agent environment which abstracts from concrete specification languages. We extend this formal setting with norms and sanctions and show how concepts from mechanism design can be used to formally analyse and verify whether specific normative behaviours can be enforced (or implemented) if agents follow their subjective preferences. We also consider complexity issues of associated problems.	complexity;multi-agent system;specification language	Nils Bulling;Mehdi Dastani	2011		10.5591/978-1-57735-516-8/IJCAI11-029	computer science;management science;algorithm	AI	-42.86364952208273	19.91844052173492	106603
7623ebf8ab7342711157d3baa7d91e7a6102f638	formalizing uml models with object-z	software analysis;proceso concepcion;representacion conocimientos;metodo diagramatico;design process;formal specification;semantica formal;object oriented design;lenguaje uml;diagramme etat;langage modelisation unifie;formal semantics;diagramme sequence;preparacion serie fabricacion;specification formelle;semantique formelle;especificacion formal;methode diagrammatique;diagram method;diagrama estado;object oriented;unified modelling language;unified modeling language;state diagram;oriente objet;process planning;knowledge representation;representation connaissances;preparation gamme fabrication;orientado objeto;sequence diagram;lenguaje formal;formal language;processus conception;langage formel	The Unified Modeling Language (UML) has been developed as a standard language for object-oriented designs. Through its graphical and intuitive diagrams, software analysis and design process become easy. However, this graphical notation lacks precisely defined semantics. It is difficult to determine whether the design is consistent, unambiguous and complete.This paper provides a method of formalizing UML models. It gives the transforming rules from UML models to Object-Z constructs. With this method, the semantics of UML models are directly expressed in formal language Object-Z. The UML class, sequence and statechart diagrams are formalized using this method. A tool OZRose is developed to automate the transforming process.	formal language;graphical user interface;object-z;state diagram;unified modeling language	Huaikou Miao;Ling Liu;Li Li	2002		10.1007/3-540-36103-0_53	knowledge representation and reasoning;unified modeling language;uml state machine;systems modeling language;uml tool;computer science;element;applications of uml;class diagram;shlaer–mellor method;programming language;node;algorithm;object constraint language	PL	-41.93142978503408	25.944923936882397	106713
560647224cc5e1f1266be8bcacfe401177695b70	evaluation of graphical control flow management approaches for event-b modelling	qa75 electronic computers computer science	Integrating graphical representations with formal methods can help bridge the gap between requirements and formal modelling. In this paper, we compare and evaluate two graphical approaches aiming at describing control flows and refinement in Event-B, and we use a fire dispatch system case study to perform this evaluation. The fire dispatch system case study provides a good example of a complex workflow through which we try to identify a process that facilitates defining the structural and the behavioural parts of the Event-B model. In our case study, we focus on building the dynamic part of the model to evaluate the two diagrammatic notations: UML Activity Diagrams and Atomicity Decomposition Diagrams. Based on our evaluation, we try to identify the advantages and limitations of both approaches. Finally, we try to compare how both graphical notations can affect the Event-B formal modelling of our case study.	activity diagram;atomicity (database systems);b-method;control flow;dynamic dispatch;formal methods;graphical user interface;plug-in (computing);refinement (computing);requirement;unified modeling language	Dana Dghaym;Michael J. Butler;Asieh Salehi Fathabadi	2013	ECEASST	10.14279/tuj.eceasst.66.891	simulation;computer science	SE	-43.67161574325374	28.878100756773467	106832
59ab8f707a81618de49ed72f5340472374d7dbca	a component assembly approach to digital library systems	digital libraries;open digital libraries;components;graphical user interface;graphic user interface;digital library	With the advent of the Internet came the promise of global information access. In keeping with this promise, Digital Libraries (DLs) began to emerge across the world as a method of providing structured information to their users. These DLs are often created using proprietary monolithic software that is usually difficult to customise and extend. The Open Digital Library (ODL) project was created to demonstrate that DLs can be built as a network of components instead of as monolithic systems. Although the ODL approach has largely been embraced by the DL community, it is not without a few shortcomings. This paper introduces a graphical user interface and its associated framework for creating DLs from distributed components, consequently addressing a number of the limitations of ODL-like systems, as well as presenting a novel and generic approach for creating component-based systems. This system was subject to a user-based evaluation to confirm its utility and provide insights into possible extensions.	component-based software engineering;dataflow;digital library;distributed element model;graphical user interface;information access;information management;internet;library (computing);malware;organic user interface;server (computing);www	Linda Eyambe;Hussein Suleman	2005	South African Computer Journal		the internet;software;digital library;human–computer interaction;multimedia;information access;computer science;graphical user interface	OS	-48.22596075794519	21.08088458816361	107405
6a0b8018689e82f0a17a4d90186e0d9810ac48e2	usability requirements as specification constraints: an example of wysiwyg	abstract model interaction;implicit assumptions;formal specification;interface design;wysiwyg;specification constraints;implicit assumptions usability requirements specification constraints wysiwyg formal modelling techniques interface design what you see is what you get style word processor interactive systems abstract model interaction template model system abstractions intended task user capabilities formal specification;what you see is what you get style word processor;usability requirements;template model;formal modelling techniques;user capabilities;software requirements and specifications;system abstractions;interactive systems;user interfaces;word processing;intended task	The paper describes the application of formal modelling techniques within interface design to a ‘what you see is what you get’ style word processor to illustrate the analysis of the usability properties of interactive systems. A formal framework as an abstract model of interaction is employed, termed the template model, which explicitly identifies system abstractions (known as templates) that have a defined relationship to the intended task and users' capabilities. In the investigation, a subset of a conventional word processor is formally specified. The specification is then analysed in terms of the template model by identifying abstractions upon which common word-processing tasks depend. The outcome of the analysis illustrates the potential benefit of the template model in explaining implicit assumptions about the usability properties of the artefact.		Chris Roast;Jawed I. A. Siddiqi	1997	Software Engineering - IEE Proceedings	10.1049/ip-sen:19970973	real-time computing;computer science;theoretical computer science;interface design;software engineering;formal specification;programming language;user interface	SE	-42.719427200232026	28.773904923356977	107465
60e60a5dcd5ac8e2db442ce0e0da6e6309fae084	a simulation model of a surveillance radar data processing system using hi-mass	visual interactive modeling surveillance radar data processing system hi mass simulation model model specification executable model construction model execution hierarchical modeling and simulation system object oriented c based system hierarchical control flow graph model paradigm sequential synchronous simulation execution algorithm complementary hierarchical specification structures model component specification interconnection specification behavior specification;model specification;formal specification;executable model construction;interconnection specification;sequential synchronous simulation execution algorithm;model component specification;hierarchical modeling and simulation system;modeling and simulation;surveillance;radar computing;search radar;visual interaction;data processing;hierarchical control;hierarchical control flow graph model paradigm;object oriented programming;flow graphs;behavior specification;model execution;hi mass;graphical user interfaces;radar computing search radar military computing military systems discrete event simulation object oriented programming formal specification radar signal processing flow graphs graphical user interfaces;surveillance data processing radar signal processing flow graphs laboratories graphical user interfaces process control communication system control sun workstations;object oriented;military systems;workstations;hierachical modeling and simulation system;hierarchical control flow graph model;process control;sun;surveillance radar data processing system;complementary hierarchical specification structures;technical report;graph model;visual interactive modeling;communication system control;c;simulation model;radar signal processing;hierarchical model;object oriented c based system;military computing;discrete event simulation	The paper discusses the model specification, construction of the executable model, model execution, and the simulation results of a simulation model of a surveillance radar data processing system that was developed using the Hierarchical Modeling and Simulation System (HI-MASS). HI-MASS is an object oriented C++ based system that supports model specification (modeling) using the Hierarchical Control Flow Graph Model paradigm and executes simulation models using the sequential synchronous simulation execution algorithm. Models specified in this model paradigm use two complementary hierarchical specification structures, one to specify the model components and their interconnections and the other to specify the behaviors of the individual components. The components and their interconnections are specified in HI-MASS via visual interactive modeling.	algorithm;c++;control flow graph;executable;programming paradigm;radar;simulation;specification language	Steven D. Farr;Douglas G. Fritz;Alex F. Sisti;Robert G. Sargent	1995		10.1145/224401.224821	real-time computing;simulation;data processing;computer science;theoretical computer science;process control;modeling and simulation;programming language;object-oriented programming	Embedded	-36.30538226302265	28.24382927131132	107556
480fa3589caba7e59e46f7198d53c355295bdd92	aspect-oriented concrete syntax definition for deep modeling languages		Multi-level modeling tools provide inherent support for modeling domain scenarios with multiple classification levels. However, as the success of domain-specific modeling tools illustrates users increasingly expect to be able to visualize models using domain-specific languages. It is relatively straightforward to support this using traditional “two-level” modeling technologies, but many of the benefits of multi-level modeling would be lost. For example, in a multi-level context it is not only desirable to define concrete syntax that is applicable over more than just one instantiation level, it should also be possible to customize the visualization of model elements as they become more specialized over instantiation and inheritance levels. In this paper we present an approach for multi-level concrete syntax definition which addresses this need by using aspect-oriented principles to parametrize the visualization associated with model elements. We also explain how this is implemented in the Melanee deep modeling tool.	aspect weaver;aspect-oriented software development;digital photo frame;domain-specific language;domain-specific modeling;error-tolerant design;graphical user interface;modeling language;multiple inheritance;no silver bullet;parse tree;universal instantiation	Colin Atkinson;Ralph Gerbig	2015			syntax (programming languages);modeling language;aspect-oriented programming;syntax;artificial intelligence;visualization;natural language processing;homoiconicity;abstract syntax;computer science	SE	-47.811426416013354	25.92370038308241	107697
84ef2ac25e180d4772991fa1ffba53a2f5435d27	flexible, lightweight requirements modeling with flexisketch	unified modeling language metamodeling educational institutions prototypes context software design;sketch recognition;computer graphics;software tools computer graphics formal verification;free form sketching;formal verification;software tools;requirements modeling;sketch recognition requirements modeling free form sketching lightweight meta modeling;paper based approach lightweight requirements modeling early stage requirements models flexisketch tool prototype free form sketching lightweight metamodeling capabilities automatic transcription documented information tablet devices pencil based approach;lightweight meta modeling	Early stage requirements models are often documented using paper and pencil-based approaches. In our current research, we are exploring lightweight modeling tools and approaches that could provide a beneficial alternative. We have developed the FlexiSketch tool prototype which combines support for free-form sketching with lightweight metamodeling capabilities. This creates the possibility for an automatic transcription of the documented information in later modeling stages. The tool is designed to be used on tablet devices.	metamodeling;prototype;requirement;requirements analysis;tablet computer;transcription (software)	Dustin Wüest;Norbert Seyff;Martin Glinz	2012	2012 20th IEEE International Requirements Engineering Conference (RE)	10.1109/RE.2012.6345826	lightweight methodology;simulation;formal verification;computer science;systems engineering;programming language;computer graphics;engineering drawing;sketch recognition	SE	-47.70817940301193	29.056531312262383	107917
95417e9440255f9b7d4d5a784a03b2aae7c9f538	live sequence charts: an introduction to lines, arrows, and strange boxes in the context of formal verification	formal semantics;formal verification;message sequence chart	The language of Message Sequence Charts (MSC) is a wellestablished visual formalism which is typically used to capture scenarios in the early stages of system development. But when it comes to rigorous requirements capturing, in particular in the context of formal verification, serious deficiencies emerge: MSCs do not provide means to distinguish mandatory and possible behavior, for example to demand that a communication is required to finally occur. The Live Sequence Chart (LSC) language introduces the distinction between mandatory and possible on the level of the whole chart and for the elements messages, locations, and conditions. Furthermore they provide means to specify the desired activation time by an activation condition or by a whole communication sequence, called pre-chart. We present the current stage of LSC language and a sketch of its formal semantics in terms of Timed Büchi Automata.	activation function;automata theory;behavioral modeling;bridging (networking);büchi automaton;damm algorithm;formal system;formal verification;graphical user interface;interaction;loop unrolling;message sequence chart;mock object;requirement;semantics (computer science);simulation;timed automaton	Matthias Brill;Werner Damm;Jochen Klose;Bernd Westphal;Hartmut Wittke	2004		10.1007/978-3-540-27863-4_21	real-time computing;real-time operating system;formal verification;computer science;artificial intelligence;theoretical computer science;formal semantics;database;distributed computing;programming language;computer security;message sequence chart;algorithm	SE	-40.84161175654598	29.22333275280312	107970
daf0daabedad5311c44050978691b2f8e971538e	bdd-based analysis of test cases for plc-based railway interlocking systems				André Medek;Jörg Ritter;Paul Molitor	2011			reliability engineering;operations management;test case;interlocking;engineering	SE	-47.04063314859833	32.20903526490696	108039
140104551cc889c94e37bf3f8e84f29eaf1d34e3	boosting web intrusion detection systems by inferring positive signatures	anomaly detection;false negative;regular language;network intrusion detection;web application security;regular languages;intrusion detection systems;false positive;intrusion detection system	We present a new approach to anomaly-based network intrusion detection for web applications. This approach is based on dividing the input parameters of the monitored web application in two groups: the “regular” and the “irregular” ones, and applying a new method for anomaly detection on the “regular” ones based on the inference of a regular language. We support our proposal by realizing Sphinx, an anomaly-based intrusion detection system based on it. Thorough benchmarks show that Sphinx performs better than current state-of-the-art systems, both in terms of false positives/false negatives as well as needing a shorter training period.	anomaly detection;anomaly-based intrusion detection system;antivirus software;benchmark (computing);black box;boosting (machine learning);electronic signature;human-readable medium;online and offline;ozoneweb;plasma cleaning;regular expression;regular language;software deployment;sphinx;statistical model;test set;web application	Damiano Bolzoni;Sandro Etalle	2008		10.1007/978-3-540-88873-4_2	anomaly-based intrusion detection system;anomaly detection;computer science;machine learning;pattern recognition;data mining	Security	-35.68295752631608	23.091855070919355	108040
10cfda804e123daa6a55b358795bf23981edafba	test generation from bounded algebraic specifications using alloy		Algebraic specification languages have been successfully used for the formal specification of abstract data types (ADTs) and software components, and there are several approaches to automatically derive test cases that check the conformity between the implementation and the algebraic specification of a software component. However, existing approaches do not assure the coverage of conditional axioms and conditions embedded in complex axioms. In this paper, we present a novel approach and a tool to automatically derive test cases from bounded algebraic specifications of ADTs, assuring axiom coverage and of all minterms in its full disjunctive normal form (FDNF). The algebraic specification is first translated into the Alloy modelling language, and the Alloy Analyzer tool is used to find model instances for each test goal (axiom and minterm to cover), from which test cases in JUnit are extracted.	32-bit;abstract data type;algebraic specification;alloy (specification language);alloy analyzer;component-based software engineering;conformity;disjunctive normal form;eclipse;embedded system;formal specification;http 404;junit;microsoft windows;modeling language;mutation testing;plug-in (computing);priority queue;random-access memory;randomness extractor;scalability;stack (abstract data type);test case	Francisco Rebello de Andrade;João Pascoal Faria;Ana C. R. Paiva	2011			formal specification;discrete mathematics;computer science;data mining;theoretical computer science;abstract data type;test case;axiom;algebraic specification;disjunctive normal form;alloy analyzer;bounded function	SE	-45.619931396105855	31.306025328260112	108408
9eb0d85bdbeea35078b86c226a6114043d0a8d8c	specification scheme for the visualisation of data structures	data structures visualization software requirements and specifications visual programming;graphical representations;data structures visualisation;structure models;visual programming data structures data visualisation formal specification;convex hull;convex hull specification scheme data structures visualisation program visualisation structure models critical entities graphical representations;data structure;specification scheme;program visualisation;critical entities	The paper describes a general principle for program visualisation, based on the concept of structure models. We propose a specification scheme that can be used to implement the general principle without requiring a change of the program code. Two aspects of the scheme are discussed in detail; the specification of critical entities and their graphical representations. Its use is illustrated by means of a specification for the visualisation of a program which calculates the convex hull of a finite set of points.	data structure	Xinbo Lu;Franz Stetter	1994	Software Engineering Journal	10.1049/sej.1994.0016	data structure;computer science;theoretical computer science;convex hull;data mining;programming language	SE	-46.89736649477965	27.875054505456546	108423
0ef6d3e5506b0ee5907d38e6e2b842c1cdae4c9a	enacting and deacting roles in agent programming	developpement logiciel;dynamic programming;lenguaje programacion;multiagent system;programacion dinamica;programming language;orientado agente;semantica formal;intelligence artificielle;formal semantics;systeme ouvert;oriente agent;semantique formelle;desarrollo logicial;software development;programmation dynamique;langage programmation;open system;artificial intelligence;agent oriented;inteligencia artificial;sistema multiagente;open systems;sistema abierto;agent programming;wiskunde en informatica wiin;systeme multiagent;agent programming language	In the paper we study the dynamics of roles played by agents in multiagent systems. We capture role dynamics in terms of four operation performed by agents: ‘enactment’, ‘deactment’, ‘activate’, and ‘deactivate’. The use of these operations are motivated, in particular for open systems. A formal semantics for these operations are provided. This formalization is aimed at serving as a basis for implementation of role dynamics in an agent programming language such as 3APL.	3apl;agent-based model;multi-agent system;open system (computing);programming language;semantics (computer science)	Mehdi Dastani;M. Birna van Riemsdijk;Joris Hulstijn;Frank Dignum;John-Jules Ch. Meyer	2004		10.1007/978-3-540-30578-1_13	simulation;computer science;artificial intelligence;open system;programming language;algorithm	AI	-39.18391814216475	24.370185442277247	108455
056a59af6f3beed7e40f932b8b4b7274a4465ccf	covering places and transitions in open nets	soa;operating guidelines;process modeling and analysis;petri nets	We present a finite representation of all services M where the composition with a given service N is deadlock-free, and a given set of activities of N can be covered (i.e. is not dead). Our representation is an extension of the existing notion of an operating guideline which only cared about deadlock freedom. We further present an algorithm to decide whether a service M matches with the extended operating guideline of N .	algorithm;business process execution language;compiler;concurrency (computer science);correctness (computer science);deadlock;formal verification;lecture notes in computer science;over-the-top content;service composability principle;soundness (interactive proof);springer (tank);web service	Christian Stahl;Karsten Wolf	2008		10.1007/978-3-540-85758-7_11	real-time computing;computer science;operations management;service-oriented architecture;database;distributed computing;petri net	Logic	-34.8164453352525	31.47992293607923	108663
27a12825e5397d5971370b62fa9fb56da574f39f	high-level behavioral sdl model for the ieee 802.15.3 mac protocol	concepcion modular;protocolo acceso;behavioral analysis;layer model;mac protocol;modelo capa;design flow;subestructura;access protocol;subsystem;client server;paradigm;sous systeme;chemin donnee;object oriented;system design;modele couche;analyse comportementale;sous structure;object oriented approach;substructure;paradigme;modular design;oriente objet;analisis conductual;protocole acces;paradigma;orientado objeto;subsistema;conception modulaire	In this paper, we present our behavioral SDL model for the IEEE 802.15.3 MAC protocol. The model was derived using an object-oriented approach based on the client/server paradigm and is divided into data path and control path subsystems. Within the model, there are different abstraction layers, each layer providing a welldefined set of services to the higher layers. This modular design approach facilitated teamwork and led to a model, which is understandable, easy to extend, adapt, and test. Thus, our SDL model can serve as a basis for the following steps in the design flow, which is also presented briefly.	abstraction layer;client–server model;design flow (eda);modular design;programming paradigm;server (computing)	Daniel Dietterle;Irina Babanskaja;Kai F. Dombrowski;Rolf Kraemer	2004		10.1007/978-3-540-24643-5_15	embedded system;simulation;substructure;telecommunications;computer science;design flow;operating system;system;object-oriented programming;modular design;client–server model;systems design	Embedded	-39.213498628985775	26.10930681864283	108956
49c400c4991a85d67fe4d0d30bbf6b040a907ff0	stability of software trustworthiness measurements models	software computational modeling mathematical model software measurement stability analysis entropy monte carlo methods;stablility measurement model of software trustworthiness monte carlo method;software evaluation tool software trustworthiness measurements models cyber physical system security monte carlo method stability rule;stablility;monte carlo method;measurement model of software trustworthiness;security of data monte carlo methods;security of data;monte carlo methods	The software trustworthiness is an important feature for the safety and security of cyber-physical system. Therefore, how to assess software trustworthiness is the key issue. Tao has recently given five measurement models of software trustworthiness based on the attributes of software in his Doctoral Dissertation and his publications. After simulating these models with the Monte Carlo method, we find out that these models have a common shortcoming that the trustworthy degree would not be within the same range as the range in which all attributes' values are. In order to solve this problem, this paper introduces the stability rule with which measurement model of software trustworthiness is proposed. According to these rules, this paper proposes two models which are originally based on Tao's models. The succeeding mathematical proof and simulation demonstrate that these models meet all the rules. These two models have been applied to compute the degree of software trustworthiness in the software trustworthy measurement and evaluation tool.	cyber-physical system;mathematical model;monte carlo method;simulation;software trustworthiness;trust (emotion)	Lewen Zhang;Yong Zhou;Yixiang Chen;Min Zhang;Juyang Zhang	2013	2013 IEEE Seventh International Conference on Software Security and Reliability Companion	10.1109/SERE-C.2013.23	simulation;computer science;theoretical computer science;data mining	SE	-36.198149076515314	20.62780189372071	109006
64f28c65dfdc187050c8f44d322c6c6280489876	variable-specific resolutions for feature interactions	feature interaction;conflict resolution	Systems assembled from independently developed features suffer from feature interactions, in which features affect one another's behaviour in surprising ways. The feature-interaction problem states that the number of potential interactions is exponential in the number of features in a system. Resolution strategies offer general strategies that resolve entire classes of interactions, thereby reducing the work of the developer who is charged with the task of resolving interactions. In this paper, we focus on resolving interactions due to conflict. We present an approach, language, and implementation based on resolution modules in which the developer can specify an appropriate resolution for each variable under conflict. We performed a case study involving 24 automotive features, and found that the number of resolutions to be specified was much smaller than the number of possible feature interactions (6 resolutions for 24 features), that what constitutes an appropriate resolution strategy is different for different variables, and that the subset of situation calculus we used was sufficient to construct nontrivial resolution strategies for six distinct output variables.	feature interaction problem;resolution (logic);situation calculus;time complexity	Cecylia Bocovich;Joanne M. Atlee	2014		10.1145/2635868.2635927	simulation;computer science;artificial intelligence	SE	-38.33854497647271	30.06811915150907	109016
9d1f75457b64eee8b9ed0afdb9cf751891cc859a	dart - a software architecture for the creation of a distributed asynchronous recognition toolbox	feedback mechanism;handwriting recognition;multi expert system;expert systems;optical character recognition;distributed processing;toolbox architecture;software performance evaluation;expert system dart software architecture distributed asynchronous recognition toolbox document recognition document analysis research cooperating recognition algorithms performance parallel execution tool configuration run time interactive access experimental systems handwriting recognition poor quality facsimile;software engineering;distributed recognition engine;dynamic reconfigurability;software architecture;cooperative systems;facsimile;system integration;document image processing;modularity;software architecture engines facsimile character recognition optical character recognition software runtime handwriting recognition writing world wide web pipelines;institutional repository research archive oaister;expert systems document image processing software engineering distributed processing optical character recognition software performance evaluation handwriting recognition facsimile cooperative systems	Automatic analysis and recognition of documents is a complex task. Substantial research effort has therefore been spent addressing sub-tasks of manageable size. The solutions, however, have to be integrated into a comprehensive engine. Following the idea of a toolbox a software architecture has been developed that enables various tools to be combined into a network of cooperating recognition algorithms. Distributing the tools on a number of processors improves overall performance by parallel execution. The configuration of the tools as well as the connections between them can easily be modified even at run-time. Simple, interactive access to the various parameters and intermediate results of an algorithm aids the development and evaluation of experimental systems. The modular approach also facilitates extension of existing systems by the integration of novel methods. DART, the Distributed Asynchronous Recognition Toolbox architecture, realises these features. DART has been successfully used for recognition of handwriting and poor quality facsimiles.	software architecture	Andreas Hennig;E. Marongiu;Nasser Sherkat;Robert J. Whitrow	1997		10.1109/ICDAR.1997.619885	software architecture;computer vision;speech recognition;computer science;theoretical computer science;machine learning;feedback;modularity;handwriting recognition;optical character recognition;world wide web;system integration	Robotics	-34.081002665393044	28.55598105223876	109088
25ddbe5ebb9c35629a45fbacb4e520353adb1e3b	a concept model of web components	service oriented development web components distributed service software development;service orientation;software engineering;software engineering internet;internet;software development;robustness educational institutions agricultural engineering protection information resources programming contracts internet web services semantic web	The Web environment has shifted from a distributed source of information to a distributed source of service. Service-oriented has become mainstream in software development. Because of this, research into the new theory and methodology of software should be carried out. As a new paradigm, Web components aim at providing support to service-oriented development by enabling automatic discovery, composition, invocation and interoperation of services. We discuss various aspects of Web components and present a concept model of Web components. By means of parameterized contracts, we discuss the introspection of Web components in detail and present an approach to tailoring the service.	information source;interoperation;introspection;programming paradigm;semantic web service;service-orientation;service-oriented architecture;service-oriented device architecture;service-oriented software engineering;software as a service;software development;web components;world wide web	Yui-Ku Fei;Zhijian Wang	2004	IEEE International Conference onServices Computing, 2004. (SCC 2004). Proceedings. 2004	10.1109/SCC.2004.1358003	web service;web application security;web development;web modeling;data web;web mapping;web design;web standards;computer science;knowledge management;component-based software engineering;software development;ws-policy;service-oriented architecture;web navigation;social semantic web;software as a service;database;web intelligence;resource-oriented architecture;web 2.0;world wide web;mashup	SE	-47.3521317911366	18.377026629130686	109374
66c7d0490dad85c5d99f7a1a2eee5c6497f1b7b4	an approach for designing a real-time intelligent distributed surveillance system		model Classes/Objects Templates/components Communication model message passing Shared data ( protocols taxonomy ) Concurrency Not inherent in the design. Inherent in the design Information Hiding Encapsulation Access procedures, access mechanisms Modularisation Objects, classes Activities, IDAs, subsystems, servers Inheritance Yes No Dynamism Through late bindings, inheritance and polymorphism. MASCOT 2-Yes (although it is not advisable) MASCOT 3/DORISNo E ss en tia l c on ce pt s Timing behaviour Non-explicit Partially explicit through the temporal interaction effects on the operations (reading and writing) Table 3-2. Summary of the aspects to compare at the conceptual model. 3.7.1 The difference of abstract model between the two approaches Conceptually one of the main differences between OO and RTN is how both approaches tackle the problem of modelling real-world entities. The OO approach abstracts the problem by modelling the real-world entities as objects. An OO design tries to reincarnate objects from the problem domain into the computer models, giving the objects in an OO program (OOP) equivalent characteristics and capabilities as the real-world entities that they are modelling. These objects are commonly grouped to simplify design and reduce code, by defining a relationship between these objects such as inheritance. For example a car object, a lorry object and a motorcycle object can be inherited from an abstract class called vehicle, because these three objects have some common attributes that can be grouped in an	abstract type;computer simulation;entity;message passing;problem domain;real-time locating system;reincarnation	Maria Valera Espina	2006			simulation;system of systems;systems engineering;engineering;artificial intelligence;monitoring and surveillance agents;systems design	SE	-38.84693205542712	30.675607172304037	109795
31421fb722a467f103dbce30a521445ed7948e42	mobster: a model-based security testing framework for web applications				Michele Peroli;Federico De Meo;Luca Viganò;Davide Guardini	2018	Softw. Test., Verif. Reliab.	10.1002/stvr.1685	model checking;software engineering;reliability engineering;security testing;model-based testing;web application;computer science	SE	-46.95095448993495	31.764153741525604	109824
87a9dd5eee03d55b3b38ba60474222758f0dc6a8	generative components for hybrid systems tools	domain specific modeling;programming language;code generation;general techniques;hybrid system	Generative techniques, while normally associated with programming languages or code generation, may also be used to produce non-executable artifacts (e.g., configuration or toolchain artifacts). Coupled with domain-specific modeling, generative techniques provide a way to consolidate toolchains and complex domains into a relatively compact space, by providing generators that produce artifacts in the appropriate semantic domain. This paper describes the motivation and usage of one such environment, in the domain of hybrid systems, as well as discussion and goals for future research.	code generation (compiler);domain-specific modeling;executable;generativecomponents;hybrid system;programming language;toolchain	Jonathan Sprinkle	2004	Journal of Object Technology	10.5381/jot.2005.4.3.a5	natural language processing;computer science;theoretical computer science;programming language;code generation;hybrid system;generative design	SE	-47.83859093082534	25.978150572766484	109979
35a29d679f9d5efb1ffe9047353da883cdf1ed42	developing an automated distributed meeting scheduler	office automation scheduling groupware distributed processing software agents;groupware;design and development;distributed processing;software systems;software agents;quality of information;scheduling;intelligent agent;intelligent agent software systems analytical models calendars processor scheduling humans intelligent systems software prototyping prototypes feedback;system functionality automated distributed meeting scheduler automated scheduling agents productive tasks information processing quality software system agent negotiation user specified constraints user feedback user interface;office automation	Automated scheduling agents allow users to concentrate on productive tasks and to improve the quality of information processing. The author uses a distributed approach with intelligent agents to design and develop efficient meeting scheduling. The purpose of the project is to design and implement a software system that uses intelligent meeting-scheduling agents that can negotiate with other agents without compromising their user-specified constraints. A small group of researchers in our department runs the prototype system, and we are using feedback from them to improve the interface and to expand the functionality of the system.	scheduling (computing)	Sandip Sen	1997	IEEE Expert	10.1109/64.608189	agent architecture;embedded system;real-time computing;computer science;artificial intelligence;software agent;distributed computing;information quality;scheduling;intelligent agent;software system	Vision	-39.6350824187441	18.521485078174635	110014
4d7ed9f1160dc574a1be06a71a894f916c46bc4e	towards real-time object-z	towards real-time object-z;specification language;real time	This paper presents a method of formally specifying systems involving continuous variables and real-time constraints using the object-oriented state-based speciication language Object-Z together with the timed trace notation of the timed reenement calculus. The basis of this integration is a mapping of the existing Object-Z history semantics to timed traces.	formal specification;object-z;real-time locating system;real-time operating system;real-time transcription;tracing (software)	Graeme Smith;Ian J. Hayes	1999			software requirements specification;formal methods;specification language;computer science;software design;social software engineering;software development;software construction;functional specification;programming language;programming language specification	SE	-42.636914827676684	30.6741561646693	110092
aba6bc5ca45d29369b805e1dd9675f65c15b94a1	on the unification power of models	generic model;research agenda;satisfiability;model integrated computing;model driven engineering;domain specific language;generic programming	In November 2000, the OMG made public the MDA™initiative, a particular variant of a new global trend called MDE (Model Driven Engineering). The basic ideas of MDA are germane to many other approaches such as generative programming, domain specific languages, model-integrated computing, generic model management, software factories, etc. MDA may be defined as the realization of MDE principles around a set of OMG standards like MOF, XMI, OCL, UML, CWM, SPEM, etc. MDE is presently making several promises about the potential benefits that could be reaped from a move from code-centric to model-based practices. When we observe these claims, we may wonder when they may be satisfied: on the short, medium or long term or even never perhaps for some of them. This paper tries to propose a vision of the development of MDE based on some lessons learnt in the past 30 years in the development of object technology. The main message is that a basic principle (“Everything is an object”) was most helpful in driving the technology in the direction of simplicity, generality and power of integration. Similarly in MDE, the basic principle that “Everything is a model” has many interesting properties, among others the capacity to generate a realistic research agenda. We postulate here that two core relations (representation and conformance) are associated to this principle, as inheritance and instantiation were associated to the object unification principle in the class-based languages of the 80’s. We suggest that this may be most useful in understanding many questions about MDE in general and the MDA approach in particular. We provide some illustrative examples. The personal position taken in this paper would be useful if it could generate a critical debate on the research directions in MDE.	automatic programming;bernard galler;computer science;conformance testing;dave thomas (programmer);david turner (computer scientist);domain-specific language;entity;executable;jean;java;marc (archive);maniac mansion;meta-object facility;meta-process modeling;metamodeling;model-driven engineering;object constraint language;ontology engineering;point of view (computer hardware company);programming language;sms language;scalability;software development;software factory;unification (computer science);unified modeling language;universal instantiation;william jolitz;xml metadata interchange	Jean Bézivin	2005	Software & Systems Modeling	10.1007/s10270-005-0079-0	model-driven architecture;simulation;computer science;domain-specific language;artificial intelligence;programming language;generic programming;algorithm;satisfiability	SE	-47.719465358099946	24.78568163346728	110102
4493092f06b55284ce97d1b2e84252f1195dfe19	an approach to synchronize uml-based design components for model-driven protocol development	multiple representation;activity diagram;protocols;unified modeling language communication protocols model driven development components model synchronization;components;uml specification uml based design components model driven protocol development uml diagrams dependable systems communication protocols sequence diagrams protocol data unit coding decoding correctness checks activity diagrams balancing model uml sequence mapping rules;semantics;data model;model driven development;dependable systems;visualization;protocols unified modeling language semantics synchronization visualization encoding data models;synchronization;model synchronization;unified modeling language;component model;communication protocol;encoding;sequence diagram;communication protocols;protocol data unit;data models;unified modeling language protocols	Applying UML diagrams for the design of dependable systems like communication protocols helps to visualize the protocol behavior in multiple representations. In principle, protocols are comprehensible by modeling its behaviors through sequence diagrams. However, the sequence diagrams encapsulate local protocol functions, such as protocol data unit coding/decoding, correctness checks, etc. To model the local actions of the protocol entities activity diagrams may be used as a balancing model. By using two different models, one should ensure that the described behaviors are consistent. To prove this we present an approach in this paper to synchronize the UML sequence and activity diagrams through mapping rules. The rules are predefined according to the UML specification by a stereotype. Later they are used for validating the two diagrams. We show the approach for an example protocol function.	activity diagram;correctness (computer science);dependability;entity;model-driven architecture;sequence diagram;stereotype (uml);unified modeling language	Prabhu Shankar Kaliappan;Hartmut König	2011	2011 IEEE 34th Software Engineering Workshop	10.1109/SEW.2011.10	communications protocol;real-time computing;computer science;theoretical computer science;applications of uml;distributed computing;semantics;story-driven modeling	SE	-43.47734265738478	28.892685922530198	110210
30ce13714dbc0f95aa761ce97edf4c4176a8fc5a	describing similar control flows for families of problem-solving methods	developpement logiciel;modelizacion;software;systeme intelligent;adquisicion del conocimiento;categories of psms;sistema inteligente;acquisition connaissances;reuse;resolucion problema;modelisation;software architecture;similarities;desarrollo logicial;knowledge acquisition;software development;control flow;intelligent system;software component;problem solving method;meta modeling;architectures;modeling;meta model;problem solving;resolution probleme;problem solving methods	A library of software components should be essentially more than just a juxtaposition of its items. For problem-solving methods the notion of a family is suggested as means to cluster the items and to provide partially a structure of the library. This paper especially investigates how the similar control flows of the members of such a family can be described in one framework.	component-based software engineering;library (computing);problem solving	Rainer Perkuhn	1999		10.1007/3-540-48775-1_27	metamodeling;software architecture;systems modeling;computer science;artificial intelligence;component-based software engineering;software development;reuse;programming language;control flow;algorithm	SE	-38.66630546838078	24.706009325540276	110443
e21b7813c570c05a2e77e48994001346218cd6c3	two cegar-based approaches for the safety verification of plc-controlled plants	bounded model checking;safety verification;cegar;reachability analysis;hybrid systems	In this paper we address the safety analysis of chemical plants controlled by programmable logic controllers (PLCs). We consider a specification of the control program of the PLCs, extended with the specification of the dynamic plant behavior. The resulting hybrid models can be transformed to hybrid automata, for which advanced techniques for reachability analysis exist. However, the hybrid automata models are often too large to be analyzed. We propose two counterexample-guided abstraction refinement (CEGAR) approaches to keep the size of the hybrid models moderate.		Johanna Nellen;Kai Driessen;Martin R. Neuhäußer;Erika Ábrahám;Benedikt Wolters	2016	Information Systems Frontiers	10.1007/s10796-016-9671-9	computer science;theoretical computer science;algorithm;hybrid system	Logic	-40.28988037396224	31.34808356024701	110580
7e6dd5150bde3dc27019a82a38736b0c5ebcfaea	specifying dima multi-agents models using maude	modele comportement;modelizacion;distributed system;behavior model;multiagent system;architecture systeme;systeme reparti;formal specification;multi agent system;validacion;agent modeling;modelo comportamiento;simultaneidad informatica;intelligence artificielle;logical programming;development process;specification formelle;feasibility;modelisation;especificacion formal;concurrency;sistema repartido;concurrent systems;programmation logique;reecriture;rewriting logic;artificial intelligence;ambiguity;arquitectura sistema;validation;inteligencia artificial;rewriting;system architecture;sistema multiagente;verification and validation;programacion logica;ambiguedad;modeling;simultaneite informatique;practicabilidad;faisabilite;reescritura;ambiguite;systeme multiagent	The lack of formalism and rigor in existing multi-agents models often leads to ambiguities and different interpretations. Those weaknesses combined with the inherent complexity of multi-agents systems generate many problems in their development process. Using formal notations to specify multi-agents systems' behavior makes it possible to produce precise description. This also offers a better support to their verification and validation process. The Maude language, based on rewriting logic, presents a rich notation supporting formal specification and implementation of concurrent systems. In this paper, we demonstrate the feasibility and the interest of formalizing the behavior of DIMA model's agents with the Maude language. The elaborated formal approach captures the inherent aspects of a DIMA model. The generated Maude descriptions have been validated using the platform supporting this language. Moreover, the proposed approach is generic and extensible. It offers, in particular, the advantage of being applicable to all multi-agents systems based on DIMA architecture and presents interesting extension possibilities.	dima;maude system	Noura Boudiaf;Farid Mokhati;Mourad Badri;Linda Badri	2004		10.1007/978-3-540-32128-6_3	feasibility study;rewriting;computer science;artificial intelligence;multi-agent system;programming language;algorithm;systems architecture	NLP	-39.98734979886195	25.421194263308255	110599
cf083dcdfa5eee3bf3dc3779c87c83de13bfaaa1	an abstract representation model for evolutionary analysis of multi-agent interactions	category theory biomedical ontologies evolutionary analysis multi agent system agent interactions;agent interaction;protocols;multiagent system;biomedical ontologies;evolutionary computation;formal specification;multi agent system;agent interactions;semantics;steering rules;dynamic systems;ontologies artificial intelligence category theory cooperative systems evolutionary computation formal specification medical computing multi agent systems;ontologies artificial intelligence;ontologies unified modeling language protocols multiagent systems semantics synchronization merging;medical computing;evolutionary multiagent interactions analysis;multi agent systems;category theory;intelligent agents;cooperative systems;evolutionary analysis;synchronization;unified modeling language;merging;biomedicine;complex systems;formal representation vehicle;ontologies;formal representation vehicle abstract representation model evolutionary multiagent interactions analysis intelligent agents dynamic systems complex systems steering rules biomedicine ontologies category theory;multiagent systems;abstract representation model	Intelligent agents are able to assist human in managing highly dynamic and complex systems in various knowledge intensive domains. The communication between different agents interacting in an integrated multi-agents system can be managed through a set of steering rules, which together form interaction protocols. To support the negotiation, communication and interaction between different intelligent agents, using an appropriate knowledge representation formalism is crucial. This paper introduces the potential of category theory as a formal representation vehicle to facilitate evolutionary analysis of agent interaction and negotiation for managing evolving ontologies in the domain of biomedicine. Utilizing categories supports agents' communication, negotiation, state transitions, compositions and transformations in different levels of abstractions.	category theory;complex systems;intelligent agent;interaction;knowledge representation and reasoning;multi-agent system;ontology (information science);semantics (computer science)	Arash Shaban-Nejad;Volker Haarslev	2011	2011 IEEE Congress of Evolutionary Computation (CEC)	10.1109/CEC.2011.5949861	unified modeling language;communications protocol;synchronization;open biomedical ontologies;computer science;knowledge management;ontology;artificial intelligence;theoretical computer science;dynamical system;multi-agent system;formal specification;category theory	AI	-40.58784898222474	19.251631627401608	110630
6423e3be9b0061a12c8bbddc881520f71ee2be92	constructing a multilayered boundary to defend against intrusive anomalies	protection information;identificacion ciega;teledetection;intruder detector;evaluation performance;its performance intrusion detection;tecnologia electronica telecomunicaciones;learning algorithm;performance evaluation;televigilancia;information security;securite;proceso markov;surveillance;gradient method;anomaly detection;evaluacion prestacion;reinforcement learning;pomdp;decision markov;multicouche;intrusion detection;algorithme apprentissage;multiple layer;methode gradient;captador medida;remote supervision;measurement sensor;vigilancia;capteur mesure;apprentissage renforce;proteccion informacion;metodo gradiente;telesurveillance;processus markov;information protection;remote sensing;capa multiple;safety;teledeteccion;identification aveugle;markov process;markov decision;information system;0707d;tecnologias;detecteur intrus;grupo a;aprendizaje reforzado;seguridad;algoritmo aprendizaje;detector intruso;systeme information;blind identification;sistema informacion	We propose a model for constructing a multilayered boundary in an information system to defend against intrusive anomalies by correlating a number of parametric anomaly detectors. The model formulation is based on two observations. First, anomaly detectors differ in their detection coverage or blind spots. Second, operating environments of the anomaly detectors reveal different information about system anomalies. The correlation among observation-specific anomaly detectors is first formulated as a Partially Observable Markov Decision Process, and then a policy-gradient reinforcement learning algorithm is developed for an optimal cooperation search, with the practical objectives being broader overall detection coverage and fewer false alerts. A host-based experimental scenario is developed to illustrate the principle of the model and to demonstrate its performance.		Zonghua Zhang;Hong Shen	2007	IEICE Transactions	10.1093/ietisy/e90-d.2.490	intrusion detection system;anomaly detection;simulation;partially observable markov decision process;computer science;gradient method;artificial intelligence;information security;machine learning;markov process;reinforcement learning;computer security;information protection policy;information system	Visualization	-36.14910913974759	19.374303312189202	110651
205f79d0690ad8588264dc23ddc0004301379eca	towards an i/o conformance testing theory for software product lines based on modal interface automata		We present an adaptation of input/output conformance (ioco) testing principles to families of similar implementation variants as appearing in product line engineering. Our proposed product line testing theory relies on Modal Interface Automata (MIA) as behavioral specification formalism. MIA enrich I/O-labeled transition systems with may/must modalities to distinguish mandatory from optional behavior, thus providing a semantic notion of intrinsic behavioral variability. In particular, MIA constitute a restricted, yet fully expressive subclass of I/O-labeled modal transition systems, guaranteeing desirable refinement and compositionality properties. The resulting modal-ioco relation defined on MIA is preserved under MIA refinement, which serves as variant derivation mechanism in our product line testing theory. As a result, modal-ioco is proven correct in the sense that it coincides with traditional ioco to hold for every derivable implementation variant. Based on this result, a family-based product line conformance testing framework can be established.	audio feedback;automaton;conformance testing;formal system;heart rate variability;input/output;modal logic;refinement (computing);software product line;spatial variability	Lars Luthmann;Stephan Mennicke;Malte Lochau	2015		10.4204/EPTCS.182.1	computer science;mathematics;algorithm	Logic	-38.02399157842956	30.432638063553235	110688
177dceba10b1f767fecf03e7b3bbb349d8004c12	a contract-based approach for monitoring collaborative web services using commitments in the event calculus	gestion integrada;modelizacion;gestion integree;commitments;gestion entreprise;fiabilidad;reliability;event calculus;surveillance;processus metier;service web;firm management;semantics;integrated management;web service;contrato;semantica;semantique;collaboration and coordination;sistema reactivo;modelisation;analyse syntaxique;vigilancia;internet;contract;monitoring;analisis sintaxico;syntactic analysis;fiabilite;service monitoring;reactive system;systeme reactif;proceso oficio;administracion empresa;monitorage;contrat;information system;monitoreo;modeling;systeme information;business process;servicio web;sistema informacion	Web services (WS) are gaining popularity for supporting business interactions in cross-organisational distributed business processes. However, current WS specifications mostly concentrate on syntactic aspects. Because multiparty collaborations in business involve complex and long-lived interactions between autonomous partners, their behaviour must be specified to ensure the reliability of the collaboration.#R##N##R##N#This paper presents an event-based framework associated with a semantic definition of the commitments expressed in the event calculus, to model and monitor multi-party contracts. This framework permits to coordinate and regulate Web services in business collaborations, by allowing detection of actual and imminent violations.	event calculus;web service	Mohsen Rouached;Olivier Perrin;Claude Godart	2005		10.1007/11581062_32	contract;web service;reactive system;computer science;reliability;semantics;event calculus;business process;law;world wide web;computer security;information system	ML	-40.257380023941494	24.270860723679498	111273
19f0f0d8626c2a5c1ed544d6080891045ef5bc89	flexible behaviour regulation in agent based systems	organisations;multiagent system;multi agent system;behaviour regulation;social order;agent based system;electronic business;norms;autonomic computing;multiagent systems	Cooperation is the fundamental underpinning of multi-agent systems, allowing agents to interact to achieve their goals. However, agents must manage the risk associated with interacting with others who have different objectives, or who may fail to fulfill their commitments. There are many ways in which such a desirable social order may be encouraged or even mandated. For example, trust oers a mechanism for modeling and reasoning about reliability, honesty, etc., while organisations and norms provide a framework within which to apply them, and motivations provide a means for representing and reasoning about overall objectives. In this talk, I will consider the role of trust, organisations and norms in a motivation-based view of agency that seeks to regulate behaviour, and will illustrate some of these issues with aspects of several projects, including the CONTRACT project, concerned with contract-based electronic business systems. Finally, I will also seek to identify some key themes entwining these notions of behaviour regulation with autonomic computing.	agent-based model;autonomic computing;electronic business;interaction;multi-agent system;ws-trust	Michael Luck	2009		10.1145/1555228.1555265	social order;computer science;organization;knowledge management;artificial intelligence;multi-agent system;management science;management;computer security;norm	AI	-43.1348482969814	19.20187321360047	111345
3627979c34e6f213b98dde7612bdf48b2c7b8821	domain specific language implementation via compile-time meta-programming	developpement logiciel;lenguaje programacion;compilacion;computacion informatica;programming language;cout developpement;research outputs;development cost;research publications;compile time meta programming;langage dedie;ligne abonne numerique;syntax extension;ciencias basicas y experimentales;digital subscriber line;desarrollo logicial;software development;domain specific language;metaprogrammation;langage programmation;compilation;grupo a;metaprogramming;languages syntax extension;meta programming;metaprogramacion;linea abonado digital;domain specific languages;lenguaje dedicado	Domain specific languages (DSLs) are mini-languages that are increasingly seen as being a valuable tool for software developers and non-developers alike. DSLs must currently be created in an ad-hoc fashion, often leading to high development costs and implementations of variable quality. In this article, I show how expressive DSLs can be hygienically embedded in the Converge programming language using its compile-time meta-programming facility, the concept of DSL blocks, and specialised error reporting techniques. By making use of pre-existing facilities, and following a simple methodology, DSL implementation costs can be significantly reduced whilst leading to higher quality DSL implementations.	acm transactions on programming languages and systems;compile time;compiler;converge;digital subscriber line;domain-specific language;embedded system;exception handling;html tidy;hoc (programming language);metaprogramming;model transformation;modeling language;problem domain;programming language;run time (program lifecycle phase);software developer;unified expression language;while	Laurence Tratt	2008	ACM Trans. Program. Lang. Syst.	10.1145/1391956.1391958	metaprogramming;computer science;domain-specific language;programming language;algorithm	PL	-47.405104499898044	26.66258351764776	111434
c62e96a55565fea02f201762f36b68fefe33b9bd	computational modeling of complex systems: case study in real world	drugs;formal specification;multi agent system;modeling and simulation;netlogo complex systems self organization autonomous entities multi agent systems;kernel scientific problem;computer model;human immunodeficiency virus;autonomous entities;multi agent systems;computational modeling;simulation methods;multi agent systems formal specification;complex system;computational modeling immune system humans kernel formal specifications multiagent systems large scale systems displays organizing hybrid intelligent systems;complex system simulation;immune system;mathematical model;complex systems;self organization;netlogo;simulation platform;simulation platform computational modeling kernel scientific problem complex system simulation computational agent based model formal specification based computational agent;agent based modeling and simulation;formal specification based computational agent;computational agent based model	The complex systems and complexity is the kernel scientific problem of the 21st century. In this paper, the complex system simulation methods and its application are discussed. The computational agent-based model and simulation methodology for complex systems is approved in the paper. First, the related works and some application fields are introduced. Second, several modeling methods are discussed. Third, several case study are introduced. Then, the formal specification based-computational agent for complex systems is proposed. Finally, the modeling and simulation framework is proposed and a simulation platform based on the agent’s is introduced.	agent-based model;complex system;complex systems;computation;computer simulation;formal specification;netlogo;prototype	Chunxiao Zhao;Lijun Wang	2009	2009 Ninth International Conference on Hybrid Intelligent Systems	10.1109/HIS.2009.119	complexity;simulation;computer science;systems engineering;theoretical computer science	Robotics	-39.88564874110933	20.721585036704273	111542
357005d2b2a3a85bb2b04baa61c0de8f7ec9fd4a	proving the absence property pattern using the b method	verification;formal specification;information systems;absence patterns;proof obligations absence property pattern b method dynamic properties information systems specification security policies;b method;security of data formal specification formal verification information systems;formal verification;temporal properties;information systems proposals conferences safety unified modeling language marketing and sales;b method verification temporal properties absence patterns;security of data	Dynamic properties are very useful in the specification of Information Systems (IS) and security policies. They allow the user to express properties that involve several states of a system. Indeed, invariance properties do not permit to cover such kind of properties. In this paper, we suggest a formal approach, based on the use of the B method, to verifying absence properties of the form Abs(P2, From P1 Until P3) that express that some states, represented by predicate P2, should not be reached starting from a state that satisfies P1 until a state satisfies P3 is reached. Our proposal consists in defining two proof obligations based on weakest preconditions that are sufficient and necessary to prove that a system verifies such a property.	b-method;information system;precondition;predicate transformer semantics;verification and validation	Amel Mammar;Marc Frappier;Raphaël Chane-Yack-Fa	2012	2012 IEEE 14th International Symposium on High-Assurance Systems Engineering	10.1109/HASE.2012.26	b-method;verification;formal verification;computer science;theoretical computer science;formal specification;programming language;computer security;information system;algorithm	SE	-41.1291685008461	28.152459037278977	111691
539dc2b986aff26572777589297e945cfb4fa371	an executable theory of multi-agent systems refinement	verification;business to business;weakest precondition calculus;multi agent system;logical framework;social simulation;timed coordination;programming environment;top down;coordination mechanisms;refinement;multi agent systems;formal verification;model checking;control structure;agent methodology and languages;software development;rewriting logic;normative rules;weakest precondition;design methodology	Complex applications such as incident management, social simulations, manufacturing applications, electronic auctions, e-institutions, and business to business applications are pervasive and important nowadays. Agent-oriented methodology is an advance in abstraction#N#which can be used by software developers to naturally model and develop systems for such#N#applications. In general, with respect to design methodologies, what it may be important to#N#stress is that control structures should be added at later stages of design, in a natural top-down#N#manner going from speciﬁcations to implementations, by reﬁnement. Too much detail (be it#N#for the sake of efﬁciency) in speciﬁcations often turns out to be harmful. To paraphrase D.E.#N#Knuth, “Premature optimization is the root of all evil” (quoted in ‘The Unix Programming#N#Environment’ by Kernighan and Pine, p. 91).#N#The aim of this thesis is to adapt formal techniques to the agent-oriented methodology#N#into an executable theory of reﬁnement. The justiﬁcation for doing so is to provide correct#N#agent-based software by design. The underlying logical framework of the theory we propose#N#is based on rewriting logic, thus the theory is executable in the same sense as rewriting logic#N#is. The storyline is as follows. We ﬁrst motivate and explain constituting elements of agent#N#languages chosen to represent both abstract and concrete levels of design. We then propose#N#a deﬁnition of reﬁnement between agents written in such languages. This notion of reﬁnement ensures that concrete agents are correct with respect to the abstract ones. The advantage#N#of the deﬁnition is that it easily leads to formulating a proof technique for reﬁnement via#N#the classical notion of simulation. This makes it possible to effectively verify reﬁnement by#N#model-checking. Additionally, we propose a weakest precondition calculus as a deductive#N#method based on assertions which allow to prove correctness of inﬁnite state agents. We#N#generalise the reﬁnement relation from single agents to multi-agent systems in order to ensure that concrete multi-agent systems reﬁne their abstractions. We see multi-agent systems#N#as collections of coordinated agents, and we consider coordination artefacts as being based#N#either on actions or on normative rules. We integrate these two orthogonal coordination#N#mechanisms within the same reﬁnement theory extended to a timed framework. Finally, we#N#discuss implementation aspects.	executable;multi-agent system;refinement (computing)	Lacramioara Astefanoaei	2011			computer science;theoretical computer science;distributed computing;algorithm	AI	-42.7462277893068	20.65777308651665	111752
848038622315ca6b839b90c83eb80ecac178b661	plc based supervision of industrial switched processes		Abstract   This paper presents a methodology for the design of supervisors for mode switching systems, one class of hybrid system that frequently appears in industrial process applications. The classical continuous control methods are based on designing controllers that are only valid for an operation point for which are designed. The switching among different controllers can optimize transient response and meet multiple objectives. The main goal of this work is to automatically generate the code of the regulation level loops supervision which will be executed on a Programmable Logic Controller (PLC) and following the guidelines for software development provided by the IEC-61131 standard. The tool developed for achieving this automatic code generation processes information about the process operation, the functional specifications and the control algorithms used in each mode. This information is captured from the different view models of the overall control system and through a user interface.		Nagore Iriondo;Elisabet Estévez-Estévez;Rafael Priego;Marga Marcos	2012		10.3182/20120403-3-DE-3010.00064	control engineering;real-time computing;engineering;control theory	Logic	-35.73408448401787	29.58161683530969	111837
5c4ecb51c8ff622292e1692e1ddd7fd329c31796	grid services adaptation in a grid workflow	modelizacion;distributed system;groupware;haute performance;systeme reparti;distributed computing;service web;pi calculus;simultaneidad informatica;dynamic system;web service;dynamical system;grid;modelisation;systeme dynamique;concurrency;sistema repartido;algebra proceso;pi calculo;pi calcul;rejilla;grid service;algebre processus;alto rendimiento;grille;calculo repartido;deadlock;interbloqueo;workflow;interblocage;sistema dinamico;process algebra;collecticiel;modeling;simultaneite informatique;high performance;calcul reparti;servicio web	At present the grid workflow is a focus topic in the research on grid technologies, but few approaches are provided for designing and checking the grid services adaptation in a workflow, especially in a formal way. As a mobile process algebra, Pi-Calculus is suitable tool for modeling and analyzing distributed, concurrent and dynamic system, such as grid workflow. Addressing the protocol level deadlock, a grid service adaptor is proposed with the Pi-Calculus based Grid Services Deadlock Eliminating algorithm. Through analyzing the experiment results the algorithm proves to be available and useful for service adaptation. As a conclusion the future research work is also discussed.	algorithm;concurrent computing;deadlock;dynamical system;process calculus;π-calculus	Wencai Guo;Yang Yang;Zhengli Zhai	2005		10.1007/11590354_24	simulation;semantic grid;computer science;dynamical system;database;distributed computing;programming language;workflow management system;drmaa;workflow engine;grid computing;workflow technology	HPC	-39.070988907210264	24.89130355976039	111852
45b41b5add0510eb4cc99a2abbae165a2c05ee75	experience report: using objective caml to develop safety-critical embedded tools in a certification framework	developpement logiciel;quality assurance;fiabilidad;reliability;embedded coding;calculateur embarque;certification;measurement;sistema critica;generation code;lenguaje sincronico;systeme critique;logiciel a securite critique;securite informatique;scade suite 6 code generator;generacion codigo;code generation;software development process;synchronous language;program verification;development process;do 178b;embedded system;sistema reactivo;experience report;computer security;langage synchrone;aseguracion calidad;verificacion programa;critical system;vulnerabilidad critica de seguridad;langage caml;desarrollo logicial;fiabilite;seguridad informatica;safety critical software;software development;boarded computer;certificacion;reactive system;systeme reactif;experimentation;verification programme;verification safety critical;assurance qualite;safety critical;calculador embarque;scade suite 6;caml language;objective caml	High-level tools have become unavoidable in industrial software development processes. Safety-critical embedded programs don't escape this trend. In the context of safety-critical embedded systems, the development processes follow strict guidelines and requirements. The development quality assurance applies as much to the final embedded code, as to the tools themselves. The French company Esterel Technologies decided in 2006 to base its new SCADE SUITE 6TM certifiable code generator on Objective Caml. This paper outlines how it has been challenging in the context of safety critical software development by the rigorous norms DO-178B, IEC 61508, EN 50128 and such.	caml;code generation (compiler);do-178b;embedded system;esterel;mission critical;ocaml;requirement;software development	Bruno Pagano;Olivier Andrieu;Thomas Moniot;Benjamin Canou;Emmanuel Chailloux;Philippe Wang;Pascal Manoury;Jean-Louis Colaço	2009		10.1145/1596550.1596582	quality assurance;simulation;computer science;software development process	Embedded	-42.203618208083334	26.877582264956303	111904
37bdc00da23e4f3fdf4fa73099227b004d79d081	experience using coloured petri nets to model railway interlocking tables		Interlocking tables are the functional specification defini ng the routes on which the passage of the train is allowed. Associated with the route, the states and a ctions of all related signalling equipment are also specified. It is well-known that designing and verif ying the interlocking tables are labour intensive, tedious and prone to errors. To assist the verific ation process and detect errors rapidly, we formally model and analyse the interlocking tables using Coloured Petri Nets (CPNs). Although a large interlocking table can be easily modelled, analysin g the model is rather difficult due to the state explosion problem and undesired safe deadlocks. The s afe deadlocks are when no train collides but the train traffic cannot proceed any further. For ease of a nalysis we incorporate automatic route setting and automatic route cancelling functions into the m odel. These help reducing the number of the deadlocks. We also exploit the new features of CPN Tool s; prioritized transitions; inhibitor arcs; and reset arcs. These help reducing the size of the stat e sp ces. We also include a fail safe specification called flank protection into the interlocking model.	authentication;coloured petri net;deadlock;expect;experiment;fail-safe;functional specification;lock (computer science);modeling perspective;reachability;requirement;state space;unreachable memory	Somsak Vanit-Anunchai	2014		10.4204/EPTCS.156.6	simulation;computer security;algorithm	SE	-40.33074751271903	30.1025888779963	112003
2ed5703d3f19213a17a2b7a362f485defea8cd78	dynamic work distribution in workflow management systems: how to balance quality and performance	systematic approach;workflow management systems offer;current practice;workflow system;performance issue;work item;workflow process;balance quality;proposed approach;art workflow system;work distribution;workflow management systems;dynamic work distribution	Today’s workflow management systems offer work items to workers using rather primitive mechanisms. While most workflow systems support a role-based distribution of work, they have problems dealing with unavailability of workers as a result of vacation or illness, overloading, context dependent suitability, deadlines, and delegation. As a result, the work is offered to too few, too many, or even the wrong set of workers. Current practice is to offer a work item to one person, thus causing problems when the person is not present or too busy, or to offer it to a set of people sharing a given role, thus not incorporating the qualifications and preferences of people. Literature on work distribution is typically driven by considerations related to authorizations and permissions. However, workflow processes are operational processes where there is a highly dynamic trade-off between security and performance. For example, an approaching deadline and an overloaded specialist may be the trigger to offer work items to lesser-qualified workers. This paper addresses this problem by proposing a systematic approach to dynamically create a balance between quality and performance issues in workflow systems. We illustrate and evaluate the proposed approach with a realistic example and also compare how a workflow system would implement this scenario to highlight the shortcomings of current, state of the art workflow systems. Finally, a detailed simulation model is used to validate our approach.	communicating sequential processes;file system permissions;function overloading;management system;mike lesser;simulation;unavailability	Akhil Kumar;Wil M. P. van der Aalst;H. M. W. Verbeek	2002	J. of Management Information Systems		unavailability;management science;workflow management system;knowledge management;workflow technology;workflow engine;authorization;workflow;delegation;computer science	DB	-38.89500181239643	20.036175667817762	112090
1ba79683ed89084045368bb2bfef8b8d10471533	assert and negate revisited: modal semantics for uml sequence diagrams	uml sequence diagram;formal semantics;formal verification;message sequence chart;sequence diagram;live sequence chart	Live Sequence Charts (LSC) extend Message Sequence Charts (MSC), mainly by distinguishing possible from necessary behavior. They thus enable the specification of rich multi-modal scenario-based properties, such as mandatory, possible and forbidden scenarios. The sequence diagrams of UML 2.0 enrich those of previous versions of UML by two new operators, assert and negate, for specifying required and forbidden behaviors, which appear to have been inspired by LSC. The UML 2.0 semantics of sequence diagrams, however, being based on pairs of valid and invalid sets of traces, is inadequate, and prevents the new operators from being used effectively. We propose an extension of, and a different semantics for this UML language - Modal UML Sequence Diagrams (MUSD) - based on the universal/existential modal semantics of LSC. MUSD can be formally defined as a UML profile, thus paving the way to apply formal verification, synthesis, and scenario-based execution techniques from LSC to the mainstream UML standard.	formal verification;message sequence chart;modal logic;profile (uml);sequence diagram;tracing (software);unified modeling language	David Harel;Shahar Maoz	2006	Software & Systems Modeling	10.1007/s10270-007-0054-z	sequence diagram;computer science;engineering;theoretical computer science;software engineering;database;system sequence diagram;programming language;message sequence chart;algorithm	SE	-41.64896395154251	28.794203451973225	112482
14a1eebe0c5022fcfcac4218e13546547294e6f3	formal modeling and verification of safety-critical software	verification;developpement logiciel;analytical models;software;case tools;control systems;nuclear power stations;software testing;software safety programmable control failure analysis us department of transportation computer aided software engineering logic testing embedded software software tools software testing control systems;formal model;tool support;securite;validacion;logiciel a securite critique;formal specifications;metodo formal;methode formelle;formal methods;programmable control;program verification;data mining;formal method;safety critical software formal verification nuclear power stations power engineering computing;failure analysis;verificacion programa;computer aided software engineering;power engineering computing;formal verification;safety analysis;vulnerabilidad critica de seguridad;software safety;desarrollo logicial;safety critical software;function block diagram fbd modeling verification safety critical software formal methods;software development;safety;reactor protection system;logic testing;us department of transportation;verification formelle;validation;nuclear power plant;function block diagram;software tools;function block diagram fbd;verification and validation;verification programme;seguridad;modeling;use case;case tools safety critical software formal modeling formal verification reactor protection system nuclear power plant formal methods safety analysis;formal modeling;embedded software	Rigorous quality demonstration is important when developing safety-critical software such as a reactor protection system (RPS) for a nuclear power plant. Although using formal methods such as formal modeling and verification is strongly recommended, domain experts often reject formal methods for four reasons: there are too many candidate techniques, the notations appear complex, the tools often work only in isolation, and output is often too difficult for domain experts to understand. A formal-methods-based process that supports development, verification and validation, and safety analysis can help domain experts overcome these obstacles. Nuclear engineers can also use CASE tools to apply formal methods without having to know details of the underlying formalism. The authors spent more than seven years working with nuclear engineers in developing RPS software and applying formal methods. The engineers and regulatory personnel found the process effective and easy to apply with the integrated tool support.	computer-aided software engineering;formal methods;formal system;reactor (software);software quality assurance;verification and validation;web server	Junbeom Yoo;Eunkyoung Jee;Sung Deok Cha	2009	IEEE Software	10.1109/MS.2009.67	reliability engineering;formal methods;computer science;systems engineering;engineering;software engineering;formal specification;computer-aided software engineering	SE	-46.32393084895665	32.11559032985066	112516
a09af30f28d012f3ec7cbcb1df948e86dbac5a56	a fractal based generalized pedagogical agent model		Pedagogical Agent (PA) is a tendency in human learning systems (HLS). However, the used Agent models are unable to decrease the complexity/performance ratio introduced by the modeling and the manipulation of multi-knowledge domains (Domain Model, Student Model, Pedagogical Model, etc). Thus, within this paper, we propose a Component based Pedagogical Agent Model that we claim makes effective and flexible the Pedagogical Agents building and maintaining. The PA building is simplified to an assembling of a set of pre-built sub-components that is directed by the PA ADL Fractal Abstract Description. Also, maintaining a sub set of sub-components means disconnecting them, removing them and replacing them by other versions those integrate the new required functionalities and/or tuning. Therefore, the building and the maintaining efficiency and flexibility are achieved by the separation of the abstract description of the PA from its fulfilling.		Soufiane Boulehouache;Ramdane Maamri;Zaïdi Sahnoun;Alla Larguet	2014		10.1007/978-3-319-01787-7_5	simulation;artificial intelligence;mathematics;communication	AI	-46.20226967942099	23.730260669828482	112602
7f5925575aa1c531420230c10869f26fca4335ab	refacing: an autonomic approach to network security based on multidimensional trustworthiness	theory of evidence;teledetection;intruder detector;evaluation performance;optimisation;multisensor;belief function;procesamiento informacion;performance evaluation;optimizacion;televigilancia;securite;funcion de creencia;surveillance;network security;teoria de la evidencia;integration information;anomaly detection;evaluacion prestacion;dempster;evidence theory;intrusion detection;data fusion;estimacion a priori;trustworthiness;algorithme;a priori estimation;algorithm;remote supervision;information integration;theorie de l evidence;vigilancia;teoria dempster shafer;telesurveillance;fusion donnee;remote sensing;dempster shafer theory;safety;information processing;teledeteccion;integracion informacion;estimation a priori;dempster shafer;optimization;information fusion;detecteur intrus;traitement information;fusion datos;autonomic communication;seguridad;detector intruso;shafer theory;autonomic computing;capteur multiple;fonction de croyance;theorie dempster shafer;algoritmo	Several research efforts have recently focused on achieving distributed anomaly detection in an effective way. As a result, new information fusion algorithms and models have been defined and applied in order to correlate information from multiple intrusion detection sensors distributed inside the network. In this field, an approach which is gaining momentum in the international research community relies on the exploitation of the Dempster– Shafer (D–S) theory. Dempster and Shafer have conceived a mathematical theory of evidence based on belief functions and plausible reasoning, which is used to combine separate pieces of information (evidence) to compute the probability of an event. However, the adoption of the D–S theory to improve distributed anomaly detection efficiency generally involves facing some important issues. The most important challenge definitely consists in sorting the uncertainties in the problem into a priori independent items of evidence. We believe that this can be effectively carried out by looking at some of the principles of autonomic computing in a self-adaptive fashion, i.e. by introducing support for self-management, self-configuration and self-optimization functionality. In this paper, we intend to tackle some of the above mentioned issues by proposing the application of the D–S theory to network information fusion. This will be done by proposing a model for a self-management supervising layer exploiting the innovative concept of multidimensional reputation, which we have called REFACING (RElationship–FAmiliarity–Confidence–INteGrity). 2008 Elsevier B.V. All rights reserved.	anomaly detection;autonomic computing;cosmic;deterministic algorithm;intrusion detection system;mathematical optimization;mind;network security;norm (social);self-management (computer science);sensor;simulation;sorting;trust (emotion);whole earth 'lectronic link	Francesco Oliviero;L. Peluso;Simon Pietro Romano	2008	Computer Networks	10.1016/j.comnet.2008.04.022	anomaly detection;dempster–shafer theory;information processing;computer science;artificial intelligence;network security;data mining;computer security;autonomic computing	AI	-36.174457250676	19.160505183208713	112617
98858ba5e6b001fe152bda7922255418ba30b89d	formal modeling of robot behavior with learning	robot behavior;abstract model;original unabstracted model;classical closed-loop simulation;associated model;formal modeling;formal approach;spin model checker;abstracted model;classical simulation;formal specification;formal verification	We present formal specification and verification of a robot moving in a complex network, using temporal sequence learning to avoid obstacles. Our aim is to demonstrate the benefit of using a formal approach to analyze such a system as a complementary approach to simulation. We first describe a classical closed-loop simulation of the system and compare this approach to one in which the system is analyzed using formal verification. We show that the formal verification has some advantages over classical simulation and finds deficiencies our classical simulation did not identify. Specifically we present a formal specification of the system, defined in the Promela modeling language and show how the associated model is verified using the Spin model checker. We then introduce an abstract model that is suitable for verifying the same properties for any environment with obstacles under a given set of assumptions. We outline how we can prove that our abstraction is sound: any property that holds for the abstracted model will hold in the original (unabstracted) model.	complex network;formal specification;formal verification;model checking;modeling language;promela;robot;spin model checker;simulation;verification and validation;verification of theories;verifying specimen	Ryan F. Kirwan;Alice Miller;Bernd Porr;Paolo di Prodi	2013	Neural Computation	10.1162/NECO_a_00493	formal system;simulation;formal methods;formal verification;computer science;formal specification;algorithm	AI	-39.547776460341304	29.832385666906507	113312
e5fd3240df9d295b7675461e97f493edeba1d47d	integrating dsl-cbi and nusmv for modeling and verifiying interlocking systems	counter example visualization computer based interlocking system cbi domain specific language for computer based interlocking systems dsl cbi interlocking table railway station;interlocking table;domain specific language dsl cbi nusmv computer based interlocking system safe train movements railway station;domain specific language for computer based interlocking systems dsl cbi;railway station;specification languages railway safety;unified modeling language rail transportation dsl computational modeling computers xml semantics;counter example visualization;specification languages;railway safety;computer based interlocking system cbi;domain specific language	The Computer Based Interlocking System (CBI) is used to ensure safe train movements at a railway station. For a given station, all the train routes and the concrete safety rules associated with these are defined in the interlocking table. Currently, the development and verification of interlocking tables is entirely manual process, which is inefficient and error-prone due to the complexity of the CBI and the human interferences. Besides, the complexity and volume of the verification results tend to make users feel extremely non-understandable. In order to tackle these problems, we introduce a toolset based on Domain Specific Language for Computer Based Interlocking Systems (DSL-CBI) to automatically generate and verify the interlocking table, and then mark the conflicting routes in the railway station. In this paper, we also discuss the advantages of the toolset and the significant contribution in developing CBI based on the proposed toolset.	algorithm;cognitive dimensions of notations;digital subscriber line;domain-specific language;model checking;model-driven engineering;nusmv;pdf/a;programmable logic device;safety engineering	Yan Cao;Qiuzi Lu;Tianhua Xu;Tao Tang;Haifeng Wang;Yongcheng Xu	2011	2011 Fifth International Conference on Secure Software Integration and Reliability Improvement - Companion	10.1109/SSIRI-C.2011.28	embedded system;simulation;computer science;domain-specific language;engineering;operating system;programming language;computer security	SE	-40.5015285389764	30.05341474573875	113384
8d2de356410d3405d992131a5f564a88b32b8e33	goal-oriented feature interaction detection in the intelligent network model	goal orientation;satisfiability;intelligent network	In the first part of the paper, a LOTOS model for specifying the Intelligent Network call model and services belonging to the Distributed Functional Plane is described. The functional entities involved in the establishment of call connection and invocation of services are formally specified. In the second part of the paper, an approach to detect feature interactions between IN services is presented. Interactions caused by violation of features properties are detected. The approach is based on stating feature properties, on deriving goals satisfying the negation of these properties, and on use of Goal Oriented Execution to detect traces satisfying these goals. Such traces, if found, show that interactions exists between the specified features by showing that a scenario violating one of the properties of the features can be found. An example showing the detection of interaction between Originating Call Screening and Call Forward Always is given.	entity;feature interaction problem;intelligent network;language of temporal ordering specification;network model;tracing (software)	Jalel Kamoun;Luigi Logrippo	1998			goal orientation;machine learning;satisfiability;negation;computer science;intelligent network;artificial intelligence	SE	-37.752292463555804	32.080293091722886	113436
6de285d3e9adafec4dc43e34833d7d18ab7b037b	real-time maude 2.1	object oriented specification;real time;simulation;model checking;object oriented;rewriting logic;hybrid system;formal analysis;simulation model;real time systems	Real-Time Maude 2.1 is an extension of Full Maude 2.1 supporting the formal specification and analysis of real-time and hybrid systems. Symbolic simulation, search and model checking analysis are supported for a wide range of systems. This paper gives an overview of the tool and documents its semantic foundations.	formal specification;hybrid system;maude system;model checking;real-time clock;real-time transcription;symbolic simulation	Peter Csaba Ölveczky;José Meseguer	2005	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2004.06.015	model checking;real-time computing;rewriting;computer science;theoretical computer science;simulation modeling;programming language;object-oriented programming;hybrid system	Logic	-36.40635095394016	31.15027593043106	113483
0e60da8dc90941bc4b6e5eb0ea03bb8416708339	a formally verified hybrid system for the next-generation airborne collision avoidance system		The Next-Generation Airborne Collision Avoidance System (ACAS X) is intended to be installed on all large aircraft to give advice to pilots and prevent mid-air collisions with other aircraft. It is currently being developed by the Federal Aviation Administration (FAA). In this paper we determine the geometric configurations under which the advice given by ACAS X is safe under a precise set of assumptions and formally verify these configurations using hybrid systems theorem proving techniques. We conduct an initial examination of the current version of the real ACAS X system and discuss some cases where our safety theorem conflicts with the actual advisory given by that version, demonstrating how formal, hybrid approaches are helping ensure the safety of ACAS X. Our approach is general and could also be used to identify unsafe advice issued by other collision avoidance systems or confirm their safety.	airborne ranger;airborne collision avoidance system;automated theorem proving;collision detection;formal verification;hash-based message authentication code;hybrid system	Jean-Baptiste Jeannin;Khalil Ghorbal;Yanni Kouskoulas;Ryan Gardner;Aurora Schmidt;Erik Zawadzki;André Platzer	2015		10.1007/978-3-662-46681-0_2	simulation;computer security	Logic	-37.789124190813716	27.38247239784385	113500
e40f43be454e84751f37ddb8822841ecdb919781	automatic refinement checking for formal system models	manuals;computational modeling;engines;smt automatic refinement checking formal system models complex system design formal modeling languages model driven design flow refinement consistency verification uml sysml satisfiability modulo theories;unified modeling language;unified modeling language computability formal verification;unified modeling language computational modeling context modeling context adaptation models engines manuals;adaptation models;context modeling;context	For the design of complex systems, formal modeling languages such as UML or SysML find significant attention. The typical model-driven design flow assumes thereby an initial (abstract) model which is iteratively refined to a more precise description. During this process, new errors and inconsistencies might be introduced. In this paper, we propose an automatic method for verifying the consistency of refinements in UML or SysML. For this purpose, a theoretical foundation is considered from which the corresponding proof obligations are determined. Afterwards, they are encoded as an instance of Satisfiability Modulo Theories (SMT) and solved using proper solving engines. The practical use of the proposed method is demonstrated and compared to a previously proposed approach.	class diagram;complex systems;design flow (eda);formal system;model-driven architecture;model-driven engineering;modulo operation;parameter (computer programming);refinement (computing);satisfiability modulo theories;simulation;systems modeling language;unified modeling language;verification and validation	Julia Seiter;Robert Wille;Ulrich Kühne;Rolf Drechsler	2014	Proceedings of the 2014 Forum on Specification and Design Languages (FDL)	10.1109/FDL.2014.7119339	unified modeling language;systems modeling language;computer science;theoretical computer science;applications of uml;context model;modeling language;programming language;computational model;node;algorithm	SE	-42.69350219112984	31.605121278614583	113850
8f90d5c36d389a088bcc1ab064fb226556fa98f9	towards a graphical notation for owl 2		"""The Ontology Definition Metamodel (ODM) defines a set of UML metamodels and profiles for development of RDF and OWL. The UML profiles in the ODM specification adapt UML notations to provide a form of visual representation for RDF and OWL. Recently, the ODM Revision Task Force (RTF) has been focused on addressing remaining open issues and usability concerns that have arisen as implementations mature. Critical issues include the development of adequate notations to distinguish necessary from necessary and sufficient conditions for class descriptions, representation of properties and individuals, and more general support for literals. While these may seem simple, it remains challenging to find solutions that result in wellformed and usable UML models with equivalent semantics in OWL. The ODM RTF is considering solutions to these and further issues including compatibility with OWL 2. This paper describes some of the revised approaches, and presents potential extensions to the UML profile to address requirements of OWL 2. Background and Motivation The Object Management Group (OMG) Ontology Definition Metamodel (ODM) standard was adopted in 2006, finalized in 2008, and is set to become an ISO standard in the coming year [1]. It includes a family of metamodels (models of the abstract syntax) for the Resource Description Framework [2], the Web Ontology Language [3], ISO Common Logic [4], ISO Topic Maps [5], and several UML (Unified Modeling Language [6]) profiles to enable use of UML tools for RDF vocabulary, OWL ontology, and topic map development. It also contains mappings (some partial and some complete) to support model transformations from one representation paradigm to another. It bridges standards and best practices from several communities and provides a foundation for defining, developing, and managing information models as independent but equal components of larger systems. This paper describes (1) the structure of the UML profiles for RDF and OWL, (2) salient features of the UML-based graphical notations included in these profiles, (3) current approaches to some of the more challenging open issues, (4) early thinking on extensions required for OWL 2, (5) other current activities and future directions, and (6) conclusions with respect to the efficacy of the approach. A key goal driving development of the UML notations was to enable ontologybased information models to be integral parts of an information-centric system architecture. Benefits of an information-centric architectural approach, incorporating coherent and integrated sets of vocabularies, ontologies, and “gold standard” data models, developed and maintained separately from other aspects of a system such as process and service architectures, include: Increased platform independence as well as interoperability across services, processes, and other applications Limited breakage and rework as applications and services evolve, reducing maintenance costs Improved software, process, and service quality (through shared information services, vocabularies, and other artifacts that are logically consistent – internally and with one another) Opportunity for new capabilities and increasing automation in search, complex event and other transactional processing, transformation services, adaptive and predictive capabilities, etc. Additional motivation for a UML-based visual notation for ontology development was to provide a standard graphical notation to enhance communication of OWL to others. This in turn should make the ontologies understandable by a much larger audience who are more versed in traditional information or software modeling. UML is widely supported by the software engineering community with a variety of mature, open source and commercial tools. The UML diagrams resonate well with our audience of RDF and OWL developers and with those seeking to incorporate these models in larger architectures as described above, including further roles of these models as described in [7]. Recently, the ODM Revision Task Force (RTF) has been focused on addressing remaining open issues and usability concerns. Critical issues include an adequate notation to distinguish necessary from necessary and sufficient conditions for class descriptions, property representation, representation of individuals, and more general approaches to support literals. The RTF is also following OWL 2 development closely [8], to ensure that the ODM 1.1 revision will be compatible with the changes to the OWL language to the extent possible, with a clear path for migration. Structure of the UML Profiles for RDF and OWL The UML profiles are defined in compliance with the Profiles section of the UML Superstructure Specification [6]. They are designed to support modelers developing vocabularies in RDF and richer ontologies in the Web Ontology Language (OWL) through reuse of UML notations and use of standard UML tools. Profiles adapt both the notations of UML and their underlying modeling elements to tailor the language for the needs of specific modeling domains. They package the elements available in a particular profile and provide lightweight extensions to the UML elements included in the profile. The principal extension mechanism is the stereotype, which defines a restricted usage of an existing element and may also add custom properties unique to that usage. In UML diagrams, an application of a stereotype is indicated by one or more stereotype keywords enclosed in guillemet characters (e.g., «owlClass»), which are shown as part of the normal diagram symbol. The UML profiles for RDF and OWL are intended to be intuitive for UML users, and to: Reuse existing UML constructs directly when they have the same semantics as RDF and OWL Define customized stereotypes of existing UML constructs to make them consistent with RDF and OWL semantics When suitable UML constructs do not already exist, define additional combinations of stereotyped UML constructs to provide usable forms of notation for RDF and OWL semantics Utilize a model library (provided in Annex A of the ODM specification) to refer to defined sets of foundation elements (such as standard data types and property values) The UML Profile for RDF provides a basic set of constructs to support users who wish to restrict their vocabularies to RDF/S, and to reflect the structure of the RDF and OWL languages to the extent possible. All constructs of the RDF profile are included in the profile for OWL, which defines the additional constructs needed for development of ontologies in OWL. Critical features that provide hooks for linking models to the Web, such as definitions for RDF documents, Uniform Resource Identifiers (URIs/IRIs), namespace definitions, and so forth are included in the RDF profile package. They are isolated from the other definitions in a manner consistent with the OWL 2 Structural Specification [9] and could be moved to an independent package to facilitate alignment with OWL 2. UML Profile Notations for RDF and OWL Much of the RDF profile is fairly straightforward – RDF classes are represented by stereotyped UML classes, RDF datatypes are represented by stereotyped UML datatypes, and so forth. Key features of the RDF profile worth mentioning include: rdfs:Resource is modeled as UML::InstanceSpecification rdf:Property is modeled by a combination of UML::Property, UML::Association, and UML::AssociationClass Graphs, named graphs (per [10]), and documents are all modeled as UML::Package Figure 1 provides an example depicting a property definition (using the AssociationClass notation). Figure 1. Example RDF Property Definition, AssociationClass Notation The profile moves away from the comfort zone of most UML modelers in its representation of restrictions. Figure 2 shows a notional set of relationships from a fictional brokerage ontology describing bonds and bond positions. The example includes OWL classes and object properties, restrictions, and the latest RTF approach to depict necessary vs. necessary and sufficient conditions for class membership. A fragment of the RDF/XML serialization for OWL is given in Figure 3. Figure 2. Basic Stereotypes for OWL Classes, Properties, and Restrictions <owl:Class rdf:about=""""Bond""""> <rdfs:subClassOf rdf:resource=""""Instrument""""/> <rdfs:subClassOf> <owl:Restriction> <owl:onProperty rdf:resource=""""isAssociatedWithA""""/> <owl:allValuesFrom rdf:resource=""""BondPosition""""/> </owl:Restriction> </rdfs:subClassOf> </owl:Class> <owl:Class rdf:about=""""BondPosition""""> <owl:equivalentClass> <owl:Restriction> <owl:onProperty rdf:resource=""""hasValuation""""/> <owl:allValuesFrom rdf:resource=""""BondPositionValuation""""/>"""	abstract syntax;belief revision;best practice;coherence (physics);common logic;data model;diagram;eclipse modeling framework;graphical user interface;information model;interoperability;koutetsu no kishi;literal (mathematical logic);metamodeling;model transformation;named graph;ontology (information science);ontology definition metamodel;open-source software;oracle data mining;profile (uml);programming paradigm;rdf/xml;requirement;resource description framework;rework (electronics);sms language;serialization;service-oriented architecture;software engineering;specification language;stereotype (uml);systems architecture;topic maps;unified modeling language;uniform resource identifier;usability;vocabulary;web ontology language;world wide web;xml	Elisa F. Kendall;Roy Bell;Roger Burkhart;Mark Dutra;Evan K. Wallace	2009			computer science;applications of uml;data mining;database	Web+IR	-47.81514279656276	21.382431746565498	114208
8b9b0b47a8b7913f0c7c7ba619c1a8042786405e	aligning uml 2.0 state machines and temporal logic for the efficient execution of services	modelizacion;distributed system;proceso concepcion;systeme reparti;logica temporal;design process;behavioral analysis;lenguaje uml;generation code;temporal logic;generacion codigo;code generation;model transformation;langage modelisation unifie;state machine;preparacion serie fabricacion;modelisation;refinement method;sistema repartido;internet;temporal logic of actions;uml profile;unified modelling language;analyse comportementale;component model;analisis conductual;process planning;methode raffinement;preparation gamme fabrication;modeling;metodo afinamiento;service engineering;logique temporelle;processus conception	In our service engineering approach, services are specified by UML 2.0 collaborations and activities, focusing on the interactions between cooperating entities. To execute services, however, we need precise behavioral descriptions of physical system components modeling how a component contributes to a service. For these descriptions we use the concept of state machines which form a suitable input for our existing code generators that produce efficiently executable programs. From the engineering viewpoint, the gap between the collaborations and the components will be covered by UML model transformations. To ensure the correctness of these transformations, we use the compositional Temporal Logic of Actions (cTLA) which enables us to reason about service specifications and their refinement formally. In this paper, we focus on the execution of services. By outlining an UML profile, we describe which form the descriptions of the components should have to be efficiently executable. To guarantee the correctness of the design process, we further introduce the cTLA specification style cTLA/e which is behaviorally equivalent with the UML 2.0 state machines used as code generator input. In this way, we bridge the gap between UML for modeling and design, cTLA specifications used for reasoning, and the efficient execution of services, so that we can prove important properties formally.	code generation (compiler);correctness (computer science);entity;executable;interaction;profile (uml);refinement (computing);temporal logic of actions;unified modeling language	Frank Alexander Kraemer;Peter Herrmann;Rolv Bræk	2006		10.1007/11914952_41	unified modeling language;the internet;systems modeling;design process;uml state machine;temporal logic;computer science;artificial intelligence;applications of uml;component object model;finite-state machine;programming language;algorithm;code generation;temporal logic of actions	SE	-40.14733479453236	25.192392514004112	114214
c0dbe69f523366ef1451e64e0efa0933bf246edf	on the generality of event-graph models	networks graphs;simulation;graph model;languages;applications	1. Event-Graph Models Event graphs were introduced by Schruben (1983) to develop simulations of discrete-event systems. The system dynamics are characterized by events that change the state of the system and the logical and temporal relationships among these events. Their utility and many examples are discussed in Schruben (1995). An event-graph model consists of several components. The state of the system is defined by the values of a set of state variables S. In the graph, the set of vertices V represents the events, and the set of directed edges E represents the temporal and logical relationships between pairs of events. Associated with each vertex v is a function fv that describes the state changes caused by the event. Each directed edge eod = vo vd indicates that if the edge condition ce holds when the origin event vo occurs, the destination event vd will occur after some time delay te. It is possible for an edge to be unconditional or for vd to be scheduled to occur without any simulated delay. The basic building block of the event graph is as follows:	broadcast delay;directed graph;event relationship graph;simulation;system dynamics;uml state machine	Eric L. Savage;Lee W. Schruben;Enver Yücesan	2005	INFORMS Journal on Computing	10.1287/ijoc.1030.0053	computer science;theoretical computer science;mathematics;language;information technology;algorithm	DB	-36.52437834609756	27.95370249039244	114294
f99b754bd51918e88ed34877c9e42c8163624278	sdl profiles: formal semantics and tool support	distributed system;tool support;specification and description language;formal semantics;modelling language;communication protocol	Over a period of 30 years, ITU-T's Specification and Description Language (SDL) has matured to a sophisticated formal modelling language for distributed systems and communication protocols. The language definition of SDL-2000, the latest version of SDL, is complex and difficult to maintain. Full tool support for SDL is costly to implement. Therefore, only subsets of SDL are currently supported by tools. These SDL subsets - called SDL profiles - already cover a wide range of systems, and are often sufficient in practice. In this paper, we present a formalised approach for extracting the formal semantics for SDL profiles from the complete SDL semantics. Based on this formalisation, we then define a notion of profile consistency. Finally, we present our SDL-profile tool, and report on our experiences.		Rüdiger Grammes;Reinhard Gotzhein	2007		10.1007/978-3-540-71289-3_17	communications protocol;computer science;systems engineering;theoretical computer science;formal semantics;programming language	PL	-40.85975888785227	28.567578302341193	114375
f5bfeebdd8ecd6c89325a6f91efea2856a32137a	merging case tools with knowledge-based technology for automatic software design	specification description language;design process;case tool;knowledge based software engineering;software design;knowledge base;expert system	An approach towards developing a Knowledge Based Software Engineering (KBSE) tool by merging a conventional CASE tool with the expert system technology is introduced. This is found useful in assisting human designers. Experimental expert systems CREATOR2 and CREATOR3 are introduced and applied to the design of switching software. The CREATOR2 has the following features: representing software design knowledge, composed of design product knowledge and design process knowledge, using frame technology; and integrating knowledge based reasoning techniques with a SDL CASE tool. CREATOR3 is an extension of the CREATOR2 system. It enables one with additional design schemas for splitting a process, adding events, etc., and additional representation power, such as using pictorial elements and designers' comments in the frame representation. This leads to a uniform modeling and advanced reasoning environment for software design. Experiments on designing switching software are reported.	comment (computer programming);computer-aided software engineering;expert system;frame technology (software engineering);image;software design	Behrouz Homayoun Far;Mari Ohmori;Takeshi Baba;Yasukiyo Yamasaki;Zenya Koono	1996	Decision Support Systems	10.1016/0167-9236(96)00019-X	legal expert system;knowledge base;verification and validation;design process;software engineering process group;software mining;computer science;knowledge management;artificial intelligence;package development process;software design;social software engineering;component-based software engineering;software development;software design description;object-oriented design;software construction;data mining;database;subject-matter expert;software walkthrough;resource-oriented architecture;computer-aided software engineering;expert system;goal-driven software development process;software requirements;domain knowledge;software system	SE	-46.79063517177329	24.481690151229383	114658
0b0b64ec7b65c26a881a2384e46cc699fd7b9507	expressing aspectual interactions in design: experiences in the slot machine domain	model persistence;large models;scalability	In the context of an industrial project we are implementing the software of a casino slot machine. This software has a significant amount of cross-cutting concerns that depend on, and interact with each other, as well as with the modular concerns.We therefore wish to express our design using an appropriate Aspect-Oriented Modeling methodology and notation. We evaluated two of the most mature methodologies: Theme/UML and WEAVR, to establish their suitability. Remarkably, neither of these allow us to express any of the dependencies and interactions to our satisfaction. In both cases, half of the interaction types cannot be expressed at all while the other half need to be expressed using a workaround that hides the intention of the design. As a result, we consider both methodologies and notations unsuitable for expressing the dependencies and interactions present in the slot machine domain. In this paper we describe our evaluation experience.	aspect-oriented software development;associate-o-matic;cross-cutting concern;edmund m. clarke;hoc (programming language);human–computer interaction;jackson;mutual exclusion;requirements engineering;symposium on applied computing;unified modeling language;workaround	Johan Fabry;Arturo Zambrano;Silvia E. Gordillo	2011		10.1007/978-3-642-24485-8_8	scalability;simulation;computer science;systems engineering;engineering drawing	SE	-47.973876296686555	24.826694127980566	114711
3f661c9eeccbaa7acf897ce416e2de60f2f35eca	a formal method to identify deficiencies of functional requirements for product lines of embedded systems		Functional requirements that were stated in cooperation with the stakeholders have to be analyzed and reviewed. Deficiencies like incompleteness, contradictions and redundancy within the requirements may lead to an extended development effort. Identifying and resolving these deficiencies in an existing or evolving set of functional requirements for embedded systems is of major importance. Especially, if the requirements describe a set of possible products. Formal methods provide a powerful way to review the requirements automatically. This paper proposes a method adopted from the formal verification of hardware components to uncover the deficiencies within a given set of requirements. The basis of this approach is built by safety properties represented as Linear Temporal Logic (LTL) formulas which are extracted from the requirements. The presented process is evaluated by means of the specification of a car seat.	algorithm;analysis of algorithms;boolean algebra;business process;embedded system;fm broadcasting;formal methods;formal verification;functional requirement;linear temporal logic;property specification language;redundancy (engineering);requirements engineering	Florian Markert;Sebastian Oster	2011			reliability engineering;discrete mathematics;systems engineering	SE	-44.372671310808514	29.915139042998856	115184
7db4559970985767f2457d05b225e0075f2f4903	situated regulation on a crisis management collaboration platform		Collaborative platforms are useful to mediate the interaction among the different actors involved on a crisis management. This paper demonstrates the grounding of the policies that regulate crisis management activities on the concrete environment where the collaborative platform is deployed. This grounded regulation is enabled by the abstractions and constructs of the Situated Artificial Institution model.	collaborative software;situated	Maiquel de Brito;Lauren Thévin;Catherine Garbay;Olivier Boissier;Jomi Fred Hübner	2015		10.1007/978-3-319-18944-4_24	simulation;engineering;knowledge management;environmental resource management	Robotics	-43.21003864719697	19.18463942361021	115598
3263cf5fefdf8744b06be19e0d0d05547bc8bf5f	efficient representation and simulation of model-based designs	signal processing;model based design;modeling and simulation	Actor-based design is based on composing a system of communicating processes called actors, which can only communicate with each other via channels. However, actor-based design does not constrain the communication behavior of its actors therefore making analyses of the system in general impossible. In a model-based design methodology the underlying Model of Computation (MoC) is known additionally which is given by a predefined type of communication behavior and a scheduling strategy for the actors. In this paper, we propose a library based on the design language SystemC called SysteMoC which provides a simulation environment for model-based designs. We will introduce the syntax and semantics supported by SysteMoC as well as discuss the simulation environment and present first results of using SysteMoC for modeling and simulation of signal processing applications. The library-based approach unites the advantage of executability with analyzability of many expressive MoCs. Finally, we compare the simulative performance of SysteMoC with other executable languages such as C++, regular SystemC, and modelling environments such as Ptolemy II.	c++;design space exploration;executable;model of computation;ptolemy ii;scheduling (computing);signal processing;simulation;systemc	Joachim Falk;Christian Haubelt;Jürgen Teich	2006			systemc;model-based design;computer science;semantics;signal processing;theoretical computer science;design language;modeling and simulation;executable;model of computation	EDA	-37.41400177214299	29.84007551720314	115706
9dcfedaa9910acf69af107c1fd2f26a7a6e1a821	simulation as a planning and scheduling tool for flexible manufacturing systems	flexible manufacturing systems;job shop scheduling flexible manufacturing systems real time systems decision making manufacturing systems processor scheduling automatic control control systems control system synthesis analytical models;production control flexible manufacturing systems digital simulation;planning and scheduling;production control;simulation technique;flexible manufacturing system;technical report;simulation based scheduling simulation planning scheduling tool flexible manufacturing systems flexible simulation technique automated experimentation arena siman manufacturing system decision making fms framework;manufacturing system;digital simulation	This paper describes a flexible simulation technique which facilitates automated experimentation of different scheduling rules. An enhanced version of Arena/SIMAN is used to develop an extremely high fidelity model of the manufacturing system. The decision making of an FMS is characterized and a framework for simulation-based scheduling and control is also introduced.	automated planning and scheduling;scheduling (computing);simulation	Glenn Drake;Jeffrey S. Smith;Brett A. Peters	1995		10.1145/224401.224735	manufacturing execution system;simulation;process development execution system;computer science;engineering;technical report;two-level scheduling;scheduling;computer-integrated manufacturing;world wide web;manufacturing engineering	Robotics	-37.19487131476138	22.57441964020745	115774
81b0de239e1fc50a646d6a7c950668a9bb34a60a	syntax and consistent equation semantics of hybrid chi	continuous time;formal languages formal systems formal proof of program correctness;structured operational semantics;complex system;hybrid automata;formal languages chi;synchronous communication;process algebra;dieren tial algebraic equation;formal language;steady state;program correctness	The hybrid χ (Chi) formalism integrates concepts from dynamics and control theory with concepts from computer science, in particular from process algebra and hybrid automata. It integrates ease of modeling with a straightforward, structured operational semantics. Its ‘consistent equation semantics’ enforces state changes to be consistent with delay predicates, that combine the invariant and flow clauses of hybrid automata. Ease of modeling is ensured by means of the following concepts: 1) different classes of variables: discrete and continuous, of subclass jumping or non-jumping, and algebraic; 2) strong time determinism of alternative composition in combination with delayable guards; 3) integration of urgent and non-urgent actions; 4) differential algebraic equations as a process term as in mathematics; 5) steady-state initialization; and 6) several user-friendly syntactic extensions. Furthermore, the χ formalism incorporates several concepts for complex system specification: 1) process terms for scoping that integrate abstraction, local variables, local channels and local recursion definitions; 2) process definition and instantiation that enable process re-use, encapsulation, hierarchical and/or modular composition of processes; and 3) different interaction mechanisms: handshake synchronization and synchronous communication that allow interaction between processes without sharing variables, and shared variables that enable modular composition of continuoustime or hybrid processes. The syntax and semantics are illustrated using several examples. Email addresses: D.A.v.Beek@tue.nl (D.A. van Beek), K.L.Man@tue.nl (K.L. Man), M.A.Reniers@tue.nl (M.A. Reniers), J.E.Rooda@tue.nl (J.E. Rooda), R.R.H.Schiffelers@tue.nl (R.R.H. Schiffelers). 1 Work partially done in the framework of the HYCON Network of Excellence, contract number FP6-IST-511368 Preprint submitted to 12 September 2006	algebraic equation;automata theory;chi;complex system;computer science;encapsulation (networking);hybrid automaton;invariant (computer science);linear algebra;local variable;operational semantics;picasa web albums;recursion;scope (computer science);semantics (computer science);steady state;synchro;usability	Dirk A. van Beek;Ka Lok Man;Michel A. Reniers;J. E. Rooda;Ramon R. H. Schiffelers	2006	J. Log. Algebr. Program.	10.1016/j.jlap.2005.10.005	complex systems;process calculus;formal language;discrete mathematics;formal verification;computer science;theoretical computer science;asynchronous communication;formal semantics;mathematics;programming language;steady state;algorithm	Logic	-33.71593476450642	31.220403099133684	115786
cdfcbde3eda1840fcda2ef0c1f09955a2d37dc36	the study of guided emergent behavior in system of systems requirement analysis	analytical models;disaster management;semi autonomous agent;parallel executive;mobile agents;system of systems;conference management;agent based modeling;system of systems guided emergent behavior systems requirement analysis core trait agent based modeling multiagent based simulation method semiautonomous agent parallel executive;systems analysis digital simulation mobile agents multi agent systems;systems engineering and theory;technology management;semiautonomous agent;requirement analysis;multi agent systems;feedback;computational modeling;autonomous agent;system of systems sos;emergent properties;core trait;parallel executive experiment;systems analysis;chromium;engineering management;information management;emergent behavior;guided emergent behavior;multiagent based simulation method;parallel executive experiment system of systems sos guided emergence semi autonomous agent;management information systems;management information systems information management technology management disaster management modeling systems engineering and theory information analysis conference management engineering management feedback;autonomous agents;agent based modeling and simulation;modeling;guided emergence;information analysis;multi agent based simulation;digital simulation;conferences;systems requirement analysis	Emergent behavior is a core trait of SoSs. But the emergence cannot be predicted before its appearance. We propose a method which using Semi-autonomous Agent based simulation to detect the emergent behaviors of SoSs. Agent based Modeling and Simulation are available for the observation of emergent behaviors of SoSs. We propose the multi-agent based simulation methods to demonstrate the evolution of SoSs. Semi-autonomous Agents is applied to model the elements which are consists of SoSs. The framework of Parallel executive and feedback to real world is used to verify and validate the emergent properties which are useful to the SoSs or not. Through the comparation between real world executive results and simulation outcomes, we could regulate the parameters or adjust rules running in the SoSs and guide the emergent behavior of SoSs to the stakeholder's desire direction.	agent-based model;autonomous agent;autonomous robot;design of experiments;distributed control system;emergence;executable;experiment;multi-agent system;requirements analysis;semiconductor industry;simulation;system of systems	Ke-Wei Yang;Ying-Wu Chen;Yan-jing Lu;Qing-Song Zhao	2010	2010 5th International Conference on System of Systems Engineering	10.1109/SYSOSE.2010.5544033	simulation;computer science;systems engineering;engineering;knowledge management;artificial intelligence;technology management;autonomous agent;information management;emergence	Robotics	-43.08661742315427	18.525786979810295	115873
b86cea482554dc0d54e7adc49b6301630f5ce7da	generation of functional mock-up units for co-simulation from simulink®, using explicit computational semantics: work in progress paper	model validation and analysis;algorithms;design;experimentation;co-simulation;simulink&reg;;measurement;numerical integration;fmi;types of simulation;simulation theory;performance	As the complexity of Software-Intensive and Cyber-Physical Systems increases, multiple formalisms are used to model different parts of a system. Rather than building simulators for these combinations of multiple formalisms, co-simulation is often used to orchestrate multiple simulations. One emerging industry standard in this field is the Functional Mock-up Interface (FMI). This standard defines the interface implemented by Functional Mock-up Units (FMUs). An FMU is encoded as a zip-file containing model variable types and values in XML-format as well as the model's equations in C C-code. The C encoding allows one to distribute IP in binary form. Solvers are typically coded instead of explicitly modeled. However, this does not allow straightforward analysis or detection of for example algebraic loops and optimization possibilities. Explicitly modeling the solvers helps overcome these limitations, since this allows for the use of model-driven engineering techniques, such as model transformations. This paper presents a method to generate FMUs from Causal Block Diagram models, more specific Simulink® models, with explicitly modeled ODE solvers. The execution performance is compared between FMUs with explicitly modeled solvers and FMUs with coded solvers. We conclude that modeling the solver has a significant positive impact on the run-time efficiency of the generated FMUs.	co-simulation;computational semantics;mock object;simulation;simulink	Bart Pussig;Joachim Denil;Paul De Meulenaere;Hans Vangheluwe	2014				AI	-37.681294886141174	28.619303516300544	115991
17dffe7a6f10b88fdda2c9d3ee6a9993c11b3d4f	hil simulation workbench for testing and validating plc programs	programmable controllers;programmable controllers control engineering computing digital simulation program testing program verification;program verification;web assisted laboratory for control engineering on line project hil simulation workbench plc program testing plc program validation hardware in the loop simulation programmable logic controllers plant models flexible automation platform networked industrial automation systems industrial protocol communications sensors actuators walc project;verification and validation hil simulation plc programs plant modeling;program testing;control engineering computing;digital simulation	Usually, Model-in-the-loop (MiL), Software-in-the-loop (SiL) and Hardware in the loop (HiL) simulation approaches are used in industry and all of them have to deal with the inter process communication issues between system's components. In this paper it is intended to describe the construction of a prototype workbench for testing and validation of Programmable Logic Controllers' (PLC) programs, using HiL simulation approach, focusing this study on guaranteeing adequate plant models to be used. This work is inserted in a bigger project that deals with creation of a flexible automation platform that is used for controlling any kind of networked industrial automation systems. This platform considers several industrial protocol communications and different kind of sensors and actuators, usually used in industry, and it was developed on the context of WALC (Web Assisted Laboratory for Control Engineering on-line) project.	as-interface;automation;control engineering;hardware-in-the-loop simulation;inter-process communication;online and offline;programmable logic device;prototype;workbench	José Machado;Eurico Seabra	2013	2013 11th IEEE International Conference on Industrial Informatics (INDIN)	10.1109/INDIN.2013.6622887	control engineering;embedded system;engineering;computer engineering	Robotics	-35.516688691203335	29.55402695904528	116044
eb87f9ba2c9d5cf6c3e1dce5d7019a711c8716f9	specification and verification of inter-component constraints in ctl	temporal logic;reasoning	The most challenging issue of component-based software is about component composition. Current component specification, in addition to the syntactic level, is very limited in dealing with semantic constraints. Even so, only static aspects of components are specified. This paper gives a formal approach to make component specification more comprehensive by including component semantic. Fundamentally, the component semantic is expressed via the powerful temporal logic CTL. There are two semantic aspects in the paper, component dynamic behavior and consistency - namely a component does not violate some property in another when composed. Based on the proposed semantic, components can be efficiently cross-checked for their consistency by an incremental verification method - OIMC, even for many future component extensions.		Nguyen Truong Thang;Takuya Katayama	2006	ACM SIGSOFT Software Engineering Notes	10.1145/1118537.1123067	real-time computing;temporal logic;common component architecture;computer science;theoretical computer science;component;programming language;reason	SE	-42.542683389814144	28.475469168833456	116053
9f54241a9d6a98d31a228ba0624b5219934267bc	ercn-merged nets and their analysis using siphons	resource allocation production control petri nets assembly planning;integrable model;resource allocation;resource control;indexing terms;production control;assembly planning;petri nets manufacturing systems resource sharing extended resource control nets assembly parallel processes siphons reversibility liveness production control;petri nets;petri net;manufacturing system;manufacturing systems petri nets merging control system synthesis process design aggregates assembly systems oceans;parallel processing;dynamic behavior	This paper generalizes the modular approach proposed by Jeng and DiCesare for modeling manufacturing systems with shared resources. First the dynamic behavior of each resource is modeled separately using extended resource control nets (ERCN’s). An important feature of ERCN’s is their capability to express explicitly assembly operations and parallel processes, which is not possible with Resource Control Nets. Interactions among the resources are then modeled through merging of common transitions and common transition subnets. This paper provides conditions, expressed in terms of siphons, under which reversibility and liveness of the integrated model are obtained. Relations between siphons, circular structure and circular-wait are formally established.	deadlock;interaction;kosterlitz–thouless transition;liveness;parallel computing;subnetwork	Xiaolan Xie;MuDer Jeng	1999	IEEE Trans. Robotics and Automation	10.1109/70.781975	parallel processing;real-time computing;stochastic petri net;computer science;systems engineering;process architecture;petri net	Robotics	-35.0608884686484	29.93264294607941	116057
9b22ee45f70940119457a68e88b731500d7f6c21	bidirectional transformations in the large		"""The model-driven development of systems involves multiple models, metamodels and transformations, and relationships between them. A bidirectional transformation (bx) is usually defined as a means of maintaining consistency between """"two (or more)"""" models. This includes cases where one model may be generated from one or more others, as well as more complex (""""symmetric"""") cases where models record partially overlapping information. In recent years binary bx, those relating two models, have been extensively studied. Multiary1 bx, those relating more than two models, have received less attention. In this paper we consider how a multiary consistency relation may be defined in terms of binary consistency relations, and how consistency restoration may be carried out on a network of models and relationships between them. We relate this to megamodelling and discuss further research that is needed."""	algorithm;bidirectional transformation;circuit restoration;confluence;consistency model;constraint satisfaction problem;delta encoding;eventual consistency;jeremy gibbons;local consistency;metamodeling;model-driven architecture;model-driven engineering;relational model;software development	Perdita Stevens	2017	2017 ACM/IEEE 20th International Conference on Model Driven Engineering Languages and Systems (MODELS)	10.1109/MODELS.2017.8	theoretical computer science;computer science;unified modeling language;software;multiple models;binary number	SE	-44.94447919113394	26.479528284450584	116119
925e3f52983e8d56616368a251b7a296af693a90	research on social relations cognitive model of mobile nodes in internet of things	decision factors;internet of things;social relations;mobile aware;cognitive model	Interaction and communication between humans with smart mobile devices are a new trend of development in Internet of Things (IoT). With the powerful sensing capability of smart device and human mobility, various services could be provided by building a trusted chain between service requesters and suppliers. The cognition of social relations between mobile nodes is the basis of final mobile-aware services. It involves many decision factors, such as time, space and activity patterns. Using social network theory, a new cognitive model for social relations of mobile nodes in IoT is proposed. Firstly, nodes’ social relations are reasoned and quantified from multiple perspectives based on the summary of social characteristics of mobile nodes and the definition of different decision factors. Then the location factor, interconnection factor, service evaluation factor and feedback aggregation factor are defined to solve the shortcomings in existing quantitative models. Finally, the weight distribution is set up by information entropy and rough set theory for these decision factors; it can overcome the shortage of traditional methods, in which the weight is set up by subjective ways and hence their dynamic adaptability is poor. We compare our cognitive model to existing models using MIT dataset by defining a variety of test indicators, such as network overall density (NOD), the degree center potential (DCP), the network distribution index (EI), etc. Simulation results show that, the cognitive model has better internal structure and significant validity in network analysis, and thus can provide mobile-aware service effectively in dynamic environment. & 2012 Elsevier Ltd. All rights reserved.	binary prefix;cognition;cognitive model;eset nod32 antivirus;entropy (information theory);interconnection;internet of things;mined;mobile device;network theory;real-time transcription;rough set;set theory;simulation;smart device;social network	Jian An;Xiaolin Gui;Wendong Zhang;Jinghua Jiang;Jianwei Yang	2013	J. Network and Computer Applications	10.1016/j.jnca.2012.12.004	cognitive model;social relation;simulation;telecommunications;computer science;artificial intelligence;computer security;internet of things;computer network	Web+IR	-36.52698481916147	20.050309023257935	116589
8be2bcee1871194a40e44e470f2cf21e5157191c	removing redundancies and deducing equivalences in uml class diagrams		The emerging Model-driven Engineering approach puts models at the heart of the software development process. The Class Diagram language is central within the UML. Automated support for class diagrams involves identification and repair of correctness and quality problems. This paper presents methods and rules for improving class diagram quality. The paper introduces formal semantics for class diagrams, which distinguishes between existential to universal constraints, and defines redundancy of existential constraints. It provides and analyzes algorithms for removing redundancy of multiplicity and generalization-set constraints in class diagrams with class hierarchy, qualifier, association class, aggregation/composition, and inter-association constraints, and presents inference rules for deducing element equivalence. All methods are under implementation in the FiniteSatUSE tool.	algorithm;class diagram;class hierarchy;correctness (computer science);model-driven architecture;model-driven engineering;semantics (computer science);software development process;turing completeness;unified modeling language	Azzam Maraee;Mira Balaban	2014		10.1007/978-3-319-11653-2_15	database;distributed computing;programming language	SE	-44.91532978905468	27.06256475501064	116638
2f96e2e39154a45a0b10635c7892c7c93206785a	a devs library for rail operations simulation	rail transportation;simulation library;devs	Detailed yet computationally efficient simulation models are needed to support the design and operation of modern rail infrastructure systems. LIBROS-II is a model component library for microscopic rail operations simulation. Basic rail elements are modeled as atomic DEVS models which are further aggregated into more elaborate rail component models. The latter can in turn be used modularly for the composition of rail network systems of arbitrary complexity in a detailed, efficient, and rigorous way. This paper explains the communication principles in the model and gives an overview of vehicle detection and control system simulation. To enhance its usability, LIBRO-II is augmented with CRMB, a model generator capable of inferring structural and behavioral features of a rail network from standard CAD data.	algorithmic efficiency;computer-aided design;control system;control unit;devs;modular programming;recursion;semantics (computer science);simulation;software propagation;usability;vehicle-to-vehicle	Yilin Huang;Mamadou D. Seck;Alexander Verbraeck	2011			embedded system;real-time computing;simulation;engineering	Embedded	-37.29373722737716	29.483055020314588	116762
052722362fe346d8f4d16521e2c9cd3b458f3057	real-time specification patterns and tools		An issue limiting the adoption of model checking technologies by the industry is the ability, for non-experts, to express their requirements using the property languages supported by verification tools. This has motivated the definition of dedicated assertion languages for expressing temporal properties at a higher level. However, only a limited number of these formalisms support the definition of timing constraints. In this paper, we propose a set of specification patterns that can be used to express real-time requirements commonly found in the design of reactive systems. We also provide an integrated model checking tool chain for the verification of timed requirements on TTS, an extension of Timed Petri Nets with data variables and priorities.	algorithm;assertion (software development);correctness (computer science);high- and low-level;machine translation;mathematical optimization;model checking;modeling language;netware file system;pattern language;petri net;real-time clock;real-time computing;real-time locating system;real-time transcription;requirement;toolchain	Nouha Abid;Silvano Dal-Zilio;Didier Le Botlan	2012		10.1007/978-3-642-32469-7_1	reliability engineering;real-time computing;computer science;programming language	SE	-42.41672125672048	30.516203516076622	116936
06f721c96d149db386a2c71bac3f6157b1f54bc7	autonomous vehicle ultrasonic sensor vulnerability and impact assessment		Vehicles today are relying more on technologies to bring about fully autonomous features. The conventional wirings within are being simplified into a network of electronic components, and this network is controlled via advanced sensing of the environment to make decisions in real-time. However, with the heavy reliance on the sensor readings, any inaccurate reading from the sensors could result in decisions that may cause life-threatening incidents. As such, this research focuses on the in-depth assessment of potential vulnerabilities of an important and commonly used obstacle sensing device, which is the ultrasonic sensor, in modern as well as autonomous vehicles. This research will help bring awareness to the car manufacturers and AV researchers so as to mitigate such issues.		Bing Shun Lim;Sye Loong Keoh;Vrizlynn L. L. Thing	2018	2018 IEEE 4th World Forum on Internet of Things (WF-IoT)	10.1109/WF-IoT.2018.8355132	computer security;computer engineering;obstacle;computer science;impact assessment;ultrasonic sensor;electronic component;vulnerability	HCI	-33.94008426608505	21.15888956226685	116983
8981555c40561fdee3a6f289389d5d96aa470422	algebraic methodology and software technology		We can integrate formal methods into an existing undergraduate curriculum by focusing on teaching their common conceptual elements and by using state of the art formal methods tools. Common elements include state machines, invariants, abstraction mappings, composition, induction, specification, and verification. Tools include model checkers and specification checkers. By introducing and regularly revisiting the concepts throughout the entire curriculum and by using the tools for homework assignments and class projects, we may be able to attain the ideal goal of having computer scientists use formal methods without their even realizing it.	computer scientist;formal methods;invariant (computer science);mathematical induction;model checking	Jan van Leeuwen;Teodor Rus Ed	2000		10.1007/3-540-45499-3	verification and validation;systems engineering;social software engineering;theoretical computer science;software development;software engineering;software construction;software system	Logic	-46.25580221126464	29.510672030259446	117146
4abab7059a2de8696250673dcb95536314458dc3	test generation for sequential nets of abstract state machines	ing inf 05 sistemi di elaborazione delle informazioni	Test generation techniques based on model checking suffer from the state space explosion problem. However, for a family of systems that can be easily decomposed in sub-systems, we devise a technique to cope with this problem. To model such systems, we introduce the notion of sequential net of Abstract State Machines (ASMs), which represents a system constituted by a set of ASMs such that only one ASM is active at every time. Given a net of ASMs, we first generate a test suite for every ASM in the net, then we combine the tests in order to obtain a test suite for the entire system. We prove that, under some assumptions, the technique preserves coverage of the entire system. We test our approach on a benchmark and we report a web application example for which we are able to generate complete test suites.	abstract state machines;finite-state machine	Paolo Arcaini;Francesco Bolis;Angelo Gargantini	2012		10.1007/978-3-642-30885-7_3	simulation;computer science;artificial intelligence;operating system;database;mathematics;computer security;algorithm	EDA	-43.86856459466038	30.031721282850157	117376
a8139ff4bdf7156506cb12e23244984f4d75dd08	verification and validation of knowledge-based systems with formal specifications	knowledge based system;formal specification;verification and validation	This paper examines how formal speci cation techniques can support the ver i cation and validation V V of knowledge based systems Formal speci cation techniques provide levels of description which support both veri cation and valida tion and V V techniques feed back to assist the development of the speci cations Developing a formal speci cation for a system requires the prior construction of a conceptual model for the intended system Many elements of this conceptual model can be e ectively used to support V V Using these elements the V V process becomes deeper and more elaborate and it produces results of a better quality compared with the V V activities which can be performed on systems de veloped without conceptual models However we note that there are concerns in using formal speci cation techniques for V V not least being the e ort involved in creating the speci cations	formal specification;knowledge-based systems;verification and validation	Pedro Meseguer;Alun D. Preece	1995	Knowledge Eng. Review	10.1017/S0269888900007542	verification and validation of computer simulation models;concepts;verification and validation;verification;formal methods;computerized system validation;formal verification;software verification;computer science;artificial intelligence;knowledge-based systems;formal specification;refinement;validation rule;intelligent verification;functional verification	SE	-45.34581598798999	28.346846357597972	117519
9632504f8938d3a78020f57770abf81a48ac074e	specifications and rapid prototyping of multi-agent systems through coloured petri net represented in abductive logic programming (cpn-lp)	coloured petri net;multi agent system;software prototyping;software engineering;abductive logic programming rapid prototyping multi agent systems coloured petri net;rapid prototyping;logic programming;software prototyping logic programming petri nets;classical logic;petri nets;abductive logic programming;prototypes multiagent systems logic programming software prototyping protocols reactive power design engineering autonomous agents concurrent computing system recovery	Specifications and prototyping are valuable means to help software engineers when developing complicated systems. In this paper, we propose a method for specifying a multi-agent system using coloured Petri net (CPN). By representing the coloured Petri net as an abductive logic programming (which is an extension of logic (LP) programming and is purely based on classical logic), a prototype is immediately resulted. Every inference step of the implementation of the prototype can be regarded as a kind of equivalence preserved transformation. We call our framework CPN-LP and use an example on Dutch auction protocol to illustrate its application	abductive logic programming;abductive reasoning;coloured petri net;lp-type problem;multi-agent system;prototype;rapid prototyping;software engineer;turing completeness	T. H. Fung	2006	2006 IEEE/WIC/ACM International Conference on Web Intelligence (WI 2006 Main Conference Proceedings)(WI'06)	10.1109/WI.2006.159	classical logic;real-time computing;concurrency;computer science;functional logic programming;multi-agent system;distributed computing;inductive programming;programming language;prolog;logic programming;petri net;abductive logic programming	Robotics	-42.38060913104432	29.77045961524916	117574
259f39bb941c66256dd55e951c93343cbb43ef78	specifying cash-point with disco	banking;logica temporal;formal specification;gestion encaisse;validacion;temporal logic;secteur bancaire;service;formal method;specification formelle;especificacion formal;cash management;object oriented;oriente objet;validation;orientado objeto;logique temporelle;gestion caja;servicio	We describe how the cash-point service problem of Formal Methods ’99 is specified using DisCo [Dis, JKS91].	formal methods;limbo	Timo Aaltonen;Pertti Kellomäki;Risto Pitkänen	2000	Formal Aspects of Computing	10.1007/PL00003932	service;formal methods;temporal logic;cash management;computer science;formal specification;database;programming language;object-oriented programming;computer security	PL	-41.25293019944202	26.317922278172325	117715
e8e79daff8eb896fba0e4b37d00c6f31ff887810	multi-level assertion-based design	formal specification;behavior modeling;formal verification	"""Assertions are advocated as a means to specify high-level models of a design. Assertions are translated into executable behavioral models (""""cando-objects""""). The cando-objects reflect the intended non-determinism of assertions as well as the non-determinism caused by the incompleteness of a set of assertions. The approach supports significant design methodological concepts like refinement and compositionality."""	executable;high- and low-level;refinement (computing)	Hans Eveking;Martin Braun;Martin Schickel;Martin Schweikert;Volker Nimbler	2007	2007 5th IEEE/ACM International Conference on Formal Methods and Models for Codesign (MEMOCODE 2007)		behavioral modeling;computer architecture;design methods;formal verification;computer science;theoretical computer science;formal specification;programming language	EDA	-42.9612583902663	28.772701177558492	117725
374e04d36189f5274b24648d476f9c11704ba3da	20 years of uppaal enabled industrial model-based validation and beyond			uppaal	Kim G. Larsen;Florian Lorber;Brian Nielsen	2018		10.1007/978-3-030-03427-6_18		Robotics	-46.84392642614669	31.878887793157556	118098
b2e7083d6a81747650e068f49b137c5a3f5e1401	a data sharing agreement framework	added value;consumidor;modelizacion;data sharing;value added services;logica temporal;flujo conduccion;shared memory;logistique;traitement flux donnee;fournisseur;consommateur;memoria compartida;temporal logic;securite informatique;resource management;supplier;flux donnee;pipe flow;flujo datos;specification language;computer security;modelisation;gestion recursos;ecoulement conduite;logistics;consumer;seguridad informatica;data flow processing;gestion ressources;valor anadido;supply chain;lenguaje especificacion;information system;data flow;modeling;langage specification;valeur ajoutee;logique temporelle;systeme information;memoire partagee;proveedor;logistica;sistema informacion	The 1999 Oregon Legislature created the Oregon Land Information System (OLIS) Fund to help fund the creation of a statewide cadastral base map for facilitating and improving Oregon’s property tax mapping system and for providing other Geographic Information System (GIS) benefits, pursuant to Oregon Revised Statute (ORS) 306.132 and 306.135. The resulting Oregon Map Project (ORMAP) evolved as a model project for maintaining tax lot data, and other cadastral data, to produce a standard set of digital tax maps for the entire state. See http://www.ormap.com/. The tax lot layer has been identified as one of the key base layers within the Oregon Geographic Information Council’s (OGIC) Framework Initiative.	geographic information system;land information system;oxford libraries information system;web mapping	Vipin Swarup;Leonard J. Seligman;Arnon Rosenthal	2006		10.1007/11961635_2	shared memory;pipe flow;logistics;data flow diagram;systems modeling;consumer;specification language;temporal logic;computer science;resource management;database;supply chain;computer security;information system;added value	HCI	-41.100667380824355	26.117498928229267	118104
3167089c781ef078e0eb0f8587249a6b24853d0f	a framework for compositional synthesis of modular nonblocking supervisors	verification;automata supervisory control software algorithms manufacturing systems discrete event systems explosions computational modeling;state space methods;state space methods control system synthesis discrete event systems finite state machines;equivalence;finite state machines;control system synthesis;synthesis abstraction finite state automata supervisory control theory;discrete event systems;des software tool supremica modular nonblocking supervisors compositional supervisor synthesis discrete event systems deterministic automata modular structure finite state automata state space explosion nonabstracted model synthesis equivalent abstractions	This paper describes a framework for compositional supervisor synthesis, which is applicable to all discrete event systems modeled as a set of deterministic automata. Compositional synthesis exploits the modular structure of the input model, and therefore works best for models consisting of a large number of small automata. The state-space explosion is mitigated by the use of abstraction to simplify individual components, and the property of synthesis equivalence guarantees that the final synthesis result is the same as it would have been for the non-abstracted model. The paper describes synthesis equivalent abstractions and shows their use in an algorithm to efficiently compute supervisors. The algorithm has been implemented in the DES software tool Supremica and successfully computes nonblocking modular supervisors, even for systems with more than 1014 reachable states, in less than 30 seconds.	algorithm;automata theory;automaton;finite-state machine;interaction;programming tool;semantics (computer science);state space;turing completeness	Sahar Mohajerani;Robi Malik;Martin Fabian	2014	IEEE Transactions on Automatic Control	10.1109/TAC.2013.2283109	control engineering;equivalence;discrete mathematics;real-time computing;verification;quantum finite automata;computer science;mathematics;finite-state machine	Logic	-35.1888732004642	30.57888581681477	118507
16c290325860cf5c794e67a6c1fbb34db7520aff	modeling trust and reputation within communities of practice	team assembly model;trust;community of practice;theoretical framework;multi agent system;agent based;agent based model;knowledge management;reputation;team assembly model community of practice trust reputation multi agent systems;multi agent systems;computational modeling;monitoring;robustness;organizations;organizational behavior;communities;knowledge management trust modeling communities inter organizational behavior practice members agent based representation;computational modeling organizations monitoring communities robustness;trust and reputation	The aim of this paper is to highlight the importance of trust and reputation in communities of practice and to describe a theoretical framework for the organization of communities of practice in a dynamic perspective. The inter-organizational behavior of communities of practice members has been researched and formalized using agent-based representation. We have proposed an adapted agent-based model to evaluate and to simulate reputation in communities of practice.	agent-based model;organizational behavior;simulation	Iulia Maries;Emil Scarlat	2010	2010 IEEE International Conference on Systems, Man and Cybernetics	10.1109/ICSMC.2010.5641684	reputation;computer science;organization;knowledge management;artificial intelligence;multi-agent system;management science;trustworthy computing;computational model;robustness	Robotics	-43.0961084811251	18.545068699842343	118720
34dc72471f690b53d735ecae23fbc7aabee9b107	composable semantics for model-based notations	composition;operational semantics;community composition;automatic generation;concurrency;transition systems;formal analysis;communication;composition operator;model based notations;state transition	We propose a unifying framework for model-based specification notations. Our framework captures the execution semantics that are common among model-based notations, and leaves the distinct elements to be defined by a set of parameters. The basic components of a specification are non-concurrent state-transition machines, which are combined by composition operators to form more complex, concurrent specifications. We define the step-semantics of these basic components in terms of an operational semantics template whose parameters specialize both the enabling of transitions and transitions' effects. We also provide the operational semantics of seven composition operators, defining each as the concurrent execution of components, with changes to their shared variables and events to reflect inter-component communication and synchronization; the definitions of these operators use the template parameters to preserve in composition notation-specific behaviour. By separating a notation's step-semantics from its composition and concurrency operators, we simplify the definitions of both. Our framework is sufficient to capture the semantics of basic transition systems, CSP, CCS, basic LOTOS, ESTELLE, a subset of SDL88, and a variety of statecharts notations. We believe that a description of a notation's semantics in our framework can be used as input to a tool that automatically generates formal analysis tools.	agent-based model;calculus of communicating systems;concurrency (computer science);model-based specification;operational semantics;programming language;shared variables	Jianwei Niu;Joanne M. Atlee;Nancy A. Day	2002		10.1145/587051.587074	composition;concurrency;computer science;composition operator;theoretical computer science;formal semantics;programming language;operational semantics;denotational semantics;algorithm	SE	-38.11504091522402	30.05456786719141	118878
0939adc78e9a5a1eb39d027ca03cdb01dd3e2b4d	a categorical model of model merging and weaving		Model driven engineering advocates the separation of concerns during the design time of a system, which leads to the creation of several different models, using several different syntaxes. However, to reason on the overall system, we need to compose these models. Unfortunately, composition of models is done in an ad hoc way, preventing comparison, capitalisation and reuse of the composition operators. In order to improve comprehension and allow comparison of merging and weaving operators, we use category theory to propose a unified framework to formally define merging and weaving of models. We successfully use this framework to compare them, both through the way they are transformed in the formalism, and through several properties, such as completeness or non-redundancy. Finally, we validate this framework by checking that it correctly identifies three tools as performing merging or weaving of models.	category theory;hoc (programming language);model-driven engineering;robert;semantics (computer science);separation of concerns;unified framework;webserver directory index	Jonathan Y. Marchand;Benoît Combemale;Benoit Baudry	2012	2012 4th International Workshop on Modeling in Software Engineering (MISE)		computer simulation;unified modeling language;model-driven architecture;cloud computing;performance;separation of concerns;computer science;artificial intelligence;composition operator;theoretical computer science;software engineering;data mining;formal specification;redundancy;programming language;computational model;weaving;category theory	SE	-44.43491117359945	26.9801943298618	119004
10b79bea60d1ef42b2f69304bce9f5566f5c7833	supporting the application of situated cellular agents in non-uniform spaces	settore inf 01 informatica;mas based modelling;multi agent system;multi agent systems;development environment;structured environment	The paper presents Situated Cellular Agents (SCA), systems of reactive agents that are heterogeneous and populate a structured environment. The structure of this environment is defined as a non-uniform network of sites in which agents are situated. The behavior of SCA agents (i.e. change of state and position) is influenced by states and types of agents that are situated in adjacent and at-a-distance sites. After an outline of SCA approach and its main applications, the paper introduces an ongoing project to develop a tool to support the development and execution of SCA applications.	situated	Stefania Bandini;Sara Manzoni;Carla Simone	2005	Future Generation Comp. Syst.	10.1016/j.future.2004.05.002	simulation;computer science;artificial intelligence;multi-agent system;development environment	HCI	-41.339844021812056	20.408096571949635	119052
72431280580f83b1725261dd11720c3d9c88ca0e	part ii: system of systems preface		a. Increase in the scope and degree of uncertainties in systems’ environments, which enforces high adaptability requirements to the systems. b. Increase in the level of interconnectivity among previously semi-isolated constituents that gives systems a more distributed nature. c. Incorporation of more self-optimizing and decision making constituents that drive systems toward higher levels of autonomy.	autonomy;interconnectedness;requirement;semiconductor industry;system of systems	Babak Heydari	2014		10.1016/j.procs.2014.09.044	system of systems;data mining;computer science	SE	-44.9473310880148	21.153844454036225	119059
56239099032c133d320d7a8ad286922178e94231	l' approche multi-agents pour le pilotage des systèmes complexes appliquée aux systèmes du trafic urbain. (the multi-agents approach for the management of complex systems applied to urban trafic)		The design, the study and the management of urban traffic systems (UTS) are difficult and expensive and the construction and are very complex tasks. In these systems the goal is to improve traffic and optimize the flow through operating rules and the control system (which constitute the decisional subsystem). The distributed approach of controlling systems can contribute to the development of agile organizations, combining the logic of network and hierarchy. However, the noncentralized control system of UTS fundamentally relies on the interactions of communicating, autonomous and capable of making decisions entities. This work fits in the development of the modeling methodology ASDImi-UTS (analysis, specification, design, implementation multiple, incremental for UTS) which aims to assist in the design and management of the UTS. The problems involved in the design of the decisional subsystem of UTS are the control of spatial and temporal consistency of decisions, considering the characteristics of control systems and their environment. We propose for the decisional subsystem a multi-agent approach and a decision-making tool to improve the quality of service to users and to solve planning issues at the strategic, tactical and operational levels.	agile software development;autonomous robot;complex systems;control system;decision support system;entity;fits;interaction;multi-agent system;quality of service;uts	Ahmad Ali	2009				SE	-41.163138093020905	21.814539289898445	119064
92fff14c599ac8824e2ab6a72509e63322931743	bridging the gaps in a model-based system engineering workflow by encompassing hardware-in-the-loop simulation	formal specification;model driven architecture mda;rail vehicle model based system engineering workflow hardware in the loop simulation mbse workflow model transformation tools system performance verification system requirements model based representation hil components effectiveness verification capability verification development platform vehicle system ibm rhapsody mathworks simulink combination system verification bidirectional transformation ibm rhapsody model simulink model platform independent model platform specific model;model driven architecture mda hardware in the loop hil simulation model based design model based system engineering mbse;formal verification;railway rolling stock;hardware in the loop hil simulation;model based system engineering mbse;software tools;control engineering computing;vehicles;model based design;article;vehicles control engineering computing formal specification formal verification railway rolling stock software tools;software packages mathematical model unified modeling language analytical models	This paper discusses how gaps in a model-based system engineering (MBSE) workflow can be bridged through the use of special model transformation tools. The goal is to create an integrated workflow tool chain to facilitate integration of various subsystems and verification of the overall system performance to meet a set of desired system requirements. This paper describes an implementation in a model-based representation that encompasses real system hardware-in-the-loop (HIL) components to verify the effectiveness and capability of the development platform. Discussion is provided on the developed model transformation processes that make this possible and is explained through the application of our approach to the development of subsystems for a vehicle system. The key contributions of research include: 1) identification of a suitable model-based systems design methodology and toolset (based on IBM Rhapsody/Mathworks Simulink combination) to include HIL for system verification; 2) design and development of model transformation tools to facilitate bidirectional transformation of an IBM Rhapsody model to a Simulink model; and 3) successful mapping between platform independent models and platform-specific models involving HIL. The research outcomes show particularly promising results that are anticipated to benefit the MBSE community.	agile software development;apple rhapsody;bidirectional transformation;bridging (networking);complex systems;emergence;fits;hil bus;hardware-in-the-loop simulation;high- and low-level;legacy system;model transformation;model-driven architecture;next-generation network;platform-specific model;rational rhapsody;requirement;scalability;seamless3d;simulink;spiral model;system requirements;systems modeling language;systems design;systems engineering;toolchain;v-model	R. S. Kalawsky;John T. O'Brien;Seng Kwong Chong;Chi-Biu Wong;Haibo Jia;Hongtao Pan;Philip R. Moore	2013	IEEE Systems Journal	10.1109/JSYST.2012.2230995	embedded system;simulation;formal verification;computer science;systems engineering;engineering;operating system;formal specification;model-based design	Robotics	-47.746335217835224	31.375730641286424	119191
6a3c6cc26e3b99f6cf851c725d9f374668cc579d	on combining organisational modelling and graphical languages for the development of multiagent systems	multiagent system;agent based	This article illustrates the application of the Gaia methodology to the development of a system for Selective Dissemination of Information on the Web, as well as the integration of Gaia with AUML. This allows a concrete design closer to implementation and the developer offers a better insight into the multiagent system that is being built. Gaia is an agent-oriented organisational methodology that generates an abstract model based on roles describing the system agents, their services and interactions. AUML, as an agent-based extension of the graphical language UML, uses that model as input and breaks it down into a series of diagrams that facilitates its implementation.	agent-based model;diagram;gaia hypothesis;graphical user interface;interaction;multi-agent system;selective dissemination of information;unified modeling language;visual programming language;world wide web	Álvaro Enrique Arenas;Juan C. García-Ojeda;José de Jesús Pérez Alcázar	2004	Integrated Computer-Aided Engineering		simulation;computer science;artificial intelligence	AI	-42.71154903485617	22.694421779402205	119269
f6624f902b96ee90cdc8432e80ec37b8cb67b111	a reflective middleware architecture for simulation integration	emergency response;structural reflection;simulation integration;metamodel;reflective middleware	This paper presents a reflective middleware architecture for simulation integration based on structural reflection and metamodel concepts. The proposed architecture extracts the simulator information as metamodels from the base-level simulators, determines the required features and modules using semantic constraints, and reflects the modified features to the base- level. It is shown that the reflective middleware architecture addresses various challenges in simulation integration. It also enables a design that is more adaptable, flexible and easier to extend. We present a detailed case study from the emergency response domain, where simulations are critical, to illustrate the potential benefits of applying the proposed architecture.	metamodeling;middleware;simulation	Leila Jalali;Nalini Venkatasubramanian;Sharad Mehrotra	2009		10.1145/1658185.1658188	real-time computing;simulation;systems engineering;engineering;middleware	Robotics	-44.26660229366486	24.779013301054206	119331
7f5f2693ee31386e0e702111626aefc3e24413f1	instructional laboratory for practical investigation of electric drive control		The study discusses the design principles of instructional laboratory equipment applied for practical investigations of electric drive control. The laboratory workstations comprise of two-motor hardware systems where each motor is controlled by a real-time DSP board. A control structure under test is assembled at the software level using a number of control elements, which is then compiled into a control algorithm for the microcontroller. In order to provide safe test execution, the control algorithm operates under the supervision of a real-time core software ensuring protection of the motors and the power converters. Due to the improvement in the reliability of hardware operation, the rated power of the motors and converters is increased to >1 kW to provide a proper characterisation of electric drives similar to industrial installations. The study also describes the laboratory hardware and software details using an example of the control system for an induction motor based on flux-vector control strategy. The example demonstrates configuring the control systems, compiling it into the execution code, the test procedure and result analysis.		Alecksey Anuchin;Yuriy Vagapov	2017	IET Circuits, Devices & Systems	10.1049/iet-cds.2016.0400	control engineering;simulation;engineering;electrical engineering	Embedded	-33.79504649591627	29.466327432070756	119375
313a1819cf2aea5d48daaed9824ecac4c3f14d0d	uml2sql—a tool for model-driven development of data access layer	object query language;activity diagram;behavior modeling;model driven development;data access;system development	The article is a condensed journey over UML2SQL: a tool for modeldriven development of data access layer. UML2SQL includes an object query language and allows for behavior modeling based on UML activity diagrams, effectively linking structural and behavioral aspects of the system development. From the general idea of UML2SQL and its origins, we go through the details of its architecture and beyond the processes and schemes which make UML2SQL a distinct tool in the data access domain. Finally, an example of developing an application using UML2SQL is given as an illustration of its practical usage.		Leszek Siwik;Krzysztof Lewandowski;Adam Wos;Rafal Drezewski;Marek Kisiel-Dorohinicki	2010		10.1007/978-3-642-04584-4_10	computer science;data mining;database;programming language	SE	-46.45551858949359	21.7106131067531	120224
49b6b4633a2ec4986c23eb84085a335ce05e6449	systemic modeling of agent coaction: a catalog of decentralized coordinating processes	system modeling	Taking inspiration from natural self-organizing systems is a successful strategy to solve computational problems in distributed systems. Faced with a particular problem, application designers have to identify an appropriate dynamical behavior and decide how to induce similar behavioral modes. In order to consolidate these ad-hoc activities to a systematic dynamical design method, we discuss and exemplify a behavioral modeling approach that describes the macroscopic behavior of agent-based software systems. This formalism is used to catalog the dynamic behavior of prominent examples of natural self-organizing systems. These here presented models represent generic, reusable templates for decentralized system adaptations that serve as analysis templates for application designs. A tailored programming model allows to supplement these templates in agent-based software applications with minimal intervention in the agent models.	12-hour clock;agent-based model;behavioral modeling;computation;computational problem;decentralised system;distributed computing;exemplification;hoc (programming language);information system;lars bak (computer programmer);organizing (structure);programming model;self-organization;semantics (computer science);software system	Jan Oliver Sudeikat	2010	ECEASST	10.14279/tuj.eceasst.27.386	simulation;systems modeling;computer science;artificial intelligence;management science	SE	-40.08439608369581	19.81459424709024	120321
b03d8b240b6ded2cd97d08fc020b4e286c1ca57b	a verification method for web service composition based on discrete event system modeling and simulation	ws cdl;a verification method for web service composition based on discrete event system modeling and simulation;wsbpel;modeling and simulation;wsdl;articulo;soa;web service;web service composition;discrete event system;devs;business process;dynamic properties	To achieve a new web service functionality based on already existing web services, we need to describe a web service composition which consists of not only a set of interface collaborations among the web services but also a set of internal behaviors of the web services like a business process. But the description of a web service composition should be verified in terms of the correctness or time-related properties while representing internal and external behaviors which are written in xml-based standards, such as WSBPEL or WS-CDL. In this paper, a verification method is proposed which evaluates the choreography and the composition of the orchestrations for a web service composition. For that purpose, this paper provides a transformation method from orchestration descriptions and a choreography description to a set of formal state-based models. Moreover, we suggest analysis guidelines to evaluate the static and dynamic properties of the expecting web service composition through checking the simulation results.	business process;compiler description language;correctness (computer science);service composability principle;simulation;systems modeling;web service;xml	Seong Yong Lim;Jongmoon Baik;Ho-Jin Choi;Danhyung Lee	2010		10.1145/1878537.1878781	web service;web modeling;real-time computing;business process execution language;data web;web-based simulation;computer science;devs;ws-policy;service-oriented architecture;ws-addressing;modeling and simulation;database;business process;ws-i basic profile;law;world wide web;devices profile for web services;mashup	Web+IR	-45.748188079566745	18.66221899262586	120334
e3e0ea9babf46a4bb9738095f2067c9609a48815	a model-driven approach to graphical user interface runtime adaptation	user interface;modelo de transformacion;runtime model adaptation;model transformation;info eu repo semantics article;interfaz de usuario;lenguajes y sistemas informaticos;tiempo de ejecucion de adaptacion del modelo	Graphical user interfaces play a key role in human-computer interaction, as they link the system with its end-users, allowing information exchange and improving communication. Nowadays, users increasingly demand applications with adaptive interfaces that dynamically evolve in response to their specific needs. Thus, providing graphical user interfaces with runtime adaptation capabilities is becoming more and more an important issue. To address this problem, this paper proposes a component-based and model-driven engineering approach, illustrated by means of a detailed example.	complex adaptive system;component-based software engineering;graphical user interface;human–computer interaction;information exchange;model-driven architecture;model-driven engineering	Javier Criado;Cristina Vicente-Chicote;Nicolás Padilla;Luis Iribarne	2010			simulation;geography;world wide web;cartography	HCI	-46.72488546885758	22.561774380926863	120436
5af6867b36c83437cf79a4e2e6e59e5f3049f935	systemions: a model for open agents	software agent open agents modern computer system;software agent;software agents open systems;software agents;open systems software agents computer architecture physics data processing cognition control systems biological system modeling systems biology concurrent computing;open systems	The agent paradigm plays a central role in the modelling and the design of modern computer systems. Just like the systems -which they implement software agents have to be both controllable in their complexity and able to acquire new behaviours. This paper presents a model of open agent stemming from the systemic metaphor which has an architecture capable of integrating external behaviours into the agent, providing the entity with a physical opening on its environment.	computer;programming paradigm;software agent;stemming	Eric Sanchis	2004	13th IEEE International Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprises	10.1109/ENABL.2004.61	agent architecture;computing;computer science;artificial intelligence;software design;component-based software engineering;software development;software agent;software engineering;belief–desire–intention software model;multi-agent system;mobile agent;distributed computing;resource-oriented architecture;intelligent agent;software system;systems design	Robotics	-40.07698101700638	20.21951099312254	120497
fd5784afb06a03ce1c3123383f2d48fbeadee592	a framework for heterogeneous formal modeling and compositional verification of avionics systems	avionics;formal specification;formal model;component calculus;formal languages;compositional verification;aerospace electronics embedded system hardware calculus safety fault tolerant systems real time systems formal languages industrial relations;object oriented programming;embedded system;formal verification;formal specification avionics formal verification object oriented programming;fault tolerant systems;calculus;safety;aerospace electronics;industrial relations;embedded system specification;system analysis;system development;system analysis formal modeling compositional verification avionics systems embedded system specification component calculus system development;avionics systems;composition operator;formal modeling;hardware;real time systems	This paper presents a component oriented framework dedicated to the specification of embedded systems in the aeronautics domain. A component is an entity with three internal layers (hardware, operating functions and applicative functions) together with a collection of models in different domain-oriented views. A composition operation allows the expression of composition scenarios, yielding a component calculus for representing composite systems. An institutional framework supports this component calculus, allowing the expression of coherence criteria between heterogeneous views. This framework can be seen as a formal documentation of a system development and analysis, supporting heterogeneous modeling and compositional verification. The approach is illustrated on a non trivial case study.	applicative programming language;avionics;complex systems;computer hardware;dhrystone;diagram;documentation;embedded system;formal methods;lustre;operational semantics;programming paradigm;refinement (computing);synthetic intelligence;systems modeling;theory;type signature;uppaal	Yamine Aït Ameur;Rémi Delmas;Virginie Wiels	2004	Proceedings. Second ACM and IEEE International Conference on Formal Methods and Models for Co-Design, 2004. MEMOCODE '04.	10.1109/MEMCOD.2004.1459858	avionics;formal language;real-time computing;formal verification;computer science;composition operator;formal specification;system analysis;industrial relations;programming language;object-oriented programming	Embedded	-40.80158677897817	31.53680286891032	120635
14429078c56404ad24b0954f1686cb2df6157f59	agent protocols for social computation		Despite the fact that social computation systems involve interaction mechanisms that closely resemble well-known models of agent coordination, current applications in this area make little or no use of the techniques the agent-based systems literature has to offer. In order to bridge this gap, this paper proposes a data-driven method for defining and deploying agent interaction protocols that is entirely based on using the standard architecture of the World Wide Web. This obviates the need of bespoke message passing mechanisms and agent platforms, thereby facilitating the use of agent coordination principles in standard Web-based applications. We describe a prototypical implementation of the architecture and experimental results that prove it can deliver the scalability and robustness required of modern social computation applications while maintaining the expressiveness and versatility of agent interaction protocols.	agent-based model;bespoke;bridging (networking);computation;experiment;global serializability;interaction;linkage (software);message passing;overhead (computing);scalability;server (computing);software deployment;world wide web	Michael Rovatsos;Dimitrios I. Diochnos;Matei Craciun	2015		10.1007/978-3-319-24804-2_7	distributed computing	AI	-40.000765924978325	21.211014148323947	120820
8aadf45771e9ef30bc82038164332b45328a912c	a three-phase framework for elicitation of infrastructure requirements	infrastructure requirements;critical infrastructures;systems engineering;network analysis planning;requirements elicitation;understanding;environment nature;interdependencies;systems analysis;requirement observer;insufficient requirements;complex systems;traditional system engineering;requirement nature;framework;infrastructure;tse;evaluation and assessment	Many of the current traditional system engineering (TSE) approaches for elicitation of requirements are insufficient when deployed in complex situations. TSE approach to requirement elicitation is based on assumption of stable environmental conditions. However, the elicitation of requirements for complex systems (i.e., interdependent critical infrastructures) requires innovative approaches that should go beyond technical aspects of a situation. Complex situations arise when multiple complex infrastructures interdependently interact to provide goods and services for public health and safety. The elicitation of requirements for such a system must consider the nature of system of interest, its environment and system observer. On this backdrop, this paper reviews complexity associated with attained requirements for complex infrastructures, failures and provides an overview of a proposed high-level framework for infrastructure requirement elicitation.	backdrop cms;complex systems;complexity;high- and low-level;interdependence;requirement;requirements elicitation;system analysis;system of systems;system requirements;systems engineering	Polinpapilinho F. Katina;Ra'ed M. Jaradat	2012	IJCIS	10.1504/IJCIS.2012.049032	reliability engineering;systems analysis;complex systems;requirements management;interdependence;expert elicitation;computer science;systems engineering;engineering;software framework;requirements elicitation;transport engineering	SE	-44.510153096722284	21.83620928982214	120894
700b0e3a3dbe92f117a792a127e66ba015891a17	a design rule language for aspect-oriented programming	design rules;aspect oriented programming;modularity	Aspect-Oriented Programming is known as a technique for modularizing crosscutting concerns. However, constructs aimed to support crosscutting modularity might actually break class modularity. This can be mitigated by using adequate Design Rules between classes and aspects. We present a language that supports most of the Design Rules found in AO Systems, making easy to express and verify them automatically. We discuss how our language improves crosscutting modularity without breaking class modularity. Also, we give some details about the language semantics expressed in Alloy.	agile software development;alloy (specification language);ambient occlusion;artifact (software development);aspect-oriented programming;aspectj;attribute grammar;compiler;cross-cutting concern;modularity of mind;semantics (computer science);software maintenance;type system;verification and validation	Alberto Costa Neto;Rodrigo Bonifácio;Márcio Ribeiro;Carlos Eduardo Pontual;Paulo Borba;Fernando Castor Filho	2013	Journal of Systems and Software	10.1016/j.jss.2013.03.104	aspect-oriented programming;computer science;systems engineering;modularity;programming language;algorithm	PL	-46.08242575960034	27.04739689053397	120998
f8263c68f32fc991df74fc37c48be75a6b965694	process algebras as support for sustainable systems of services	critical system;distributed information system;datavetenskap datalogi;computer science;process algebra;concurrent process	Process algebras are indispensable tools in modeling concurrent processes in theoretical computer science. We propose a novel use of process algebra as a back-bone in designing and maintaining complex open distributed information systems. Our π-calculus approach allows us to create and maintain service based mission oriented tasks with intended behaviors and with support for observing and maintaining mission critical systemic criteria.	bridging (networking);complex systems;home page;information system;internet backbone;metaphysical naturalism;mission critical;process calculus;semantics (computer science);theoretical computer science;π-calculus	Rune Gustavsson;Martin Fredriksson	2005	Applicable Algebra in Engineering, Communication and Computing	10.1007/s00200-005-0175-y	process calculus	DB	-39.60679087205079	28.762654811475816	121079
3743de84be90e2cb50a2d7cbcf04d76ee10bbd9f	rational verification: from model checking to equilibrium checking		Rational verification is concerned with establishing whether a given temporal logic formula φ is satisfied in some or all equilibrium computations of a multi-agent system – that is, whether the system will exhibit the behaviour φ under the assumption that agents within the system act rationally in pursuit of their preferences. After motivating and introducing the framework of rational verification, we present formal models through which rational verification can be studied, and survey the complexity of key decision problems. We give an overview of a prototype software tool for rational verification, and conclude with a discussion and related work.	computation;decision problem;model checking;multi-agent system;programming tool;prototype;temporal logic;verification and validation	Michael Wooldridge;Julian Gutierrez;Paul Harrenstein;Enrico Marchioni;Giuseppe Perelli;Alexis Toumi	2016			verification and validation of computer simulation models;discrete mathematics;simulation;mathematics;runtime verification;algorithm;functional verification	AI	-36.463686914251376	24.27266304968124	121102
22dcb23a2e2d9336d53da9452c9ee8ed3d471705	a scenario-based approach to hierarchical state machine design	distributed processing real time systems finite state machines;distributed processing;scenario models;state machine;finite state machines;patters;behavior integration patterns scenario based approach hierarchical state machine design real time system development system behavior interacting components finite state machines;hierarchical state machines;real time systems concurrent computing aerospace electronics process design software design user interfaces displays printers printing;finite state machine;real time systems	"""One of the most crucial and complicated phases of realtime system development lies in the transition from system behavior (generally specified using scenario models) to the behavior of interacting components (typically captured by means of communicating hierarchical finite state machines). It is commonly accepted that a systematic approach is required for this transition. In this paper, we overview such an approach, which we root in a hierarchy of """"behavior integration patterns"""" we have elaborated. The proposed patterns guide the structuring of a component’s behavior, and help in integrating the behavior associated with new scenarios into the existing hierarchical finite state machine of a component. One of these patterns is discussed at length here."""	design pattern;finite-state machine;interaction;real-time computing;uml state machine	Francis Bordeleau;Jean-Pierre Corriveau;Bran Selic	2000		10.1109/ISORC.2000.839514	embedded system;richards controller;real-time computing;simulation;computer science;distributed computing;finite-state machine;virtual finite-state machine;abstract state machines	SE	-39.47658939138057	30.938749240883507	121162
c7d40baf7ca37bd443f28650486d6cb3debc1834	engineering mobility in large multi agent systems: a case study in urban traffic management	zona urbana;movilidad;multiagent system;systeme grande taille;multi agent system;mobility;road traffic;gestion trafic;trafic urbain;zone urbaine;software systems;large scale system;urban traffic;mobilite;ingenieria logiciel;traffic management;software engineering;trafico urbano;large scale;trafic routier;force field;genie logiciel;gestion trafico;motion coordination;autoorganizacion;urban area;self organization;coordinacion;trafico carretera;escala grande;sistema multiagente;autoorganisation;sistema gran escala;systeme multiagent;coordination;echelle grande	The complexity raised in modern software systems seems to be no longer affordable in terms of the abstractions and methodologies promoted by traditional approaches to computer science and software engineering and radically new approaches are required. This paper focuses on the problem of engineering the motion coordination of a large-scale multi-agent system, and proposes an approach that takes inspiration from the laws of physics. Our idea is to have the movements of agents driven by force fields, generated by the agents themselves and propagated via some infrastructure or by the agents in an ad-hoc way. A globally coordinated and self-organized behavior in the agent’s movements can then emerge due to the interrelated effects of agents following the shape of the fields and dynamic fields re-shaping. The approach is presented and its effectiveness described with regard to a concrete case study in the area of urban traffic management.	computation;computer science;data structure;force field (chemistry);hoc (programming language);middleware;mobile computing;multi-agent system;noise shaping;personal digital assistant;pervasive informatics;self-organization;software engineering;software system;throughput	Marco Mamei;Michael Mahan	2002		10.1007/3-540-35828-5_7	active traffic management;self-organization;simulation;computer science;artificial intelligence;force field;multi-agent system;mobile computing;software system	AI	-39.32056521791296	23.73821114435847	121172
038d38289cc6267d9ab07b5b699f180d0fbc1b81	a scalable formal method for design and automatic checking of user interfaces	human computer interaction;formal specification;user interface;software engineering;automatic generation;formal method;formal verification;model checking;design and implementation;graphic user interface;human computer interaction hci;design verification;gui design;applications of model checking	The paper addresses the formal specification, design and implementation of the behavioral component of graphical user interfaces. Dialogs are specified by means of modular, communicating grammars called VEG (Visual Event Grammars), which extend traditional BNF grammars to make the modeling of dialogs more convenient. A VEG specification is independent of the actual layout of the GUI, but it can be easily integrated with various layout design toolkits. The specification may be verified with the model checker Spin, in order to test consistency and correctness, to detect deadlocks and unreachable states, and also to generate test cases for validation purposes. Efficient code is automatically generated by the VEG toolkit, based on compiler technology. Realistic applications have been specified, verified and implemented, like a Notepad-style editor, a graph construction library and a large real application to medical software. The complete VEG toolkit is going to be available soon as free software.	beta normal form;compiler;correctness (computer science);deadlock;estimation of signal parameters via rotational invariance techniques;formal methods;formal specification;graphical user interface;ilog;ian sommerville (technician);list of toolkits;michel hénon;model checking;modular programming;spin;scalability;test case;unreachable memory	Jean Berstel;Stefano Crespi-Reghizzi;Gilles Roussel;Pierluigi San Pietro	2001	ACM Trans. Softw. Eng. Methodol.	10.1145/1061254.1061256	model checking;formal methods;formal verification;computer science;theoretical computer science;software engineering;formal specification;graphical user interface;database;programming language;user interface	SE	-47.06610608791333	29.20537384712173	121381
7cb3db30a219b81aa9102e8462ca07e7c2ee635e	modeling concurrent systems: reconfigurable nets	petri nets;graph rewriting;dynamic changes.;concurrent systems;structural dynamics;petri net	The aim of this work is the modeling and verification of concurrent systems subject to dynamic changes using extensions of Petri nets. We introduce the reconfigurable nets. The expressiveness of reconfigurable nets and Petri nets is equivalent, but with reconfigurable nets we can model easily and directly systems that change its structure dynamically. The change of configuration amounts to the modification of the flow relations of the places in the domain of the involved rule according to the rule and independently of the context in which this rewriting applies.	concurrency (computer science);petri net;rewriting	Eric Badouel;Marisa Llorens;Javier Oliver	2003			computer science;petri net;distributed computing;graph rewriting;stochastic petri net	SE	-38.0036785351728	30.077440634553806	121470
320f5dcd5c0f6b3076b686c3ba5d9d37e85a1792	evolution analysis of modularity-based java system structure	modularity;module partition;system structure evolution	In order to study the modularity of system structure and analyze the law of system architecture evolution, we summarised three typical definitions about system modularity from different perspectives in this paper. Then we adopted the quantitative calculation method, established three optimization models, got some methods of module partition and evaluated and analyzed the effects of the different divisions. Finally, we used the Java class diagram (JDK) as an example, analyzed the modular structures of different JDK versions, interpreted the results, drew patterns and trends in the evolution of each version.	java	Hongmin Liu;Tieju Ma	2013		10.1007/978-3-642-39787-5_29	computer science;artificial intelligence;algorithm	SE	-43.66576032884623	23.681540870121605	121489
20bb9a787b231724469286595b69f5bb2c61e46f	perts: an environment for specification and verification of reactive systems: [reliability engineering and system safety, 71(3), 2001, 299-310]			reliability engineering;system safety	A. K. Bhattacharjee;S. D. Dhodapkar;R. K. Shyamasundar	2001	Rel. Eng. & Sys. Safety	10.1016/S0951-8320(01)00021-7	reliability engineering;systems engineering;software engineering	SE	-46.928848920849425	32.12710649706102	121582
686836cb94c42563dd4b29ca9b77b53a2acd1b33	the integrated cwb-nc/pioatool for functional verification and performance analysis of concurrent systems	functional verification;concurrent systems;performance analysis	"""This paper reports on an eeort to integrate two veriica-tion tools, the Concurrency Workbench of the New Century (CWB-NC) and PIOATool. Our aim is to build a single tool that combines the \functional"""" analysis capabilities of the CWB-NC with the compo-sitional performance-analysis features of PIOATool. We discuss some of the issues involved in the integration, highlighting a particular integration paradigm in which one tool becomes a subshell of the other."""	concurrency (computer science);demoscene compo;electron shell;nc (complexity);profiling (computer programming);programming paradigm;workbench	Dezhuang Zhang;Rance Cleaveland;Eugene W. Stark	2003		10.1007/3-540-36577-X_31	real-time computing;computer science;database;high-level verification;functional verification	Logic	-36.50950502231267	32.05296863067506	121643
dcbdaa0c7966292c6b011ee424094e4a57f6efa6	conceptual level versus logical level user-database interaction	logical level user-database interaction;conceptual level	User-database interaction can be classified into various abstraction levels. The two higher levels are the conceptual level and the logical level. On the conceptual level, the user talks of things in his world, for example, in terms of entities and relationships. On the logical level, the user talks of things in the database system, for example, in terms of relations and join operations. The user world is something that the user is expected to know, but the data in the database system is something new to the user. Thus, the conceptual level is closer to the user. Therefore, we hypothesized that the conceptual level interaction will be easier for the user. This was tested with the entity-relationship (ER) model for the conceptual level model and the relational model for the logical level model. The results showed that users of the conceptual level had 38% higher accuracy, 16% higher confidence, and took only 35% of the time taken by users of the logical level. The differences were statistically significant with p values better than 0.003. From the user's perspective, the huge differences make it worthwhile to consider the ER model in place of the relational model.	database;entity;entity–relationship model;erdős–rényi model;join (sql);relational model	Hock Chuan Chan;Kwok Kee Wei;Keng Siau	1991			knowledge management;relational model;database;entity–relationship model;computer science;abstraction	DB	-36.99162682680444	18.52958180453914	121656
d6137e0d4629f98e2ff4510e1c78572f9e624dee	crest - a continuous, reactive systems dsl		The advance of cyber-physical systems in everyday life requires powerful modeling capabilities. Existing formalisms often have severe limitations and require complicated notations. In this paper we introduce CREST, a domain-specific language for modeling entity behavior and resource transfers in CPS. CREST aims to support CPS architects through clarity, comprehensiveness and analyzability.	automata theory;automatic control;cyber-physical system;digital subscriber line;discretization;domain-specific language;entity;input/output;rewriting;simulation	Stefan Klikovits;Alban Linard;Didier Buchs	2017			real-time computing;digital subscriber line;crest;reactive system;computer science	PL	-45.70097521970021	25.11270151661949	121683
d5e38129b41ad3fb5a6510922fd838dc6ec7ee5b	vers une approche formelle pour la validation des protocoles d'interaction en systèmes multi-agents	modelizacion;lenguaje natural;multiagent system;formal specification;validacion;lenguaje uml;generic models;metodo formal;langage naturel;methode formelle;pertinencia;langage modelisation unifie;intelligence artificielle;formal method;specification formelle;modelisation;especificacion formal;agents;formal verification;natural language;unified modelling language;pertinence;formally checking;artificial intelligence;verification formelle;validation;inteligencia artificial;relevance;information system;sistema multiagente;modeling;systeme information;interaction protocols;roles;systeme multiagent;sistema informacion	Research works interested by multi-agent systems have been essentially focused on how to define interaction protocoles in order to manage inter-agent communication. However these agent interaction protocols have often been described in informal ways (using natural language) or in semi-formal ways (by diagrams). Hence, they lack sound theoretical bases that would prove they are correct. Thus, it seems important to clearly define a design methodology which allows to specify and check these system's interaction protocols. In this context, formal methods, such as B, provide a useful contribution. In our investigation, we propose to bridge the gap between a semi-formal modeling in AUML and its formal counterpart in B. Then, we prove how well our approach performs by inserting into the resulting formal specification a number of formal elementary properties such as message coherence, protocols and roles relevance, etc.	linear algebra	Hind Fadil;Jean-Luc Koning	2008	Ingénierie des Systèmes d'Information	10.3166/isi.13.2.33-52	unified modeling language;formal methods;systems modeling;relevance;formal verification;computer science;artificial intelligence;software agent;role;formal specification;natural language;information system;algorithm	Crypto	-39.94641378339013	24.95980856594432	121690
70bcee5345100e93f6383cab3f019e005309de0a	towards the integration of the agent-oriented modeling diversity with a powertype-based language		Multi-agent Systems (MASs) are one of the main fields of distributed systems. MASs are based on autonomous entities that cooperate obtaining emergent behaviors, and can be useful for integrating open systems. However, the great diversity of agent-oriented modeling languages (AOMLs) hinders the understanding and interchange of MAS models. Most MAS concepts are shared among the AOMLs. However, these concepts have certain peculiarities in each AOML, such as the expected behavior and concrete syntax. This paper presents a metamodeling solution for the integration of the AOML diversity that uses the powertype pattern. In this pattern, the clabjects represent concept subtypes and are instantiated in models. MAS designers can change the clabject properties to indicate the peculiarities of each concept subtype, depending on the particular needs. Each designer can understand models of other experts by consulting the peculiarities of concepts in models. This solution is the Inter-methodology AOML, which is supported with a graphical modeling tool. This tool is created with a model-driven development approach. This work presents this AOML as a first step of a potential standardization process in the modeling of MASs. In addition, the Ingenias Development Kit tool, an existing agent-oriented software engineering tool, is adapted to export models to the presented AOML. The proposed Inter-methodology AOML is quantitatively compared with other AOMLs in nine different problem domains, and this comparison shows that the proposed Inter-methodology AOML can determine a higher proportion of concepts in these domains than other AOMLs. The presented AOML is also evaluated and validated with its mapping to FAML.		Iván García-Magariño	2014	Computer Standards & Interfaces	10.1016/j.csi.2014.02.002	simulation;computer science;artificial intelligence	DB	-42.84560882758592	22.767104568384042	122082
446d84b7bcf37de6f4ebc5ce281b5f18b48e33c4	developing ode software in new computing environments	user interface;simulation language	The MATLAB ODE Suite is used as a case study for the development of ODE software in a new computing environment. Some current work on a multimedia project for teaching ODEs is used to illustrate another environment.	open dynamics engine	Lawrence F. Shampine;Mark W. Reichelt	1996			computational science;computer science;package development process;theoretical computer science;programming language	HPC	-34.96605380162396	26.50526796503956	122233
a36d5e88aa7eac3a8a212a441d5523e12837d00b	formal digital license language with ots/cafeobj method	rights expression language;algebraic specification;theorem proving formal digital license language observational transition system ots cafeobj method formal algebraic specification language digital rights management xml rights expression language deontic temporal logic dynamic state transition formal verification;deontic temporal logic;formal specification;temporal logic;formal digital license language;formal languages;copyright;digital rights management;theorem proving;formal verification;specification languages;transition systems;xml;ots cafeobj method;dynamic state transition;formal algebraic specification language;xml algebraic specification copyright formal languages formal verification specification languages temporal logic;digital right management;state transition;observational transition system;licenses permission logic mathematical model specification languages formal specifications formal verification automata information science information technology	This paper discusses how to model digital licenses as observational transition systems (OTSs) with CafeOBJ, a formal algebraic specification language. To extend the concept of licensing to cover various application domains of digital rights management, we first analyze the concepts of permission and obligation with some real-world examples which are not covered by current XML-based Rights Expression Languages (RELs), and then discuss how to formally specify licenses in terms of deontic and temporal logic with OTS/CafeOBJ method. Several important deontic and temporal modeling issues of licenses are also addressed for discussion. The proposed formal license language can be used not only for the formal specifications of licenses which capture both static observations and dynamic state transitions of the licenses, but also for the formal verification of licenses thanks to the executability and theorem proving facility of CafeOBJ.	algebraic specification;automated theorem proving;deontic logic;digital rights management;formal verification;specification language;temporal logic;xml	Jianwen Xiang;Dines Bjørner;Kokichi Futatsugi	2008	2008 IEEE/ACS International Conference on Computer Systems and Applications	10.1109/AICCSA.2008.4493599	formal language;xml;temporal logic;formal verification;computer science;theoretical computer science;formal specification;digital rights management;database;automated theorem proving;programming language;algorithm	EDA	-34.032542561220204	31.864276606210165	122265
465b463b2d7a5646a945652b1f2cbf5eff590c36	modeling of hybrid supervisory systems using uml and petri nets	supervisory system design hybrid supervisory systems modeling uml petri nets global system performance local controller switching configuration policies control architecture hierarchical levels dynamic behavior differential equation systems flexibility abstractions representation;performance index;differential equation;performance index specification languages petri nets control system synthesis control system analysis modelling differential equations;system performance;unified modeling language petri nets control systems mechatronics system performance differential equations three term control programmable control process design control theory;specification languages;control architecture;control system synthesis;system design;control system analysis;differential equations;petri nets;petri net;dynamic behavior	In this work, a new approach for the design of supervisory systems is introduced. It focuses on how supervisory systems can improve global system performance through the use of efficient local controller switching configuration policies. For this purpose, a modeling approach is developed that can represent the integration of different hierarchical levels of the control architecture and different dynamic behavior. UML, Petri nets and differential equation systems are merged in order to provide a framework with flexibility for representing the abstractions that emerge when considering supervisory system design.	petri net;systems design;unified modeling language	Paulo E. Miyagi;Emília Villani;Newton Maruyama	2001	ETFA 2001. 8th International Conference on Emerging Technologies and Factory Automation. Proceedings (Cat. No.01TH8597)	10.1109/ETFA.2001.997681	control engineering;real-time computing;computer science;control theory;computer performance;process architecture;petri net;differential equation;hybrid system	Robotics	-35.50162594688137	29.669232883220452	122273
37c3fbd263b2184eba05149ada70dc1d11937858	mapping a business process model to a semantic web service model		The purpose of OWL-S is to support effective automation of various Web services related activities including service discovery, composition, execution and monitoring. For our work, we are interested in automated Web services composition for a business process model. OWL-S process ontology provides a standard language for describing the composition of Web services. Thus we can treat composed Web services as a process model. However, since OWL-S is an XML based syntax description which is used for automatic agent processing, it is difficult to read and understand for human reader, especially for those with little XML knowledge but from a process modelling background, for example, businessmen. Therefore it can not be easily and directly used for process modelling tasks. The Fundamental Business Process Modelling Language (FBPML) is a diagram based business process modelling language which merges IDEF3, RAD and PSL. It has a precise operational semantics and describes business processes in a conventional logic. Because it is diagram based, it can be easily accepted by processes modelers who normally are familiar with such diagrams. However, its problem is that it does not provide a direct specification for Web services based agents. This paper bridges the gap via conceptual mapping between two different process modelling languages, FBPML and OWL-S.	business process;diagram;display resolution;idef3;modeling language;owl-s;operational semantics;process modeling;process ontology;rapid application development;semantic web service;service discovery;software deployment;web ontology language;xml	Li Guo;Yun-Heh Chen-Burger;David Stuart Robertson	2004	Proceedings. IEEE International Conference on Web Services, 2004.	10.1109/ICWS.2004.1314808	software engineering	SE	-47.1809729641969	18.395700224536288	122328
7c71273a5093c271fe6c590d8efd79ccf9c46937	a multidimensional environment implementation for enhancing agent interaction	programming language;interaction;simulation techniques;environment;complex systems;tools and environments	The environment, as a space shared between agents, is a key component of multiagent systems (MAS). Depending on systems, this space may integrate physical, communication or social dimensions. Each of them has its own process and rules to support agents’ interaction. For instance, in the physical dimension, the rules may be based on the agents’ location. The agents’ interaction is then contextualized, and the environment allows a multiagent control since it performs the interactions according to the state and rules of the MAS. The dimensions of the environment are generally connected either in an application-dependent ad-hoc way outside of the agents or within each agent. In order to ensure a multiagent control, the relations between dimensions must be explicit outside of the agents. Using these relations between the environment dimensions, the interaction becomes also multidimensional. In this paper, we propose to formalize rules and mechanisms to make this connection outside of the agents and in a generic way.	agent-based model;hoc (programming language);interaction;multi-agent system;social engineering (security)	Stéphane Galland;Flavien Balbo;Nicolas Gaud;Sebastian Rodriguez;Gauthier Picard;Olivier Boissier	2015			complex systems;interaction;simulation;computer science;distributed computing;natural environment	AI	-41.93897158115683	19.87334543491703	122414
011aa02b42ae6ca4089ae3fe7602214a51e40ded	rodin: an open toolset for modelling and reasoning in event-b	verification;machine abstraite;modelizacion;teoria demonstracion;lenguaje programacion;outil logiciel;software tool;event b theory;theorie preuve;event b;programming language;tool support;proof theory;tool developments;integrated modelling;teoria conjunto;metodo formal;maquina abstracta;methode formelle;abstraction;theorie ensemble;refinement;set theory;abstraccion;abstract machine;formal method;theorem proving;modelisation;refinement method;demonstration theoreme;langage programmation;methode raffinement;demostracion teorema;herramienta software;modeling;metodo afinamiento;qa76 computer software	Event-B is a formal method for system-level modelling and analysis. Key features of Event-B are the use of set theory as a modelling notation, the use of refinement to represent systems at different abstraction levels and the use of mathematical proof to verify consistency between refinement levels. In this article we present the Rodin modelling tool that seamlessly integrates modelling and proving. We outline how the Event-B language was designed to facilitate proof and how the tool has been designed to support changes to models while minimising the impact of changes on existing proofs. We outline the important features of the prover architecture and explain how well-definedness is treated. The tool is extensible and configurable so that it can be adapted more easily to different application domains and development methods.	application domain;as-easy-as;b-method;formal methods;integrated development environment;programming tool;refinement (computing);rodin tool;seamless3d;set theory	Jean-Raymond Abrial;Michael J. Butler;Stefan Hallerstede;Thai Son Hoang;Farhad Mehta;Laurent Voisin	2010	International Journal on Software Tools for Technology Transfer	10.1007/s10009-010-0145-y	verification;formal methods;systems modeling;computer science;proof theory;refinement;abstraction;abstract machine;automated theorem proving;programming language;algorithm;set theory	SE	-40.350257061033844	26.21087493301492	122425
db023fae127ade43ec9021067c121b3e812f172b	multi-agent system for hierarchical control with self-organising database	opc;continuous time;multi agent system;real time;multi agent control system;hierarchical control;discrete time;control system;process control;information system;pilot plant;real time self organising data base	The paper presents hierarchical and multi-agent control and information system with real-time update of self organising database as well as with negotiation capability for control events and decisions. A practical application is presented, that utilizes the OPC technology in the continuous-time part, and scripts using XML in the discrete-time part of the system for negotiation and cooperation in multi-agent environment. This feature is applied for the improvement of a non-conventional biotechnological process control in the pilot plant.	multi-agent system	Dariusz Choinski;Witold Nocon;Mieczyslaw Metzger	2007		10.1007/978-3-540-72830-6_68	discrete time and continuous time;ole for process control;real-time computing;simulation;computer science;networked control system;control system;process control;multi-agent system;hierarchical control system;information system	DB	-38.1294505311271	22.187069760081517	122715
110aa5be6610de5b6bf0e414254ff1a3817ded89	lifeworld analysis	common control structure;formal tool;encoding task state;different control structure;lifeworld analysis;toast system;partial set;thicker notion;different convention;specific example;environment interaction	We argue that the analysis of agent/environment interactions should be extended to include the conventions and invariants maintained by agents throughout their activity. We refer to this thicker notion of environment as a lifeworld and present a partial set of formal tools for describing structures of lifeworlds and the ways in which they computationally simplify activity. As one speci c example, we apply the tools to the analysis of the Toast system and show how versions of the system with very di erent control structures in fact implement a common control structure together with di erent conventions for encoding task state in the positions or states of objects in the environment.	control flow;interaction;invariant (computer science)	Philip E. Agre;Ian Horswill	1997	J. Artif. Intell. Res.	10.1613/jair.342	computer science;artificial intelligence;communication;social psychology	Logic	-36.936684327862615	19.575345412735164	122891
81b06330171062dda0416089792c587918fb3848	raffinement de modèles topologiques en b événementiel. des droites aux 2-g-cartes	developpement logiciel;modelizacion;topology;modele geometrique;event b;metodo formal;topologie;methode formelle;complex method;interpretacion abstracta;data refinement;topologia;formal method;2 g map;modelisation;refinement method;geometric modelling;metodo complex;desarrollo logicial;methode complex;software development;modele donnee;interpretation abstraite;methode raffinement;abstract interpretation;modeling;metodo afinamiento;geometrical model;data models;modelo geometrico	Geometric modellers allow us to design computer-generated images. They have become very complex, formal methods may help when developing them. Our experience shows it is difficult to prove the correctness of a geometric operation when we manipulate mathematic models data implemented in modellers. On the other hand, the proof becomes feasible if the specification is expressed with abstract data. In this case, we also have to refine these data. We illustrate this process on a simplified version of a classical operation. More precisely, by using event B and its refinement, we show we can transform a set of lines into a set of2-G-maps, where a 2-G-map is a topological model often implemented in modellers.		Jean-Marc Mota;Catherine Dubois	2007	Technique et Science Informatiques	10.3166/tsi.26.883-908	data modeling;formal methods;systems modeling;computer science;artificial intelligence;software development;algorithm	Logic	-40.7348728509551	26.18791447456593	122916
01fae89eb0a7aaa05edd9ce1c20bf50f42053dc7	unifying analysis tools with rosetta	system designer;rosetta system specification language;system designer rosetta system specification language analysis capability tool;analysis capability tool;specification language;systems analysis;specification languages;system design;systems analysis software tools specification languages;analytical models programming energy consumption specification languages computer languages algorithm design and analysis software engineering;software tools	The Rosetta system specification language will require a variety of analysis capabilities to assist system designers. The language's generality prohibits the development of a single analysis tool. It is proposed, instead, to leverage the existing analysis tools and create an analysis environment unified around the Rosetta language. A semi-automated tool, the Rosetta Nexus, will generated tool-specific analysis models and a correspondence with the original Rosetta specifications.	boolean satisfiability problem;component-based software engineering;extensibility;haskell;semiconductor industry;specification language	Nicolas Frisby	2008	2008 23rd IEEE/ACM International Conference on Automated Software Engineering	10.1109/ASE.2008.93	systems analysis;specification language;computer science;systems engineering;programming language;systems design	SE	-47.283191064524004	29.989806647335726	122972
4f6e7e71ee02b6a20ce9ac940177fa4be4219f0f	generating composite behavior of embedded software components based on uml behavioral model and process algebra	formal model;behavior modeling;specification language;mde;timing analysis;design;data flow;process algebra;embedded software;real time systems	This paper defines formally the composite behavior of two main embedded software components; application software and platform. The two typical embedded software components interact with one another continuously to achieve the purpose of system, but they have different computation characteristics; application software is oriented to data-flow for implementing software's functionalities, whereas the platform is oriented to control-ow for the control of software's executions. Hence, it is not easy to represent those capabilities in one behavioral model to analyze their composite behaviors. Thus, this paper presents a formal modeling framework, in which application software and platforms are defined in appropriate specification language suited to their own characteristics, and their behaviors in models are composed to capture their interactive and composite behaviors in their composite executions. In particular, we focus here on defining their composite behaviors in formal way.	behavioral modeling;component-based software engineering;computation;dataflow;embedded software;embedded system;process calculus;specification language;unified modeling language	Jin Hyun Kim;Jin-Young Choi;Inhye Kang;Insup Lee	2011	ACM SIGSOFT Software Engineering Notes	10.1145/1921532.1921562	embedded system;software visualization;design;software requirements specification;verification and validation;real-time computing;software sizing;embedded software;specification language;computer science;package development process;software design;software framework;component-based software engineering;software development;software design description;software construction;programming language;resource-oriented architecture;goal-driven software development process;software system	SE	-41.43965790585783	32.30614563046222	123056
2ae1ef7760f997e660e2a61f84818d928cac5fed	multisimulations: towards next generation integrated simulation environments	simulation integration;reflective middleware;metamodels;methodology	In this paper, we consider the challenge of designing a reflective middleware to integrate multiple autonomous simulation models into an integrated simulation environment (multiasimulation) wherein we can model and execute complex scenarios involving multiple simulators. One of the limitations of the simulators is that they are developed by domain experts who have an in-depth understanding of the phenomena being modeled and typically designed to be executed and evaluated independently. Therefore, the grand challenge is to facilitate the process of pulling all of independently created models together into an interoperating multisimulation model where decision makers can explore different alternatives and conduct low cost experiments. We aim to build such integrated simulation environments by creating a loosely coupled federation of pre-existing simulators. We evaluate our proposed methodology via a detailed case study from the emergency response domain by integrating three disparate pre-existing simulators – a fire simulator (CFAST), an evacuation simulator (Drillsim) and a communication simulator (LTEsim).	autonomous robot;compactflash;experiment;grand challenges;loose coupling;middleware;simulation	Leila Jalali;Sharad Mehrotra;Nalini Venkatasubramanian	2011		10.1007/978-3-642-24933-4_18	real-time computing;simulation;systems engineering;engineering	AI	-41.554280886613626	22.203745092678705	123279
9711bcb78dea6681d09bd17e1f19cddc87c5ca7c	the prominent role of probe data and big data in modern technology	industries;probes;big data;roads;safety;vehicles;vehicle dynamics	In today's society, the management of probe data and big data is becoming increasingly important with new technological advancements. This can be demonstrated in the ongoing development of automated driving systems and the dynamic map. The safety of these new systems depends on high quality data and a reliable shared platform. As the transition to artificial intelligence continues, it is the responsibility of humans to create a system that can effectively control information with minimal risks.	artificial intelligence;autonomous car;big data;display resolution	Hideki Isetani	2016	2016 IEEE 16th International Conference on Data Mining Workshops (ICDMW)	10.1109/ICDMW.2016.0116	vehicle dynamics;simulation;big data;computer science;data mining	DB	-34.29971098934155	19.572058751608967	123422
98dbe5f10ef2c8bdbf96573bbf5cda02ecd30cfb	a synthesis of evaluation criteria for software specifications and specification techniques	evaluation criteria;specification technique;software specification;descartes specification language	Several evaluation criteria exist in the literature for both specification and specification techniques. These evaluation criteria identify a list of desired properties in specifications and specification techniques for judging their goodness. This paper presents a detailed analysis of several specification and specification technique evaluation criteria. Detailed analysis of these criteria identified that there is a lack of consistency in the property definition among criteria. The implication of this lack of differentiation between the two concepts is that the criteria for both specification and specification techniques are intermingled. Since the concept of specification is different from specification technique, the criteria used for one might not be applicable for the other. For example, “completeness” and “consistency” are specification criteria. A specification can be complete and consistent regardless of the medium used to represent the specification, the process used in its construction, the degree/extent of tools and automation used, or whether it is formal or informal. However, there is meaning to denote that a technique can be used to produce “consistent” or “complete” specifications. Hence, for proper applicability of these criteria, this paper separates specification criteria from that of the specification technique criteria. This paper also presents a unified criteria terminology and uses a table to list each criterion property from various researchers mapped to the unified terminology. The paper also identifies and presents a mapping from technique criteria to the specification criteria that shows which technique criteria satisfies specification criteria. The applicability of the mapping is then demonstrated by applying the mapping to a specification language and its support environment.	common criteria;complete (complexity);specification language	Amir A. Khwaja;Joseph E. Urban	2002	International Journal of Software Engineering and Knowledge Engineering	10.1142/S0218194002001062	reliability engineering;software requirements specification;specification language;computer science;systems engineering;software engineering;system requirements specification;analysis effort method;formal specification;functional specification;programming language specification;language of temporal ordering specification;specification pattern	SE	-46.19662827335545	28.98659907106195	123522
f33846e1bbdd158f27dc12127b75a6e854feb6c6	a cloud resource management model for the creation and orchestration of social communities	chemical computing;context aware;social communities;resource management;cloud;qa75 electronic computers computer science;article;qa76 computer software	Managing resources, context and data in mobile clouds is a challenging task. Specific aspects of spontaneity, non-determinism and dynamic interaction share a metaphorical resemblance to chemistry, chemical reactions and solutions. In this paper, it is argued that by adopting a nature-inspired chemical computing model, a mobile cloud resource management model can be evolved to serve as the basis for novel service modelling and social computing in mobile clouds. To support the argument, a chemistry inspired computation model, Chemistry for Context Awareness (C2A), is extended with Higher Order Chemical Language (HOCL) and High Level Petri-net Graph (HLPNG) formalisms. A scenario and simulation based evaluation of the proposed model, focusing on two applications dynamic service composition and social communities identification, is also presented in this paper. The formal encoding of C2A validates its assumptions, enabling formal execution and analysis of context based interactions that are derived using C2A principles.		Ahsan Ikram;Ashiq Anjum;Nik Bessis	2015	Simulation Modelling Practice and Theory	10.1016/j.simpat.2014.05.003	simulation;cloud computing;computer science;knowledge management;artificial intelligence;resource management;theoretical computer science;operating system;machine learning	Web+IR	-43.32985304065668	19.68868782912077	123802
4dfbbce6293ee8ec2e1009aae7e78da34ebdadc1	on context-specific substitutability of web services	context aware services web services assembly logic computer science context modeling distributed computing application software;context information;composition;environment dependent substitution;substitution;labeled transition systems;web services formal verification;context specific substitutability;web service;web service composition;environment independent substitution;formal verification;model checking;web service substitution;web services;transition systems;model checking context specific substitutability web service substitution context information environment independent substitution environment dependent substitution;mu calculus	Web service substitution refers to the problem of identifying a service that can replace another service in the context of a composition with a specified functionality. Existing solutions to this problem rely on detecting the functional and behavioral equivalence of a particular service to be replaced and candidate services that could replace it. We introduce the notion of context-specific substitutability, where context refers to the overall functionality of the composition that is required to be maintained after replacement of its constituents. Using the context information, we investigate two variants of the substitution problem, namely environment-independent and environment- dependent, where environment refers to the constituents of a composition and show how the substitutability criteria can be relaxed within this model. We provide a logical formulation of the resulting criteria based on model checking techniques as well as prove the soundness and completeness of the proposed approach.	boolean satisfiability problem;correctness (computer science);message passing;modal μ-calculus;model checking;non-functional requirement;observational equivalence;programming paradigm;regular expression;run time (program lifecycle phase);sensor;service-oriented device architecture;simulation;turing completeness;web service	Jyotishman Pathak;Samik Basu;Vasant Honavar	2007	IEEE International Conference on Web Services (ICWS 2007)	10.1109/ICWS.2007.134	web service;computer science;database;distributed computing;law;world wide web	SE	-41.655630449264564	28.24103730888748	124072
1e2397ada55de5982ed3fabbba2112bab00c3bb0	object petri nets marking using uml	model verification;sequence diagrams;uml2;uml semantics;model validation;model checking;oom;object diagrams;object petri nets;object oriented modelling;state space explosion	UML semantics formalisation has aroused much interest these two last decades. Among the numerous proposed works many undertake the formalisation by translation into state-transition languages. The verification is afterwards performed by model-checking. However, one important issue raised by model checking is the state space explosion. The purpose of this paper will mainly address this issue. It is threefold. We first propose an approach to mark the derived formalisms starting from any time of the system lifecycle. The marking is drawn from the object and sequence diagrams. We secondly exploit the association ends modelled on the object diagram to retrieve the first action of each object behaviour. This contribution ensures a strong consistency when handling the object and sequence diagrams. We finally propose a method based on the association end formalisation in order to deal with the models validation. The whole of the solution is analysed by model checking.	item unique identification;petri net;unified modeling language	Thouraya Bouabana-Tebibel;Lila Méziani	2013	IJCAT	10.1504/IJCAT.2013.054349	sequence diagram;model checking;method;computer science;systems engineering;theoretical computer science;regression model validation;algorithm;statistics	Robotics	-43.83202495391803	28.223852943871865	124174
e7662e069edc67df72d290c0d1c40318156fe5ed	mate - a model analysis and transformation environment for matlab simulink		  In the automotive industry, the model driven development of software is generally based on the use of the tool MATLAB Simulink.  Huge catalogues with hundreds of modeling guidelines have already been developed to increase the quality of models and ensure  the safety and reliability of the generated code. In this paper, we present the MATLAB Simulink Analysis and Transformation  Environment (MATE), a tool using metamodeling techniques and visual graph transformations to automate the analysis and correction  of models according to these guidelines. The MATE approach is illustrated by a typical example, and compared to other classical  approaches for model analysis.    	mate;matlab;simulink	Elodie Legros;Wilhelm Schäfer;Andy Schürr;Ingo Stürmer	2007		10.1007/978-3-642-16277-0_14	computational science;simulation;computer science;machine learning	AI	-47.78976192804757	29.74319473615534	124350
bef358cf15fec6026113d924629b4dd02577dc58	lightweight symbolic verification of graph transformation systems with off-the-shelf hardware model checkers		We present a novel symbolic bounded model checking approach to test reachability properties of model-driven implementations of software. Given a concrete initial state of a software system, a type graph and, respectively, a set of graph transformations describing the system’s structure and, respectively, behavior, the reachability properties are expressed in terms of graph constraints. Without any user intervention, our approach exploits state-of-the-art model checking technologies successfully used in hardware industry. The efficiency of our approach is demonstrated in two case studies.	algorithm;anisotropic filtering;artifact (error);blu-ray;control table;dining philosophers problem;eclipse modeling framework;emoticon;expect;graph rewriting;metamodeling;model checking;model-driven architecture;model-driven engineering;performance evaluation;reachability;software system;table (database);the witness;xfig	Sebastian Gabmeyer;Martina Seidl	2016		10.1007/978-3-319-41135-4_6	computer science;theoretical computer science;symbolic trajectory evaluation;algorithm	SE	-43.86915038931425	31.35834253298587	124499
13cc5247f0a885884a09609e647ae4f9c4f918a2	concurrent and distributed model transformations based on linda		Recently Model-Driven Engineering (MDE) is becoming more and more popular as it is able to solve complex problems by exploiting the abstraction power of models. As models, metamodels and model transformations are the heart of MDE, they play a vital role. Nevertheless, existing transformation languages and accompanying tools cannot deal with large models such those used in the fields of astronomy, genetics, etc. The main problems are related to the storage of very large models, the unreasonable time needed to execute the transformation and the impossibility of transforming distributed or streaming models. We tackle this problem by means of incorporating the concurrent and distributed mechanisms that Linda (a mature coordination language for parallel processes) provides into model transformation approaches.	linda (coordination language);metamodeling;model transformation;model-driven engineering;model-driven integration;transformation language	Loli Burgueño	2013			impossibility;distributed element model;abstraction;theoretical computer science;model transformation;computer science	HPC	-43.99189127492949	24.266846384577107	124644
3d068f144ac77b3fa77f454c2d619dcd9c9a993c	hardware trojans classification for gate-level netlists based on machine learning	trojan horses feature extraction hardware logic gates support vector machines integrated circuits benchmark testing;support vector machines;static detection hardware trojan gate level netlist machine learning support vector machine svm;support vector machine svm;trojan horses;static detection;gate level netlist;logic gates;machine learning;feature extraction;support vector machines invasive software learning artificial intelligence pattern classification;trust hub benchmarks hardware trojans classification gate level netlists machine learning malicious third party vendors ic products hardware trojan infected nets support vector machine five dimensional vector learned svm classifier svm based hardware trojan classification;hardware trojan;integrated circuits;benchmark testing;hardware	Recently, we face a serious risk that malicious third-party vendors can very easily insert hardware Trojans into their IC products but it is very difficult to analyze huge and complex ICs. In this paper, we propose a hardware-Trojan classification method to identify hardware-Trojan infected nets (or Trojan nets) using a support vector machine (SVM). Firstly, we extract the five hardware-Trojan features in each net in a netlist. Secondly, since we cannot effectively give the simple and fixed threshold values to them to detect hardware Trojans, we represent them to be a five-dimensional vector and learn them by using SVM. Finally, we can successfully classify a set of all the nets in an unknown netlist into Trojan ones and normal ones based on the learned SVM classifier. We have applied our SVM-based hardware-Trojan classification method to Trust-HUB benchmarks and the results demonstrate that our method can much increase the true positive rate compared to the existing state-of-the-art results in most of the cases. In some cases, our method can achieve the true positive rate of 100%, which shows that all the Trojan nets in a netlist are completely detected by our method.	hardware trojan;machine learning;netlist;sensitivity and specificity;support vector machine;trojan horse (computing)	Kento Hasegawa;Masaru Oya;Masao Yanagisawa;Nozomu Togawa	2016	2016 IEEE 22nd International Symposium on On-Line Testing and Robust System Design (IOLTS)	10.1109/IOLTS.2016.7604700	support vector machine;benchmark;logic gate;feature extraction;computer science;engineering;theoretical computer science;machine learning;data mining	EDA	-35.063897935676195	23.11763200454219	124766
e5e3e87a08f4b988b8ead80c672289c6a0a15f01	performance analysis of computing servers - a case study exploiting a new gspn semantics	generalized stochastic petri nets;computing services;markov automata;model based analysis	"""Generalised Stochastic Petri Nets (GSPNs) are a widely used modeling formalism in the field of performance and dependability analysis. Their semantics and analysis is restricted to """"well-defined"""", i.e., confusion-free, nets. Recently, a new GSPN semantics has been defined that covers confused nets and for confusion-free nets is equivalent to the existing GSPN semantics. The key is the usage of a non-deterministic extension of CTMCs. A simple GSPN semantics results, but the question remains what kind of quantitative properties can be obtained from such expressive models. To that end, this paper studies several performance aspects of a GSPN that models a server system providing computing services so as to host the applications of diverse customers (""""infrastructure as a service""""). Employing this model with different parameter settings, we perform various analyses using the MaMa tool chain that supports the new GSPN semantics. We analyse the sensitivity of the GSPN model w.r.t. its major parameters processing failure and machine suspension probabilities by exploiting the native support of non-determinism. The case study shows that a wide range of performance metrics can still be obtained using the new semantics, albeit at the price of requiring more resources (in particular, computation time)."""	profiling (computer programming)	Joost-Pieter Katoen;Thomas Noll;Thomas Santen;Dirk Seifert;Hao Wu	2014		10.1007/978-3-319-05359-2_5	real-time computing;computer science;database;distributed computing	Logic	-36.39020110171756	31.05584319919538	124768
fcf69ae170244a48b47c2a27e6bce13a98a6cd04	distributed transparency in endogenous environments: the jacamo case		This paper deals with distribution aspects of endogenous environments, in this case, distribution refers to the deployment in several machines across a network. A recognized challenge is the achievement of distributed transparency, a mechanism that allows the agent working in a distributed environment to maintain the same level of abstraction as in local contexts. In this way, agents do not have to deal with details about network connections, which hinders their abstraction level, and the way they work in comparison with locally focused environments, reducing flexibility. This work proposes a model based on hierarchical workspaces, creating a distinctive layer for environment distribution, which the agents do not manage directly but can exploit as part of infrastructure services. The proposal is in the context of JaCaMo, the Multi-Agent Programming framework that combines the Jason, CArtAgO, and MOISE technologies, specially focusing on CArtAgO, which provides the means to program and organize the environment in terms of workspaces.		Xavier Limón;Alejandro Guerra-Hernández;Alessandro Ricci	2017		10.1007/978-3-319-91899-0_7	software deployment;workspace;software framework;abstraction layer;transparency (graphic);exploit;computer science;distributed computing;distributed computing environment;abstraction	Robotics	-41.58310798107541	20.3323137837601	124805
f03f02c6624ba44ca0362c33771d662250d0b4bb	model checking hybrid multiagent systems for the robocup	multiagent system;continuous variable;multi robot system;model checking;levels of abstraction;hybrid automata;state explosion;real time systems	This paper shows how multiagent systems can be modeled by a combination of UML statecharts and hybrid automata. This allows formal system specification on different levels of abstraction on the one hand, and expressing real-time system behavior with continuous variables on the other hand. It is shown how multi-robot systems can be modeled by hybrid and hierarchical state machines and how model checking techniques for hybrid automata can be applied. An enhanced synchronization concept is introduced that allows synchronization taking time and avoids state explosion to a certain extent.	agent-based model;model checking;multi-agent system	Ulrich Furbach;Jan Murray;Falk Schmidsberger;Frieder Stolzenburg	2007		10.1007/978-3-540-68847-1_24	model checking;real-time computing;simulation;computer science;distributed computing;abstraction model checking	AI	-38.92729132845587	29.837232863424024	124840
039852caf45047f97164b8ce3a907ce24cabe9d8	a data mining classification approach for behavioral malware detection		Data mining techniques have numerous applications in malware detection. Classification method is one of the most popular data mining techniques. In this paperwe present a datamining classification approach to detectmalware behavior.Weproposed different classification methods in order to detect malware based on the feature and behavior of each malware. A dynamic analysis method has been presented for identifying themalware features. A suggested programhas been presented for converting amalware behavior executive history XML file to a suitable WEKA tool input. To illustrate the performance efficiency as well as training data and test, we apply the proposed approaches to a real case study data set using WEKA tool. The evaluation results demonstrated the availability of the proposed data mining approach. Also our proposed data mining approach is more efficient for detecting malware and behavioral classification of malware can be useful to detect malware in a behavioral antivirus.	algorithm;antivirus software;data mining;malware;sensor;statistical classification;weka;xml	Monire Norouzi;Alireza Souri;Majid Samad SamadZamini	2016	Journal Comp. Netw. and Communic.	10.1155/2016/8069672	computer science;data mining;world wide web;computer security	ML	-35.603005279088606	23.004888672669356	124852
45aa5282ded0702284ad0d23eff85b7830dd4b80	business-oriented management of web services	tecnologia electronica telecomunicaciones;computacion informatica;grupo de excelencia;web service;ciencias basicas y experimentales;tecnologias	Using tools and abstractions for monitoring and controlling Web services.	web service	Fabio Casati;Eric Y. Shan;Umeshwar Dayal;Ming-Chien Shan	2003	Commun. ACM	10.1145/944217.944238	web service;law	Networks	-46.313101483001766	20.249408366501598	125078
9f298930a1615df5e6b75b4331843e6585c27fab	using formal models to cross check an implementation	formal methods;requirements;interactive systems;traces	Interactive systems are developed according to requirements, which may be, for instance, documentation, prototypes, diagrams, etc. The informal nature of system requirements may be a source of problems: it may be the case that a system does not implement the requirements as expected, thus, a way to validate whether an implementation follows the requirements is needed. We propose a novel approach to validating a system using formal models of the system. In this approach, a set of traces generated from the execution of the real interactive system is searched over the state space of the formal model. The scalability of the approach is demonstrated by an application to an industrial system in the nuclear plant domain. The combination of trace analysis and formal methods provides feedback that can bring improvements to both the real interactive system and the formal model.	co-simulation;design rationale;diagram;documentation;formal language;formal methods;interactivity;mathematical model;mutation testing;non-deterministic turing machine;parser;reactor (software);real life;requirement;scalability;simulation;software prototyping;state space;system requirements;test case;tracing (software);verification and validation	Raquel Oliveira;Sophie Dupuy-Chessa;Gaëlle Calvary;Daniele Dadolle	2016		10.1145/2933242.2933257	real-time computing;simulation;computer science;systems engineering;formal specification;effect system	SE	-44.08696564689264	31.489584416641048	125329
f8a7f7fb0abdab0f8aa77446be4e9b39d7f60526	bike sharing as a key smart city service: state of the art and future developments		Bike sharing has outgrown its first failures in the '60s and '70s and has become ubiquitous around the world. This rapid growth is strongly intertwined with the rise of Smart Cities: the use of connected bikes makes the service more practical for users, avoids thefts and provides a large amount of data for system planners. Over the past few years, research on bike sharing has bloomed, providing several innovative solutions to improve the service and to encourage citizens to use environmentally friendly modes of transportation, reducing both traffic and commuting times. In this work, we present the most promising developments towards a tighter integration between Smart City data and techniques and the operation and planning of bike-sharing systems, focusing on two model use-cases: New York City's CitiBike service, a large system with hundreds of stations, and Padova's GoodBike system, which has just 28 stations.	smart city	Federico Chiariotti;Chiara Pielli;Angelo Cenedese;Andrea Zanella;Michele Zorzi	2018	2018 7th International Conference on Modern Circuits and Systems Technologies (MOCAST)	10.1109/MOCAST.2018.8376628	smart city;environmentally friendly;geographic information system;data modeling;instrumentation;business;transport engineering	HCI	-33.76125061561319	19.3223216565328	125478
8c92dc1acea38c26d98b11e001e4a40547d5888c	coupling crowdsourcing, earth observations, and e-gnss in a novel flood emergency service in the cloud	satellite navigation airborne radar cloud computing geophysical techniques geophysics computing;emergency services floods crowdsourcing cloud computing;media;global positioning system;floods;economics;floods emergency services cloud computing global positioning system media economics real time systems;cloud computing;social networks coupling crowdsourcing earth observations e gnss novel flood emergency service cloud space based systems harm humankind worldwide economic losses copernicus emergency management service floodis state of the art cloud computing technologies;emergency services;real time systems	Despite the growing development of space-based systems aimed at monitoring and studying natural hazards, floods continue to harm humankind worldwide, causing enormous human and economic losses. In view of improving the existing Copernicus Emergency Management Service (EMS) we propose FLOODIS: a novel Copernicus downstream service that exploits existing space assets together with crowdsourcing and state-of-the-art cloud computing technologies in order to provide a fast, flexible and scalable flood emergency service. After collecting the requirements from end-users, we define the FLOODIS architecture and implement a FLOODIS prototype. We also study the challenges related to consider real-time data coming from modern social networks like Twitter. Finally, we draft a business case for FLOODIS by analyzing the potential market along with the estimated social benefits brought by the proposed service.	cloud computing;crowdsourcing;downstream (software development);prototype;real-time clock;real-time data;requirement;satellite navigation;scalability;social network	Claudio Rossi;Wolfgang Stemberger;Conrad Bielski;Gunter Zeug;Nina Costa;Davide Poletto;Emiliano Spaltro;Fabrizio Dominici	2015	2015 IEEE International Geoscience and Remote Sensing Symposium (IGARSS)	10.1109/IGARSS.2015.7326371	meteorology;simulation;media;global positioning system;cloud computing;computer science;computer security;remote sensing	Mobile	-34.30796283873544	19.529317812027497	125670
16ed95f6f3fa9d3cabd8ff3893969a4a3bc782d1	compositional specification of behavioral semantics	dsml designer;compositional specification;domain-specific modeling languages;semantic unit composition;semantic anchoring framework;abstract state machine;semantic unit;dsml semantics;reference semantics;semantic anchoring;behavioral semantics;abstract syntax;metamodeling;embedded software;model based design;embedded systems;nanotechnology;intersymbol interference;software systems;concrete;automata;carbon nanotube;cntfet;system analysis and design;application software;unified modeling language;fault detection;software design;formal specifications	"""An emerging common trend in model-based design of embedded software and systems is the adoption of Domain-Specific Modeling Languages (DSMLs). While abstract syntax metamodeling enables the rapid and inexpensive development of DSMLs, the specification of DSML semantics is still a hard problem. In previous work, we have developed methods and tools for the semantic anchoring of DSMLs. Semantic anchoring introduces a set of reusable """"semantic units"""" that provide reference semantics for basic behavioral categories using the Abstract State Machine (ASM) framework. In this paper, we extend the semantic anchoring framework to heterogeneous behaviors by developing a method for the composition of semantic units. Semantic unit composition reduces the required effort from DSML designers and improves the quality of the specification. The proposed method is demonstrated through a case study."""	abstract state machines;abstract syntax;directory services markup language;domain-specific language;domain-specific modeling;embedded software;metamodeling	Kai Chen;Janos Sztipanovits;Sandeep Neema	2007	2007 Design, Automation & Test in Europe Conference & Exhibition		metamodeling;unified modeling language;abstract syntax;semantic computing;application software;real-time computing;carbon nanotube;concrete;embedded software;computer science;software design;theoretical computer science;automaton;programming language;model-based design;structured systems analysis and design method;fault detection and isolation;intersymbol interference;software system;abstract state machines	EDA	-41.58643558636663	31.925862509534195	125778
1092ac05e3330ab411b11e114f8a7afe351e6df8	asynchronous and synchronous communications in petri nets for run-time analysis of a device ecology	petri net;timing analysis;innovative;synchronous communication		device ecology;petri net	Sucha Smanchat;Maria Indrawan;Sea Ling;Seng Wai Loke	2005			theoretical computer science;petri net;asynchronous communication;computer science;static timing analysis	EDA	-35.32983308306838	32.226983605834114	126012
7cb8082d4671eb6652e66a457223abec00eb7216	modeling web browser interactions and generating tests	coverage criteria;coverage criteria web applications test generation;web pages;client systems;navigation application software system testing web pages pressing presses data security software quality uniform resource locators web server;presses;testing;satisfiability;web browser interactions;web applications;pressing;program testing internet online front ends;online front ends;navigation;fsm test tree web browser interactions client systems web applications on the fly navigation models;internet;program testing;on the fly;test generation;on the fly navigation models;security;load modeling;fsm test tree	Web applications can only be accessed through dedicated client systems called Web browsers. The behaviors of Web browser interactions influence the security, functionalities and navigation of Web applications. Modeling and testing Web applications should take them into account. In this paper, special care on Web browser interactions is paid and an approach to modeling on-the-fly navigation models and test generation with Web browser interactions and PDR is proposed. The extended FSM (OFNM/FSM) is employed to formalize the on-the-fly navigation models and a FSM-TT (FSM Test-Tree) derived from the OFNM/FSM is constructed using the algorithm we present. Test generation is given out from FSM-TT which satisfies the corresponding coverage criteria.	algorithm;design review (u.s. government);interaction;web application	Bo Song;Huaikou Miao;Shengbo Chen	2008	2008 International Conference on Computational Intelligence and Security	10.1109/CIS.2008.188	web service;ajax;web application security;embedded system;navigation;static web page;web development;web application;web modeling;the internet;web mapping;web-based simulation;web design;comet;computer science;information security;web api;web navigation;web page;database;software testing;pressing;client-side scripting;world wide web;computer security;web server;mashup;satisfiability	SE	-46.69908987473103	20.84536933254981	126144
153336df2dc2b260bb2a0534f7c3dba48f216926	a fuzzy timed object-oriented petri net for multi-agent systems	object oriented model;multi agent system;formal model;agent oriented software engineering;model complexity;artificial intelligent;time petri net;object oriented;asynchronous communication;software development;petri net	In this paper, a multi-agent system (MAS) modeling method called fuzzy timed object-oriented Petri nets (FTOPN) is proposed. FTO-PN has extended Petri nets (PN) supporting object-oriented modeling and temporal fuzzy learning based on timed hierarchical object-oriented Petri net (TOPN) and fuzzy timed Petri net (FTPN). Our focus is the adaptation according to TOPN concepts of cooperation objects for supporting synchronous and asynchronous communications and the temporal fuzzy learning proposed in FTPN. These two diagrams have been chosen because they are the most commonly used in modeling MAS and describing agent learning and reasoning ability. That is to say, they can be used to model and illustrate both the structural and dynamic aspects of MAS. Not only the proposed FTOPN can be used to model complex MAS, but also FTOPN model can be refined into the object-oriented implementation easily. It has bridged the gap between the formal modeling and the system refinement, which can overcome the development problems in agent-oriented software engineering. At the same time, it also can be regarded as a conceptual and practical artificial intelligence (AI) tool for the integration of MAS into the mainstream practice of software development.		Hua Xu;Peifa Jia	2008		10.1007/978-3-540-87734-9_24	real-time computing;computer science;artificial intelligence;software development;asynchronous communication;multi-agent system;object-oriented programming;petri net	AI	-42.67224719654792	22.891572678757605	126214
f2cc082c067bb36cb08c0362ca110db3a7d57699	modular refinement for submachines of asms		We describe and formalize a compositional, contract-based submachine refinement for a variant of Abstract State Machines. We motivate the approach by models of the Flash file system case study, where it is infeasible to refine a complete machine as a whole.	abstract state machines;concurrency (computer science);data recovery;flash file system;iterative and incremental development;posix;precondition;refinement (computing);simulation	Gidon Ernst;Jörg Pfähler;Gerhard Schellhorn;Wolfgang Reif	2014		10.1007/978-3-662-43652-3_16	computer science;data mining;database;algorithm	Logic	-43.76118648288341	30.347935664503897	126333
587881f44067ae5c1282a6be12c8ed552fc3763c	from natural language to formal proof goal	structure methods;natural language	In the Protocure project, medical guidelines are formalised to enable the use of formal verification methods to improve those guidelines. To verify goals given in natural language, a translation is required to the formalism of the verification tool. The main concern is to assure equivalence of the translation and the original. In general this is a problem. When the domain expert and the expert on formal methods are different persons, neither has sufficient knowledge to check this equivalence. A method is required to assure equivalence also in these cases. This thesis proposes a goal formalisation method in which the domain expert is involved in such a way, that the correctness of the result can be assured. By providing a common conceptual model of goals, the domain expert and the formal method expert share a frame of reference. Both have their own representation of this model: one in natural language, one in a newly introduced formal language GDL: the Goal Definition Language. Throughout the thesis examples from the medical domain are provided, although the applicability of the method transcends the boundaries of any specific domain. The conclusion shows that the proposed method satisfies amongst others, requirements in area of correctness, traceability, variability and reusability.	correctness (computer science);formal language;formal methods;formal proof;formal verification;heart rate variability;natural language;requirement;semantics (computer science);subject-matter expert;traceability;turing completeness	Ruud Stegers;Annette ten Teije;Frank van Harmelen	2006		10.1007/11891451_8	computer science;natural language;programming language;algorithm	AI	-45.871624635200384	26.505949621316507	126366
3cf5e111d2b8cc7fadbf06fbf27a1ab741e906fe	agent mediated soa with xml framework for grid computing	service oriented architecture;service model;grid computing;autonomous agent	Service oriented architecture is applied to Grid computing in the form of OGSA. But the classical service mechanism is too sophisticated to build a large scale service oriented Grid because of varieties of homogeneous and heterogeneous services with different level of quality. On the other hand, agent communities successfully built multi-agent system theory and agent based software engineering in recent years. Autonomic agent becomes a possible solution that hides this complexity. This article reviews the current research trends in Agent based Computing. It also extends SOA into an agent mediated SOA and summarizes methods for describing agent services. It aims to propose a cooperative and competing agent based service mechanism for large scale network and virtual organization. And it also proposes to build a prototype to verify the extended architecture and use existing formal methodology to build an agent service model.	agent-based model;autonomic computing;grid computing;multi-agent system;open grid services architecture;prototype;service-oriented architecture;software engineering;systems theory;virtual organization (grid computing);xml framework	Gehao Lu;Hao Li;Joan Lu;Shaowen Yao	2006			virtual organization;autonomous agent;intelligent agent;xml framework;mobile agent;grid computing;database;service-oriented architecture;distributed computing;computer science	AI	-41.18344003676839	19.913896375674963	126507
2eccae6b4e31d4c45f4ce8ce3bb442b177e0f8b9	analyzing rule-based behavioral semantics of visual modeling languages with maude	rule based;graph transformation;modeling language;visual modeling;model checking;visual representation;system design;abstract syntax;rewriting logic;model driven engineering;visual language;tools and techniques;formal analysis;building model	There is a growing need to explicitly represent the behavioral semantics of Modeling Languages in a precise way, something especially important in industrial environments in which simulation and verification are critical issues. Graph transformation provides one way to specify the semantics of Domain Specific Visual Languages (DSVLs), with the advantage of being intuitive and easy to use for the system designer. Even though its theory has been extensively developed during the last 30 years, it has some limitations concerning specific analysis capabilities. On the contrary, Maude is a rewriting logic-based language with very good formal analysis support, but which requires specialized knowledge. In this paper we show how a mapping between graph transformation-based specifications of DSVL semantics and Maude is possible. This allows performing simulation, reachability and model-checking analysis on the models, using the tools and techniques that Maude provides.	domain-specific language;graph rewriting;maude system;model checking;reachability;simulation;systems design;visual modeling	José Eduardo Rivera;Esther Guerra;Juan de Lara;Antonio Vallecillo	2008		10.1007/978-3-642-00434-6_5	rule-based system;model checking;abstract syntax;model-driven architecture;rewriting;computer science;theoretical computer science;formal semantics;modeling language;programming language;algorithm;systems design	PL	-44.09977891827196	27.91709670345529	126542
6c3f1950bbe4b6a17d5a3970ea1c424660d31dcd	object-oriented programming applied to laboratory automation. 3.the standard robot interface protocol for the analytical director	object oriented programming		laboratory automation;robot	T. Zhou;Thomas L. Isenhour;John C. Marshall	1994	Journal of Chemical Information and Computer Sciences	10.1021/ci00019a013	simulation;chemistry;computer science;theoretical computer science;object-oriented programming	Robotics	-34.373619742381656	26.17456685966208	126554
15cbd590cc35ea52829aaeed7a34546fb70dadbf	goal-oriented methodology for agent system development	goal net;developpement logiciel;modelizacion;multiagent system;tecnologia electronica telecomunicaciones;goal orientation;methode orientee objectif;distance learning multi agent systems software agents software architecture formal specification;agent oriented software engineering;agent logiciel;software agents;modelisation;goal oriented modeling;e learning system goal oriented methodology agent system development multiagent system requirement analysis architecture design multiagent development environment;desarrollo logicial;software development;agent systems;tecnologias;grupo a;sistema multiagente;modeling;software engineering intelligent agent concurrent computing multiagent systems computer architecture electronic learning application software cognitive science programming protocols;systeme multiagent	The goal-orientation is one of the key features in agent system. This paper proposes a new methodology for multi-agent system development based on goal net model. The methodology covers the whole life cycle of the agent system development, from requirement analysis, architecture design, and detailed design to implementation. A multi-agent development environment (MADE) that facilitates the design and implementation of agent systems is presented. A case study on agent-based e-learning system using the proposed methodology is illustrated in this paper.	agent-based model;multi-agent system;requirements analysis;software engineering	Zhiqi Shen;Chunyan Miao;Robert K. L. Gay;Dongtao Li	2005	IEEE/WIC/ACM International Conference on Intelligent Agent Technology	10.1093/ietisy/e89-d.4.1413	simulation;systems modeling;computer science;artificial intelligence;software development;software agent;goal orientation	Robotics	-39.45733192940923	24.19931365090684	126606
e71d79f0afb5c373da5c439d8273edf9635b7533	answer set programming: language, applications and development tools	powerful development tool;extensible integrated development environment;real-world asp application;efficient asp system;advanced development tool;real-world application;well-assessed development platform;asp system;dlv system;applications development	Answer Set Programming (ASP) is a powerful language for knowledge representation and reasoning, that has been developed in the field of nonmonotonic reasoning and logic programming. The high knowledge-modeling power of ASP, together with the availability of efficient ASP systems, have implied a renewed interest in this formalism in recent years. ASP has been applied in many scientific applications, ranging from Artificial Intelligence, to Knowledge Management and Information Integration. The big challenge now is to show that ASP can be profitably used for real-world applications, and can attract much interest also in industry.#R##N##R##N#In this paper, we report on our on-the-field experience on the development of real-world applications in ASP. We have employed the DLV system, the first ASP system which is undergoing an industrial exploitation by a spin-off company, and is very well-suited for applications development, thanks also to the endowment of powerful development tools, supporting the activities of researchers and implementors. In particular, we describe a couple of real-world ASP applications for work-force management and e-tourism, and we focus on two advanced development tools for DLV: ASPIDE and JDLV. ASPIDE is an extensible integrated development environment for ASP; while JDLV is a plug-in for Eclipse, integrating ASP in a well-assessed development platform which enables a bilateral interaction between ASP and Java.		Giovanni Grasso;Nicola Leone;Francesco Ricca	2013		10.1007/978-3-642-39666-3_3	computer science;artificial intelligence;programming language	EDA	-44.14864152486027	23.584662995090323	126990
4383d44182b7744eb6acfe88de2d11da6887def8	a survey of signature based methods for financial fraud detection	level of service;supervised learning;real time;behaviour scoring;data processing;financial data;data analysis;data storage;user profile;user profiling;transaction data;fraud management;user behaviour;process model;fraud detection;account signatures;identity theft;knowledge discovery	Fraud detection mechanisms support the successful identification of fraudulent system transactions performed through security flaws within deployed technology frameworks while maintaining optimal levels of service delivery and a minimal numbers of false alarms. Knowledge discovery techniques have been widely applied in fraud detection for data analysis and training of supervised learning algorithms to support the extraction of fraudulent account behaviour within static data sets. Escalating costs associated with fraud however have continued to drive the migration towards increasingly proactive methods of fraud detection, to support the real-time screening of transactional data and detection of ambiguous user behaviour prior to transaction completion. This shift in data processing from post to pre data storage significantly reduces the available time within which to evaluate newly arriving system requests and produce an accurate fraud decision, demanding increasingly robust and intelligent user profiling technologies to support advanced fraud detection. This paper provides a comprehensive survey of existing research into account signatures, an innovative account profiling technology which maintains a statistical representation of normal account usage for rapid recalculation in real-time. Fraud detection architectures, processing models and applications to date are critically examined and evaluated with respect to their proactive capabilities for detection of fraud within streaming financial data. Discussion is also presented on challenges which remain within the proactive profiling of account behaviour and future research directions within the signature domain.		Michael Edward Edge;Pedro R. Falcone Sampaio	2009	Computers & Security	10.1016/j.cose.2009.02.001	data processing;identity theft;computer science;transaction data;computer data storage;process modeling;data mining;internet privacy;supervised learning;data analysis;level of service;computer security	Crypto	-35.580121498726385	21.17294246051961	127058
69f8fac1a6117aed9be18be33c5a301bc9670d64	hermes: agent-based middleware for mobile computing	sensibilidad contexto;distributed system;structure topologique;groupware;biological system;movilidad;multiagent system;systeme reparti;context aware;systeme interaction;informatique mobile;compilateur;agent mobile;orientado agente;library service;componente logicial;agent based;programming environment;mobility;resource control;data collection;agente movil;specification;metodo formal;methode formelle;topological structure;biologie cellulaire;bioinformatique;mobile computer;composant logiciel;mobilite;product line;oriente agent;compiler;sistema interaccion;biologia celular;embedded system;formal method;intergiciel publication souscription;development tool;medio ambiente programacion;commande industrielle;software architecture;systeme biologique;sistema repartido;intergicial editor suscriptor;especificacion;distributed environment;algorithme reparti;industrial control;software component;biological systems;workflow;middleware;estructura producto;algoritmo repartido;agent oriented;bioinformatica;service discovery;sensibilite contexte;mobile agent;sistema multiagente;mobile computing;distributed algorithm;collecticiel;interaction system;estructura topologica;structure produit;publish subscribe middleware;sistema biologico;architecture logiciel;compilador;product structure;environnement programmation;cell biology;systeme multiagent;generic programming;bioinformatics	Hermes is a middleware system for design and execution of activity-based applications in distributed environments. It supports mobile computation as an application implementation strategy. While middleware for mobile computing has typically been developed to support physical and logical mobility, Hermes provides an integrated environment where application domain experts can focus on designing activity workflow and ignore the topological structure of the distributed environment. Generating mobile agents from a workflow specification is the responsibility of a context-aware compiler. Hermes is structured as a component-based, agent-oriented system with a 3-layer software architecture. It can be configured for specific application domains by adding domain-specific component libraries. The Hermes middleware layer, compilers, libraries, services and other developed tools together result in a very general programming environment, which has been validated in two quite disparate application domains, one in industrial control and the other in bioinformatics. In the industrial control domain, embedded systems with scarce computational resources control product lines. Mobile agents are used to trace products and support selfhealing. In the bionformatics domain, mobile agents are used to support data collection and service discovery, and to simulate biological system through autonomous components interactions.	abstract machine;application domain;autonomous robot;bioinformatics;biological system;comparison of command shells;compiler;component-based software engineering;computation;computational resource;domain-specific language;embedded system;formal verification;graphical user interface;integrated development environment;interaction;library (computing);middleware;mobile agent;mobile computing;programmer;service discovery;simulation;software architecture;systems biology;ver (command)	Flavio Corradini;Emanuela Merelli	2005		10.1007/11419822_8	embedded system;workflow;software architecture;middleware;compiler;simulation;computer science;component-based software engineering;operating system;middleware;mobile agent;service discovery;programming language;generic programming;mobile computing;specification;distributed computing environment;data collection	SE	-39.23122016401957	24.330343502970546	127076
fd0c08d856e0ba4c44426a1e5b01f5944aa4bbdd	prototypic implementations of the building block for component based open hypermedia systems (bb/cb-ohss)				Omer Mohamed	2005			implementation;hypermedia;theoretical computer science;computer science	SE	-37.773268480158805	26.913748151446985	127111
bd3ee2563e2c9c90d38f4f10ed8f96e21320627c	a state-space based model-checking framework for embedded system controllers specified using iopt petri nets		This paper presents a state-space based model-checking framework to test and validate embedded system controllers specified using the IOPT Petri net formalism. The framework is composed of an automatic software code generator, a state-space generator and a query engine, used to define queries applied to the resulting state-space graphs. During state-space generation, the tools collect information required to enable the efficient implementation of hardware/software controllers, including place bounds, deadlocks and conflicts between concurrent transitions. User defined queries can check relevant system properties, as the occurrence of undesired error situations, the reachability of desired states, system liveliness and the occurrence of deadlocks and livelocks. The new tool, available online under a Web based user interface, provides a fast and efficient way to test and validate system controllers, contributing to the reduction of development time.	code generation (compiler);deadlock;embedded system;model checking;petri net;prototype;reachability;regression testing;semantics (computer science);simulation;state space;usability;user interface	Fernando Pereira;Filipe Moutinho;Luís Gomes	2012		10.1007/978-3-642-28255-3_14	process architecture	Logic	-41.43347775157053	31.066171707932078	127181
68738cd69fd4a859a6099c0daa0c7cf8e730fa58	representing dynamic invariants in ontologically well-founded conceptual models		Conceptual models often capture the invariant aspects of the phenomena we perceive. These invariants may be considered static when they refer to structures we perceive in phenomena at a particular point in time or dynamic/temporal when they refer to regularities across different points in time. While static invariants have received significant attention, dynamics enjoy marginal support in widely-employed techniques such as UML and OCL. This thesis aims at addressing this gap by proposing a technique for the representation of dynamic invariants of subject domains in UML-based conceptual models. For that purpose, a temporal extension of OCL is proposed. It enriches the ontologically well-founded OntoUML profile and enables the expression of a variety of (arbitrary) temporal constraints. The extension is fully implemented in the tool for specification, verification and simulation of temporal enriched OntoUML models.	marginal model;object constraint language;ontouml;simulation;unified modeling language	John Guerson;João Paulo A. Almeida	2016		10.1007/978-3-319-39429-9_19	conceptual model;theoretical computer science;unified modeling language;ontology;invariant (mathematics);mathematics	SE	-43.906880799752145	26.211519075995444	127282
418b61748633af60a0fbc5ecb80d44c504e78bca	control-flow semantics of use cases in uml	computacion informatica;uml;grupo de excelencia;use case modelling;requirements elicitation;ciencias basicas y experimentales;control flow;control flow semantics;use case;sequence diagram	1 The control-flow for five kinds of use cases is analysed: for common use cases, variant use cases, component use cases, specialised use cases and for ordered use cases. The control-flow semantics of use cases – and of the uses-relation, the extends-relation and the precedesrelation between use cases is described in terms of flowgraphs. Sequence diagrams of use cases are refined to capture the control-flow adequately. Guidelines are given for use case descriptions to attain a well-defined flow of control.	control flow;sequence diagram;unified modeling language	Klaas van den Berg;Anthony J. H. Simons	1999	Information & Software Technology	10.1016/S0950-5849(99)00027-0	sequence diagram;use case;unified modeling language;event partitioning;computer science;systems engineering;engineering;software engineering;requirements elicitation;database;control flow;algorithm	SE	-45.66422477025453	25.867067037880606	127586
56d99046ed6202e6e4e2d22742099554d9583219	towards task-based linguistic modeling for designing guis	task model;linguistic modeling;architecture and formalism of interactive systems	The linguistic perspective emphasizes the use of linguistic taxonomy to classify (partition) graphical user interface concepts and elements on several linguistic levels with clearly-defined interfaces between levels. This perspective is based on Nielsen's Virtual Protocol for Interaction that consists of several linguistic levels: goal, pragmatic (task), semantic, syntactical, lexical, alphabetical and physical.  A linguistic modeling is modeling the graphical interface by abstracting each linguistic level. The aim of the linguistic modeling is to enhance the maintainability quality of the graphical user interface model as defined in ISO-25010:2011, by enhancing sub-qualities of modularity, analyzability and modifiability.  Recent research reported on the linguistic perspective and the linguistic modeling requirements. In this paper, we elaborate more towards a linguistic modeling by modeling the task level; the high abstract level in the linguistic stack. Our contribution is an executable hierarchical task model that fulfils the specific needs towards linguistic modeling.	comparison of command shells;control engineering;event condition action;executable;expressive power (computer science);goms;graphical user interface;handbook;human–computer interaction;iso/iec 646;iso/iec 9126;interactive computing;interactivity;international federation for information processing;linear algebra;neville's algorithm;p (complexity);pumping (computer systems);requirement;sigchi;software engineering;software quality;springer (tank);state diagram;task analysis;taxonomy (general);the new york times	Iyad Khaddam;Nesrine Mezhoudi;Jean Vanderdonckt	2015		10.1145/2820619.2820636	natural language processing;deep linguistic processing;computer science;programming language;communication	NLP	-46.06754501284452	28.364913976921358	127684
def179017c87b586e5474b7e2fdff3e0973358ba	modeling formalisms for dynamic structure systems	general systems theory;performance;differential equation;dynamic structure systems specifications;structural change;parallel models;discrete event system;theory;design;parallel modeling formalisms;network structure;experimentation;article;hierarchical model;discrete time system	We present a new concept for a system network to represent systems that are able to undergo structural change. Change in structure is defined in general terms, and includes the addition and deletion of systems and the modification of the relations among components. The structure of a system network is stored in the network executive. Any change in structure-related information is mapped into modifications in the network structure. Based on these concepts, we derive three new system specifications that provide a shorthand notation to specify classes of dynamic structure systems. These new formalisms are: dynamic structure discrete time system, dynamic structure differential equation specified systems, and dynamic structure discrete event system specification. We demonstrate that these formalisms are closed under coupling, making hierarchical model construction possible. formalisms are described using set theoretic notation and general systems theory concepts.	coupling (computer programming);devs;discrete system;hierarchical database model;set theory;systems theory	Fernando J. Barros	1997	ACM Trans. Model. Comput. Simul.	10.1145/268403.268423	design;discrete mathematics;discrete event dynamic system;performance;computer science;theoretical computer science;structural change;differential equation;theory;algorithm	Embedded	-36.49268993700584	27.93337912567896	127755
d6f63df524371e30cc622bc79766a4854e342ab3	the application of causal analysis techniques for computer-related mishaps	elicitation;adverse event;programmable circuit;argumentacion;arbol defecto;organigramme;fonction barriere;fault tree;argumentation;control theory;causal analysis;ciclo desarrollo;flowchart;explosion;life cycle;circuit programmable;securite;accident;catalytic cracking;health and safety executive;theorie commande;fluidized catalytic cracking;sistema reactivo;control system;circuito programable;crude oil;arbre defaut;causalite;safety;defaillance;cycle developpement;reactive system;systeme reactif;elicitacion;explosions;accidente;failures;seguridad;organigrama;fallo;funcion barrera;barrier function;liquidity trap;causality;causalidad	Causal analysis techniques support the investigation of incidents and accidents. These include elicitation methods, such as Barrier Analysis, and event-based techniques, for example accident fault trees. Other approaches rely on flow charts, including those within the PRISMA approach and accident models, including the control theory model in STAMP. A further class of causal analysis techniques relies upon models of argumentation, such as the counterfactual approach in WBA. This paper reviews the support that different causal analysis techniques provide for the investigation of adverse events and near misses involving Electrical, Electronic or Programmable, Electronic Systems (E/E/PES). The events leading to an explosion and fires at a fluidized catalytic cracking unit are used to illustrate the application of these different techniques. This is then used to assess the degree of support that different techniques provide for the identification of latent failures at different stages in the software and systems lifecycle.	causal filter;causal system;causality;chart;closing (morphology);control theory;counterfactual conditional;fault tree analysis;flowchart;hybrid search engine;packetized elementary stream;password cracking;software development;software engineering;why–because analysis	Chris W. Johnson	2003		10.1007/978-3-540-39878-3_29	simulation;computer science;engineering;control system;artificial intelligence;operations research;computer security;algorithm;fluid catalytic cracking	SE	-41.41927227848852	27.276509147660033	127928
ddbe5b2b19a06517753830dc59e3197c2bbcd950	research on interface automata testing	software;protocols;formal specification;complexity theory;functional testing;magnetic heads;formal specifications;software engineering formal specification program testing;specification based testing;testing;interface automata testing;software engineering;automata;conformance testing;program testing;interface automata;conformance testing model based testing interface automata;software development;software component;process control;automata automatic testing software testing formal specifications protocols software quality educational institutions programming computer science software engineering;model based testing;software component interfaces;functional tests;software component interfaces interface automata testing formal specifications functional tests model based testing specification based testing software development	Testing from formal specifications offers a simple, structured, and more rigorous approach to the development of functional tests than standard testing techniques. Therefore, model-based testing (Specification-based testing) has been employed widely in software development. Interface automata is a light-weight formalism that captures the temporal aspects of software component interfaces, which has been widely used to model component behaviors. In this study, the definition of distinguishable state and controllable operation segment in interface automata are introduced, the testing process and algorithm for producing test sequences are presented, and the proposed approach is illustrated, after which the conformance testing of implementation to specification is carried out with the complete test sequences.	algorithm;automata theory;automaton;component-based software engineering;conformance testing;model-based testing;semantics (computer science);software development	Liangming Li;Lei Liu;Zhijian Wang;Yelong Tang	2008	2008 International Conference on Computer Science and Software Engineering	10.1109/CSSE.2008.850	model-based testing;orthogonal array testing;white-box testing;computer science;software engineering;process control;functional testing;formal specification;dynamic testing;software testing;programming language;graphical user interface testing	SE	-46.48053784476324	30.864162900438558	128050
6287a2428a982a634d0fe331dc866e50b83c1e83	context-descriptive prototypes and their application to medicine administration	pervasive computing;user centered design;prototyping	A context-descriptive prototype is an interactive graphical animation, driven by a formal, executable engine, implemented in some programming or modelling language. The two main properties of a context-descriptive prototype are: (1) it is an integrated description that describes system, work processes, and context of use; (2) it is a formal description. Because of (1), designers, including users, are provided with a means to investigate the system in the context of the envisioned work processes. Because of (2), investigations into questions of formalisation and automation, not only of the system, but also of the work processes, can be made explicitly and become subject for discussions and further elaboration. We describe a concrete context-descriptive prototype of the hospital work process medicine administration and its support by a new pervasive system. We discuss findings from evaluation of the prototype in cooperation with nurses, and finally compare context-descriptive prototypes with other kinds of prototypes.	description logic;executable;graphical user interface;modeling language;prototype	Claus Bossen;Jens Bæk Jørgensen	2004		10.1145/1013115.1013157	user-centered design;simulation;human–computer interaction;computer science;systems engineering;engineering;artificial intelligence;operating system;prototype;ubiquitous computing	HCI	-45.71461525565805	24.036691674859355	128070
257fb14040e1a069a0b7fbb3bc0aaf206e835921	adaptivity and learning in intelligent real-time systems	dynamic maintenance;adaptation and learning;broker agent;agent architecture;reusable;monitoring and control;real time systems	Intelligent monitoring and control is a key technique in modern real-time technology. The abstract resource framework provides an adaptive agent architecture equipped with a scheduler that steers the agent’s computation using internal profiles: Utility-based meta-control trades off the cost of invested resources against the expected performance. As in other approaches to meta-control, the important question of how to incorporate external performance feedback has however not been addressed until now: For situated agents, external profiling is a more natural way of predicting utility, because it grounds its estimations on observational feedback with respect to ultimate goals of the agent This paper presents a control process based on abstract resources that additionally considers confidence into internal profiling. Confidence measures are derived from external stimuli by a multi-method learning algorithm. The approach is exemplified and evaluated at hand of the RoboCup simulation domain that provides a benchmark for adaptivity and learning in intelligent real-time systems.	agent architecture;algorithm;benchmark (computing);computation;intelligent agent;real-time clock;real-time computing;real-time transcription;scheduling (computing);simulation;situated	Jürgen Lind;Christopher G. Jung;Christian Gerber	1999		10.1145/301136.301253	agent architecture;real-time computing;simulation;computer science;knowledge management;artificial intelligence	Embedded	-38.120563137499005	20.779005486320646	128110
9450e65b39708410bd84f6bb0c583e905e1e3cc6	a conversation with adam bosworth	bea;web service	The changes that are going to be driven by web services will result in a major language extension.	web service	Adam Bosworth;Kirk McKusick	2003	ACM Queue	10.1145/637958.640150	web service;computer science;multimedia;world wide web	Theory	-47.61701409253188	20.73623512690984	128140
6eef3785422d3e5c3ec1a40e13fb6138be995b08	a formal semantics of the osek/vdx standard in \({\mathbb {k}}\) framework and its applications		The OSEK/VDX is an international standard of automobile operating systems. Such systems are safety-critical and require extensive safety analysis and verification. Formal methods have been shown useful and effective to verify the safety of both the OSEK/VDX-based operating systems and applications. Using formal methods requires formal semantics of the OSEK/VDX standard. In this paper, we present a formal semantics of the standard using (mathbb K), a rewrite-based formal semantics framework. With the formal semantics, we can (1) verify user-defined applications by model checking, and (2) automatically generate test cases for testing of the OSEK/VDX-based operating systems. Features of the formal semantics are its executability and flexibility. Compared with existing formal semantics of the standard, the formal semantics defined in (mathbb K) is more flexible and generic. This work also shows that (mathbb K) is not only used for formalizing the semantics of programming languages, but also for automobile operating systems.		Min Zhang;Yunja Choi;Kazuhiro Ogata	2014		10.1007/978-3-319-12904-4_16	real-time computing;theoretical computer science;programming language	PL	-43.81507874012071	30.84717343838135	128295
5d3a0ed006adbbd791f050c5f6542889d7a571fe	ws-engineer: a model-based approach to engineering web service compositions and choreography	model based approach;web service composition	In this chapter, we describe a model-based approach to the analysis of service interactions for web service choreography and their coordinated compositions. The move towards implementing web service choreography requires both design time verification and execution time validation of these service interactions to ensure that service implementations fulfil requirements of multiple interested partners before such compositions and choreographies are deployed for use. The approach employs several formal analysis techniques and perspectives, and applies these to the domain of web service choreographies and the compositional implementations that each role in these choreographies must satisfy. Our approach models the service interaction designs of choreographies (in the form of Message Sequence Charts), the service choreography descriptions (in WS-CDL – the Web Service Choreography Description Language) and the service composition processes (in BPEL4WS – the Business Process Language for Web Services). We translate models between UML and Web service specifications using the Finite State Process algebra notation. Where interactions deviate from choreography rules, the interaction sequences can be shown back to the user of the approach in an easy and accessible way, in the UML form. The described approach is supported by a suite of cooperating tools, formal modelling, simulation, animation and providing verification results from choreographed web service interactions. The tool suite and related papers are available for download at http://www.doc.ic.ac.uk/ltsa/eclipse/wsengineer.	software engineer;web service	Howard Foster;Sebastián Uchitel;Jeff Magee;Jeff Kramer	2007		10.1007/978-3-540-72912-9_4	web service;web modeling;data web;web standards;ws-policy;database;world wide web	SE	-45.596863951413376	19.264039501065916	128344
9c00b5531396d1eb249533562f90ccc63cd28534	a brief review on models for performance evaluation in dss architecture		Distributed Software Systems (DSS) are used these days by many people in the real time operations and modern enterprise applications. One of the most important and essential attributes of measurements for the quality of service of distributed software is performance. Performance models can be employed at early stages of the software development cycle to characterize the quantitative behavior of software systems. In this research, performance models based on fuzzy logic approach, queuing network approach and Petri net approach have been reviewed briefly. One of the most common ways in performance analysis of distributed software systems is translating the UML diagrams to mathematical modeling languages for the description of distributed systems such as queuing networks or Petri nets. In this paper, some of these approaches are reviewed briefly. Attributes which are used for performance modeling in the literature are mostly machine based. On the other hand, end users and client parameters for performance evaluation are not covered extensively. In this way, future research could be based on developing hybrid models to capture user’s decision variables which make system performance evaluation more user driven. Keywords—Distributed Software Systems; Performance Evaluation; Fuzzy logic; Queuing Networks; Petri Nets	decision theory;diagram;distributed computing;enterprise software;fuzzy logic;mathematical model;modeling language;performance evaluation;petri net;quality of service;software system;uml state machine	Ghassem Tofighi;Kaamran Raahemifar;Anastasios N. Venetsanopoulos	2013	CoRR	10.7321/jscse.v3.n3.68	real-time computing;simulation;computer science;operating system	SE	-36.87562724712845	28.654421502098156	128443
19f2ed82ef77cdd8d68d271358b2bdf0e2c01776	what kind of verification of formal navigation modelling for reliable and usable web applications	usability evaluation;model based verification;formal description technique;model based web developpement;formal description techniques	In this paper we introduce briefly a notation dedicated to model navigation of Web applications and we discuss some strategies to assess the usability over navigation models built with such as a notation. Our aim with this kind of evaluation is to ensure (prior to implementation) that important users tasks can (or cannot) be performed using the system.	usability;web application	Marco A. Winckler;Eric Barboni;Philippe A. Palanque;Christelle Farenc	2005		10.1016/j.entcs.2005.12.056	web usability;web modeling;simulation;computer science;theoretical computer science;formal specification	HCI	-46.56385291295251	28.32518439159786	128510
43bebf8990e196c61d9b1e9b99bdd280e5dff773	a normative model for behavioral differentiation	norm;generation;traffic simulation software normative model multi agent systems behavioral differentiation model nondeterministic generation engine;norm agent behavior generation variety;software engineering multi agent systems;variety;software engineering;agent;multi agent systems;computational modeling;adaptation model;engines;data structures;engines multiagent systems intelligent agent application software traffic control data structures data models reproducibility of results clothing;driver circuits;vehicles;behavior;data models	In multi-agent systems simulations, reproducing realistic behaviors is a crucial issue. Their variety and consistency are important factors, usually not specifically considered. In this paper, we propose a behavioral differentiation model designed (1) to generate various and consistent behaviors, and (2) to control the determinism of this generation. Based on a normative system and a nondeterministic generation engine, it allows users adapting it easily to their various needs. Finally, we show its application to the traffic simulation software developed and used at Renault, SCANeR(c) II.	multi-agent system;simulation software	Benoit Lacroix;Philippe Mathieu;Andras Kemeny	2008	2008 IEEE/WIC/ACM International Conference on Web Intelligence and Intelligent Agent Technology	10.1109/WIIAT.2008.287	real-time computing;simulation;generation;data structure;computer science;artificial intelligence;multi-agent system;variety;computer security;norm;behavior	Robotics	-36.84949660127728	30.231766179293146	128756
b8389b612740b997405375c34acdd56983fae451	towards a computer aided simulation model engineering (casme) environment	simulation model engineering;random number generation;model building;programming;voting;simulation model;computational modeling;computer aided software engineering;model specification;software engineering;computer simulation;case tool	There is increasing focus on the model development aspect of systems simulation, termed Engineering. Current software development tools consist primarily of CASE tools with simulation extensions or simulation tools with model-building extensions. The need for a Computer-Aided Simulation Model Engineering (CASME) environment is identified and discussed. In particular, a CASME environment should support a model building process based on the interconnection of components which are either primitives or collections of primitives (model modules) to form other model modules. The features and tools comprising a CASME environment which support such a process and provide model specifications for use in simulation execution environments are also identified and discussed. The conclusion is that such a tool would be useful, but only insofar as simulation environments provide for implementation of model and measurement (experimental frame) specifications.	simulation	Joel J. Luna	1993		10.1109/WSC.1993.718394	computer simulation;programming;simulation;model building;voting;random number generation;computer science;systems engineering;technical report;computer-aided software engineering;computer engineering	DB	-35.62860169409722	27.23142092391773	128870
543ecb3c3b93954e1f90f613d34215eff94579d4	distributed real-time control of railway crossings using multi-agent technology	dynamic change;distributed control rail transportation real time systems control systems software engineering artificial intelligence operating systems application software computer architecture hardware;system modeling;agent based;real time control;real time;real time operating system;multi agent technology;software engineering;artificial intelligent;software agents;distributed real time control;multi agent systems;software engineering control engineering computing distributed control multi agent systems railway safety real time systems software agents;railway system;real time application interface;software engineering techniques;real time application interface distributed real time control multi agent technology railway system software engineering techniques agent based control scheme real time operating system rtai;agent technology;railway safety;control engineering computing;agent based control scheme;real time application;distributed control;rtai;real time systems	Control of railway systems takes place in a complex, real-time and dynamically changing environment. This paper deals with distributed real-time control of crossings in a railway system. The current adopted software engineering techniques (e.g. artificial intelligence) are not able to couple with real-time constraints due to its nature undeterministic behavior. Therefore, this paper proposes the usage of a novel agent-based real-time approach. The detailed agent-based control scheme is presented in this paper focusing on the agent-algorithm development and its implementation under the real-time operating system RTAI (real time application interface). Moreover, the complete architecture of railway system model (hardware and software) used for the case study is also presented	agent-based model;algorithm;application programming interface;artificial intelligence;automation;computation;computational intelligence;control system;e-commerce;multi-agent system;rtai;real-time clock;real-time operating system;real-time transcription;software engineering	Dania A. El-Kebbe;Marcelo Götz	2005	International Conference on Computational Intelligence for Modelling, Control and Automation and International Conference on Intelligent Agents, Web Technologies and Internet Commerce (CIMCA-IAWTIC'06)	10.1109/CIMCA.2005.1631357	embedded system;real-time computing;real-time operating system;systems modeling;real-time control system;computer science;artificial intelligence;software agent;multi-agent system	Robotics	-38.82695759997368	22.204950172735817	128967
16aa9f18a8942775a1bfdfdf03c36ca68b987db5	an overview of lp, the larch power	larch power	We sketch a method for deduction-oriented software and system development The method incorporates formal machine-supported specification and verification as activities in software and systems development. We describe experiences in applying this method. These experiences have been gained by using the LP, the Larch proof assistant, as a tool for a number of small and medium size case studies for the formal development of software and systems. LP is used for the verification of the development steps. These case studies include ž quicksort, ž the majority vote problem, ž code generation by a compiler and its correctness, ž an interactive queue and its refinement into a network. The developments range over levels of requirement specifications, designs and abstract implementations. The main issues are questions of a development method and how to make good use of a formal tool like LP in a goal-directed way within the development. We further discuss of the value of advanced specification techniques, most of which are deliberately not supported by LP and its notation, and their significance in development. Furthermore, we discuss issues of enhancement of a support system like LP and the value and the practicability of using formal techniques such as specification and verification in the development process in practice.	code generation (compiler);compiler;correctness (computer science);formal methods;formal verification;natural deduction;proof assistant;quicksort;refinement (computing);software development process	Stephen J. Garland;John V. Guttag	1989	Formal Methods in System Design	10.1007/3-540-51081-8_105	algorithm;algebra;computer science;larch prover;critical pair;larch	SE	-45.39768478690404	29.16125246511594	129121
c64c01e995a718ef6f9c54bdf7d25b085fe5e321	an architecture for personal cognitive assistance	agent;software architecture;personal cognitive assistant;agent architecture	Current desktop environments provide weak support for carrying out complex user-oriented tasks. Although individual applications are becoming increasingly sophisticated and featurerich, users must map their high-level goals to the low-level operational vocabulary of applications, and deal with a myriad of routine tasks (such as keeping up with email, keeping calendars and web sites up-to-date, etc.). An alternative vision is that of a personal cognitive assistant. Like a good secretary, such an assistant would help users accomplish their high-level goals, coordinating the use of multiple applications, automatically handling routine tasks, and, most importantly, adapting to the individual needs of a user over time. In this paper we describe the architecture and its implementation for a personal cognitive assistant called RADAR. Key features include (a) extensibility through the use of a plug-in agent architecture (b) transparent integration with legacy applications and data of today’s desktop environments, and (c) extensive use of learning so that the environment adapts to the individual	agent architecture;desktop computer;email;emoticon;extensibility;high- and low-level;machine learning;personal digital assistant;plug-in (computing);principal component analysis;radar;vocabulary	David Garlan;Bradley R. Schmerl	2006			agent architecture;software architecture;simulation;human–computer interaction;computer science;engineering;artificial intelligence;software engineering;multimedia	HCI	-48.14996509818244	20.515227716322872	129163
b8f31ceafab5291e6a47dac2354cc985f1c775f1	strictly class-based modeling considered harmful	software metrics;object oriented methods;programming environment;object oriented programming;set theory;software engineering;complexity control strictly class based modelling object oriented methods class based approaches prototype based methods systems development programming environments systems development process class based assumptions limited reduction principle prototype based approaches;software metrics object oriented programming object oriented methods;system design;system development;prototypes uncertainty object oriented modeling software prototyping power system modeling design engineering programming software development management power system management mathematics;object oriented methods computer science	Many object-oriented methods have assumed classbased approaches, without considering prototype-based ones. Some authors, while admitting prototypes as a usejid concept, only envision their application in early phases of systems development. Others consider only the use of the prototype concept in programming environments and not with respect to the whole systems development process. We propose that these omissions are neither necessary nor useful and often can be harmful, in that methods grounded in purely class-based assumptions do not reject the nature of problems inherent in modeling. In this paper; we argue, using the principle of limited reduction, that both class-based and prototype-based approaches should be used in object-oriented methods, respectively for controlling complexity, and capturing enough detail for evolution.	complexity;emoticon;engineering design process;ibm notes;prototype;software development process	Birgitte Krogh;Sean Levy;Allen H. Dutoit;Eswaran Subrahmanian	1996		10.1109/HICSS.1996.495405	method;simulation;computer science;object;theoretical computer science;component-based software engineering;software development;object-oriented design;software engineering;object-oriented programming;software metric;set theory;systems design	HPC	-48.270238572998835	28.822827248681882	129247
9cc09f51e7a75ee4842f0dd498489ded9677e977	automated generalized petri net reduction using an evolutionary approach applied to a manufacturing system model	manufacturing systems;evolutionary computation;genetic algorithm automated generalized petri net reduction evolutionary approach manufacturing system model state space explosion reduction rules;mathematical model genetic algorithms analytical models sociology statistics manufacturing systems explosions;genetic algorithms;petri nets;petri nets evolutionary computation genetic algorithms manufacturing systems	Petri Net (PN) is a graphical mathematical tool used to create models that provide a formal specification of systems, creating the possibility of running behaviour analysis and properties verification. This kind of model is used to specify several system types and a good example of area in which this formalism is applied is to develop Manufacturing Systems models. In general, using PN to model systems where too much detailing is needed, causes the problem called state space explosion, that consists of a great element profusion in the model. In order to mitigate this problem several kinds of reduction rules were created aiming at simplifying the models, so that they can be easily analysed or simulated, maintaining some properties like: bounded ness, liveness and fairness. The combination of rules together within an automated method motivates the development of the present research. The goal was to define a group of reduction rules and create a genetic algorithm to automatically reduce PN models. The method obtained good results when automatically reducing PN models using six well known reduction techniques.	earthbound;fairness measure;formal specification;genetic algorithm;liveness;petri net;semantics (computer science);state space;type system	Andre Bevilaqua;Edilson R. R. Kato;Emerson Carlos Pedrino;Roberto H. Tsunaki	2013	2013 IEEE International Conference on Systems, Man, and Cybernetics	10.1109/SMC.2013.403	simulation;genetic algorithm;computer science;artificial intelligence;machine learning;mathematics;petri net;algorithm;evolutionary computation	Robotics	-35.955146503587514	29.469888056178856	129337
043851f9fbd5daedffcc18962f5be9cd6676523b	formal foundation for pattern-based modelling	coloured petri net;category theory;conferenceobject;design pattern;bookpart;sequence diagram	We present a new visual and formal approach to the specification of patterns, supporting pattern analysis and pattern-based model completion. The approach is based on graphs, morphisms and operations from category theory and exploits triple graphs to annotate model elements with pattern roles. Novel in our proposal is the possibility of describing (nested) variable submodels, as well as inter-pattern synchronization across several diagrams (e.g. class and sequence diagrams for UML design patterns). We illustrate the approach on UML design patterns, and discuss its generality and applicability on different types of patterns, e.g. workflow patterns using Coloured Petri nets.	cardinality (data modeling);category theory;code refactoring;coloured petri net;critical pair (logic);design pattern;graph (discrete mathematics);metamodeling;pattern recognition;sequence diagram;spatial variability;unified modeling language;vocabulary;workflow pattern	Paolo Bottoni;Esther Guerra;Juan de Lara	2009		10.1007/978-3-642-00593-0_19	sequence diagram;computer science;software engineering;design pattern;algorithm;category theory	SE	-44.85310199652384	26.94918068220567	129514
2e3e35988de63aca54e94323eb76140ea0dd291b	models for trustworthy service and process oriented systems	004;concurrent constraint calculi session types logic service and process oriented computing	Service and process-oriented systems promise to provide more effective business and work processes and more flexible and adaptable enterprise IT systems. However, the technologies and standards are still young and unstable, making research in their theoretical foundations increasingly important. Our studies focus on two dichotomies: the global/local views of service interactions, and their imperative/declarative specification. A global view of service interactions describes a process as a protocol for interactions, as e.g. an UML sequence diagram or a WS-CDL choreography. A local view describes the system as a set of processes, e.g. specified as a π -calculus or WS-BPEL process, implementing each participant in the process. While the global view is what is usually provided as specification, the local view is a necessary step towards a distributed implementation. If processes are defined imperatively, the control flow is defined explicitly, e.g. as a sequence or flow graph of interactions/commands. In a declarative approach processes are described as a collection of conditions they should fulfill in order to be considered correct. The two approaches have evolved rather independently from each other. Our thesis is that we can provide a theoretical framework based on typed concurrent process and concurrent constraint calculi for the specification, analysis and verification of service and process oriented system designs which bridges the global and local view and combines the imperative and declarative specification approaches, and can be employed to increase the trust in the developed systems. This article describes our main motivations, results and future research	business process execution language;compiler description language;concurrent constraint logic programming;control flow;control theory;declarative programming;imperative programming;interaction;parallel computing;sequence diagram;trustworthy computing;unified modeling language	Hugo A. López	2010		10.4230/LIPIcs.ICLP.2010.270	computer science;artificial intelligence;database;distributed computing;programming language;algorithm	SE	-39.89557268296036	28.175601964334884	129616
01fb5277f8f4c5d1173fff320866ae8d3c26f5c9	requirements, specifications, and minimal refinement	research outputs;research publications;requirement specification	The area of automatic verification has, in the recent past, provided us with feasible methods for automatically checking whether a design, representing a system, satisfies a set of requirements (see e.g. [CE81, BCM90, McM93]). However, the development of system designs (usually expressed as transition systems) is not trivial. The usual cycle of design–debug–re-design is time-consuming and error prone, partly due to the fact that the incorporation of a requirement in an existing design is a non-trivial, largely unformalised process. Within the context of design development, it is often the case that a design that satisfies a set of requirements already exists and a new requirement is to be ‘added’, in some sense, to that design. This may happen either when a new system is being designed with an existing one as a basis, or while incrementally designing a system. In both cases, it is desirable to have a methodology for automatically obtaining a design out of the old one and the new requirement. Moreover, this process should be theoretically well-understood in terms of guarantees of how exactly the new design relates to the original one and the requirement to be added. There are many types of such changes, corresponding to the different meanings assigned to the process of ‘adding’ a requirement to a design of a system. Therefore, one cannot possibly hope to create a meaningful, unified theoretical framework that encompasses any and all types of design change. In this paper, we will focus on a specific type that we believe is useful in the process of designing systems, which we call minimal refinement.	adjusted winner procedure;algorithm;antisymmetry;basis (linear algebra);best, worst and average case;ccir system m;cobham's thesis;cognitive dimensions of notations;computational complexity theory;denotational semantics;fairness measure;long division;max august zorn;maximal set;method of analytic tableaux;microsoft dynamics ax;modal logic;model checking;mutual exclusion;pspace;pspace-complete;reference implementation;refinement (computing);requirement;time complexity;universal quantification;worst-case complexity	Nikos Gorogiannis;Mark Ryan	2002	Electr. Notes Theor. Comput. Sci.	10.1016/S1571-0661(04)80550-4	software requirements specification;computer science;system requirements specification;functional specification	EDA	-43.19631136125191	29.87458368723477	129727
3ad03aef46d3eeb2375255903a027fa1812ea0c4	the credo methodology - (extended version)	file sharing;distributed system	This paper is an extended version of the Credo Methodology [16]. Credo offers tools and techniques to model and analyze highly reconfigurable distributed systems. In a previous version we presented an integrated methodology to use the Credo tool suite. Following a compositional, component–based approach to model and analyze distributed systems, we presented a separation of the system into components and the network. A high–level, abstract representation of the dataflow level on the network was given in terms of behavioral interface automata and a detailed model of the components in terms of Creol models. Here we extend the methodology with a detailed model of the network connecting these components. The Vereofy tool set is used to model and analyze the dataflow of the network in detail. The behavioral automata connect the detailed model of the network and the detailed model of the components. We apply the extended methodology to our running example, a peer-to-peer file-sharing system.	automata theory;automaton;dataflow;distributed computing;peer-to-peer file sharing;vereofy	Immo Grabe;Mohammad Mahdi Jaghoori;Joachim Klein;Sascha Klüppelholz;Andries Stam;Christel Baier;Tobias Blechmann;Bernhard K. Aichernig;Frank S. de Boer;Andreas Griesmayer	2009		10.1007/978-3-642-17071-3_3	real-time computing;simulation;computer science;theoretical computer science	Metrics	-35.48860887868181	31.996073183131518	129769
5c01654f5c29ce8f61b93b3ab3bf9b180f30baf1	"""errata to """"a petri net-based method for compatibility analysis and composition of web services in business process execution language"""" [jan 09 94-106]"""	business process execution language;web service;software architecture;computer science education;web services;partial response channels;educational programs;petri nets;business process re engineering;petri net;web services automation partial response channels computer science education educational programs;automation	In the above titled paper (ibid., vol. 6, no. 1, pp. 94-106, Jan 09), Fig. 1 was incorrect. The correct figure is presented here.	business process execution language;petri net;web service	Wei Tan;Yushun Fan;Mengchu Zhou	2009	IEEE Trans. Automation Science and Engineering	10.1109/TASE.2009.2018013	web service;business process execution language;computer science;engineering;artificial intelligence;operating system;software engineering;database;process architecture;petri net;algorithm	SE	-42.677046393767725	24.35291301890147	130175
89fae01be5226a4335f482e1c38814013fece395	semantic traits of graphical interfaces to support human scheduling	humans scheduling prototypes informatics problem solving costs potential well iterative methods;graphical interface;human resource management scheduling graphical user interfaces bakeries;planning and scheduling;bakery planning semantic traits graphical interfaces human scheduling expressive richness dependency constraints global homogeneity rollout representational system;graphical user interfaces;scheduling;bakeries;human resource management	Three semantic traits are considered central in the design of interfaces for scheduling: (1) expressive richness, (2) dependency constraints and (3) global homogeneity. These traits are exploited by diagrammatic representations that 'structurally integrate' systems of domain relations through analogous systems of diagrammatic relations. These traits are discussed in relation to ROLLOUT - a prototype representational system for bakery planning and scheduling. This article provides a semantic evaluation of ROLLOUT in terms of these representational traits and proposes explanations of how these traits lead to increased cognitive support in scheduling activities.	automated planning and scheduling;diagram;heuristic (computer science);linda (coordination language);prototype;scheduling (computing);stan	Rossano Barone;Peter C.-H. Cheng	2005	Ninth International Conference on Information Visualisation (IV'05)	10.1109/IV.2005.115	simulation;computer science;knowledge management;theoretical computer science	Robotics	-38.2012203979048	18.73904345455457	130271
31c4ac8aefe3829aadd9511ae92e8df9b63f30a7	an integrated environment for reuse reengineering c code	software systems;software component;software metric;source code;tool evaluation;source code analysis;reverse engineering	The paper presents an integrated environment implemented in Prolog for reuse reengineering existing C systems. Dierent tools developed in the RE project are integrated in the environment through sharing a ®ne-grained representation for C programs, the Combined C Graph (CCG). Dierent views of a system can be abstracted and visualised from the data-base of Prolog facts implementing its CCG representation. Software metric tools evaluate the reengineering costs, while reengineering operations are expressed as transformation rules and a symbolic executor allows the production of the reusable module's speci®cation. Ó 1998 Elsevier Science B.V. All rights reserved.	code refactoring;comparison of command shells;database;prolog;software metric	Gerardo Canfora;Andrea De Lucia;Malcolm Munro	1996	Journal of Systems and Software	10.1016/S0164-1212(98)10006-7	computer science;systems engineering;component-based software engineering;operating system;software engineering;programming language;reverse engineering;software metric;software system;source code	SE	-46.67357205402114	25.545263461888148	130311
6b789864c9f2fb156a4e9b82b120e274cb85cb10	a cooperative simulation mechanism of distributed control systems based on object-oriented design pattern	automatic control;analytical models;java 3d api;communication system traffic control;sensor phenomena and characterization;digital simulation object oriented programming java application program interfaces;distributed control systems;object oriented design;distributed control system;traffic control;actuators;application program interface;object oriented programming;statechart based controller model;simulation software;graphical plant model;object oriented;application program interfaces;solid modeling;heavy traffic;open network interconnecting devices;application program interface cooperative dcs simulation software distributed control systems object oriented design patterns open network interconnecting devices event chain mechanism statechart based controller model graphical plant model java 3d api;object oriented design patterns;cooperative dcs simulation software;object oriented modeling distributed control automatic control solid modeling analytical models actuators communication system traffic control traffic control discrete event simulation sensor phenomena and characterization;simulation model;distributed control;object oriented modeling;digital simulation;java;discrete event simulation;event chain mechanism	Distributed control systems (DCSs) consisting of a plant, a controller composed of many devices, and an open network interconnecting devices, are now used in many automation areas. For assuring the control performance under the heavy traffic on the network, the simulation of DCS is strongly needed. In the case of DCSs for controlling a mechanical plant, the graphical and cooperative simulation between the controller model and the plant model becomes important to verify the sequence of motions of the plant. For this purpose, we propose a systematic object-oriented-based DCS modeling procedure to efficiently and uniformly develop the DCS simulation model. From this procedure, we can describe the formal description of DCS simulation model based on five object-oriented design patterns which describe the structure and behavior of the DCS. We also propose an event chain mechanism between the statechart-based controller model and the graphical plant model. Finally, the cooperative DCS simulation software is developed by using the Java 3D API.	application programming interface;cooperative mimo;design pattern;distributed control system;event chain methodology;graphical user interface;java 3d;physical plant;prototype;requirements analysis;simulation software;state diagram;unified modeling language	Toyoaki Tomura;Satoshi Kanai;Takeshi Kishinami	2003		10.1109/ISORC.2003.1199239	embedded system;real-time computing;simulation;computer science;operating system;automatic control;distributed computing;distributed control system;programming language;object-oriented programming	Robotics	-35.84640954014749	28.75000884266469	130330
b4a1aea5304b96f06cd974e623bc463de06681f9	combining static and dynamic modelling methods: a comparison of four methods	modelizacion;metodo analisis;object oriented methods;formal specification;static method;programmation modulaire;flot donnee;program transformation;conceptual model;programacion modular;dynamic method;flujo datos;transformation programme;integration;method integration;specification formelle;modelisation;methode analyse;transformacion programa;conceptual modelling;object oriented;methode dynamique;analysis method;integracion;dynamic modelling;modular programming;oriente objet;system development;metodo dinamico;metodo estatico;object oriented analysis;data flow;modeling;orientado objeto;entity relationship;methode statique	A conceptual model of a system is an explicit description of the behaviour required of the system. Methods for conceptual modelling include ER modelling, data ow modelling, JSD, and several object-oriented analysis methods. Given the current diversity of modelling methods, it is important for teaching as well as using these methods to know what the relationships between them is and to be able to indicate what the (im)possibilities of integrating diierent methods are. This paper compares three modelling methods (ER, data ow, JSD) on their possibilities for integration and combination. It is shown that there is a common core of these methods, which centers around the concept of system transaction and that uniies the static view of a system taken by ER modelling with the dynamic view taken by JSD and the functional view taken by data ow modelling. Several object-oriented analysis methods integrate these three views. This paper illustrates how this is done in the analysis stage of OMT. Finally, it is shown that the transaction decomposition table can be used as a pivot around which to combine diierent methods. The results of this paper can be used in teaching to explain the relationships and diierences between the methods analysed here, and in system development practice to ease the transition from structured to object-oriented methods.	entity–relationship model;jackson system development	Roel Wieringa	1995	Comput. J.	10.1093/comjnl/38.1.17	object-oriented analysis and design;data flow diagram;systems modeling;entity–relationship model;computer science;artificial intelligence;conceptual model;modular programming;formal specification;programming language;object-oriented programming;algorithm;empirical modelling	DB	-38.386513674965435	24.708101330608027	130400
08046248f8ef141a34d64fd1f8439c6cf48e2d18	non-interference properties for data-type reduction of communicating systems	communication system;dynamical processes;system of systems;data type;automated verification;modelling language	An increasing interest in “Systems of Systems”, that is, Systems comprising a varying number of interconnected sub-systems, raises the need for automated verification techniques for dynamic process creation and a changing communication topology. In previous work, we developed a verification approach that is based on finitary abstraction via Data-Type Reduction. To be effective in practice, the abstraction has to be complemented by non-trivial assumptions about valid communication behaviour, so-called non-interference lemmata. In this paper, we mechanise the generation and validation of these kind of non-interference properties by integrating ideas from communication observation and counter abstraction. We thereby provide a fully automatic procedure to substantially increase the precision of the abstraction. We explain our approach in terms of a modelling language for dynamic communication systems, and use a running example of a car platooning system to demonstrate the effectiveness of our extensions.	graphics device interface;interference (communication);modeling language;non-interference (security);refinement (computing);system of systems	Tobe Toben	2007		10.1007/978-3-540-73210-5_32	simulation;system of systems;data type;computer science;theoretical computer science;distributed computing;programming language;communications system	PL	-39.38941779421184	30.791337214228115	130511
1b1c5c97ba16916c14ca5d92a3458f066f12bfc1	test scenarios generation for a class of processes defined in the bpel language	scenario generation;suw zintegrowany system wymiany wiedzy i udostepniania akademickich publikacji z zakresu nauk technicznych	The main purpose of this research is adaptation of critical paths method [1] to the processes defined in BPEL. The critical path method is the specification based and simulation oriented method. In the paper it is show that under some assumptions the BPEL process may be considered as an embedded system, in which tasks are like services and communication between tasks is like coordination of the services according to the task graph of the system. An example is given where a set of test scenarios is presented.	business process execution language;correctness (computer science);critical path method;embedded system;functional programming;requirement;scenario testing;server (computing);silicon controlled rectifier;simulation;web service	Krzysztof Sapiecha;Damian Grela	2008	Annales UMCS, Informatica	10.2478/v10065-008-0026-0	real-time computing;computer science;distributed computing;programming language	Embedded	-40.68006585764631	31.92340614630115	130554
49c9cedb49e09784a8b05dfc9c06b73ba27bf74a	changing system interfaces consistently: a new refinement strategy for csp||b	compositionality result;b machine;complementary notion;action refinement framework;csp process;refinement process;action refinement;o refinement;abstract event;new refinement strategy;b framework;formal method;csp	This paper introduces action refinement in the context of CSP‖B. Our motivation to include this notion of refinement within the CSP‖B framework is the desire to increase flexibility in the refinement process. We introduce the ability to change the events of a CSP process and the B machines when refining a system. Notions of refinement based on traces and on traces/divergences are introduced in which abstract events are refined by sequences of concrete events. A complementary notion of refinement between B machines is also introduced, yielding compositionality results for refinement of CSP‖B controlled components. The paper also introduces a notion of I/O refinement into our action refinement framework.	input/output;refinement (computing);tracing (software)	Steve A. Schneider;Helen Treharne	2009		10.1007/978-3-642-00255-7_8	computer science;data mining;algorithm	PL	-38.46596782669838	30.314208710879768	130874
720d73bdec2ecf69f74f9ad6756a5a156557d02b	specification and validation of a simple overtaking protokol using lotos		We present a specification of a simple Overtaking protocol forrnvehicles using the Formal Description Technique LOTOS. A detailed description ofrnthe design process leading to this specification is given. The designrnprocess involves early use of simulation and validation tools available forrnLOTOS. We discuss the applicability of existing tools in the context ofrnthis example.		Patrik Ernberg;Lars-Åke Fredlund;Bengt Jonsson	1991			real-time computing;simulation;computer science;algorithm;language of temporal ordering specification	NLP	-41.81309598735677	30.39567104036445	130918
bf0c778925d2860dc095db9edf6891d1da25dd91	support for authoring service front-ends	front end;composite web service;user interface;web service;user interface composition;interactive application;service oriented computing;web services;model based design	The success of service-oriented computing has important implications on how people develop user interfaces. This paper discusses a method for supporting the development of interactive applications based on the access to services, which can be associated with user interface annotations. In particular, we show how model-based descriptions can be useful for this purpose and the design of an authoring environment for the development of interactive front-ends of applications based on Web services. A prototype of the authoring environment is presented.	front and back ends;prototype;service-oriented software engineering;user interface;web service	Fabio Paternò;Carmen Santoro;Lucio Davide Spano	2009		10.1145/1570433.1570451	user interface design;web service;web modeling;web design;human–computer interaction;computer science;web api;ws-policy;web navigation;multimedia;user interface;world wide web	HCI	-48.20455548934349	21.422524095120473	131119
a3dc5a3b2e27507f11cfea7f4f1e8d3db6363491	amalgamation of domain specific languages with behaviour	e motions;graph transformation;behaviour aware morphisms;article;domain specific languages	Domain-specific languages (DSLs) become more useful the more specific they are to a particular domain. The resulting need for developing a substantial number of DSLs can only be satisfied if DSL development can be made as efficient as possible. One way in which to address this challenge is by enabling the reuse of (partial) DSLs in the construction of new DSLs. Reuse of DSLs builds on two foundations: a notion of DSL composition and theoretical results ensuring the safeness of composing DSLs with respect to the semantics of the component DSLs. Given a graph-grammar formalisation of DSLs, in this paper, we build on graph transformation system morphisms to define parameterized DSLs and their instantiation by an amalgamation construction. Results on the protection of the behaviour along the induced morphisms allow us to safely reuse and combine definitions of DSLs to build more complex ones. We illustrate our proposal in e-Motions for a DSL for productionline systems and three independent DSLs for describing non-functional properties, namely response time, throughput, and failure rate.	concurrency (computer science);digital subscriber line;domain-specific language;encapsulation (networking);failure rate;global telecommunications system;graph rewriting;iterative method;map;profiling (computer programming);response time (technology);simulation;static program analysis;structural similarity;substitution (logic);temporal logic;throughput;tracing (software);type inference;universal instantiation	Francisco Durán;Antonio Moreno-Delgado;Fernando Orejas;Steffen Zschaler	2017	J. Log. Algebr. Meth. Program.	10.1016/j.jlamp.2015.09.005	combinatorics;discrete mathematics;computer science;domain-specific language;mathematics;programming language;algorithm	PL	-41.86178478981702	28.633080359077674	131199
1c0baf731557a366523c9d1be65de4891775c703	designing multi-agent reactive systems: a specification method based on reactive decisional agents	multiagent system;systeme intelligent;architecture systeme;formal specification;network protocol;multi agent system;formal model;sistema inteligente;sistema reactivo;formal method;specification formelle;especificacion formal;formal verification;specification and verification;intelligent system;reactive system;systeme reactif;verification formelle;arquitectura sistema;system architecture;sistema multiagente;process control system;systeme multiagent	A Reactive system is one that is in continual interaction with its environment, and executes at a pace determined by that environment. Examples of such systems are network protocols, industrial-process control systems etc. The use of rigorous formal method in specification and validation, can help designers to limit the introduction of potentially faulty components during the construction of the system.#R##N##R##N#Due to their complex nature, reactive systems are extremely difficult to specify and validate. In this paper, we propose a new formal model for the specification and the validation of such systems. This approach considers a Reactive System as a Reactive Multi-Agent System consisting of concurrent reactive agents that cooperate with each other to achieve the desired functionality. In addition, this approach uses formal synchronous specification and verification tools in order to specify and to verify the systems behaviors. Finally an example of an application of the approach is mentioned.	intelligent agent	Bouchaib Bounabat;Rahal Romadi;Salah Labhalla	1999		10.1007/3-540-46693-2_15	embedded system;communications protocol;real-time computing;formal methods;formal verification;reactive system;computer science;process control;multi-agent system;formal specification;programming language;systems architecture	SE	-39.31064774057735	25.156466447281044	131243
d8910e6f51a51172416b91294cd5a3209f182835	model checking of ctl-extended ocl specifications		In software modeling, the Object Constraint Language (OCL) is an important language to specify properties that a model has to satisfy. The design of OCL reflects the structure of MOF-based modeling languages like UML and its tight integration results in an intuitive usability. But OCL allows to express properties only in the context of a single instance model and not with respect to a sequence of instance models that capture the execution of the system. In this paper, we show how OCL can be extended with CTL-based temporal operators to express properties over the lifetime of an instance model. We formally introduce syntax and semantics of our OCL extension cOCL. The properties specified with our OCL extension can be verified with our explicit state space model checking framework, called MocOCL. In a case study, we illustrate the expressiveness and usability of our approach and evaluate the performance of our implementation.	graph rewriting;meta-object facility;model checking;object constraint language;parse tree;performance evaluation;prototype;runtime library;single-instance storage;software system;state space;state-space representation;unified modeling language;usability testing	Robert Bill;Sebastian Gabmeyer;Petra Kaufmann;Martina Seidl	2014		10.1007/978-3-319-11245-9_13	computer science;model checking;programming language;modeling language;object constraint language;state space;ctl*;usability;unified modeling language;graph rewriting	SE	-44.802878496996506	26.972708377337337	131244
dc1eb8deb1e23487839dc9491274bc9f89d6b14d	kassandra: a framework for distributed simulation of heterogeneous cooperating objects		To address the heterogeneity and scalability issues of simulating Cooperating Objects (COs) systems, we propose Kassandra, a conceptual framework for enabling distributed COs simulation by integrating existing simulation tools. Moreover, Kassandra exploits the communication middleware used by real-world COs as underlying communication mechanism for integrating Kassandra-enabled simulation tools. In this way, real-world COs can be included with simulated objects in a seamless way to perform more accurate system performance evaluation. Moreover, such a hardware-in-the-loop approach is not limited to pre-deployment performance analysis, and can offer possibilities to analyse performance at different phases of CO applications. The concept of Kassandra has been carried out in the EU PLANET project. In this paper, we introduce the Kassandra framework components and show their interactions at different phases for node deployments in PLANET use cases. The result demonstrates the applicability of Kassandra to facilitate the development of CO applications.	simulation	Richard Figura;Chia-Yen Shih;Matteo Ceriotti;Songwei Fu;Falk Brockmann;Héctor Nebot;Francisco Alarcón;Andrea Kropp;Konstantin Kondak;Marc Schwarzbach;Antidio Viguria;Margarita Mulero-Pázmány;Gianluca Dini;Jesús Capitán;Pedro José Marrón	2017	Journal of Systems Architecture - Embedded Systems Design	10.1016/j.sysarc.2016.11.012	embedded system;real-time computing;simulation;computer science;operating system;distributed computing	Embedded	-43.69845902885684	24.472030518995624	131399
1073f8e2fb6374f3d07a97c72cb1057eefa04ffe	constraint-oriented variability modeling	feature oriented problem space variability modeling;product lines;syntax oriented variability modeling;feature oriented software development;top down;computer model;feature modeling;biological system modeling;semantics;loose programming;product line;satisfiability;software engineering;behavioral knowledge;synthesis;declarative description;reusable artifacts;semantic data model;feature constraints constraint oriented variability modeling syntax oriented variability modeling reusable artifacts declarative description behavioral knowledge solution space variability modeling feature oriented problem space variability modeling feature oriented software development product lines feature selection;computational modeling;feature constraints;workflows;software development;taxonomy;integrity constraints;feature selection;biological system modeling computational modeling bioinformatics taxonomy semantics data models programming;programming;loose programming variability modeling feature modeling workflows constraints synthesis;constraints;solution space variability modeling;constraint oriented variability modeling;data models;variability modeling;bioinformatics	Traditional syntax-oriented variability modeling specifies the set of possible system variants by explicitly describing how variability is expressed by linguistic means and it concentrates on the set of features that may or may not be present in a product. In contrast, constraint-based variability modeling defines variability in a top-down way by restricting the set of possible compositions of reusable artifacts in terms of properties and by including in this declarative description also some behavioral knowledge the experts may have about the product. Concretely, we propose here to integrate constraint-based solution space variability modeling with feature-oriented problem space variability modeling. This new approach paves the way to significantly simplify feature-oriented software development of product lines: Each feature is described by a set of constraints capturing what the feature contributes to a product variant and expects from it, and, for a given feature selection, the set of associated feature constraints allows synthesizing the set of product variants satisfying the constraints automatically. We illustrate and evaluate the proposed approach on the concrete example of a family of workflows from the bioinformatics domain.	bioinformatics;feasible region;feature selection;feature-oriented programming;heart rate variability;problem domain;software development;spatial variability;top-down and bottom-up design	Ina Schaefer;Anna-Lena Lamprecht;Tiziana Margaria	2011	2011 IEEE 34th Software Engineering Workshop	10.1109/SEW.2011.17	semantic data model;data modeling;workflow;programming;computer science;theoretical computer science;software development;machine learning;top-down and bottom-up design;data integrity;data mining;semantics;computational model;feature selection;taxonomy;satisfiability	SE	-45.32060285427245	25.64480712207294	131408
36268b2815e623ca84d0c6e2af49ff4575257a74	an integrated multi-agent model for modelling hazards within air traffic management	hazards;safety risk analysis;multi agent systems aerospace simulation air traffic hazards;aerospace simulation;multi agent systems;agent based modelling;emergent behaviour air traffic management agent based modelling safety risk analysis;air traffic;atmospheric modeling hazards analytical models object oriented modeling computational modeling meteorology;emergent behaviour;formal description integrated multiagent model modelling hazards air traffic management atm socio technical system systematic analysis agent based modelling multiagent model;air traffic management	Air Traffic Management (ATM) forms a large and complex socio-technical system which includes a variety of interacting human and technical agents. These interactions may emerge into various types of nominal and off-nominal behaviours. Agent-based modelling and simulation can provide a systematic analysis of such emergent behaviours in ATM. In order to improve the agent-based modelling, in earlier research a library of agent-based model constructs for hazards in ATM has been established. The objective of the current paper is to integrate these agent-based model constructs into a large multi-agent model. To illustrate the integration approach, a formal description of a selected combination of model constructs is presented and the results are discussed.	atm turbo;agent-based model;emergence;interaction;multi-agent system;simulation;sociotechnical system	Tibor Bosse;Henk A. P. Blom;Sybert H. Stroeve;Alexei Sharpanskykh	2013	2013 IEEE/WIC/ACM International Joint Conferences on Web Intelligence (WI) and Intelligent Agent Technologies (IAT)	10.1109/WI-IAT.2013.107	simulation;systems engineering;engineering;operations research	AI	-40.349575392314236	21.954373972605094	131704
477d442c3c0f56e21df9f863add11a25391cd126	service innovation for the user interface of an atm catering to the needs of the student community	user interfaces electronic money;automated teller machine;user interface;electronic money;service innovation;asynchronous transfer mode analytical models computational modeling data models technological innovation software banking;automated teller machine atm discrete event system simulation service innovation;discrete event system;currency user interface atm automated teller machine;discrete event system simulation;automated teller machine atm;simulation model;user interfaces	The paper develops and analyzes the simulation model of an automated teller machine (ATM). This case study is carried out on an ATM installed in an Institute of National importance in the Southern part of India. Two simulation models have been developed to analyze the effectiveness in a modified ATM. This work proposes to provide information about the availability of a particular denomination of currency before the customers enter the system.	atm turbo;service innovation;simulation;user interface	Girish Krishnan;Sanjay Kumar;C. R. Jithin;Vinay V. Panicker;R. Sridharan	2011	2011 IEEE International Conference on Industrial Engineering and Engineering Management	10.1109/IEEM.2011.6118101	real-time computing;simulation;computer science;engineering;marketing;operations management;user interface	Robotics	-35.705731655036864	25.431859649571688	132097
a890c37ea0bc28971f43545bb92c686ab4ea2bee	the nuxmv symbolic model checker		This paper describes the NUXMV symbolic model checker for finiteand infinite-state synchronous transition systems. NUXMV is the evolution of the NUSMV open source model checker. It builds on and extends NUSMV along two main directions. For finite-state systems it complements the basic verification techniques of NUSMV with state-of-the-art verification algorithms. For infinitestate systems, it extends the NUSMV language with new data types, namely Integers and Reals, and it provides advanced SMT-based model checking techniques. Besides extended functionalities, NUXMV has been optimized in terms of performance to be competitive with the state of the art. NUXMV has been used in several industrial projects as verification back-end, and it is the basis for several extensions to cope with requirements analysis, contract based design, model checking of hybrid systems, safety assessment, and software model checking.	algorithm;bit array;hybrid system;model checking;multi-core processor;nusmv;open-source software;requirement;requirements analysis;satisfiability modulo theories;scripting language;state transition table	Roberto Cavada;Alessandro Cimatti;Michele Dorigatti;Alberto Griggio;Alessandro Mariotti;Andrea Micheli;Sergio Mover;Marco Roveri;Stefano Tonetta	2014		10.1007/978-3-319-08867-9_22	model checking;computer science;theoretical computer science;programming language;symbolic trajectory evaluation;algorithm	Logic	-41.92671398123662	31.35094405664252	132268
6e0af6f088c1f227333ede28db58776357109119	requirements elicitation for agent-based applications	developpement logiciel;multi agent systems development;multiagent system;sistema experto;exigence;multi agent system;red www;orientado agente;agent based;sociologia;reseau web;activity checklist;software systems;intelligence artificielle;requirement;oriente agent;requirements elicitation;social science;internet;desarrollo logicial;agent intelligent;cognition;software development;security key;exigencia;intelligent agent;cognicion;artificial intelligence;world wide web;agent oriented;agente inteligente;inteligencia artificial;systeme expert;sociologie;activity theory;cle securite;sistema multiagente;sociology;systeme multiagent;expert system;llave seguridad	Requirements elicitation for a software system is a key stage in a successful development. At the same time, it is one of the most challenging, because requirements have to consider the mutual influences between the envisioned system and the human context where it will work. These influences cover aspects such as organization, motivation, evolution, and cognition, taking place in a specific setting. The agent paradigm facilitates the analysis of these features because of its intentional and social nature. Nevertheless, determining the information that should be obtained and the way it should be modelled is not a trivial task. Developers are experts in software systems but not always familiarized with the concrete domain of those systems. The Requirements Elicitation Guide, a technique based on the Activity Theory from Social Sciences, can be applied to support developers in these issues. This guide empowers developers with the experience of social sciences in these studies. This paper introduces this guide and shows its application in a case study about a web application.	agent-based model;cognition;introspection;programming paradigm;requirement;requirements elicitation;requirements engineering;software agent;software system;subject-matter expert;unified modeling language;vocabulary;web application	Rubén Fuentes-Fernández;Jorge J. Gómez-Sanz;Juan Pavón	2005		10.1007/11752660_4	simulation;systems engineering;engineering;artificial intelligence;requirements elicitation	SE	-40.75993278103067	22.879691454421824	132375
05a69865060c3b77ebb890fff7bf278144bfc24b	esys.net: a new solution for embedded systems modeling and simulation	lenguaje programacion;langage description materiel informatique;conception conjointe;model specification;gestion memoire;fiabilidad;reliability;hardware software codesign;memory management;langage simulation;red www;cil;systeme embarque;programming language;hdls;diseno conjunto;componente logicial;modeling and simulation;lenguaje simulacion;storage management;simulation;verilog;net framework;hardware description languages;reseau web;systemverilog;composant logiciel;langage java;system on a chip;embedded system;net;attribute programming;embedded systems;gestion memoria;embedded system design;codesign;sistema sobre pastilla;system on chip;system design;fiabilite;vhdl;software component;next generation;langage programmation;world wide web;intermediate format;simulation language;lenguaje java;component based programming;systeme sur puce;c;modeling;esys net;framework;model simulation;java language;systemc;java	The next generation of tools for embedded systems design will represent a common arena for several cooperating groups. These tools will permit system design at a high abstraction level and enable automatic refinement through several abstraction levels to obtain the final prototype. To facilitate this evolution, we propose a new .Net Framework based system level modeling and simulation environment. This environment allows (1) cooperation -- by enabling web-based design and multi-language features, (2) easy systems specification task -- by enabling the integration of software components and by alleviating memory management and (3) the linking to automatic refinement tools -- by enabling the translation of model specifications into a standard intermediate format and by permitting the annotation of model specifications.	.net framework;.net reflector;abstraction layer;application programming interface;bsd;common language infrastructure;component-based software engineering;computer-aided design;coroutine;debugging;digital-to-analog converter;ecmascript;ee times;electronic system-level design and verification;embedded system;erlang (programming language);ieee software;iso/iec 42010;iso/iec 646;introspection;level design;markup language;memorandum;memory management;multi-core processor;open-source software;prototype;refinement (computing);requirement;semiconductor;simulation;system on a chip;systemc;systemverilog;systems design;systems modeling;vhdl;verilog;web application;wrapping (graphics);xml	James Lapalme;El Mostapha Aboulhamid;Gabriela Nicolescu;Luc Charest;François R. Boyer;J. P. David;Guy Bois	2004		10.1145/997163.997179	system on a chip;embedded system;computer science;operating system;modeling and simulation;programming language	EDA	-39.01683604414848	26.809186507495852	132382
e177df76317ad41f3a624ea6458e9b9b94b06108	towards analysing and controlling self-organising systems with socio-economic principles	distributed application;control systems;cognitive systems;flexible manufacturing systems;large scale distributed application;cognition biological system modeling multiagent systems stability analysis control systems adaptation model observers;high level representation self organising system control socio economic principle large scale distributed application flexible manufacturing system reasoning;biological system modeling;self adjusting systems;robust control;economic model;socio economic principle;observers;self organising system control;socio economic effects cognitive systems flexible manufacturing systems large scale systems robust control self adjusting systems;adaptation model;flexible manufacturing system;high level representation;cognition;stability analysis;reasoning;socio economic effects;large scale systems;multiagent systems	The increasing complexity of large-scale distributed applications motivates the study and development of self-organising systems. However, engineering self-organising systems is still a challenge. Despite their benefits, self-organising systems suffer from a lack of control and stability, so that methods and tools are needed for improving their understanding and control. In this paper, we consider socio-economic concepts as a tool for analysing and controlling self-organising systems. We propose an approach to enhance existing self-organising mechanisms with high-level representation and reasoning abilities based on socio-economic models. This approach has the advantage of preserving the typical performance, flexibility and robustness of a self-organising system, while improving its stability and making it more understandable to its users. We illustrate the approach with the example of a flexible manufacturing system we have evaluated, and we explore further directions based on this example.	distributed computing;flexible-fuel vehicle;high- and low-level;self-organization	Mathieu Vallée	2010	2010 Fourth IEEE International Conference on Self-Adaptive and Self-Organizing Systems Workshop	10.1109/SASOW.2010.16	robust control;von neumann stability analysis;cognition;computer science;control system;economic model;multi-agent system;management science;reason	Robotics	-40.335740646374965	19.793464986839663	132602
94ff15bbf116049be86f34cf2c92197754002177	model driven architecture for agile web information system engineering	navegacion;red www;web information system;web engineering;reseau web;model transformation;navigation;software architecture;internet;engineering information systems;architecture basee modele;world wide web;model driven architecture;systeme information ingenierie;architecture logiciel	Web Engineering is concerned with establishment and use of sound scientific, engineering and management principles. In this paper we present an agile approach for web engineering supported by a MDA (Model Driven Architecture) tool, named Netsilon. We promote agility by automating the generation of executable applications via model transformations (even from incomplete models), allowing the developer to focus on three essential aspects (business, presentation and navigation), while getting immediate feedback, at any time, through interaction with the system under development.	agile software development;information system;model-driven architecture	William El Kaim;Philippe Studer;Pierre-Alain Muller	2003		10.1007/978-3-540-45242-3_30	enterprise architecture framework;web service;web application security;reference architecture;software architecture;website architecture;navigation;web development;web modeling;the internet;simulation;web mapping;information engineering;web design;web standards;computer science;applications architecture;web navigation;database;solution architecture;web intelligence;web engineering;view model;web 2.0;world wide web	DB	-47.024949452485906	22.215935823128074	132773
3b263e5cfa194211dae7c29567df0ab07a780876	the factors that influence apropos security approaches for the object-oriented paradigm	object oriented paradigm	Over the past several years, there has been a strong emergence of interest and increased utilization of the object-oriented paradigm in many diverse areas of computing research, design, and development. Object-oriented programming languages, database models and systems, CAD and CASE design tools, and other applications have brought the paradigm into the forefront as a valued design and development technique. A natural consequence of these efforts has been an emphases on security approaches for the object-oriented paradigm, with both traditional (mandatory access control) and newer (discretionary access control) solutions. Often many of these proposed solutions do not consider the unique and special features of the object-oriented paradigm. The premise that is promoted by this work is that the paradigm itself must be the guiding factor in the research, design, and development of apropos security capabilities.	programming paradigm	Steven A. Demurjian;T. C. Ting	1993			computer science;knowledge management;artificial intelligence;mathematics;management science	PL	-45.225472397932286	21.54483855380679	133041
d7720edfa5e934fbeb8daa3e19c88dbcf7a99075	i want to go home: empowering the lost mobile device	personal data loss;reality mining data lost mobile device personal data loss machine learning based algorithm lost cell phone probability false positive rate;machine learning based algorithm;reality mining data;poles and towers;lost cell phone;probability;mobile device;cellular radio;data collection;training;data mining;artificial neural networks;false positive rate;machine learning;heuristic algorithms;mobile handsets;entropy;security of data cellular radio data mining learning artificial intelligence mobile computing mobile handsets probability;entropy poles and towers heuristic algorithms mobile handsets cellular phones training artificial neural networks;learning artificial intelligence;false positive;mobile computing;security of data;lost mobile device;cellular phones	It is estimated that over 8 million cell phones are lost or stolen each year [7]; often the loss of a cell phone means the loss of personal data, time and enormous aggravation. In this paper we present machine-learning based algorithms by which a cell phone can discern that it may be lost, and take steps to enhance its chances of being successfully recovered. We use data collected from the Reality Mining project [10] to create a suite of realistic test cases that model lost cell phone behavior. On these data sets our best algorithms can identify cases of a lost mobile device, based on its behavior over the previous 3 hours, with close to 100% accuracy. In addition, the algorithm generates false positive identifications with probability less than 3%; for individuals with relatively predictable lifestyles the False Positive Rate is substantially less. We also use the Reality Mining data to construct a set of test cases that model the behavior of a stolen phone, and show that similar algorithmic techniques give reasonable results in this setting as well.	algorithm;machine learning;mobile device;mobile phone;personally identifiable information;test case	Chi Zhang;Robert W. H. Fisher;Joel Wein	2010	2010 IEEE 6th International Conference on Wireless and Mobile Computing, Networking and Communications	10.1109/WIMOB.2010.5644848	entropy;simulation;type i and type ii errors;telecommunications;false positive rate;computer science;artificial intelligence;probability;data mining;mobile device;mobile computing;computer security;statistics;data collection	Visualization	-34.16341361989913	22.125440020406796	133053
ee8983e27236f0985c3df88286de8b409a713395	adds - a dialogue development system for the ada programming language	construccion modular;development;programming language;ada;user interface;man machine dialogue;desarrollo;developpement dialogue;systeme conversationnel;interfaz usuario;interactive system;construction modulaire;developpement;sistema conversacional;dialogo hombre maquina;interface utilisateur;modular construction;ada language;dialogue homme machine	A dialogue development system for the Ada programming language is described. The system supports the production of multi-level adaptable interfaces and provides the following features: input validation, user recovery/backtracking, in-depth help facilities, user-performance monitoring and a variety of user interface specification languages. In addition, development tools are provided that enable dialogue specific software to be automatically generated from the constituent specifications. Considerations are given to the use of multi-level interfaces and the employment of such systems in studying user adaptability and learning. The architecture of ADDS is described and some simple examples of its use are given. Although ADDS is designed for, and implemented in, Ada, it is structured in a manner that will make the features it supports more widely applicable.	ada;programming language	Alan Burns;Joshua J Robinson	1986	International Journal of Man-Machine Studies	10.1016/S0020-7373(86)80046-3	ada;human–computer interaction;computer science;programming language;user interface	Robotics	-38.449148732084495	26.00218701494913	133424
0f28c8e19199d5db219af43fcf4e6c41bbe025b6	on the use of formal specifications as part of running programs	developpement logiciel;occupation time;adaptability;concepcion ingenieria;adaptabilite;multiagent system;engineering design;confiance;psychologie sociale;formal specification;systeme grande taille;codificacion adaptativa;interoperabilite;interoperabilidad;conception ingenierie;codigo tiempo;environmental conditions;logicial personalizado;large scale system;codage adaptatif;software engineering;adaptabilidad;specification formelle;intergiciel;especificacion formal;confidence;temps occupation;confianza;adaptive coding;desarrollo logicial;code temps;software development;tiempo ocupacion;psicologia social;genie logiciel;middleware;social psychology;interoperability;sistema multiagente;ingenieria informatica;time code;sistema gran escala;systeme multiagent	Issues related to large scale systems made of autonomous com ponents encompassinteroperabilityamong independently developed software and daptability to changing environmental conditions. Formal specificatio ns are traditionally used at design time for software engineering tasks. How ever, recently, several attempts of using formal specifications at run-time hav e been realised that let envisage a future use of formal specifications at run-tim e that will enhance interoperability and adaptability of autonomous componen ts. This paper intends to highlight the potentialities of the us of formal specifications at run-time as a support for the correct execution of su ch components. This paper reviews and discusses the use of formal specifications at run-time from different perspectives: software engineering, run-time code evolution, adaptive middleware, trust and security, or business applications. It h ighlights the potentialities of the use of formal specifications at run-time as a support fo r interoperability and adaptability of interacting autonomous components. It ide ntifi s as well application domains and open issues related to the combination of sp ecifications and code in the framework of large scale systems.	autonomic computing;autonomous robot;coupling (computer programming);executable;formal specification;ibm notes;interaction;interoperability;middleware;run time (program lifecycle phase);semantics (computer science);service-oriented software engineering;software engineering;switzerland	Giovanna Di Marzo Serugendo	2005		10.1007/11738817_14	interoperability;adaptability;simulation;computer science;artificial intelligence;software development;middleware;formal specification;confidence;adaptive coding;engineering design process	SE	-39.52806249641751	24.33222063603132	133444
4a7882584d06546ae8a059b047a96338c1a030d2	integrated usage of data mining methods for malware detection	data mining;malware detection	The problem of counteracting malicious software (malware)remains a real one in all computer systems, including Geographical  Information Systems (GIS), despite the obv ious successes of anti virus vendors in technologies aimed at early recognition  of malwarepropagation, code analysis, and malware rapid updating of databases.The basic issue of that problem is the quality  of heuristic detection methods. The goal of these methods is to provide recognition of unknown malware samples; therefore  heuristic detection is the last defense line of any critical object in IT infrastructure. The paper is devoted to the application  of data mining methods to heuristic detector development. The offered approach differs from existing ones by cyclic interactive  covert processing of behavioral infor mation, and integrated use of different methods of data mining for various classes of  malware. The paper discusses research into how a family of different data mining methods based on Bayes approach,  decision trees and neural networks were implemented and investi  gated. The paper proposes a general integrated approach to realization  of malware detection methods.  	data mining;malware	Dmitriy Komashinskiy;Igor V. Kotenko	2009		10.1007/978-3-642-00304-2_24	internet privacy	ML	-35.57275786937037	21.189211829916292	133575
1120bf70d1f1ea70c65ff3ea685a259d47b9046e	towards user-friendly and efficient analysis with alloy		In model-driven engineering, structural models represent software at the early phases of software development. They are assumed to generate the models in subsequent phases which finally result in software. Thus, it is important to make sure these models are correct w.r.t. different concerns, e.g., consistency, or lack of redundant constraints. In this paper, we present a bounded verification approach using Alloy and integrate it into a graphical modelling tool. The graphical models and the properties to be verified are automatically transformed to Alloy specifications, which are examined by the Alloy Analyzer to verify whether the models satisfy the properties. The verification results are presented as feedbacks in the modelling tool. In this way, a model designer can verify models without knowing the underlying verification techniques and receive user-friendly feedbacks. A challenge in the verification approach is scalability. To tackle this, we present a technique for splitting models into submodels according to their constraints and the properties to be verified. A submodel is left-total if each of its instances can be extended to an instance of the whole model by adding elements typed by the elements that are not in the submodel. The verification of a model is then reduced to the verification of its left-total submodels. We will demonstrate the approach by a running example and we present an experimental result to show that the splitting technique may alleviate the scalability problem.	alloy (specification language);alloy analyzer;digital photo frame;feedback;graphical model;graphical user interface;model-driven architecture;model-driven engineering;scalability;software development;usability;workbench	Xiaoliang Wang;Adrian Rutle;Yngve Lamo	2015			scalability;software;theoretical computer science;user friendly;alloy analyzer;software development;bounded function;graphical model;computer science	SE	-47.161847550197386	27.00317222408451	133596
e97221cee714c5acafd6f4342df19bb448162451	intégration de la modélisation comportementale dans la conception par points de vue	composition du comportement;profil vuml;conception par points de vue;profil vxuml;machine a etats multivue;sonde d evenements;conception par points de vue profil vuml profil vxuml sonde evenements machine a etat multivue composition du comportement en francais	View-based modeling is the main subject of this thesis. It is a variant of the object oriented modeling approach for the analysis and design of complex systems, focusing on the actors that use the system and decomposing the specification according to their needs. With this prospect, our team developed a UML profile named VUML (View based UML), which allows the elaboration of a unique and sharable model accessible according to the view of each of the system's actors. However the achieved work on the VUML profile does not tackle the behavior aspects of the modeling process. The VUML approach address the structural aspects related to the composition of views and to the sharing of data without dealing with the way these views will react, or how to be able to synchronize them in order to obtain the behavior of multiple-view objects (instances of a multi-view class). The achieved work in this thesis aims to fill this gap by providing new mechanism to the VUML profile that allows expressing the behavioral needs of a system. We will focus on describing the individual behavior of multi-view objects by state-machines that require adjustments of UML modeling concepts. To achieve this objective we introduced the concept of event probes, which allow to specify implicit communication between the view-objects via event observation. This allows decoupling the view specifications that are a priori strongly interconnected, and therefore allows them to be designed separately, in agreement with the VUML method recommendations, and then to be integrated without the need of making modifications. We first define the concept of event monitoring and identified the different types of probes and the appropriate parameters that characterize them. We also define a set of concepts that can extend and manipulate probes. Then we propose a UMLcompatible representation of the introduced concepts in form of a profile named VxUML (extension of VUML). In addition to defining the profile elements (stereotypes, tagged value, predefined library classes), we have developed rules for proper formation of the static semantics using OCL to reduce ambiguity in the specification of such concepts. Afterwards, to demonstrate the usefulness of the concepts introduced, we developed a case study through which we sought to provide a full viewbased model, addressing both structural and behavioral aspects. At the end, to concretely validate our approach in a model driven engineering setting, we developed a code generator that takes as input a specification developed in VxUML profile. This generator uses the techniques of model transformation related to the code generation, including transformation of platform independent models (PIM) to platform specific models (PSM), and transformation of PSMs to code; the current target language is Java. Finally, another contribution of this thesis is a process associated with VxUML. It is an approach that complements the approach associated with VUML (which deal only with structural aspects) to be able to use in methodical manner the new mechanisms dedicated to behavioral treatment. Now, the VxUML development process offers a complete view based modeling, that is, dealing with both structural and behavioral aspects.	code generation (compiler);compiler;complex systems;coupling (computer programming);event monitoring;java;linear algebra;model transformation;model-driven engineering;object constraint language;profile (uml);programming language;stereotype (uml);uml tool;unified modeling language;vue	Younes Lakhrissi	2010			philosophy;performance art	SE	-43.37751542136493	24.917424120950972	133862
02bbd419efa00950654bc9676a4dda24467a1dd8	object-oriented analysis, modeling, and simulation of a notional air defense system	tracking system;modeling and simulation;distributed reactive systems;software systems;state machine;object oriented techniques;software engineering;simulation software;state machines;object oriented;reactive system;object oriented analysis;software specification;model simulation;modeling and analysis	This paper describes the analysis, modeling, and simulation of a notional air defense system using SMOOCHES (State Machines for Object-Oriented, Concurr ent, Hierarchical Engineering Specifications). SMOOCHES is an object-oriented environment based on hierar chical state machines and extensions to Statecharts, specifically developed as an envir onment to specify , model, simulate and analyze / evaluate distributed, r active systems. Using a high level system specification language, an object-oriented, hierar chical state specification of the radar tracking system with r ealistic constraints is derived. A graphical statechart r epresentation of the tracking system behavior is also derived and implemented within the SMOOCHES envir onment.	graphical user interface;high-level programming language;simulation;specification language;state diagram;tracking system	Bernard T. Barcio;Srini Ramaswamy;Robert MacFadzean;K. Suzanne Barber	1996	Simulation	10.1177/003754979606600102	object-oriented analysis and design;software requirements specification;real-time computing;simulation;simulation software;tracking system;reactive system;computer science;systems engineering;finite-state machine;object-oriented programming;software system	SE	-43.81295000676829	32.06077955116644	133870
b63e58fc79f57c0f854430c173d11b31df06838c	user interface development environment based on components: assets for mobility	composition;interaction;component;component composition;assembly;development environment;merging;semantic;abstract view;user interface development environment;concrete view	In this paper we present our UI development environment based on components. The UI is considered as a technical service of a business component just like security or persistence. The dialog between UI and business components is managed by an interaction/coordination service that allows the reconfiguration of components without modifying them. A UI component merging service handles dynamic assembly of corresponding UI components.	computer security;persistence (computer science);user interface;dialog	Anne-Marie Pinna-Dery;Jérémy Fierstone	2004		10.1145/1050873.1050889	human–computer interaction;systems engineering;engineering;world wide web	SE	-47.508145103082306	23.69157685925083	134069
0c68eb9f9d4c5fbb993fd414339f926b74be66b7	aspect algebra: the operational semantics for aspect oriented software	graph theory;cross cutting concerns;programming language semantics;formal specification;conceptual modeling;aspect oriented modeling;aspect oriented programming;cross cutting operations;weaving mechanism aspect algebra operational semantics aspect oriented software graph semantic based aspect model gam formal representation aos concepts graph based semantics conceptual semantics cross cutting concerns aspect oriented system design;programming language semantics aspect oriented programming formal specification graph theory process algebra;aspect oriented system;cross cutting operations aspect oriented system aspect oriented modeling conceptual modeling cross cutting concerns;semantics unified modeling language weaving medical services object oriented modeling programming algebra;process algebra	This paper has proposed novel aspect algebra for Graph -- semantic based Aspect Model called GAM. The GAM provides formal representation of Aspect Oriented System (AOS) concepts like join points, advices, Point Cut etc. using graph based semantics. On the other hand, the proposed algebra is comprised of set of operators defined on conceptual semantics of AOS. Those operators are used to conceptualize the different operational semantics of cross cutting concerns in Aspect Oriented System design and will play a crucial role on realization of weaving mechanism formally at model level.	aspect-oriented programming;cross-cutting concern;operational semantics	Anirban Sarkar;Narayan C. Debnath	2012	2012 Ninth International Conference on Information Technology - New Generations	10.1109/ITNG.2012.28	process calculus;aspect-oriented programming;computer science;conceptual model;graph theory;theoretical computer science;formal specification;programming language;operational semantics	DB	-44.96077216500092	26.80349990501879	134222
17df23f4676434bd359c3ac60e032cce98bbb104	an organisational multi-agent systems approach for designing collaborative tagging systems	information resources;groupware;multiagent systems tagging intelligent agent international collaboration rivers adaptive systems content addressable storage communities network topology centralized control;organisations in multi agent systems;collaboration;collaborative tagging systems;virtual groups;multi agent systems;collaborative tagging systems organisations in multi agent systems;multi agent systems groupware information resources;agent co evolution organisational multi agent systems approach collaborative tagging system design complex systems self organisation mechanisms;communities;couplings;programming;multiagent systems;tagging	Collaborative tagging systems are an example of socially-aware, self-organising, complex systems. The multi-agent systems paradigm coordinated by self-organisation mechanisms has been used as an effective way for the design and modeling of such systems. Existing tagging systems do not take full advantage of their complex systems characteristics, especially in adapting to their environment and allowing emergence. In this paper, we propose a model for designing a tagging system, using a multi-agent system approach, governed by the co-evolution of the social and spatial organisations of the agents. We show how the proposed system has new functionalities that could enhance current collaborative tagging systems.	complex systems;emergence;folksonomy;multi-agent system;programming paradigm;self-organization	Maya Rupert;Carlos Li;Salima Hassas	2008	2008 IEEE/WIC/ACM International Conference on Web Intelligence and Intelligent Agent Technology	10.1109/WIIAT.2008.182	programming;system of systems;computer science;knowledge management;artificial intelligence;multi-agent system;coupling;world wide web;systems design;collaboration	AI	-40.56889798086633	18.994348950574064	134504
e4ccde39396dc871a0cc25e2d295362ce2ae6e68	consistent projectional text editors		For modelling and domain-specific languages, projectional editors have become popular. These editors implement the MVC pattern and provide a direct connection to the underlying model. In particular, projectional editors allow much more freedom in defining the concrete syntax than traditional grammars. The downside is that it is possible to define presentations that are of bad quality, and that this is not easily visible. In this article, we identify some of the problems with projectional editors and propose ways to resolve them. We also demonstrate a proof-of-concept solution, showing how problematic editor presentations could be identified automatically.	abstract syntax;best practice;canonical lr parser;domain-specific language;graphical user interface;graphics;ll parser;language workbench;model–view–controller;parse tree;parsing;projection screen;prototype;sanity check;structure editor	S. M. Guttormsen;Andreas Prinz;T. Gjøsæter	2017		10.5220/0006264505150522	computer science;theoretical computer science;applied mathematics	HCI	-47.75949775079987	25.653263882636015	134582
a1e0dfbb232815623eba4544f851eecf884938f7	emergent engineering: a radical paradigm shift	self organisation;self assembly;evolveability;communications;emergence;systems design;systems engineering;emergent engineering;co evolution;reassembly;computing;cpe;disassembly;cyber physical ecosystems;developmental biology;complex systems;emergence and self organisation	We shed light on the disruptive advances brought by the ubiquity of computing and communication environments, which link devices and people in unprecedented ways into a new kind of techno–social systems and infrastructures recently named ‘cyber-physical ecosystems’ (CPE). While pointing to fundamental biases that prevent the traditional engineering school of thought from coping with the magnitude in scale and complexity of these new technological developments, we attempt to lay out the foundation for a new way of thinking about systems design, referred to as emergent engineering. One major characteristic of CPE is that, given their very nature, they cannot be a priori defined but rather emerge from the interactions among a myriad of elementary components. We show how this emergence can be guided by balancing positive and negative feedback, which tunes the growth of new configurations and adapts the system to sharp and unexpected changes. Rather than attempting to design the system as a whole, the components of the system are endowed with capabilities of dynamic self-assembly, disassembly and re-assembly to enable ‘evolve-ability’. As paradoxical as it may seem to the classically trained systems engineer, this new attitude of the designer as an ‘enabler’ (vs. ‘dictator’ of a system’s blueprint) allows the system to seamlessly adapt its development and evolve to meet dynamic goals and unexpected situations in an anticipative manner – an impossible feat under the traditional approach. To the extent that it produces new functionality, the proposed method enables a system to evolve via its ability of pervasive adaptation. Emergent engineering lies at a boundary where theoretical discovery meets systems engineering, computing and communications into a new convergent science of complex systems design. It currently transforms systems and software engineering by embracing various highly interdisciplinary perspectives.	avionics;blueprint;closing (morphology);closing the loop;complex systems;computer engineering;computer simulation;constant phase element;disassembler;distributed computing;ecosystem;emergence;emergent;emergentism;holism;interaction;interdependence;mit engineering systems division;negative feedback;pervasive informatics;physical computing;programming paradigm;risk management;seamless3d;self-assembly;social system;software deployment;software engineering;systems design;systems engineering;systems science	Mihaela Ulieru;René Doursat	2011	IJAACS	10.1504/IJAACS.2011.037748	embedded system;complex systems;computing;simulation;system of systems;telecommunications;computer science;artificial intelligence;ultra-large-scale systems;developmental biology;computer security;emergence;systems design	SE	-37.05727208162198	20.783117631467107	134727
480e2aed4e417f00f84bea19797cde4e45af1dda	consistency checking of multiviews based on agent	data integrity multi agent systems object oriented programming formal specification;formal specification;data integrity;agent modeling;viewpoint;intelligent agent interconnected systems internet signal processing programming concrete design for disassembly software systems;object oriented programming;agent;multi agent systems;requirement engineering;consistency checking;intelligent agent;agent systems;viewpoint agent;interviewpoint consistency consistency checking viewpoint oriented requirements engineering automatic checking multiple viewpoint requirements engineering multiple agent system viewpoint agent model intelligent agent intraviewpoint consistency	Consistency checking of intra-viewpoint and inter-viewpoint is very important in viewpoint-oriented requirements engineering, and the automatic check of these two kinds of consistency is rather difficult. Based on the researches of multiple viewpoint requirements engineering and multiple agent system, this article proposes a viewpoint agent model and its consistency checking method, which, by virtue of the autonomy, proactiveness and social ability of intelligent agent, can automatically check the consistency of intra-viewpoint and inter-viewpoint.	agent-based model;intelligent agent;model checking;requirements engineering	Zhengping Liang;Guoqing Wu	2004	The Fourth International Conference onComputer and Information Technology, 2004. CIT '04.	10.1109/CIT.2004.1357340	real-time computing;computer science;artificial intelligence;data integrity;formal specification;database;object-oriented programming;intelligent agent	SE	-48.034409407622505	28.420566224809324	134948
21e5fe2161006e7f138cf302effc4e9b5cf5c704	semantics of ocl specified with qvt	dsl;ocl semantics;uml;graphical approach;graph transformations;qvt;model transformation;graph transformation;object constraint language;meta model	The Object Constraint Language (OCL) has been for many years formalized both in its syntax and semantics in the language standard. While the official definition of OCL’s syntax is already widely accepted and strictly supported by most OCL tools, there is no such agreement on OCL’s semantics, yet. In this paper, we propose an approach based on metamodeling and model transformations for formalizing the semantics of OCL. Similarly to OCL’s official semantics, our semantics formalizes the semantic domain of OCL, i.e. the possible values to which OCL expressions can evaluate, by a metamodel. Contrary to OCL’s official semantics, the evaluation of OCL expressions is formalized in our approach by model transformations written in QVT. Thanks to the chosen format, our semantics definition for OCL can be automatically transformed into a tool, which evaluates OCL expressions in a given context. Our work on the formalization of OCL’s semantics resulted also in the identification and better understanding of important semantic concepts, on which OCL relies. These insights are of great help when OCL has to be tailored as a constraint language of a given DSL. We show on an example, how the semantics of OCL has to be redefined in order to become a constraint language in a database domain.	apl;class diagram;code refactoring;correctness (computer science);definition;digital subscriber line;graphical user interface;handy board;metamodeling;object constraint language;programming language;qvt;semantics (computer science);snapshot (computer storage);unified modeling language;well-formed element	Slavisa Markovic;Thomas Baar	2008	Software & Systems Modeling	10.1007/s10270-008-0083-2	natural language processing;metamodeling;unified modeling language;digital subscriber line;computer science;software engineering;database;programming language;object constraint language	SE	-47.51313519126081	26.20428814032617	135062
6ed049a280f8c57f288cd0986f42e93ebbd33ea8	on the semantics of the extend relationship in use case models: open-closed principle or clairvoyance?	extend relationship;uml meta model;extension point;use case;meta model	A use case is a description of the interactions of a system with the actors that use it. The Achilles' heel of use cases is the unclear UML semantics, in particular the definition of the extend relationship. This article is an attempt to clarify the semantics of the extension mechanism. In particular, we advocate for the application of the open-closed principle, adding modification details in the extending use case, instead of in the base case. A revision of the UML standard would be impractical, but a disciplined reinterpretation of the extend and extension point concepts could represent a great improvement. Textual and graphical approaches (based in the UML Behavior meta-model) are considered. Using these recommendations, the base use cases can be independently described, while the extending use cases will be self-contained.	data validation;experiment;extensibility;functional requirement;graphical user interface;interaction;metamodeling;recursion;unified modeling language	Miguel A. Laguna;José Manuel Marqués Corral;Yania Crespo	2010		10.1007/978-3-642-13094-6_32	use case;metamodeling;use-case analysis;artificial intelligence;software engineering;data mining;algorithm	AI	-46.04916517096658	26.020367914107194	135195
7114b671466213e057078c68b0da3d527d8976a9	timing coverification of concurrent embedded real-time systems	codesign tools;time scale;state space methods;hardware software codesign;co simulation;information science;embedded real time systems;state space explosions;concurrent embedded real time systems;embedded system;verification scalability timing coverification concurrent embedded real time systems hardware software codesign state space explosions codesign tools linear hybrid automata;automata;embedded systems;timing real time systems hardware automata embedded software explosions costs embedded system digital systems information science;complex system;digital systems;linear hybrid automata;verification scalability;automata theory;hardware software co specification;explosions;hybrid automata;state space explosion;automata theory timing hardware software codesign embedded systems state space methods;mixed system modeling;embedded software;timing coverification;hardware;multithreading;real time systems;timing	Hardware-software codesign results of c~ncurrcnt embedded realtime systems are often not easily verifiable. The main difficulty lies in-the different time-scales df the embedded hardware, of thk embedded software, and of the environment. This rate difference cawes state-space explosions and hence coverification has been mostly restricted t0 the initial system specifications. Currently, most codesign tools or methodologies only support validation in the form of cosimulation and testing. Here, we propose a new formal coverification method based on linear hybrid automam. The basic problems found in nm~t coveritication tasks are presented and solved. For complex systems, a simplification strategy is proposed to attack state-space explosions in formal covedtication. Experimental results show the feasibility of our approach and the increase in verification scalability through the application of the proposed method.	complex systems;device driver synthesis and verification;embedded software;embedded system;formal verification;level of detail;real-time clock;real-time computing;scalability;state space	Pao-Ann Hsiung	1999		10.1145/301177.301501	embedded system;parallel computing;real-time computing;computer science	Embedded	-39.571671866781955	32.020998002080034	135339
cc5165904eee5dfe476278edd91073a3a4020860	design of trusted systems with reusable collaboration models		We describe the application of our collaboration-oriented software engineering approach to the design of trust-aware systems.  In this model-based technique, a specification does not describe a physical system component but the collaboration between  various components which achieve system functions by cooperation. A system model is composed from these collaboration specifications.  By a set of transformations, executable code can be automatically generated. As a modeling language, we use UML 2.0 collaborations  and activities, for which we defined a semantics based on temporal logic. Thus, formal refinement and property proofs can  be provided by applying model checkers as well. We consider our approach to be well-suited for the development of trust-based  systems since the trust relations between different parties can be nicely modeled by the collaborations. This ability facilitates  also a tight cooperation between trust management and software engineering experts which are both needed to create scalable  trust-aware applications. The engineering approach is introduced by means of an electronic auction system executing different  policies which are guided by the mutual trust of its principals. While the approach can be used for various trust models,  we apply Jøsang’s Subjective Logic in the example.  	trusted system	Peter Herrmann;Frank Alexander Kraemer	2007		10.1007/978-0-387-73655-6_30	computer science;systems engineering;knowledge management;data mining	NLP	-43.45057228975637	23.519625347481636	135688
8de0640543dbe226c732e7bfefe74e174688516c	a distributed problem solving environment (pse) for scientific computing	constant definition;symbol manipulation;partial differential equation;problem solving scientific computing distributed computing computational modeling grid computing computer simulation educational institutions partial differential equations documentation control engineering;distributed resources distributed problem solving environment scientific computing partial differential equation program flow c language source code distributed computing mesh information equation manipulation program structure variable definition constant definition documentation support module program generation module liaison module job execution service module;mathematics computing;adaptive modulation;c language source code;distributed processing;distributed computing;control engineering;program generation;equation manipulation;computational modeling;distributed problem solving environment;program flow;partial differential equations;module liaison module;job execution service module;variable definition;documentation support module;scientific computing;source code;distributed problem solving;mesh information;natural sciences computing;distributed resources;grid computing;program structure;computer simulation;symbol manipulation distributed processing mathematics computing natural sciences computing partial differential equations;documentation;problem solving;generic programming	A distributed problem solving environment (PSE) is proposed to help users solve partial differential equation (PDE) based problems in scientific computing. The system inputs a problem description and outputs a program flow, a C-language source code for the problem and also a document for the program. Each module is distributed on distributed computers. The PSE contains all the information of the problem, PDEs, discretization scheme, mesh information, equation manipulation results, designed program structure, variable and constant definitions and program itself. Therefore the documentation support module generates a document for the generated program and the problem itself in the PSE. The module liaison module generates an adapter module among the distributed PSE modules. The job execution service module deploys programs generated or prepared on distributed computer resources and helps users run the programs on the distributed computers. The concept of the distributed PSE extends the potential of conventional PSE systems	computational science;computer;control flow;cooperative distributed problem solving;discretization;distributed computing;documentation;problem solving environment;server (computing);simulation;structured programming	Shigeo Kawata;Hideaki Fuju;Hideaki Sugiura;Yuichi Saitoh;Yoshikazu Hayase;Takayuki Teramoto;Takashi Kikuchi	2005	First International Conference on e-Science and Grid Computing (e-Science'05)	10.1109/E-SCIENCE.2005.3	computer simulation;computational science;computer science;theoretical computer science;operating system;database;distributed computing;partial differential equation	HPC	-34.714940112541726	27.352534320499377	135990
980d03f71ce8c7a40332fcdf4fc772b2a03393ae	genepi/a-a protocol independent system for testing protocol implementation	protocol implementation			Jean-Pierre Ansart	1982			computer science	Networks	-35.79551635269418	32.225214508990874	136037
307cb0131405e75d153abfe90838d3fe3881460e	supporting group interaction among humans and autonomous agents	computadora;software;espacio;heterogeneous groups;agent interaction;architectural design;human interaction;architecture systeme;human computer interaction;logiciel;concepcion sistema;commande;ordinateur;autonomous system;interaction;software agent;sistema informatico;heterogeneous agents;coaccion;contrainte;68n01;group behavior;hombre;automatisation;espace;computer system;autonomy;automatizacion;computer;sistema autonomo;recherche;autonomia;man machine system;computer architecture;modelo;constraint;autonomous agent;architecture ordinateur;support group;system design;systeme autonome;human;multi agent architecture;sistema hombre maquina;logicial;arquitectura sistema;control;space;systeme informatique;modele;interaccion;arquitectura ordenador;system architecture;robot;distributed collaboration;investigacion;models;conception systeme;autonomie;homme;systeme homme machine;proxy agents;automation	An important aspect of interaction among groups of humans and software agents is supporting collaboration among these heterogeneous agents while they operate remotely and communicate asynchronously. We are developing an architecture that supports multiple humans interacting with multiple automated control agents in such a manner. We are evaluating this architecture with a group consisting of the crew of a space-based vehicle and the automated software agents controlling the vehicle systems. Such agent interaction is modeled as a loosely coordinated group because this model minimizes agent commitment to group goals and constraints while addressing a significant portion of crew and control agent group behaviors. In this paper we give background on human interaction with space-based automation. We identify related research in multi-agent autonomous architectures and single agent human-computer interaction systems. We describe our architecture design for human-software agent groups. And we identify research issues in loosely coordinated human-software groups. 1. Background: Human interaction with space-based automation Future manned space operations will include greater use of automation than is seen today. Automated software agents will perform difficult tasks like system control while operating mostly autonomously. Such sophisticated software agents have been referred to as immobile robots or immobots (Williams and Nayak 1996) due to their computational similarity to physical robots. As automated agents like robots or immobots become more prevalent, human interaction with them becomes more frequent and routine. One particular type of group interaction that has yet to be explored greatly in the research is the interaction among multiple humans and multiple autonomous agents. We are investigating the interaction among distributed humans and control software agents when organized in loosely coordinated groups. By loose coordination we mean that (1) domain responsibilities are allocated to group members based on related but non-overlapping roles, (2) activities of group members are coordinated by means of a pre-built, high-level, centralized plan that allocates activities to group members based on assigned roles and the availability of shared resources, and (3) unplanned actions conducted by group members are prevented from interfering with the ongoing actions of other group members. We have chosen to investigate loosely coordinated groups because they represent an approach that minimizes agent commitment to group goals and constraints while addressing a significant portion of crew and control agent group behaviors. The simplifying assumptions of loose coordination (i.e. centralized planning, limited dynamic reconfiguration of teams) make multi-human/multi-agent interaction realistic but tractable in a complex domain like space. We have observed that the need for human-agent teams that can be dynamically reconfigured based on skills is not common in space-based operations because both human and control agents have highly specialized skills that preclude such flexible reconfiguration of human-software teams. The use of centralized planning for coordinating group activities supports some reconfiguration through activity reassignment to humans performing related roles (e.g. primary and backup roles) and role reassignment. We also expect to extend our approach in later years to support more tightly coordinated human-software teams formed for the purpose of cooperative, traded control activities to achieve goals shared by group members. An important aspect of interaction among loosely coordinated groups of humans and software agents is supporting collaboration among these heterogeneous agents while they operate remotely and communicate asynchronously. For example, in the space domain, the crew should be able to monitor and control autonomous operations from any location at the site and with only occasional intervention. This requires the crew be able to quickly form an integrated view of distributed control without continuously monitoring control data. It also requires the crew be able to command control systems from anywhere inside or nearby outside the space site. And, at the crew's discretion, they must be able to override autonomous control in response to system anomalies and mission opportunities. The crew should be supported in interleaving group activities like monitoring and control operations with non-group manual activities like performing science tasks. Since nominal operations for control agents will be mostly autonomous, the crew typically will spend their time on non-group tasks. Occasionally, however, the crew must respond to unusual situations requiring more active intervention. In effect, the crew is 'on call' to handle these situations. This requires assistance in handling interruptions and managing increased workload when 'called in'. Crew located throughout the site should be able to collaborate with other members of the group (other crew as well as automated control agents) distributed throughout site. This requires adapting the standard interaction protocols used in manned space operations today to address what information to communicate, and how and when to notify remote crew of important events and system status. These protocols must be associated with crew roles, since information needs change when roles change. These protocols also must accommodate asynchronous communication. Crew participating in the collaboration must be able to make control decisions jointly. When more than one crewmember is commanding, it is necessary to prevent conflicting control commands and to assist in reconfiguring automation for manual intervention, if needed. This description of human interaction with space-based control automation is based on our experience at the Johnson Space Center in developing automated control software for crew life support systems (Schreckenghost et al. 2002a).	autonomous agent;autonomous robot;backup;centralized computing;cobham's thesis;computation;content-control software;distributed control system;expect;forward error correction;high- and low-level;human–computer interaction;information needs;interaction protocol;multi-agent system;software agent	Debra Schreckenghost;Cheryl E. Martin;R. Peter Bonasso;David Kortenkamp;Tod Milam;Carroll Thronesbery	2002	Connect. Sci.	10.1080/0954009021000068709	robot;agent architecture;interpersonal relationship;interaction;simulation;computer science;autonomous system;artificial intelligence;autonomous agent;software agent;automation;space;autonomy;constraint;group dynamics;scientific control;systems architecture;systems design	HCI	-38.73064946471042	19.619522988001552	136084
c587a5ea02df6ca8b71e2133caf716754f8c888d	saml goes eclipse — combining model-based safety analysis and high-level editor support		Software-intensive systems become more and more important in safety critical applications, mainly because of the rising number and complexity of embedded system. Many traditional safety analysis techniques where developed decades ago and thus cannot cope with the complexity of modern systems. Model based analysis techniques where developed to deal with the complexity of software-intensive systems. However, due to the lack of tool support these techniques are currently limited to highly skilled experts. Thus model-based analysis is rarely used by system engineers.  Based on the safety analysis modeling language (SAML) framework we propose the S3E, which integrates a complete safety analysis environment into the eclipse platform. S3E covers the whole safety analysis work flow. This implies a powerful editor for model creation, a seamless integration of model-analysis tools and presentation as well as evaluation of the analysis results into one environment. In this paper we present the current state of S3E and first experiences with the eclipse plug-in development.	application programming interface;eclipse xtext;embedded system;high- and low-level;level editor;model checking;modeling language;plug-in (computing);seamless3d;security assertion markup language;specification language;user experience;user interface	Michael Lipaczewski;Simon Struck;Frank Ortmeier	2012	2012 Second International Workshop on Developing Tools as Plug-Ins (TOPI)			SE	-44.728148013092515	30.782387867611273	136215
0c5746c21b7985c00e21dcdf25bd023c287b539a	designing security requirements models through planning	developpement logiciel;modelizacion;distributed system;outil logiciel;proceso concepcion;software tool;multiagent system;confiance;systeme reparti;psychologie sociale;design process;securite;software verification;exigence usager;exigencia usuario;automatisation;intelligence artificielle;automated reasoning;automatizacion;software engineering;preparacion serie fabricacion;selection automatique;modelisation;refinement method;qa076 computer software;software architecture;confidence;planificacion;raisonnement automatique;sistema repartido;confianza;desarrollo logicial;user requirement;seleccion automatica;security requirements;requirement engineering;software development;safety;psicologia social;genie logiciel;architecture basee modele;artificial intelligence;planning;social psychology;inteligencia artificial;process planning;information system;planification;methode raffinement;sistema multiagente;herramienta software;seguridad;preparation gamme fabrication;modeling;metodo afinamiento;ingenieria informatica;model driven architecture;systeme information;architecture logiciel;automatic selection;systeme multiagent;processus conception;razonamiento automatico;arquitectura basada modelo;sistema informacion;automation	The quest for designing secure and trusted software has led to refined Software Engineering methodologies that rely on tools to support the design process. Automated reasoning mechanisms for requirements and software verification are by now a well-accepted part of the design process, and model driven architectures support the automation of the refinement process. We claim that we can further push the envelope towards the automatic exploration and selection among design alternatives and show that this is concretely possible for Secure Tropos, a requirements engineering methodology that addresses security and trust concerns. In Secure Tropos, a design consists of a network of actors (agents, positions or roles) with delegation/permission dependencies among them. Accordingly, the generation of design alternatives can be accomplished by a planner which is given as input a set of actors and goals and generates alternative multiagent plans to fulfill all given goals. We validate our claim with a case study using a state-of-the-art planner.	agent-based model;automated reasoning;automatic identification and data capture;correctness (computer science);design pattern;functional programming;graphical user interface;planner;refinement (computing);requirement;requirements engineering;software development process;software engineering;software verification;solver;trusted system	Volha Bryl;Fabio Massacci;John Mylopoulos;Nicola Zannone	2006		10.1007/11767138_4	planning;software architecture;simulation;systems modeling;design process;software verification;computer science;systems engineering;engineering;artificial intelligence;user requirements document;software development;automation;software engineering;requirements engineering;confidence;automated reasoning;management;information system	SE	-40.60341086178911	24.37234995787924	136310
70428596f7a378942f85ff01b7e263ed57effc7d	on the use of orthogonal context uncertainty models in the engineering of collaborative embedded systems		Collaborative embedded systems operate in highly dynamic and uncertain contexts. For instance, in vehicle platooning, several embedded systems form a collaborating group. Among others, they have to cope with unclear intentions of collaborators, uncertainties caused by imperfect technology, and the inherent indeterminacy in the physical surroundings. Hence, it is crucial to systematically consider and model context uncertainty during the development of these systems. Existing uncertainty modeling approaches mainly focus on one specific artifact type, and do not consider the need for supporting purpose-driven abstractions and corresponding perspectives on a system’s operational context. In this paper, we build upon the SPES XT Context Modeling Framework, which employs three different perspectives, each using a specific diagram type. Based on state-of-the-art concepts related to uncertainty, we investigate the use of capturing uncertainty in separate, orthogonal models, and establish relations to the three different context perspectives. We illustrate our promising results using a vehicle platooning scenario.	decision theory;diagram;embedded system;nondeterministic algorithm;platoon (automobile)	Torsten Bandyszak;Patrick Kuhs;Jasmin Kleinblotekamp;Marian Daun	2018				SE	-39.66079285013185	28.918230608141172	136331
4ffa3421743b3e85be016c2edc7c2e179a57c81e	mupif - a distributed multi-physics integration tool	software integration;object oriented design;distributed computing;multi physics simulations;system integration;interactive computing	This paper presents the design of a multi-physics integration tool with an object-oriented architecture that facilitates the implementation of multi-physics and multi-level simulations assembled from independently developed applications (components). The tool provides high-level support for mutual data exchange between codes, including support for different discretization techniques and specific field transfer operators, being aware of the underlying physical phenomena. Parallel and distributed applications and aspects of the applications are also addressed. Each application is required to implement application and data interfaces, which allow abstract access to solution domains and fields, and provide services for steering individual applications. The Python scripting language is extended by modules representing interfaces to existing codes. The high-level language serves as a glue to tie the modules or components together and to create a specialized application. The capabilities of the tool are demonstrated on two examples that illustrate staggered thermo-mechanical analysis and distributed field mapping.		Borek Patzák;Daniel Rypl;Jaroslav Kruis	2013	Advances in Engineering Software	10.1016/j.advengsoft.2012.09.005	interactive computing;computer science;theoretical computer science;operating system;distributed computing;programming language;system integration;computer engineering	SE	-34.064510045470435	27.981635831732024	136403
1f4607628dfcacb4175f98c8b8688ac4d8e58fe4	specification and synthesis of reactive protocols for aircraft electric power distribution	protocols;generators;clocks;power systems;contactors power systems generators protocols clocks aircraft;temporal logic aerospace control aircraft aircraft power systems control system synthesis;contactors;centralized control aircraft electric power distribution reactive protocols temporal logic specification language temporal logic formal method game based method distributed control architecture;aircraft	The increasing complexity of electric power systems leads to challenges in integration and verification. We consider the problem of designing a control protocol for an aircraft electric power system that meets a set of requirements describing the correct behaviors of the system and reacts dynamically to changes in internal system states. We formalize the requirements by translating them into a temporal logic specification language and apply game-based, temporal logic formal methods to automatically synthesize a controller protocol that satisfies these overall properties and requirements. Through a case study, we perform a design exploration to show the benefits and tradeoffs between centralized and distributed control architectures.	centralized computing;distributed control system;formal methods;ibm power systems;requirement;specification language;temporal logic	Huan Xu;Ufuk Topcu;Richard M. Murray	2015	IEEE Transactions on Control of Network Systems	10.1109/TCNS.2015.2401174	contactor;control engineering;communications protocol;electronic engineering;real-time computing;computer science;engineering;control theory;electric power system	Embedded	-38.092345194246974	31.649784872477156	136426
ae17c73584c37885dcab7fee8b6afbf535ff7e10	concrete syntax: a multi-paradigm modelling approach		Domain-Specific Modelling Languages (DSLs) allow domain experts to create models using abstractions they are most familiar with. A DSL's syntax is specified in two parts: the abstract syntax defines the language's concepts and their allowed combinations, and the concrete syntax defines how those concepts are presented to the user (typically using a graphical or textual notation). However important concrete syntax is for the usability of the language, current modelling tools offer limited possibilities for defining the mapping between abstract and concrete syntax. Often, the language designer is restricted to defining a single icon representation of each concept, which is then rendered to the user in a (fixed) graphical interface. This paper presents a framework that explicitly models the bi-directional mapping between the abstract and concrete syntax, thereby making these restrictions easy to overcome. It is more flexible and allows, amongst others, for a model to be represented in multiple front-ends, using multiple representation formats, and multiple mappings. Our approach is evaluated with an implementation in our prototype tool, the Modelverse, and by applying it on an example language.	abstract syntax;bi-directional text;digital subscriber line;domain-specific language;front and back ends;graphical user interface;parse tree;programming paradigm;prototype;usability	Yentl Van Tendeloo;Simon Van Mierlo;Bart Meyers;Hans Vangheluwe	2017		10.1145/3136014.3136017	natural language processing;syntax (programming languages);programming language;artificial intelligence;computer science;abstract syntax tree;syntax error;homoiconicity;syntax;abstract syntax;abstraction;abstract semantic graph	SE	-47.35560798771174	25.285173686401144	136564
61bd27f2d33f09caa2531eefe47c96e29e131604	lscs: breathing life into message sequence charts	formal specification;tool support;uml;sequence charts;state machine;message sequence chart;use case;live sequence chart;partial order	"""While message sequence charts (MSCs) are widely used in industry to document the interwork-ing of processes or objects, they are expressively quite weak, being based on the modest semantic notion of a partial ordering of events as deened, e.g., in the ITU standard. A highly expressive and rigorously deened MSC language is a must for serious, semantically meaningful tool support for use-cases and scenarios. It is also a prerequisite to addressing what we regard as one of the central problems in behavioral speciication of systems: relating scenario-based inter-object speciication to state-machine intra-object speciication. This paper proposes an extension of MSCs, which we call live sequence charts (or LSCs), since our main extension deals with specifying \liveness"""", i.e., things that must occur. In fact, LSCs allow the distinction between possible and necessary behavior both globally, on the level of an entire chart and locally, when specifying events, conditions and progress over time within a chart. This makes it possible to specify forbidden scenarios, and strengthens structuring constructs like as subcharts, branching and iteration."""	finite-state machine;iteration;message sequence chart	Werner Damm;David Harel	1999	Formal Methods in System Design	10.1023/A:1011227529550	partially ordered set;use case;unified modeling language;computer science;software engineering;formal specification;finite-state machine;programming language;message sequence chart;algorithm	SE	-41.478823649710904	28.68794768326948	136756
b4cb1b6175b383583d60eacc1a8836eadd2f4aa0	engineering accessible web applications. an aspect-oriented approach	modeling technique;life cycle;design and development;separation of concern;web accessibility;aspect oriented design;user interface models;interface model;user interface design;aspect oriented;user interaction	The development of accessible Web software is complicated for several reasons. Though some of them are technological, the majority are related with the need to compose different and, many times, unrelated design concerns which may be functional as in the case of most of the specific application’s requirements, or non-functional such as Accessibility itself. In this paper, we present a novel approach to conceive, design and develop Accessible Web applications in an aspect-oriented manner. In order to reach our goal, we provide some modeling techniques that we specifically developed for handling the non-functional, generic and crosscutting characteristics of the Accessibility concerns. Specifically, we have enriched User Interaction Diagrams with integration points, which are used to reason and document Accessibility for activity modeling during user interface design. Then by instantiating a Softgoal Interdependency Graph template with association tables, we work on an abstract interface model (composed by ontology widgets) to obtain a concrete and accessible interface model for the Web application being developed. We use a real application example to illustrate our ideas and point out the advantages of a clear separation of concerns throughout the development life-cycle.	abstraction layer;accessibility;aspect-oriented programming;aspect-oriented software development;diagram;interdependence;requirement;separation of concerns;user interface design;web application;world wide web	Adriana Martín;Gustavo Rossi;Alejandra Cechich;Silvia E. Gordillo	2010	World Wide Web	10.1007/s11280-010-0091-3	user interface design;web service;biological life cycle;user experience design;web modeling;aspect-oriented programming;web design;human–computer interaction;separation of concerns;web standards;computer science;web accessibility;database;programming language;user interface;world wide web	SE	-48.18647379960577	22.5208073221189	136804
058f10a2ac020d8821db6b6d28c7012c6bb17b27	modularizing crosscutting concerns in component-based systems		We define a method to modularize crosscutting concerns in the Behavior Interaction Priority (BIP) component-based framework. Our method is inspired from the Aspect Oriented Programming (AOP) paradigm which was initially conceived to support the separation of concerns during the development of monolithic systems. BIP has a formal operational semantics and makes a clear separation between architecture and behavior to allow for compositional and incremental design and analysis of systems. We thus distinguish local from global aspects. Local aspects model concerns at the component level and are used to refine the behavior of components. Global aspects model concerns at the architecture level, and hence refine communications (synchronization and data transfer) between components. We formalize global aspects as well as their integration into a BIP system through rigorous transformation primitives and overview local aspects. We present AOP-BIP, a tool for Aspect-Oriented Programming of BIP systems, and demonstrate its use to modularize logging, security, and fault-tolerance in a network protocol.	component-based software engineering;cross-cutting concern	Antoine El-Hokayem;Yliès Falcone;Mohamad Jaber	2016		10.1007/978-3-319-41591-8_25	reliability engineering;real-time computing;computer science;systems engineering	Logic	-39.22089832347311	29.151239442999696	136835
046af43ed75dab6a2268e2d6db9619f0cc46695d	quantitative timing analysis of uml activity diagrams using statistical model checking		Unified Modeling Language (UML) activity diagrams are widely used in modeling the dynamic aspects of system designs. However, due to frequent interactions between systems and external uncertain environment, the current version of UML activity diagrams cannot be used to accurately capture and quantify the overall timing behaviors of complex systems. To address this issue, this paper extends the UML activity diagrams to enable the stochastic modeling of user inputs and action executions, which strongly affect the overall timing behaviors of systems. Based on the statistical model checker UPPAAL-SMC, this paper proposes an automated framework that can perform quantitative reasoning under various functional and non-functional queries. Experimental results demonstrate the effectiveness of our proposed approach.	activity diagram;behavior model;complex systems;correctness (computer science);interaction;model checking;run time (program lifecycle phase);static timing analysis;statistical model;stochastic modelling (insurance);stochastic process;uppaal;unified modeling language	Fan Gu;Xinqian Zhang;Mingsong Chen;Daniel Große;Rolf Drechsler	2016	2016 Design, Automation & Test in Europe Conference & Exhibition (DATE)		timing diagram;model checking;unified modeling language;real-time computing;communication diagram;activity diagram;systems modeling language;uml tool;computer science;unified process;theoretical computer science;applications of uml;class diagram;database;semantics;modeling language;story-driven modeling;node;object constraint language;statistics	EDA	-43.27426563220026	31.91208616725368	136844
42c17c65df2ede8a1933612a1014b66f94665801	a formal approach to computer systems requirements documentation	duration calculus;software design	This paper demonstrates how the extended duration calculus [4] can be used to support the approach to documentation of computer systems presented by in [1]. This approach uses the general concept of mathematical relations to specify properties, while the calculus of durations provides the means to reason about such specifications, and in particular, prove formally that a design implies the requirements. The presentation is based on an example originally presented in [2], and later reformulated in [3] following the approach described on [1]. In the present paper we introduce all needed relations, express them in terms of duration calculus, and formally verify software design acceptability.	documentation;duration calculus;hardware description language;requirement;software design	Marcin Engel;Marcin Kubica;Jan Madey;David Lorge Parnas;Anders P. Ravn;A. John van Schouwen	1992		10.1007/3-540-57318-6_40	software requirements specification;computing;formal methods;computer science;systems engineering;software design;software engineering;software documentation;software system;computer engineering	Logic	-43.563179849498994	29.65507880712726	137037
70be50d76691358760880049a9c7d4ca660ee3ac	open petri nets as semantic model for workflow integration	semantic model;petri net	The integration of workflows of different enterprises requires to resolve conceptual inconsistencies which are best dealt with using a high-level modelling language. Languages like the UML provide dedicated notations for workflow modelling (e.g., by means of activity diagrams), but due to the lack of formal semantics, only little support for detecting and resolving inconsistencies can be provided. We propose open Petri nets as a suitable semantic model for workflows spanning different enterprises, and discuss the use of this model to formalise a notion of consistent evolution.	activity diagram;bisimulation;computer multitasking;concurrency (computer science);file spanning;formal methods;graph rewriting;high- and low-level;hoare logic;petri net;process calculus;semantics (computer science);sensor;theory;turing completeness;unified modeling language	Reiko Heckel	2003		10.1007/978-3-540-40022-6_14	process architecture;petri net	DB	-42.74500447987102	28.375021473032618	137059
92441014d04ed039b13139b36d71bdb3705e1aa7	orchestrating bigdata analysis workflows		Data analytics has become not only an essential part of day-to-day decision making, but also reinforces long-term strategic decisions. Whether it is real-time fraud detection, resource management, tracking and prevention of disease outbreak, natural disaster management or intelligent traffic management, the extraction and exploitation of insightful information from unparalleled quantities of data (BigData) is now a fundamental part of all decision making processes. Success in making smart decisions by analyzing BigData is possible due to the availability of improved analytical capabilities, increased access to different data sources, and cheaper and improved computing power in the form of cloud computing. However, BigData analysis is far more complicated than the perception created by the recent publicity. For example, one of the myths is that BigData analysis is driven purely by the innovation of new data mining and machine learning algorithms. While innovation of new data mining and machine learning algorithms is critical, this is only one aspect of producing BigData analysis solutions. Just like many other software solutions, BigData analysis solutions are not monolithic pieces of software that are developed specifically for every application. Instead, they often combine and reuse existing trusted software components that perform necessary data analysis steps. Furthermore, in order to deal with the large variety, volume and velocity of BigData, they need to take advantage of the elasticity of cloud and edge datacenter computation and storage resources as needed to meet the requirements of their owners.	algorithm;big data;cloud computing;component-based software engineering;computation;data center;data mining;elasticity (cloud computing);machine learning;real-time transcription;requirement;velocity (software development)	Rajiv Ranjan;Saurabh Kumar Garg;Ali Reza Khoskbar;Ellis Solaiman;Philip James;Dimitrios Georgakopoulos	2017	IEEE Cloud Computing	10.1109/MCC.2017.55	computer science;computer security;component-based software engineering;resource management;software;data mining;data modeling;big data;cloud computing;workflow;data analysis	ML	-34.48842770199759	19.642484305231942	137239
6570a5be08b16fa80a22ae4913a9b8b96d78af61	evaluation guidelines for asynchronous distributed heuristics in smart grid applications		In the context of Smart Grid applications, distributed control algorithms show advantageous properties over classical centralized approaches. Regarding their operation in a critical infrastructure, however, it is of utmost importance to validate the correct behavior of such approaches beforehand. In this paper, we give an overview on different aspects of evaluating Smart Grid applications, with a special focus on asynchronous distributed heuristics.	algorithm;algorithm engineering;autonomous robot;centralized computing;critical infrastructure protection;distributed control system;genetic algorithm scheduling;heuristic (computer science);mathematical optimization;optimization problem;problem domain;process modeling;taxonomy (general)	Christian Hinrichs;Michael Sonnenschein	2014			real-time computing;computer science;theoretical computer science;distributed computing	HPC	-38.19213916407407	21.66507492795867	137314
5ef0f4af48dcca0137c0f1d1d2917c77ca7d062c	a real-time animator for hybrid systems	systeme temps reel;systeme commande;equation differentielle;sistema control;representacion conocimientos;sistema hibrido;systeme discret;automata estado finito;real time;differential equation;semantics;dynamic system;continuous system;semantica;semantique;ecuacion diferencial;dynamical system;systeme continu;systeme dynamique;control system;sistema continuo;real time animation;software package;hybrid system;real time system;finite automaton;timed automata;sistema tiempo real;hybrid automata;progiciel;automate fini;sistema dinamico;sistema discreto;knowledge representation;representation connaissances;discrete system;systeme hybride	In this paper, we present a real time animator for dynamical systems that can be modeled as hybrid automata i.e. standard finite automata extended with differential equations. We describe its semantic foundation and its implementation in Java and C using CVODE, a software package for solving ordinary differential equations. We show how the animator is interfaced with the Uppaal tool to demonstrate the real time behavior of dynamical systems under the control of discrete components described as timed automata.	automata theory;dynamical system;electronic component;finite-state machine;graphical user interface;hybrid automaton;java;real-time computing;real-time transcription;sampling (signal processing);timed automaton;uppaal	Tobias Amnell;Alexandre David;Wang Yi	2000		10.1007/3-540-45245-1_9	real-time operating system;computer science;control system;artificial intelligence;dynamical system;semantics;algorithm	Embedded	-36.90697381042085	26.536331744013648	137420
72e24963afee6d961d8f5c8dfed83154b42710c0	tools for task modelling: where we are, where we are headed	goal orientation;interaction analysis;tool support;task model;task analysis;task modelling;interactive simulation;user interface design	Task models represent the intersection between user interface design and more systematic approaches by providing designers with the means to represent and manipulate abstractions of goal-oriented activities. While task modelling and task-based design have long been considered, their adoption has been limited by the lack of tools supporting the development, interactive analysis and use of task models. This paper discusses what support can be actually useful for designers and provides a taxonomy useful to compare tools for task modelling based on the experience accumulated with the CTTE tool. Some promising future developments will also be considered.	consistency model;taxonomy (general);usability;user interface design	Fabio Paternò	2002			user interface design;simulation;human–computer interaction;computer science;knowledge management;goal orientation;task analysis	HCI	-45.900440949178034	24.603278801562258	137430
4db04d3354b7c50f24ea12c00d321f52122ba881	disciplined exploration of emergence using multi-agent simulation framework	multi agent simulation	In recent years the concept of emergence has gained much attention as ICT systems have started exhibiting properties usually associated with complex systems. Although emergence creates many problems for engineering complex ICT systems by introducing undesired behaviour, it also offers many possibilities for advance in the area of adaptive self-organizing systems. However, at the moment the inability to predict and control emergent phenomena prevents us from exploring its full potential or avoiding problems in existing complex systems. Towards this end, 370 O. Paunovski, G. Eleftherakis, A. Cowling this paper proposes a framework for empirical study of complex systems exhibiting emergence. The framework relies on agent-oriented modelling and simulation as a tool for examination of specific manifestations of emergence. The main idea is to use an iterative simulation process in order to build a coarse taxonomy of causal relationships between the microand macro layers. In addition to the detailed description of the framework, the paper also discusses the corresponding verification and validation processes as important factor for the success of such a study.	agent-based model;causal filter;causality;complex systems;correctness (computer science);distributed computing;emergence;iteration;iterative method;mit engineering systems division;multi-agent system;organizing (structure);refinement (computing);self-organization;simulation;the herd with colin cowherd;verification and validation	Ognen Paunovski;George Eleftherakis;Anthony J. Cowling	2009	Computing and Informatics		simulation;computer science;artificial intelligence	AI	-42.831419018052635	21.828588367657645	137441
08672978ca4ec0d75f411f349df4d14c5c5f71e6	on using partial orders for web application design	labelled transition system;computer applications;web application design;internet;computer application;programming;virtual museum;design methodology;partial order	Purpose – This paper aims to deal with some design issues of web applications using partial orders to enhance their navigability and extensibility. Design/methodology/approach – The paper uses a static web applications model as a deterministic labelled transition system in which states are html pages and transitions are urls. Findings – By using this model it is possible, on the one hand, to characterize the temporal evolution of a web application and, on the other, to classify web applications into several types according to the way the information is organized over the web application. This classification captures interesting properties related to the navigability and extensibility of web applications. Practical implications – These ideas are applied to develop a simple web application, namely, a small virtual museum based on approximations of original paintings. Moreover, based on the extensibility characterization, the virtual museum is extended with different paintings approximations, while preserving navigability properties as well as browsing of paintings’ approximations of higher quality resolution. Originality/value – The results of this work provide useful and practical insights into the design of web applications that ensure navigability and extensibility properties.	approximation;exemplification;extensibility;formal language;html;image resolution;microsoft picture it!;performance evaluation;transition system;web application	Joaquim Gabarró;Isabel Vallejo;Fatos Xhafa	2007	IJWIS	10.1108/17440080710829199	partially ordered set;programming;web modeling;the internet;web mapping;web-based simulation;web design;design methods;human–computer interaction;computer science;artificial intelligence;operating system;social semantic web;data mining;database;multimedia;computer applications;world wide web;web design program;mashup	Web+IR	-47.126496808610256	20.633544916556424	137616
d925820ec4a424af020c5924cf58ab98950c1ab1	a formal approach for the iterative design of behavioural models	formal specification;information systems;resource management semantics testing adaptation models abstracts standards information systems;formal language iterative design behavioural models update operation behavioral specification use case scenario model under test source specification equivalence information system states formal semantics logical property;weakest precondition semantics information systems iterative design model based testing;iterative design;model based testing;weakest precondition semantics	In the process of specifying update operations of an information system, it is critical to ensure that the resulting design is consistent with the developers' understanding about the requirements, before it is adapted to a chosen platform of implementation. We present a formal approach to testing behavioral specifications that characterise the intended effects on the state as two-state, first-order predicates. By supplying use-case scenarios that are of interest, the developers are able to examine the test results, decide if the model under test is consistent, and revise the source specifications if necessary. To facilitate an iterative process of this, in this paper we develop a list of equivalence and refinement (rewriting) laws of predicates that are targeted at information system states. Our development is built upon the formal semantics and logical properties of a formal language of substitutions that serves as an abstract implementation language for these predicates.	emoticon;first-order predicate;formal language;information system;iterative and incremental development;iterative design;iterative method;object language;refinement (computing);requirement;rewriting;semantics (computer science);sensor;turing completeness	Chen-Wei Wang	2012	2012 19th Asia-Pacific Software Engineering Conference	10.1109/APSEC.2012.125	formal system;iterative design;model-based testing;formal methods;specification language;formal verification;computer science;theoretical computer science;software engineering;formal semantics;formal specification;database;programming language;operational semantics;information system	SE	-42.901232621833024	28.159007062810858	137719
f5b59d96b4fd9b2171e63907160f0e672de57665	generic petri net models of protocol mechanisms in communication systems	communication system;petri net	Abstract   Communication protocols define rules and data formats for the exchange of messages of interacting entities. The behaviour of protocols is based on few characteristic mechanisms. The basic functionality of these protocol mechanisms is independent from the layer where they are located.  In this paper, a class of performance Petri nets (deterministic and stochastic Petri nets) is used to model protocol mechanisms. This class of performance Petri nets allows the evalutation of performance aspects of the modelled system. Applying the analysis methods of embedded Markov chains, performance characteristics of protocol mechanisms are calculated and some interesting results are presented. However, the main focus of this paper are the models themselves, which help in a detailed understanding of the functionality of protocol mechanisms. They are presented and explained in a systematical and complete fashion.	petri net	Martin Bosch;Günter Schmidt	1991	Computer Communications	10.1016/0140-3664(91)90066-A	real-time computing;computer science;theoretical computer science;distributed computing;process architecture;petri net;communications system	Theory	-34.779371260575644	31.98691480126526	137869
b62d69d224d752f62f11b42b6246660cb5d29b49	on constructing a cooperative paradigm	traffic control;computer networks;artificial intelligence	In a network environment, it is the interaction and cooperation among distributed entities that make the computation dynamic and alive. But until recently, this interaction and cooperation still relied on expensive, complex, and inflexible solutions. A software agent is an important abstraction for building distributed systems. In this paper, we provide a framework for how to construct a cooperative paradigm for network applications by intelligent communication among agents. A case study--Urban Traffic Control System--is given to show how to construct a cooperative paradigm for a distributed working environment step-by-step from bottom to top. From our experience, we found that with the solution to construct a cooperative paradigm for the agents representing different entities in the real world, a network can become a natural, efficient, and easy working environment.	programming paradigm	Ying Dong;John Hallam;Mingshu Li	2002	Applied Artificial Intelligence	10.1080/088395102753559280	simulation;computer science;knowledge management;artificial intelligence	AI	-40.951658877203954	19.92737127828833	138067
ebcb61a714cb6e48b3de249978cbe5f65e2e434a	a dsl toolkit for deferring architectural decisions in dsl-based software design	computacion informatica;domain specific language dsl;design and development;grupo de excelencia;software architecture;ciencias basicas y experimentales;architectural decisions;domain specific language;software design;language model	A number of mature toolkits and language workbenches for DSL-based design have been proposed, making DSL-based design attractive for many projects. These toolkits preselect many architectural decision options. However, in many cases it would be beneficial for DSL-based design to decide for the DSL’s architecture later on in a DSL project, once the requirements and the domain have been sufficiently understood. We propose a language and a number of DSLs for DSL-based design and development that combine important benefits of different DSL toolkits in a unique way. Our approach specifically targets at deferring architectural decisions in DSL-based design. As a consequence, the architect can choose, even late in a DSL project, for options such as whether to provide the DSL as one or more external or embedded DSLs and whether or not to use an explicit language model.	architectural decision;digital subscriber line;dynamic programming;embedded system;entity;experience;fragmentation (computing);language model;list of toolkits;logic programming;model-driven architecture;parsing;programming language;requirement;scalability;software design	Uwe Zdun	2010	Information & Software Technology	10.1016/j.infsof.2010.03.004	software architecture;computer science;systems engineering;domain-specific language;software design;software engineering;programming language;language model	SE	-47.49021316151335	26.55164523320298	138078
0884b9f20ad3b75eec43f76cc80ff6c50a12f15b	framework for model-based design of multi-agent systems	agent based systems;simulation;mas;system modelling;multi agent systems;model based design;programming languages	When developing a Multi-Agent System (MAS), we need, among others, to build agent architectures together with some decision algorithms and communication protocols. Before such systems are realised in a real world, we should sufficiently test and verify their behaviour. The presented text describes a new approach to building artificial agents and MASs using the methodology of model-based design. In this methodology some models are used for testing the behaviour of particular elements as well as for testing the behaviour of the system as a whole – in both cases by simulation. Our aim is to develop a tool that would allow model-based design of systems with artificial agents. For this reason we have been building an application called Tool for Multi-Agent System Simulation (T-Mass) which is aimed at model-based development. As a part of the tool we also developed a language called Agent Low-Level Language (ALLL), by which agents’ behaviour is controlled.	algorithm;intelligent agent;model-driven engineering;multi-agent system;simulation	Frantisek Zboril;Vladimír Janousek;Radek Kocí;Frantisek Zboril;Zdenek Mazal	2009	Int. J. Auton. Comp.	10.1504/IJAC.2009.024746	simulation;computer science;artificial intelligence;multi-agent system;model-based design	AI	-42.632024513267645	22.526882507839954	138120
6f314bf6a7fe368c46fd6fa275bfd7f48e8e8da7	state-based analysis and uml-driven equivalence checking for c++ state machines	equivalence checking;state machine		c++;formal equivalence checking;turing completeness;unified modeling language	Patrick Heckeler;Jörg Behrend;Thomas Kropf;Jürgen Ruf;Wolfgang Rosenstiel;Roland J. Weiss	2010			finite-state machine;programming language;formal equivalence checking;unified modeling language;computer science	Logic	-44.49848544681498	30.68957855763458	138145
24c0ffb694cca287ffd30817d14b3151f77600fe	formal analysis of intelligent agents for model-based medicine usage management	agent modeling;dynamic system;intelligent agent;agent systems;formal analysis	A model-based agent system model for medicine usage management is presented and formally analysed. The model incorporates an intelligent ambient agent model that has an explicit representation of a dynamical system model to estimate the medicine level in the patient’s body by simulation, is able to analyse whether the patient intends to take the medicine too early or too late, and can take measures to	agent-based model;dynamical system;intelligent agent;simulation	Mark Hoogendoorn;Michel C. A. Klein;Zulfiqar Ali Memon;Jan Treur	2008			agent architecture;intelligent decision support system;computer science;artificial intelligence;autonomous agent;dynamical system;multi-agent system;intelligent agent;agent-based social simulation	AI	-42.36155064072787	22.218377701135605	138438
ecd1010a3b00eeaa641d91b696abba147f220c91	mda transformations applied to web application development	developpement logiciel;modelizacion;text;query view transformation;red www;lenguaje uml;generacion automatica;interrogation base donnee;reseau web;software systems;interrogacion base datos;model transformation;langage modelisation unifie;texte;general techniques;automatic generation;modelisation;software architecture;generation automatique;metamodel;internet;web design;metamodele;metamodelo;desarrollo logicial;unified modelling language;software development;uml based web engineering;architecture basee modele;world wide web;web application development;texto;modeling;database query;model driven architecture;architecture logiciel;arquitectura basada modelo	Current Web generation techniques are mainly hard-coded for predefined architectures of Web applications. Consequently, there is a gap between Web design models and the final implementation. We solve this problem, following with our approach the Model-Driven Architecture (MDA) principles of automatic generation of software systems based on model transformations. In this context, we present a transformation process and propose a visual and textual specification for the transformations using the forthcoming OMG standard Query /Views/ Transformations (QVT). Our proposal is illustrated by transformations involving elements of the UML-based Web Engineering (UWE) metamodel and the WebSA metamodel, showing this way how both approaches are integrated.	web application development	Santiago Meliá;Andreas Kraus;Nora Koch	2005		10.1007/11531371_59	metamodeling;unified modeling language;software architecture;model-driven architecture;web modeling;the internet;simulation;systems modeling;web design;computer science;software development;software engineering;database;web application development;world wide web;software system	SE	-46.804667911159264	22.64232822243108	138510
3cad472f1228a69e79003a7a19cb69650f1a81c9	adding a textual syntax to an existing graphical modeling language: experience report with grl		A modelling language usually has an abstract syntax e.g., expressed with a metamodel separate from its concrete syntax. The question explored in this paper is: how easy is it to add a textual concrete syntax to an existing language that offers only a concrete graphical syntax? To answer this question, this paper reports on lessons learned during the creation of a textual syntax supported by an editor and transformation tool for the Goal-oriented Requirement Language GRL, which is part of the User Requirements Notation standard. Our experiment shows that although current technologies help create textual modelling languages efficiently with feature-rich editors, there are important conflicts between the reuse of existing metamodels and the usability of the resulting textual syntax that require attention.		Vahdat Abdelzad;Daniel Amyot;Timothy Lethbridge	2015		10.1007/978-3-319-24912-4_12	natural language processing;abstract syntax;computer science;syntax;linguistics;programming language;homoiconicity;abstract syntax tree;syntax error	SE	-47.847771341873795	25.773827532694963	138538
ee779cd97900853b1eb9836a177eb057a14c254c	teletraffic system performance evaluation based on labview virtual instruments development	databases;instruments;system performance;artificial neural networks;servers;communications technology;conferences	This paper proposes and presents the structure and the functionality of new Virtual instruments developed for teletraffic system performance evaluation based on LABVIEW platform. The LABVIEW design platform, is widely use today for creation of virtual instruments, ensuring the operation of automated information systems for collecting, analyzing and processing data in real time. The developed new Virtual instruments are designed for statistical analysis of the performance parameters and for the impact of incoming traffic flow on them for different numbers of servers via using synthesized structures of artificial neural networks with backpropagation of error and classifier based on the adaptive neurofuzzy interface system (ANFIS).	adaptive neuro fuzzy inference system;artificial neural network;backpropagation;information system;labview;performance evaluation	Ivelina Balabanova;Georgi Georgiev;Rozalina Dimova;Stela Kostadinova	2016	2016 IEEE International Black Sea Conference on Communications and Networking (BlackSeaCom)	10.1109/BlackSeaCom.2016.7901593	embedded system;simulation;engineering;computer engineering	Visualization	-35.719628409112666	25.09957712328628	138558
92a8c780614f808513447c1f8fc809579e0820fd	introducing formal methods to software engineers through omg's cobra environment and interface definition language	distributed system;formal specification;tool support;software engineering;formal method;interface definition language	This paper talks about an ongoing project at Sun Microsystems Laboratories in which the interface definition language IDL of OMG's CORBA environment is extended with formal specification constructs. Tool support is provided to compile the specifications into code that can perform sanity checks to provide an added amount of security in a distributed system.	formal methods;interface description language;sms language;software engineer	Sriram Sankar	1996		10.1007/BFb0014307	interface description language;formal methods;object language;specification language;formal verification;computer science;formal specification;programming language	SE	-45.81792701967476	29.506342631746172	138814
f9de687d1d04171cb84937b4cdb4fa1a64070971	android malware familial classification and representative sample selection via frequent subgraph analysis		The rapid increase in the number of Android malware poses great challenges to anti-malware systems, because the sheer number of malware samples overwhelms malware analysis systems. The classification of malware samples into families, such that the common features shared by malware samples in the same family can be exploited in malware detection and inspection, is a promising approach for accelerating malware analysis. Furthermore, the selection of representative malware samples in each family can drastically decrease the number of malware to be analyzed. However, the existing classification solutions are limited because of the following reasons. First, the legitimate part of the malware may misguide the classification algorithms because the majority of Android malware are constructed by inserting malicious components into popular apps. Second, the polymorphic variants of Android malware can evade detection by employing transformation attacks. In this paper, we propose a novel approach that constructs frequent subgraphs (fregraphs) to represent the common behaviors of malware samples that belong to the same family. Moreover, we propose and develop FalDroid, a novel system that automatically classifies Android malware and selects representative malware samples in accordance with fregraphs. We apply it to 8407 malware samples from 36 families. Experimental results show that FalDroid can correctly classify 94.2% of malware samples into their families using approximately 4.6 sec per app. FalDroid can also dramatically reduce the cost of malware investigation by selecting only 8.5% to 22% representative samples that exhibit the most common malicious behavior among all samples.	algorithm;android;dataflow;malware analysis	Ming Fan;Jun Liu;Xiapu Luo;Kaixian Chen;Zhenzhou Tian;Qinghua Zheng;Ting Liu	2018	IEEE Transactions on Information Forensics and Security	10.1109/TIFS.2018.2806891	artificial intelligence;malware;android (operating system);computer science;pattern recognition;feature extraction;malware analysis;statistical classification	Security	-35.493725711941856	23.18102697638234	139640
157dcbd69a5e09048b1be79db1bdd86f9d27503a	deductive planning and plan reuse in a command language environment	command language;formal specification;automatische handlungsplanung;kunstliche intelligenz;deduktionssystem	In this paper we introduce a deductive planning system currently being develop ed as the kernel of an intelligent help system. It consists of a deductive planner and a plan reuse component and with that provides planning from first as well as planning from second principles . Both components rely upon an interval-based temporal logic. The deductive formalisms realizing plan formation from formal specifications and the reuse of already existing plans respectively are presented and demonstrated by examples taken from an operating system's domain .	application domain;automated planning and scheduling;axiomatic system;command language;control flow;frame problem;operating system;planner;temporal logic	Susanne Biundo-Stephan;Dietmar Dengler;Jana Koehler	1992			computer science;formal specification;database;programming language	AI	-40.19886540864046	27.14356552823627	139861
398715419ec58b3ebe75940e40d7bba9e522d770	on combining semiformal and formal object specification techniques	formal specification language;design technique;software development	In the early phases of software development it seems profitable to freely mix semi-formal and formal design techniques. Formal techniques have their strength in their ability to rigorously define desired software qualities like functionality, whereas semi-formal methods are usually said to be easier to understand and to be more human-nature oriented. We propose a new approach in order to combine these two areas by exploiting how constructs of the formal specification language TROLL light are related to the graphical elements of the UML approach.		Martin Gogolla;Mark Richters	1997		10.1007/3-540-64299-4_37	b-method;formal methods;object language;specification language;formal verification;computer science;software development;formal specification;refinement;programming language;programming language specification;language of temporal ordering specification	SE	-46.2918802680455	29.42269695731762	139966
ae70f46c0cf9e29faaee931184683e37d11f1691	facilitating collaboration in a distributed software development environment using p2p architecture	discussion paper	This paper describes efforts to facilitate collaborative work in a distributed environment by providing infrastructure that facilitates the understanding of inter-connected processes involved and how they interact. In this work we describe how our agent-based framework supports these. This distributed work environment makes use of both P2P and client-server architectures. Using an example of developing an open source software system, we explain how a collaborative work environment can be achieved. In particular we address how the support for coordination, collaboration and communication are provided using our framework.	agent-based model;client–server model;integrated development environment;open-source software;peer-to-peer;server (computing);software development;software system	Maryam Purvis;Martin K. Purvis;Bastin Tony Roy Savarimuthu	2006		10.1007/978-3-540-79705-0_16	human–computer interaction;systems engineering;engineering;knowledge management	SE	-41.718848597049	20.22933081264428	140048
7ffe998f8e4a4ced44a5842a25b0c7af6343046b	handling conflicts in autonomous coordination of distributed collaborative activities	protocols;organizations clocks history fires protocols floods privacy;disaster response;history;distributed collaborative activity;clocks;telephone;handling conflict;inter organizational process management;fax;information exchange;autonomous coordination;organizations;floods;point of view;fires;distributed collaboration;inter organizational process management handling conflict autonomous coordination distributed collaborative activity disaster response information exchange e mail telephone fax;e mail;privacy;electronic data interchange	Coordination between different organizations in dynamic situations, such as a disaster response, is challenging. Organizations are autonomous and coordinate the situation from their point of view. There is no central authority to coordinate all operations. To coordinate their actions, organizations need to exchange information on what they are doing. However, they cannot share everything with everybody due to privacy, regulatory or strategic reasons. Currently, only e-mail, telephone or fax are used to exchange information. This makes detecting and handling of conflicting views on the situation very difficult. We propose an approach for inter-organizational process management for these kinds of dynamic scenarios. It allows different organizations to share selected activities by replicating them in the different workspaces of the organizations. State changes of shared activities are propagated optimistically. We explain detecting and handling of two different types of conflicts that can occur in this setting. We provide an implementationand interviews to validate the concepts.	autonomous robot;email;experiment;fax;hoc (programming language);optimistic concurrency control;organizational behavior;privacy;propagation of uncertainty;sensor;social network;software propagation;workspace	Jörn Franke;François Charoy;Cedric Ulmer	2011	2011 IEEE 20th International Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprises	10.1109/WETICE.2011.73	communications protocol;information exchange;computer science;organization;knowledge management;artificial intelligence;operating system;software engineering;electronic data interchange;database;distributed computing;management;privacy;world wide web;computer security	Vision	-39.41956562998306	18.53161454006172	140063
408c65a51a7cd216c31fb4f9b834173cd46258c9	enhancing peer-to-peer collaboration using trust	p2p system;trust;distributed system;multi agent system;cooperation;hd28 management industrial management;reputation;qa76 electronic computers computer science computer software;qa75 electronic computers computer science;agents;autonomous agent;peer to peer;tk electrical engineering electronics nuclear engineering	Distributed systems generally require their component parts to interact cooperatively, in order for the system as a whole to function effectively. For any given activity, there are typically several alternative components that have the required capabilities. In decentralised systems, where there is no overarching control, individual components are responsible for selecting other components with which to cooperate. However, the candidate components may be unreliable or dishonest, and are typically locally controlled. Such decentralised systems can be viewed as multi-agent systems, comprising autonomous agents that must cooperate for the system to be effective. Peer-topeer (P2P) systems are a subclass of decentralised distributed systems, in which not only is there no overarching control, but neither is there any hierarchy of control, power, or responsibly among the system components. Selecting appropriate peers to cooperate with is a challenging problem, since the candidate peers are autonomous and may be unreliable or dishonest. Peers need a mechanism for task delegation that takes the uncertainly of interactions into account. In this paper we present a mechanism, called MDT-R, that enables peers to delegate activities appropriately, using trust and the recommendations of other peers to meet individual preferences, such as minimising risk and maximising quality. 2006 Elsevier Ltd. All rights reserved.	autonomous agent;autonomous robot;decentralised system;distributed computing;genetic algorithm;interaction;model-based testing;multi-agent system;norm (social);peer-to-peer;prototype;simulation;systems design	Nathan Griffiths	2006	Expert Syst. Appl.	10.1016/j.eswa.2006.01.017	simulation;reputation;computer science;artificial intelligence;autonomous agent;software agent;multi-agent system;distributed computing;trustworthy computing;computer security;cooperation	AI	-43.44267443374258	19.329934823053524	140557
08a826adf9feb095d8f4982e0dd1ef10671fb3b3	sesa: emerging technology for service-centric environments	developpement logiciel;web service description language;service centric information systems;sesa;information systems;web service modelling ontology;service information;wsdl;web services information systems middleware semantic web software architecture;sesa technology;sesa technology soap wsdl middleware semantically enabled soa service centric information systems semantic web service technologies service oriented architectures;semantics;semantically enabled soa;service ontology;service oriented architectures;soa;soap;web service;semantica;semantique;orientado servicio;emerging technology;service oriented architecture web services ontologies middleware business communication mediation software systems computer architecture logic programming profession;software architecture;wsmo;web service modeling ontology;desarrollo logicial;software development;web services;semantic web;servicio informacion;middleware;oriente service;information service;information system;service oriented architecture;semantic web service technologies;wsmo web services service ontology semantic web problem solving service oriented architecture soa semantically enabled soa sesa web service modeling ontology;article;systeme information;problem solving;service oriented;sistema informacion	Service-oriented architectures - and particularly the Web service technologies that enable them, such as WSDL (Web Services Description Language) and SOAP - are widely acknowledged for their potential to revolutionize computing. However, existing SOAs will prove difficult to scale without a proper degree of automation. SOAs' success depends on resolving fundamental challenges that existing SOA technologies don't sufficiently address: search, integration, and mediation. Extending service-oriented architectures with semantics can help create service-centric information systems that better adapt to changes throughout software systems' lifetime.	information system;soap;service-oriented architecture;service-oriented device architecture;software system;web services description language;web service;world wide web	Tomas Vitvar;Michal Zaremba;Matthew Moran;Maciej Zaremba;Dieter Fensel	2007	IEEE Software	10.1109/MS.2007.178	web service;computer science;knowledge management;service-oriented architecture;database;semantics;world wide web;information system	SE	-47.69283771251053	18.999680834644334	140615
29da52b176f7ed828391f3649b47e6abd662a256	precise modelling of compensating business transactions and its application to bpel	formal specification;b method;formal semantics	We describe the StAC language which can be used to specify the orchestration of activities in long running business transactions. Long running business transactions use compensation to cope with exceptions. StAC supports sequential and parallel behaviour as well as exception and compensation handling. We also show how the B notation may be combined with StAC to specify the data aspects of transactions. The combination of StAC and B provides a rich formal notation which allows for succinct and precise specification of business transactions. BPEL is an industry standard language for specifying business transactions and includes compensation constructs. We show how a substantial subset of BPEL can be mapped to StAC thus demonstrating the expressiveness of StAC and providing a formal semantics for BPEL.	angelic layer;b-method;business process execution language;centrality;declarative programming;exception handling;html tidy;identifier;linear algebra;misra c;modeling language;operational semantics;operators in c and c++;orc;orchestration (computing);parallel computing;process-oriented programming;production (computer science);semantics (computer science);service composability principle;speculative execution;task parallelism;technical standard;unbounded nondeterminism;web service	Michael J. Butler;Carla Ferreira;Muan Yong Ng	2005	J. UCS	10.3217/jucs-011-05-0712	b-method;real-time computing;computer science;formal semantics;formal specification;database;programming language	DB	-42.43210464067287	28.148705947569447	140623
da2fb592ea1d783b57286e93af408e4a278b4a06	a formal model for service-oriented interactions	temporal logic;formal methods;journal article;service oriented computing;conversational protocols;orchestration;labelled transition systems	In this paper, we provide a mathematical semantics for a fragment of a language — SRML— that we have defined in the IST-FET-GC2 Integrated Project SENSORIA for modelling service-oriented systems. The main goal of this research is to make available a foundational basis for the development of practical modelling languages and tools that designers can use to model complex services at a level of abstraction that captures business functionality independently of the languages in which services are implemented and the platforms in which they execute. The basic artefact of the language is the service module, which provides a model for a complex service in terms of a number of components that jointly orchestrate a business function and may dynamically discover and bind to external parties that can deliver required functionalities. We define a mathematical model of computation and an associated logic for service-oriented systems based on the typical business conversations that occur between the parties that deliver a service. We then define the semantics of SRML service modules over this model and logic, and formulate a property of correctness that guarantees that services programmed and assembled as specified in a module provide the business functionality advertised by that module. Finally, we define an algebraic operation of composition of service modules that preserves correctness. To the best of our knowledge, there is no other formal approach that has been defined from first principles with the aim of capturing the business nature of service conversations and support service assembly based on the business logic that is required, not as it is programmed.	business logic;correctness (computer science);denotational semantics;interaction;mathematical model;model of computation;modeling language;service-oriented architecture;service-oriented device architecture	José Luiz Fiadeiro;Antónia Lopes;João Abreu	2012	Sci. Comput. Program.	10.1016/j.scico.2011.12.003	formal methods;temporal logic;computer science;knowledge management;theoretical computer science;service-oriented architecture;orchestration;programming language	DB	-43.34018767522552	23.91376172094082	140714
2e525ac71ba97272afdd5e733ee19bcfbc2cb2d5	rhapsody: a complete life-cycle model-based development system	developpement logiciel;outil logiciel;life cycle model;software tool;ciclo desarrollo;life cycle;lenguaje uml;production system;metodo formal;methode formelle;model based approach;langage modelisation unifie;modeling language;formal method;herramienta controlada por logicial;desarrollo logicial;unified modelling language;software development;cycle developpement;software development tools;model based testing	We discuss Rhapsody, a UML based software development tool, designed to support complete model-based iterative life-cycle. First, we identify several key inhibiting factors that prevent model-based approaches from being adopted as a mainstream practice.We then examine the requirements for allowing complete life-cycle model-based development and discuss how they are met by Rhapsody through its key enabling technologies, which include: - model-code associativity - automated implementation generation - implementation framework - model execution - model-based testingWe explain why each of these features is instrumental to an effective development of production systems, based on a key observation that the modeling language does not replace the implementation platform, but should be integrated with it in a synergistic manner. This allows the use of modeling for expressing requirements and design abstractions, along with the use of the full power of an implementation language and its supporting platform to specify implementation details. While allowing this flexibility, Rhapsody facilitates full consistency of the modeling and implementation artifacts throughout the life-cycle, and it also supports a high level of automation in the implementation and validation of the developed system.	apple rhapsody	Eran Gery;David Harel;Eldad Palachi	2002		10.1007/3-540-47884-1_1	unified modeling language;biological life cycle;model-based testing;simulation;formal methods;computer science;software development;software engineering;production system;modeling language;algorithm	Robotics	-42.87619113595023	26.653543242023584	140754
5ea22e265d31c6260595539addfebfda05dd2b56	performance analysis of computer virus detection from binary code using ensemble classifier		This paper presents the analysis of using data mining to detect unseen viruses. The supervised learning of ensemble classifiers, random forest and extreme gradient boosting, are being explored. The features consist of n-gram bytecode, n-gram opcode and basic-block opcode. Each feature is selected from top 8,192 attributes using term frequency-inverse document frequency. Half of the attributes are recursively removed by recursive feature elimination with 4-fold cross-validation. Every step of attribute removal is evaluated by 10-fold cross-validation. F1-score is used as a measurement for virus detection. Our data set contains 6,319 portable executable files. The result shows that data with more than 128 attributes achieve more than 0.936 F1-score for every model. Also, extreme gradient boosting is 66.33% faster using 256 attributes and 164.8% faster using 128 attributes compared to random forest. Moreover, trained model of extreme gradient boosting is smaller than random forest. However, random forest learns faster than extreme gradient boosting at that same number and types of features.	antivirus software;basic block;binary code;computer virus;cross-validation (statistics);data mining;ensemble learning;f1 score;gradient boosting;n-gram;opcode;profiling (computer programming);random forest;recursion;supervised learning;tf–idf	Prasit Usaphapanus;Krerk Piromsopa	2017		10.1145/3163080.3163110	binary code;computer virus;supervised learning;bytecode;opcode;gradient boosting;portable executable;random forest;pattern recognition;artificial intelligence;computer science	ML	-35.58457733108662	23.105987272511666	140816
b23f777408cf9d2cb27738aa415d868a777c2489	source code analysis with a temporal extension of first-order logic		Formal methods and static analysis are widely used in software development, in particular in the context of safety-critical systems. They can be used to prove that the software behavior complies with its specification: the software correctness. In this article, we address another usage of these methods: the verification of the quality of the source code, i.e., the compliance with guidelines, coding rules, design patterns.	first-order logic;first-order predicate	David Come;Julien Brunel;David Doose	2018		10.1007/978-3-030-03044-5_3	programming language;first-order logic;formal methods;software;source code;software design pattern;correctness;software development;static analysis;computer science	Logic	-44.62393756340351	30.64300668976825	141032
62cc2bc86af2b3dec8d4bb9ebec988822d8c4d09	resolute: an assurance case language for architecture models	aadl;languages;reliability;architecture models;assurance case;avionics	Arguments about the safety, security, and correctness of a complex system are often made in the form of an assurance case. An assurance case is a structured argument, often represented with a graphical interface, that presents and supports claims about a system's behavior. The argument may combine different kinds of evidence to justify its top level claim. While assurance cases deliver some level of guarantee of a system's correctness, they lack the rigor that proofs from formal methods typically provide. Furthermore, changes in the structure of a model during development may result in inconsistencies between a design and its assurance case. Our solution is a framework for automatically generating assurance cases based on 1) a system model specified in an architectural design language, 2) a set of logical rules expressed in a domain specific language that we have developed, and 3) the results of other formal analyses that have been run on the model. We argue that the rigor of these automatically generated assurance cases exceeds those of traditional assurance case arguments because of their more formal logical foundation and direct connection to the architectural model.	complex system;correctness (computer science);domain-specific language;formal methods;graphical user interface	Andrew Gacek;John D. Backes;Darren D. Cofer;Konrad Slind;Mike Whalen	2014		10.1145/2663171.2663177	avionics;computer science;programming language;algorithm	SE	-44.481100548797315	28.21857647199872	141167
a24fdf7ee3be46da469d1447bd9b7585bfa28bfb	requirements-driven verification of wsbpel processes	event calculus;tool support;temporal logic;web services protocols ontologies proposals calculus system recovery testing process design monitoring publishing;web service;process design;web service composition;event calculus requirements driven verification wsbpel processes web service composition;formal verification;web services;web services formal verification temporal logic;wsbpel processes;data flow;requirements driven verification	Current Web services composition proposals, such as BPML, WSBPEL, WSCI, and OWLS, provide solutions for describing the control and data flows in Web service composition. However, such proposals remain at the descriptive level, without providing any kind of mechanisms or tool support for analysis and verification. Therefore, there is a growing interest for the verification techniques which enable designers to test and repair design errors even before actual running of the service, or allow designers to detect erroneous properties and formally verify whether the service process design does have certain desired properties. In this paper, we propose to verify Web services composition using an event driven approach. We assume Web services that are coordinated by a composition process expressed in WSBPEL and we use event calculus to specify the properties and requirements to be monitored.	business process modeling language;event calculus;requirement;service composability principle;web service	Mohsen Rouached;Claude Godart	2007	IEEE International Conference on Web Services (ICWS 2007)	10.1109/ICWS.2007.153	web service;web modeling;computer science;ws-policy;data mining;database;law;world wide web	SE	-45.932420569564954	18.300443436363782	141257
1c32ea1bf2d32b97d569857fb9f4426dbaa3b8be	argumentation and artifact for dialogue support	multi agent system;software agent;tuple space;col	Intelligent and autonomous software agents may engage in dialogue and argument with one another, and much recent research has considered protocols, architectures and frameworks for this. Just as with human dialogues, such agent dialogues may be facilitated by the presence of a mediator, able to summarise different positions, identify common assumptions and inconsistencies, and make appropriate interventions in the dialogue. Drawing on the theory of co-ordination artifacts in multi-agent systems, we propose a formal framework to explicitly represent the functions of a mediator artifact. We then describe an implementation of this framework using the TuCSoN coordination infrastructure for MAS, where the mediator artifact is realised by a tuple centre—a programmable tuple space.	autonomous robot;dns certification authority authorization;dialog system;matchware mediator;multi-agent system;prototype;software agent;software framework;tuple space;visual artifact	Enrico Oliva;Mirko Viroli;Andrea Omicini;Peter McBurney	2008		10.1007/978-3-642-00207-6_7	computer science;knowledge management;artificial intelligence;communication	AI	-42.27007032267909	19.37388496119675	141346
cadafd404adf30a2ed13c6e1321a02d78a70205d	peer-to-peer and multi-agent systems technologies for knowledge management applications. an agent-oriented analysis	multi agent system;p2p;knowledge management	This paper focuses on a framework for developing knowledge management (KM) applications that integrates peer-to-peer (P2P) and multi-agent systems (MAS) technologies. The objective of this framework is to support a particular KM paradigm that emphasizes aspects such as autonomy and distributedness of knowledge sources. In particular, we present a characterization of peer-to-peer in terms of a general architectural pattern and a set of guidelines for designing peer-to-peer applications according to the proposed framework. We adopt an agent-oriented approach that extends Tropos, a software engineering methodology introduced in earlier papers.	architectural pattern;autonomy;knowledge management;multi-agent system;peer-to-peer;programming paradigm;software development process;software engineering	Davide Bertolini;Paolo Busetta;Michele Nori;Anna Perini	2002			computer-aided technologies;peer-to-peer;multi-agent system;knowledge management;computer science	DB	-43.775479812329166	20.44547577058283	141411
c27e59250a29e8a5ebfffaeb099abb5a4c44c3a7	some ownership management issues in distributed simulation using hla/rti	telecommunications	Modelling and Simulation (Mu0026S) is a multi-disciplinary field that is widely used in various domains. It provides a means to study complex systems before actual physical prototyping and helps lowering, amongst others, manufacturing and training costs. However, as Mu0026S gains more popularity, the demand on reducing time and resource costs associated with development and validation of simulation models has also increased. Composing simulation models of reusable and validated simulation components is one approach for addressing the above demand. This approach, which is still an open research issue in Mu0026S, requires a composition process that is able to support a modeller with discovery and identification of components as well as giving feedback on feasibility of a composition. Combining components in order to build new simulations raise the non-trivial issue of composability. Composability has been defined as the capability to select and assemble reusable simulation components in various combinations into simulation systems to meet user requirements. There are three main types of composability, syntactic, semantic and pragmatic. Syntactic composability is concerned with the compatibility of implementation details, such as parameter passing mechanisms, external data accesses, and timing mechanisms. It is the question of whether a set of components can be combined. Semantic composability, on the other hand, is concerned with the validity of the composition, and whether the composed simulation is meaningful. Pragmatic composability is yet another type which is concerned with the context of the simulation, and whether the composed simulation meets the intended purpose of the modeller. Of these three types syntactic composability is easiest to accomplish and some significant progresses on this issue have been reported in the literature. Semantic and pragmatic composability are much harder to achieve and has inspired many researchers to conduct both theoretical and experimental research. The Base Object Model (BOM) is a new concept identified within Mu0026S community as a potential facilitator for providing reusable model components for the rapid construction and modification of simulations. Although BOMs exhibit good capabilities for reuse and composability they lack the required semantic information for semantic matching and composition. There is little support for defining concepts and terms in order to avoid ambiguity, and there is no method for matching behaviour of conceptual models (i.e., state machines of the components), which is required for reasoning about the validity of BOM compositions. In this work we have developed a framework for component-based model development that supports both syntactic and semantic composability of simulation models by extending the BOM concept using ontologies, Semantic Web and Web Services technologies, and developing a rule-based method for reasoning about BOM compositions. The issue of pragmatic composability has not been the focus of this work, and it has only been partly addressed. The framework utilises intelligent agents to perform discovery and composition of components, according to the modeller needs. It includes a collaborative environment, a semantic distributed repository and an execution environment to support model development and execution process. The basic assumption of this work is that semantic composability should be achieved at conceptual level. Through precise definition and specification of components’ semantic and syntax one can capture the basic requirements for matching and semantically meaningful composition of those components. This requires a common methodology for specification of simulation components. The specification methodology consists of meta-models describing simulation components at different levels. In order to enable automatic matching of meta-models they are formalized and structured using Semantic Web technology in OWL (Web Ontology Language). Hence, the models are based on ontologies to avoid misunderstanding and to provide unambiguous definitions as a basis for reasoning about syntactic and semantic validity of compositions.	run-time infrastructure (simulation);simulation	Farshad Moradi;Rassul Ayani;Gary S. H. Tan	2001	Scalable Computing: Practice and Experience		simulation;engineering;operations management;computer security	HPC	-41.923913091238845	22.011118139073787	141718
3e5bb5de7a42103bf3cef24a7b7673c00d5b7ae6	miningzinc: a modeling language for constraint-based mining	constraint based mining;data mining;constraint programming;modeling	We introduce MiningZinc, a general framework for constraint-based pattern mining, one of the most popular tasks in data mining. MiningZinc consists of two key components: a language component and a toolchain component. The language allows for high-level and natural modeling of mining problems, such that MiningZinc models closely resemble definitions found in the data mining literature. It is inspired by the Zinc family of languages and systems and supports user-defined constraints and optimization criteria. The toolchain allows for finding solutions to the models. It ensures the solver independence of the language and supports both standard constraint solvers and specialized data mining systems. Automatic model transformations enable the efficient use of different solvers and systems. The combination of both components allows one to rapidly model constraint-based mining problems and execute these with a wide variety of methods. We demonstrate this experimentally for a number of well-known solvers and data mining tasks.	algorithm;constraint programming;data mining;declarative programming;emergence;experiment;high- and low-level;machine learning;mathematical optimization;model transformation;modeling language;software development process;solver;the australian;toolchain	Tias Guns;Anton Dries;Guido Tack;Siegfried Nijssen;Luc De Raedt	2013			concept mining;constraint programming;systems modeling;constraint satisfaction;computer science;theoretical computer science;machine learning;data mining;data stream mining;programming language	AI	-44.8394994339538	25.075908735825394	141778
2d4a73b1bdbc3cfdfe0af6230bb2498ed0560f90	validated code generation for activity diagrams	developpement logiciel;modelizacion;activity diagram;programming environment;diagrama actividad;red petri;lenguaje uml;generation code;sintesis mecanismo;lenguaje sincronico;generacion lenguaje;generacion codigo;distributed computing;code generation;semantics;langage modelisation unifie;synchronous language;program verification;synthese mecanisme;semantica;semantique;langage synchrone;modelisation;medio ambiente programacion;verificacion programa;internet;desarrollo logicial;unified modelling language;software development;calculo repartido;generation langage;mechanism synthesis;diagramme activite;model based design;verification programme;petri net;modeling;calcul reparti;reseau petri;environnement programmation;language generation	Beyond the development of client-server, warehouse and decision support applications and the implementation of supporting infrastructure, IM managers are faced with the challenge of managing and maintaining the corporate information holding. A major component of this challenge relates to conversion / transition of legacy and transaction data to the confines of the reengineered transaction or information warehouse systems. and verification key interface components and integrated error reporting and correction. • Direct involvement of Functional (Business) Analysts in the interface design process. • Direct involvement of Security Analysts in the design GUARDS and FILTERS to protect the Security, Privacy and Confidentiality of information. • Development and maintenance of critical data interfaces is simplified through the graphical design tools and automated SQL generation. • Capture of security classification, considerations and constraints built into the interface design and • Reverse engineering of legacy systems through standard IAD interfaces to commercially available development and reengineering tools. • Cross-platform Conversion support facilitates the loading of target system / applications from multiple source applications and electronic storage media. • Data Conversion interface is now defined and documented as part of the design process and stored in the corporate metadata repository in conjunction with other repository information. • Interface metadata is managed, validated and maintained using the same QA and CM practices as other corporate metadata. • Data validation is achieved through the use of business rules and referential integrity defined during the design of the target system. • Automatic production of design, QA and Security documentation.	activity diagram;client–server model;code refactoring;confidentiality;data validation;decision support system;documentation;exception handling;graphical user interface;guard (computer science);iad;legacy system;metadata repository;referential integrity;reverse engineering;sql;server (computing);software quality assurance;transaction data	A. K. Bhattacharjee;R. K. Shyamasundar	2005		10.1007/11604655_57	unified modeling language;the internet;systems modeling;activity diagram;computer science;artificial intelligence;software development;distributed computing;semantics;programming language;petri net;algorithm;code generation	HCI	-41.60446546876346	25.440426627710316	141815
aeb85d53bbcb4e98db548afb649654153e2d6ecb	advanced local checking of global consistency in heterogeneous multimodeling		Software design requires deployment of interdependent models conforming to different metamodels. This set of models is called a multimodel, and it must satisfy a set of global constraints regulating interaction of the multimodel components. A straightforward approach to global consistency checking would require merging component metamodels modulo their overlap, adding, perhaps, new global constraints to this merge, merging component models modulo their overlap, and checking the latter merge against the constraints in the former one. Being a natural definition for global consistency, these steps can not be used algorithmically because of two major practical drawbacks: they involve costly (meta)model matching to specify overlaps, and require building big and unfeasible merged metamodels and models. The present paper makes two contributions. First, it presents a new algorithm to check each global constraint individually, and as local as possible, i.e., only using those (meta)model elements that affect the validity of the constraint. Second, it develops a mathematical foundation that allows us to formally prove that this individual local consistency checking is sound and complete w.r.t. the definition of global consistency.	algorithm;diagram;digital photo frame;global optimization;graphical user interface;interdependence;local consistency;mathematical optimization;metamodeling;modulo operation;object constraint language;software deployment;software design;turing completeness	Harald König;Zinovy Diskin	2016		10.1007/978-3-319-42061-5_2	software deployment;systems engineering;local consistency;merge (version control);computer science;theoretical computer science;metamodeling;data mining;software design;modulo	AI	-44.08616523705512	27.33591197594923	141920
7f0c82214045c1cc730789b2dcebb650c15fdbb9	analyzing critical decision-based processes	model verification;institutional repositories;analytical models;patient treatment cancer decision trees formal languages formal specification multi agent systems;cancer therapy critical decision based process analysis tool supported techniques partial models environment state incomplete decisions nondeterministic task selections unreachable tasks process paths nonfunctional process requirement violation event based models state based invariants formal language event based specification state based specification process modeling language informal flowcharts high level message sequence charts task related variables environment related variables task compositions task refinements decision trees multiagent communication scenarios time constraints resource constraints;formal specification;fedora;cancer;formal specification process modeling process analysis model verification decision errors safety critical workflows non functional requirements domain specific languages;safety critical workflows;semantics;formal languages;decision errors;vital;non functional requirements;multi agent systems;process modeling;blood;unified modeling language;analytical models unified modeling language algorithm design and analysis semantics blood flowcharts medical treatment;patient treatment;vtls;process analysis;medical treatment;decision trees;flowcharts;algorithm design and analysis;ils;domain specific languages	Decision-based processes are composed of tasks whose application may depend on explicit decisions relying on the state of the process environment. In specific domains such as healthcare, decision-based processes are often complex and critical in terms of timing and resources. The paper presents a variety of tool-supported techniques for analyzing models of such processes. The analyses allow a variety of errors to be detected early and incrementally on partial models, notably: inadequate decisions resulting from inaccurate or outdated information about the environment state; incomplete decisions; non-deterministic task selections; unreachable tasks along process paths; and violations of non-functional process requirements involving time, resources or costs. The proposed techniques are based on different instantiations of the same generic algorithm that propagates decorations iteratively through the process model. This algorithm in particular allows event-based models to be automatically decorated with state-based invariants. A formal language supporting both event-based and state-based specifications is introduced as a process modeling language to enable such analyses. This language mimics the informal flowcharts commonly used by process stakeholders. It extends High-Level Message Sequence Charts with guards on task-related and environment-related variables. The language provides constructs for specifying task compositions, task refinements, decision trees, multi-agent communication scenarios, and time and resource constraints. The proposed techniques are demonstrated on the incremental building and analysis of a complex model of a real protocol for cancer therapy.	algorithm;decision theory;decision tree;flowchart;formal language;generic programming;message sequence chart;modeling language;multi-agent system;process modeling;requirement;unreachable memory	Christophe Damas;Bernard Lambeau;Axel van Lamsweerde	2014	IEEE Transactions on Software Engineering	10.1109/TSE.2014.2312954	unified modeling language;algorithm design;formal language;real-time computing;flowchart;computer science;systems engineering;domain-specific language;theoretical computer science;operating system;software engineering;decision tree;process modeling;formal specification;semantics;programming language;non-functional requirement;cancer	SE	-43.24332001962932	31.627613519170286	141958
36f617b50549bc1eecdc48c74b726ca2941cae2b	web modeling languages strike back	standards;interaction flow modeling language web software ifml omg standards;ifml;web modeling approach web modeling language object management group interactive applications development interaction flow modeling language ifml;simulation languages internet;omg;internet;simulation languages;web software;interaction flow modeling language	The Object Management Group has adopted a new standard for interactive applications development, the Interaction Flow Modeling Language (IFML). The author briefly analyzes this new standard's importance and its relationship with other Web modeling approaches.	web modeling	Gustavo Rossi	2013	IEEE Internet Computing	10.1109/MIC.2013.78	web modeling;the internet;web standards;computer science;database;modeling language;programming language;law;world wide web	Visualization	-48.04703000463471	21.31878960933053	142002
b6db3616f9e1531e9d938fab1189bef77be52b27	modeling the characteristics of system of systems	systems analysis digital simulation multi agent systems;belonging;system engineering;systems;theoretical model;model system;agent based model;systems engineering;system of systems;systems engineering characteristic modeling system of systems agent based modeling simulation;autonomy;data mining;agent based model systems system of systems autonomy belonging connectivity modeling;characteristic modeling;connectors;multi agent systems;computational modeling;systems engineering and theory laboratories convergence mathematical model faa cities and towns airports concrete context modeling fluctuations;agent based modeling simulation;systems analysis;mathematical model;connectivity;modeling;context;digital simulation	The term system of systems (SoS) has become a quite common expression with no single accepted definition. Based on analysis [1], five characteristics have been identified from an assortment of SoS descriptions. These characteristics are named autonomy, belonging, connectivity, diversity, and emergence, whose degrees of strength determines the foundation of any SoS. To utilize these characteristics, concrete definitions are presented in context and then applied to the development of a theoretical model. The resulting model forms the basis of a generic SoS instantiated as an agent-based modeling simulation. This simulation demonstrates the appropriateness of the characteristics and can be used to explore further aspects of a SoS. Modeling and experimenting on these characteristics will contribute to the field of systems engineering by providing a means to increase our understanding of SoS.	agent-based model;apple sos;emergence;experiment;norm (social);simulation;system of systems;systems engineering;theory	W. Clifton Baldwin;Brian J. Sauser	2009	2009 IEEE International Conference on System of Systems Engineering (SoSE)		systems analysis;simulation;systems modeling;system of systems;computer science;systems engineering;engineering;artificial intelligence;connectivity;multi-agent system;mathematical model;system;autonomy;computational model	SE	-40.42220973901929	21.940786888295072	142011
5af33cdcdcaae45d0b8c45c47ff6cc758414d1d5	exploiting automatic analysis of e-commerce protocols	protocols;reliability;electronic commerce;formal model;application software;availability;uml;e commerce;logic;formal methods;e commerce protocols;netbill e commerce protocols availability reliability formal verification techniques uml formalism auml protocol diagrams visual modeling model checking e commerce protocol;formal verification electronic commerce protocols reliability specification languages;auml protocol diagrams;formal verification;formal verification techniques;spin promela;internet;visual modeling;model checking;design and implementation;specification languages;error correction;netbill;business;unified modeling language;agent uml;e commerce protocol;protocols application software unified modeling language availability business internet logic programming error correction laboratories;uml formalism;programming	While e-commerce continuously grows prosperous, some advantages e-commerce applications claimed haven’t really been gained. More seriously, the availability and reliability of these systems are particularly hard to obtain. The e-commerce protocols, as the core of e-commerce applications, ask for new development approach and techniques to be introduced for their highly reliable and safe design and implementation. This paper describes research on synthesis of extended UML formalism and ,formal verification techniques for automatic development of e-commerce protocols. In this paper, we refine AUML protocol diagrams for visual modeling, and develop algorithm and rules to translate visually modeled ecommerce protocols into formal models that are then validated using model checking. This approach is applied to the design of an e-commerce protocol -NetBill as exemplification. Our objective is to create tools that enable designers to automatically develop available arid reliable e-commerce protocols.	arid;algorithm;diagram;e-commerce;exemplification;formal system;formal verification;model checking;unified modeling language;visual modeling	Jun Wei;Shing-Chi Cheung;Xu Wang	2001		10.1109/CMPSAC.2001.960598	e-commerce;unified modeling language;computer science;theoretical computer science;database;programming language	Logic	-44.49228023126209	30.611445044746038	142017
2a48812f6c4dd0c2ae8a493fc9d77389f7376a80	a product derivation tool based on model-driven techniques and annotations	generative programming;product derivation tools;software product lines;d.2.13;model-driven development categories: d.2.3;generic programming	In this paper, we present a model-based tool for product derivation. Our tool is centered on the definition of three models (feature, architecture and configuration models) which enable the automatic instantiation of software product lines (SPLs) or frameworks. The Eclipse platform and EMF technology are used as the base for the implementation of our tool. A set of specific Java annotations are also defined to allow generating automatically many of our models based on existing implementations of SPL architectures. We illustrated the use and validation of our tool in the preparation of the automatic derivation of the JUnit framework and a J2ME games product line.	aspectj;automatic programming;code refactoring;eclipse modeling framework;emoticon;feature model;junit;java annotation;library (computing);model-driven integration;osgi;parsing;partial template specialization;software framework;software product line;universal instantiation	Elder Cirilo;Uirá Kulesza;Carlos José Pereira de Lucena	2008	J. UCS	10.3217/jucs-014-08-1344	data mining;feature model;implementation;theoretical computer science;software;programming language;java annotation;architecture;computer science;software product line;generic programming;derivation	SE	-48.11992570166436	27.037022801332295	142055
d900055e7e8480ae773bbb0886ccdea587a8b02f	a method for verifiable and validatable business process modeling	activity diagram;rule based;process design;business process model;expressive power;business process modeling notation;business process	We define an extensible semantical framework for business process modeling notations. Since our definition starts from scratch, it helps to faithfully link the understanding of business processes by analysts and operators, on the process design and management side, by IT technologists and programmers, on the implementation side, and by users, on the application side. We illustrate the framework by a high-level operational definition of the semantics of the BPMN standard of OMG. The definition combines the visual appeal of the graph-based BPMN with the expressive power and simplicity of rule-based modeling and can be applied as well to other business process modeling notations, e.g. UML 2.0 activity diagrams.	activity diagram;business process execution language;business process model and notation;child process;coloured petri net;coreasm;exception handling;fundamental pattern;high- and low-level;hoc (programming language);interrupt;iteration;java;logic programming;operational definition;principle of abstraction;process modeling;programmer;programming language;refinement (computing);rule-based modeling;timer;unified modeling language;workflow pattern	Egon Börger;Bernhard Thalheim	2007		10.1007/978-3-540-89762-0_3	rule-based system;process design;business domain;activity diagram;computer science;systems engineering;engineering;knowledge management;artifact-centric business process model;business process management;function model;process driven development;process modeling;database;business process model and notation;business process;process mining;business process discovery;business rule;business process modeling;expressive power;business architecture	SE	-45.19104409058309	24.500915353992806	142208
67cbee6e1ceb89d4ba30517057e55aaa600df862	a generic framework supporting self-organisation and self-management in hierarchical systems		A novel, generic, framework for supporting self-organisation and self-management in hierarchical systems is presented. The framework allows for the incorporation of local self-organising and self-managing strategies at each level in the hierarchy. These local strategies determine the behaviour of that level and the effects of these strategies can be communicated to, and used by, the strategies in adjacent levels of the hierarchy. Thus, in general, strategies may be viewed as parameterised functions. Information emanating from both the lower and the upper levels in the hierarchy can be used as parameters. Information from below represents the status of the lower levels, whereas information from above can be used to influence the direction and the rate of system evolution. As the component parts of the system evolve to their goal states, the rate of evolution slows. At that point, by definition, a component is maximally contributing to the global goal state of the system as a whole. A novel concept to measure the distance that a component is from this stasis, its Suitability Index is presented and formally defined. Although the proposed framework can be generalised to any hierarchical system, this paper applies it specifically to large scale, hierarchically structured, computer systems. An implementation of this framework and an empirical study of its effectiveness has been conducted as part of the the CloudLightning Project.	project xanadu;quality of service;self-management (computer science);self-organization;simulation;software propagation;vergence	C. K. Filelis-Papadopoulos;Huanhuan Xiong;Adrian Spataru;Gabriel G. Castañé;Dapeng Dong;George A. Gravvanis;John P. Morrison	2017	2017 16th International Symposium on Parallel and Distributed Computing (ISPDC)	10.1109/ISPDC.2017.18	empirical research;self-management;computer science;cloud computing;distributed computing;hierarchy;hierarchical control system	HPC	-42.29562923241248	20.497755761107957	142326
8106296c11a3c5823b9719fef608aa79c91155cf	simulating simulation-agnostic sysml models for enterprise information systems via devs		Systems Modeling Language (SysML) is used as the modeling infrastructure in systems engineering, especially for complex systems design, independently of the system domain. Simulation is a common method to perform system model verification, during the systems development process. However, simulation code generation and execution is not integrated within the system design activity, as it is facilitated by SysML. It is either conducted as an external activity, after system design, or it affects the system design environment and practices, according to specific simulators requirements. This paper presents how existing, simulation-agnostic SysML models from the domain of Enterprise Information System (EISs), can be transformed to executable simulation code and in addition how the simulation results can be incorporated into the source SysML model through the exploitation of Model Driven Architecture (MDA) principles and techniques. To this end, several tools and technologies are utilized, while the verification process is triggered and finalized via the system modeling environment. Adoption of MDA provides a solid, high-level infrastructure and tool availability to the proposed approach. © 2016 Elsevier B.V. All rights reserved.	code generation (compiler);complex systems;devs;enterprise information system;executable;high- and low-level;model-driven architecture;requirement;simulation;software development process;systems modeling language;systems design;systems engineering	Anargyros Tsadimas;Georgios-Dimitrios Kapos;Vassilis Dalakas;Mara Nikolaidou;Dimosthenis Anagnostopoulos	2016	Simulation Modelling Practice and Theory	10.1016/j.simpat.2016.04.001	real-time computing;simulation;systems engineering;engineering	SE	-44.496995513709116	24.862662537108605	142372
83de549e09949684f9d6c1463695fa92d6ec096c	a reference model and architecture for future computer networks		The growing need for a trustworthy Future Internet demands evolutionary approaches unfettered by legacy constrains and concepts. The networking community is calling for new network architectural proposals that address the deficiencies identified in present network realizations, acknowledge the need for a trustworthy IT infrastructure, and satisfy the society's emerging and future requirements. Proposed architectures need to be founded on well-articulated design principles, account for network operational and management complexities, embrace technology and application heterogeneity, regulate network-inherent emergent behavior, and overcome shortcomings attributed to present network realizations. This dissertation presents our proposed clean-slate Concern-Oriented Reference Model (CORM) for architecting future computer networks. CORM stands as a guiding framework from which network architectures can be derived according to specific functional, contextual, and operational requirements or constraints. CORM represents a pioneering attempt within the network realm, and to our knowledge, CORM is the first reference model that is bio-inspired and derived in accordance with the FunctionBehavior-Structure (FBS) engineering framework. CORM conceives a computer network as a software-dependent complex system whose design needs to be attempted in a concern-oriented bottom-up approach along two main dimensions: a vertical dimension addressing structure and configuration of network building blocks; and a horizontal dimension addressing communication and interactions among the previously formulated building blocks. For each network dimension, CORM factors the design space into function, structure, and behavior, applying to each the principle of separation of concerns for further systematic decomposition. In CORM, the network-building block is referred to as the Network Cell (NC), which represents CORM’s first basic abstraction. An NC's structure and inherent behavior are bio-inspired, imitating a bacterium cell in a bacteria colony, thus it is capable of adaptation, self-organization and evolution. An NC's functional operation is defined by CORM second basic abstraction; the ACRF framework. The ACRF framework is a conceptual framework for network-concerns derived according to our interpretation of computer network requirement specifications. CORM networks are recursively synthesized in a bottom-up fashion out of CORM NCs. CORM addresses the multi-dimensionality of computer networks by modeling the network structure and behavior using a network structural template (NST), and an information flow model (IFM), respectively. Being developed according to a complex system paradigm, CORM refutes the long endorsed concept of layering, intrinsically accounts for emergent behavior, and ensures system integrity and stability. As a reference model, CORM is more typical of conventional engineering. Therefore it was validated using the FBS engineering framework. However, the behavior to be realized in CORM-based networks was substantiated and evaluated by deriving CellNet, our proposed CORM-based network architecture. CellNet-compliant protocols' behavioral adaptation and modification were illustrated and evaluated through simulation. CORM will have a profound impact on the operation and behavior of computer networks composing the Internet. By introducing awareness adaptability and evolvability as network intrinsic features, CORM-based Internet will proactively respond to changes in operational contexts, underlying technologies, and end user requirements. A major direction in CORM future work would be to detail the IFM component.	apollonian network;bottom-up parsing;british informatics olympiad;complex system;emergence;function-behaviour-structure ontology;future internet;information flow (information theory);interaction;interaction-free measurement;knowledge management;network security toolkit;network architecture;network synthesis filters;programming paradigm;recursion;reference model;requirement;self-organization;separation of concerns;simulation;system integrity;user requirements document	Hoda Mamdouh Hassan	2010			enterprise architecture framework;reference architecture;network architecture;architecture;computer network programming;reference model;theoretical computer science;network simulation;applications architecture;computer science	Networks	-45.05124232652813	20.91024427371197	142430
9fe405cc247cee3650c995e4068a109193359941	measuring component adaptation	mismatching;developpement logiciel;adaptacion;component based software engineering;componente logicial;specification;composant logiciel;metric;software engineering;software architecture;desadaptacion;especificacion;heterogeneidad;desarrollo logicial;contexto;adaptation;software development;software component;genie logiciel;contexte;coordinacion;metrico;desadaptation;ingenieria informatica;context;metrique;architecture logiciel;heterogeneity;heterogeneite;coordination	Adapting heterogeneous software components that present mismatching interaction behaviour is one of the crucial problems in Component-Based Software Engineering. The process of component adaptation can be synthesized by a transformation from an initial specification (of the requested adaptation) to a revised specification (expressing the actual adaptation that will be featured by the deployed adaptor component). An important capability in this context is hence to be able to evaluate to which extent an adaptor proposal satisfies the initially requested adaptation. The aim of this paper is precisely to develop different metrics that can be employed to this end. Such metrics can be fruitfully employed both to assess the acceptability of an adaptation proposal, and to compare different adaptation solutions proposed by different servers.	component-based software engineering	Antonio Brogi;Carlos Canal;Ernesto Pimentel	2004		10.1007/978-3-540-24634-3_8	simulation;computer science;component-based software engineering;software engineering;programming language	SE	-40.082533512993834	25.326826602979246	142730
b5fcb83c11cfc8865487f8d01cd25a9c5cc81fba	a dsl to feedback formal verification results		The integration of early formal validation and verification (V&V) tools (model checking, static analysis, etc.) in the V&V activities for domain-specific modeling languages (DSMLs) is a key asset to improve safety and reduce development and maintenance costs. However, system designers (DSMLs endusers) expect a seamless approach embedding transparently these tools in automated toolchains while enjoying their benefits. Thus, a mandatory task for DSML designer is to feedback at the DSML level the verification results generated by these tools. This contribution highlights a domain-specific language (DSL) to describe this feedback and the associated tools that helps the DSML designer in integrating the V&V tools. A translational semantics is given — as a higher-order transformation — for this DSL in order to automatically generate a model transformation which builds verification results at the DSML level from the ones produced at the formal level.	complex event processing;diagram;digital subscriber line;directory services markup language;domain-specific language;domain-specific modeling;executable;feedback;formal verification;ladder logic;model checking;model transformation;modeling language;programmable logic device;run time (program lifecycle phase);seamless3d;static program analysis;toolchain;verification and validation	Faiez Zalila;Xavier Crégut;Marc Pantel	2016			intelligent verification;theoretical computer science;digital subscriber line;formal verification;computer science;distributed computing	SE	-44.70973145414779	30.833899805925668	142912
a0d35daf44bc1b3c17c5efa4dcc96efa8c0db622	an approach to workflow modeling and analysis	activity diagram;eclipse;workflow;petri nets;petri net;workflow analysis;activity diagrams;modeling and analysis	In this paper we present a new approach to workflow analysis. We model the workflow using Activity diagrams, convert the Activity diagrams to Petri nets and use the theoretical results in the Petri nets domain to analyze the equivalent Petri nets and infer properties of the original workflow. We have demonstrated the possibility by developing an Eclipse plug-in, which can be used to model workflows using Activity Diagrams and then analyze these workflow models using Petri nets.	activity diagram;eclipse;petri net;plug-in (computing)	Hemant Kumar Meena;Indradeep Saha;Koushik Kr. Mondal;T. V. Prabhakar	2005		10.1145/1117696.1117714	activity diagram;computer science;systems engineering;engineering;data mining;database;process architecture;petri net	SE	-46.288582192135586	26.147489633031142	143050
dac00d6193fd4288edf787affc68bb602831750c	agent-oriented approach based on discrete event systems (wip)	agent based simulation;multi agent system;mas;group behaviour;cellular network;devs;discrete event simulation	Inspired by existing works, in this paper, we propose software architecture for coupling the MAS and DEVS formalism. This architecture is designed to enable the modeling of large quantities of agents. Previous works often associated with an agent to a DEVS model. The complexity of the system increases proportionately with the number of agents. We describe an approach to group a set of agents in the same DEVS model, and allow representing many more agents.	devs;semantics (computer science);software architecture	Paul-Antoine Bisgambiglia;Romain Franceschini	2013			embedded system;real-time computing;simulation;engineering;devs	AI	-40.64561077277745	21.85649329733808	143212
956e53a40cfe49abd74441d97aa5cf997a700834	proof-based system engineering and embedded systems	concepcion asistida;system engineering;computer aided design;preuve programme;program proof;monitoring control system;systeme controle commande;ingenieria logiciel;sistema control mando;software engineering;embedded system;algorithme;algorithm;system synthesis;lessons learned;system design;synthese systeme;prueba programa;sintesis sistema;genie logiciel;conception assistee;algoritmo	We introduce basic principles that underlie proof-based system engineering, an engineering discipline aimed at computer-based systems. This discipline serves to avoid system engineering faults. It is based upon fulfilling proof obligations, notably establishing proofs that decisions regarding system design and system dimensioning are correct, before embarking on the implementation or the fielding of a computer-based system. We also introduce a proof-based system engineering method which has been applied to diverse projects involving embedded systems. These projects are presented and lessons learned are reported. An analysis of the Ariane 5 Flight 501 failure serves to illustrate how proof-based system engineering also helps in diagnosing causes of failures.	embedded system;systems design;systems engineering	Gérard Le Lann	1996		10.1007/3-540-65193-4_23	simulation;system of systems;system of systems engineering;computer science;systems engineering;computer aided design;algorithm;systems design	SE	-42.07751171863596	27.210274647681945	143545
273761ac568409ef14a15f922fcb2e58697dc0c8	semantics-based composition of class hierarchies	developpement logiciel;base composition;software systems;semantics;program verification;semantica;semantique;verificacion programa;impact analysis;object oriented;desarrollo logicial;software development;oriente objet;program analysis;verification programme;orientado objeto;correctness proof	Class hierarchy composition aims at constructing software systems by composing a set of class hierarchies into an executable system. Current composition algorithms cannot provide semantic guarantees. We present a composition algorithm, together with an interference criterion and its correctness proof, which guarantees that behavior of the original hierarchies is preserved for interference-free compositions. In case of interference, an impact analysis can determine the consequences of integration. The method is based on existing program analysis technology and is illustrated by various examples.	algorithm;class hierarchy;correctness (computer science);executable;interference (communication);program analysis;software system	Gregor Snelting;Frank Tip	2002		10.1007/3-540-47993-7_24	program analysis;computer science;theoretical computer science;software development;semantics;programming language;object-oriented programming;algorithm;software system	PL	-41.042218099121364	27.408669317646893	143557
0949af214f4362d36a21c936f543a49712ac258e	heterogeneous devs simulations with connectors and reo based compositions	connectors;design;devs;discrete event;experimentation;measurement;model composition;performance;reo;simulation theory	Composition of DEVS models in heterogenous environments requires resolutions for manifold incompatibilities including data type and time resolution mismatch. This paper proposes a solution for implementing DEVS simulations in heterogenous environments with the help of connectors in the sense of component based software engineering. Our solution involves implementing connectors as atomic models to be used in mediation of data type and time resolution mismatches. Employing atomic models as connectors allows connector composition in the style of Reo and promotes higher level of reuse in simulation construction. In this paper we describe our solution formally and present a case study to demonstrate its application.	devs;simulation	Ahmet Kara;Halit Oguztüzün;M. Nedim Alpdemir	2014			component-based software engineering;devs;data type;reuse;distributed computing;computer science	EDA	-43.82969849188176	24.52063229940548	143616
00eae0bbb18b473720487ea066bfd9b96d8e0a98	specification and implementation of an extensible multimedia system	modelizacion;distributed system;multimedia authoring;systeme reparti;document model;multimedia;tool support;specification;multimedia systems;modelisation;sistema repartido;especificacion;computer based training;modeling	Multimedia authoring does not consist solely of the specification of the temporal and spatial layout of a document. Application specific concepts (e.g. for computer based training) or animation effects (e.g. moving media items) are often required by authors. Existing multimedia authoring tools support only one specific concept for the temporal specification, spatial specification and interaction. This paper presents research results for an extensible multimedia system called MAVA (MultimediA documentVersatileArchitecture). It allows to integrate new and alternative concepts for multimedia documents. MAVA uses an operator based approach as meta document model, what means that all extensions will define concrete operators that will be used by authors.	computer	Jürgen Hauser;Kurt Rothermel	2000		10.1007/3-540-40002-8_23	systems modeling;computer science;operating system;database;distributed computing;multimedia;programming language;world wide web;specification;statistics	DB	-36.4137646473856	24.711335047139936	143653
aea8087c4c3a884c14a9ab44c7038456120cc53f	visual debugging support for graph rewriting-based model transformations	graph theory;program diagnostics;mathematical model visualization debugging runtime engines matlab;matlab simulink model processing model transformation graph rewriting model transformation debugging;rewriting systems;matlab simulink domain visual debugging support graph rewriting model transformations graph based models modeling tools rewriting rule based transformations continuous animation transformation traceability transformation debugging visual model transformation debugger visual modeling;software tools;program debugging;software tools graph theory program debugging program diagnostics rewriting systems	Graph rewriting-based model transformation is an essential tool with a strong mathematical background used to process graph-based models. The most recent modeling tools tend to support the definition of rewriting rule based transformations in a visual or textual way. However, only a few of these support the continuous animation of the modifications performed on the models, which makes the traceability and the debugging of transformations more challenging. This paper presents the visual model transformation debugger realized in the Visual Modeling and Transformation System. The solution facilitates the step-by-step execution of model transformations, the visualization of the overall state of the transformation and also supports individual matches. Furthermore, it provides the possibility to influence the behavior of the transformation at runtime. The realized features are illustrated in a case study from the MATLAB Simulink domain.	debugger;debugging;graph rewriting;matlab;model transformation;run time (program lifecycle phase);simulink;traceability;visual modeling	Tamás Mészáros;Péter Fehér;László Lengyel	2013	Eurocon 2013	10.1109/EUROCON.2013.6625025	computer science;graph theory;theoretical computer science;algorithmic program debugging;programming language;algorithm;graph rewriting	SE	-44.602404066777865	29.466051414309383	143661
e8072355d96b22d91af8abab0a61dde695e5767e	refinement and extension of smdm, a method for defining valid measures		Although literature contains a huge amount of measures for measuring quality characteristics of software artifacts throughout the development life-cycle, the majority go no further than the step of definition. The key to obtaining valid measures which may be useful in practice is to carry out a definition of these by following a rigorous method. In a previous work we defined a method for obtaining valid measures, called SMDM (Software Measure Definition Method). In this paper we present the extensions and refinements of this method, which has been redefined in the light of seven years of application to various software artifacts, such as OCL expressions, UML diagrams, ER diagrams, Relational database schemas, Datawarehouse conceptual models, etc. In order to illustrate the redefined method, an example of the definition of a measure for the import-coupling of OCL expressions is presented.	activity diagram;artifact (software development);cognition;cognitive complexity;context-sensitive language;definition;diagram;entity–relationship model;experiment;gqm;linear algebra;metamodeling;natural language;object constraint language;refinement (computing);relational database;seaman;software development;software engineering;uml state machine;unified modeling language	Luis Reynoso;Marcela Genero;Mario Piattini	2010	J. UCS	10.3217/jucs-016-21-3210	data mining;database;algorithm	SE	-45.744189544758356	26.714588569471225	143758
3442790c802f5470d3cd1318f819b5a07f775014	modeling and composing navigational concerns in web applications. requirements and design issues.	application development;design model;user interaction diagrams;partial navigation scenario building;formal specification;applications development;consequent tradeoff analysis;navigation application software object oriented modeling scattering history information analysis advertising design methodology;diagrams;systems analysis diagrams formal specification internet;system design web application modeling web application navigation composition partial navigation scenario building user interaction diagrams requirements specification consequent tradeoff analysis applications development;internet;web application modeling;requirements specification;systems analysis;system design;crosscutting concerns;user interaction;requirement specification;web application navigation composition	Complex applications, in particular Web applications, deal with a myriad of different concerns and some of them affect several others. The result is that these crosscutting concerns are scattered throughout different software artifacts and tangled with other concerns. In this paper we present an approach for modeling and composing navigational concerns in Web applications. By showing how to build partial navigation scenarios with user interaction diagrams, analyzing how they crosscut and defining corresponding composition rules, we add modularity to the requirements specification stage, facilitating reasoning about the requirements and a consequent tradeoff analysis to support informed decisions on architectural choices. Moreover, by focusing on navigation concerns during the early stages of applications development, we aim to address the impact of crosscutting concerns in design models, improve the discovering of meaningful design artefacts and improve traceability of design decisions	cross-cutting concern;diagram;requirement;software requirements specification;traceability;web application	Silvia E. Gordillo;Gustavo Rossi;Ana Moreira;João Araújo;Carla Vairetti;Matias Urbieta	2006	2006 Fourth Latin American Web Congress	10.1109/LA-WEB.2006.21	systems analysis;software requirements specification;the internet;simulation;computer science;diagram;formal specification;database;rapid application development;systems design	SE	-47.35083887647185	20.76794477723065	143778
905fedd4d711f2efd1f5a0e9b9e629baf22fa940	industrial experiences from multi-paradigmatic modelling of signal processing	digital signal processing;executable uml;executable software models;model driven engineering;telecommunications industry;domain specific languages	Embedded software is often composed of interacting domains. A common problem is that the implementation intertwines the different domain solutions with each other and the platform-specific details. The result is a code mass that is hard to understand, maintain and reuse. We report on an effort to overcome these problems by using a domain-specific executable modelling language for each included domain. The application was delivered for the Ericsson LTE-A uplink test bed as part of the 4G telecommunications system that was presented at the Mobile World Congress in Barcelona, February 2011. The requirements for the delivered software included efficient real-time performance for signal processing on new hardware as well as a firm non-negotiable delivery deadline. Our results show that the chosen modelling languages allowed independent implementation and validation of each domain. Neither did the integration of the separate solutions imply additional problems.	compaq lte;domain-specific language;embedded software;executable;interaction;modeling language;platform-specific model;real-time transcription;requirement;signal processing;telecommunications link;testbed	Håkan Burden;Rogardt Heldal;Martin Lundqvist	2012		10.1145/2508443.2508445	domain analysis;real-time computing;simulation;computer science;theoretical computer science;feature-oriented domain analysis;domain engineering	Embedded	-48.05763775401576	31.899586039631963	144014
a660bbb64944eb82299733f1ba6e61f87213a274	reasoning about model accuracy	developpement logiciel;modelizacion;complexite;model specification;metodologia;sistema informatico;methode approchee;complejidad;abstraction;metodo aproximado;computer system;intelligence artificielle;complexity;approximate method;abstraccion;raisonnement;methodologie;modelisation;refinement method;specification modele;especificacion modelo;desarrollo logicial;software development;razonamiento;artificial intelligence;systeme informatique;inteligencia artificial;methode affinement;reasoning;methodology;modeling;metodo afinamiento	Weld, D S, Reasoning about model accuracy, Artificial Intelligence 56 (1992) 225-300 Although computers are widely used to simulate complex physical systems, crafting the underlying models that enable computer analysis remains a difficult job vath only a small number of computer tools for support Our goal is to mechanize this process by building an automated model management system that evaluates simplifying assumptions and selects appropriate perspectives In this paper we present our initial results a framework for dynamically changing model accuracy based on model senslttvlty analysts We show how to perform model sensitivity analysis efficiently when one model is afittmg approxtmatton of the other Finally, we discuss two implementations of our technique m programs that perform • query-directed simplification by adding bounding abstractions, and • discrepancy-driven refinement Our programs use a mixture of qualitative and quanUtative techniques with both symbolic and numeric computations	artificial intelligence;computation;computer;discrepancy function;level of detail;refinement (computing);simulation	Daniel S. Weld	1992	Artif. Intell.	10.1016/0004-3702(92)90029-W	complexity;systems modeling;computer science;artificial intelligence;software development;methodology;abstraction;specification;reason;algorithm	AI	-37.154559953463846	23.917782871783405	144015
187c1005fe489952dd37c0239dd8181fa3ddca8b	sysml to nusmv model transformation via object-orientation		This paper proposes a transformation of SysML models into the NuSMV input language. The transformation is performed automatically using SysMV-Ja and relies on a notion of intermediate model structuring the relevant SysML components in an object-oriented fashion.	model transformation;nusmv;systems modeling language	Georgiana Caltais;Florian Leitner-Fischer;Stefan Leue;Jannis Weiser	2016		10.1007/978-3-319-51738-4_3	machine learning;model transformation;systems modeling language;artificial intelligence;computer science;object-orientation	SE	-44.58498932385705	27.185912991401352	144066
108100b8441141a404b3b31276bfe4e50b61aac0	proposal for a standard default color space for the internet - srgb	color space	HP and Microsoft propose the addition of support for a standard color space, sRGB, within the Microsoft OS’s, HP products and the Internet. The aim of this color space is to complement the current color management strategies by enabling a third method of handling color in the OS’s and the Internet that utilizes a simple and robust device independent color definition that will provide good quality and backwards compatibility with minimum transmission and system overhead. Based on a colorimetric RGB color space well suited to Cathode Ray Tube (CRT) monitors, television, scanners, digital cameras, and printing systems, such a space can be supported with minimum cost to software and hardware vendors. Our intent here is to promote its adoption by showing the benefits of supporting a standard color space, the suitability of the standard color space we are proposing, describe some of the system issues and propose a methodology for its implementation on the Web.	backward compatibility;cathode ray tube;color management;color space;device independence;digital camera;image scanner;internet;operating system;overhead (computing);printing;television;world wide web	Matthew Anderson;Ricardo Motta;Srinivasan Chandrasekar;Michael Stokes	1996			the internet;artificial intelligence;computer science;computer vision;srgb;color quantization;icc profile;color space	Graphics	-33.789500286992755	23.41989651782924	144092
d740b23c55dcb8d791b7173f286bdac732b5a0c8	detecting and fixing uml model inconsistencies using constraints	owl;software systems;maintenance engineering;navigation;unified modeling language;context	Complex software systems are often modeled as a collection of related UML diagrams, each of which describes particular aspects of the system being investigated. These diagrams might contain inconsistencies due to the evolving nature of software systems and to the refinement of the models across the software life cycle. It is so mandatory to discover the potential inconsistencies in UML models as soon as possible before implementing the system. This paper proposes a method for checking the consistency of UML models, based on formal constraints defined at the meta-model of UML. These constraints are described using EVL (Epsilon Validation Language) by matching related diagrams features at the meta-level. EVL also helps repair and correct the inconsistencies being detected. Our method is easily automated and is complete in terms of coverage of both potential inconsistencies and the UML diagrams commonly used.	diagram;electronic visualization laboratory;metamodeling;refinement (computing);software release life cycle;software system;unified modeling language	Driss Allaki;Mohamed Dahchour;Abdeslam En-Nouaary	2016	2016 4th IEEE International Colloquium on Information Science and Technology (CiSt)	10.1109/CIST.2016.7805060	reliability engineering;systems modeling language;uml tool;computer science;systems engineering;applications of uml;database;shlaer–mellor method;node	SE	-45.90898158164339	27.65940236803093	144709
807ac8ede9ac06de13142f269a394d53415c33a6	fatima modular: towards an agent architecture with a generic appraisal framework		This paper presents a generic and flexible architecture for emotional agents, with what we consider to be the minimum set of functionalities that allows us to implement and compare different appraisal theories in a given scenario. FAtiMA Modular, the architecture proposed is composed of a core algorithm and by a set of components that add particular functionality (either in terms of appraisal or behaviour) to the architecture, which makes the architecture more flexible and easier to extend.	agent architecture;algorithm;generic programming;optimistic concurrency control;theory	João Dias;Samuel Mascarenhas;Ana Paiva	2014		10.1007/978-3-319-12973-0_3	enterprise architecture framework;reliability engineering;reference architecture;space-based architecture;simulation;computer science;systems engineering;applications architecture;solution architecture;data architecture	Robotics	-43.998608864384884	20.829245751228594	144820
75612e6b7ee7da111bfe340e9f2559531811a90a	a dds-based distributed simulation approach for engineering-level models	dds-based distributed simulation;military computing;weapons;interoperation;component-based simulation environment;time synchronization;data distribution service;engineering-level models;anti-ship warfare;addsim nodes;digital simulation;data exchange mechanism;weapon system modeling;distributed processing;synchronisation;object-oriented methods	AddSIM is a component-based simulation environment that has been developed for weapon system modeling and engagement simulation. While AddSIM addresses component-based model development and reuse issues, it does not fully consider distributed simulation for massive and frequently changing data. We studied some approaches to develop an engagement simulation environment based on data distribution service for distributed systems (DDS). This article introduces three different approaches to apply DDS to AddSIM and describes their advantages and disadvantages. Then, we choose the best way to develop the mixture of AddSIM and DDS. According to the proposed approach, we explain the data exchange mechanism between AddSIM nodes and time synchronization for correct execution. We also define several DDS topic types for interoperation. Finally, we describe an anti-ship warfare case study to show the difference between AddSIM and the proposed approach.	component-based software engineering;data distribution service;distributed computing;interoperation;simulation;systems modeling	Do-hyung Kim;Ockhyun Paek;Taeho Lee;Samjoon Park;Hyunshik Bae	2014	Proceedings of the Winter Simulation Conference 2014		real-time computing;simulation;computer science;engineering;distributed computing;world wide web;computer security	HPC	-39.871551374028705	22.023158581347122	144841
819688b0b6a9399f44edec2170a000cb44e26465	constituent elements of a correctness-preserving uml design approach	developpement logiciel;model specification;fiabilidad;reliability;lenguaje ocl;productivite;melangeage;lenguaje uml;metodo formal;methode formelle;langage modelisation unifie;interpretacion abstracta;productividad;formal method;software architecture;design method;specification modele;especificacion modelo;object oriented;system design;desarrollo logicial;fiabilite;unified modelling language;ocl;software development;present day;langage contraint objet;oriente objet;productivity;interpretation abstraite;abstract interpretation;mixing;orientado objeto;mezclado;architecture logiciel	The correctness of design decisions is a very relevant aspect of building any software or hardware system. Emerging techniques tend to include formal methods in the system design flow. Together with older, established techniques, already well known to the present day designer, the combined approach should bring benefits in the form of correctness of the design, increase of reliability, etc, all these leading to a similar increase in productivity. In this study, we present a method of such combined design, by mixing a formal method strategies and rules, with UML, a relatively new but popular design method. Our formal framework is represented by the Action Systems formalism. We show how the UML models can be correctly changed by incorporating precise derivation rules expressed in OCL. The initial, abstract models can be thus transformed into more concrete models, without violating the intended specification.	correctness (computer science);unified modeling language	Tiberiu Seceleanu;Juha Plosila	2004		10.1007/978-3-540-24756-2_13	unified modeling language;software architecture;productivity;formal methods;design methods;computer science;artificial intelligence;software development;software engineering;applications of uml;reliability;mixing;programming language;object-oriented programming;specification;algorithm;object constraint language;systems design	EDA	-42.813256633294294	26.559522451290473	144938
02708fcf141c1a32754f8a7ca2cb552499eb5355	a wsdl-based type system for ws-bpel	modelizacion;distributed system;semantica operacional;theorie type;systeme reparti;xml language;operational semantics;service web;web service;software engineering;modelisation;qa75 electronic computers computer science;tipificacion;semantique operationnelle;sistema repartido;lenguaje descripcion;calcul operationnel;typing;calculo operacional;type theory;typage;genie logiciel;coordinacion;modeling;ingenieria informatica;operational calculus;interactive web service;langage xml;lenguaje xml;langage description;servicio web;type system;coordination;description language	We tackle the problem of providing rigorous formal foundations to current software engineering technologies for web services. We focus on two of the most used XML-based languages for web services: WSDL and WS-BPEL. To this aim, first we select an expressive subset of WS-BPEL, with special concern for modeling the interactions among web service instances in a network context, and define its operational semantics. We call - the resulting formalism. Then, we put forward a rigorous typing discipline that formalizes the relationship existing between - terms and the associated WSDL documents and supports verification of their compliance. We prove that the type system and the operational semantics of - are ‘sound’ and apply our approach to an example application involving three interacting web services.	business process execution language;interaction;operational semantics;semantics (computer science);software engineering;type system;web services description language;web service;xml	Alessandro Lapadula;Rosario Pugliese;Francesco Tiezzi	2006		10.1007/11767954_10	web service;web modeling;xml;systems modeling;type system;computer science;database;programming language;ws-i basic profile;operational semantics;world wide web;type theory	SE	-40.474159201433054	24.798837085570035	144960
3a986f69c4ceb5e5989f76cd0241bf52d3b836ea	evaluation of real-time characteristics for mission critical systems using hierarchically profiled petri net		Development of mission-critical systems requires the verification and the validation (Vu0026V) considering limited time, available resource and costs to analyze the possibility of mission accomplishment in system development life cycle. In this paper we propose a Petri Net based modeling formalism, called Hierarchically Profiled Petri Net (HPPN), which provides a unified solution for above problems through the profiled firing rule in which the state evolves according to the state transition rule. Additionally we propose an analysis technique, which represents the multi-aspect based state enumeration that considers the state of token and the state of marking. Expressive and analysis capabilities of the model are demonstrated with reference to an intercontinental ballistic missiles (ICBM) scenario.	mission critical;petri net;real-time transcription	Hyunsang Youn;Ingeol Chun;Eunseok Lee	2011		10.1007/978-3-642-26010-0_25	real-time computing;systems engineering;engineering;distributed computing	Robotics	-38.16847195412192	31.67872210265361	145103
873870fc526651130bd636c63bd7f816c88a2780	a measurement of software trustworthiness based on approximation algorithms	software;approximate algorithm;probability;probability approach software trustworthiness measurement approximation algorithm;approximation algorithms;software trustworthiness measurement;algorithm structure;approximation algorithm;software trustworthiness;trust model;probability approach;software engineering;approximation algorithms approximation methods software algorithms algorithm design and analysis software polynomials optimization;polynomials;software engineering approximation theory probability security of data;approximation theory;software algorithms;optimization;approximation methods;security of data;algorithm design and analysis;algorithm structure software trustworthiness probability approach approximation algorithm	The trustworthiness of algorithms is one of the important parts of that of softwares. We introduce a trust model and define trustworthy degree for the approximation algorithms by a probability approach. Relative properties are investigated based on the structure of the algorithms.	approximation algorithm;order of approximation;software trustworthiness;trust (emotion)	Jie Zhou;Hong Zhu	2010	2010 7th International Conference on Ubiquitous Intelligence & Computing and 7th International Conference on Autonomic & Trusted Computing	10.1109/UIC-ATC.2010.58	algorithm design;mathematical optimization;computer science;theoretical computer science;machine learning;probability;approximation algorithm;polynomial;approximation theory	Robotics	-36.172963108192924	20.634376238022245	145295
0fedafa0588912cc39d6c7909141329f9b76afe2	tool building in formal methods	formal method		formal methods	Frédéric Gervais;Benoît Fraikin	2011	Softw., Pract. Exper.	10.1002/spe.1046	formal methods;computer science;formal specification;refinement;programming language	NLP	-45.44335592065399	30.528259921437385	145418
09e8161dce19af96d41c007d4fcf0c9345ebdb0e	to bdi, or not to bdi: design choices in an agent-based traffic flow management simulation	air traffic control;agent based;belief desire intent;belief desire intention;efficiency;traffic flow management;bdi agents;intelligent agent	Belief-Desire-Intention (BDI) is a powerful agent paradigm that allows for the development of so-called intelligent agents - agents that can reason and act based on their beliefs and intentions. However, this power often comes at the cost of increased computational overhead. We describe our experience using a BDI agent framework for developing a simulation of collaborative air traffic flow management and the efficiency problems we encountered. By using BDI more judiciously in our simulation, we were able to address these issues and greatly reduce the execution time of our simulation. From our successes and failures, we derive several guidelines that may enable other researchers to avoid similar efficiency issues in BDI-based simulations.	agent-based model;belief–desire–intention software model;computation;intelligent agent;overhead (computing);programming paradigm;run time (program lifecycle phase);simulation	Shawn R. Wolfe;Maarten Sierhuis;Peter A. Jarvis	2008			simulation;computer science;engineering;knowledge management;artificial intelligence;air traffic control;efficiency;management;computer security;intelligent agent	AI	-40.940264853755714	21.580037927914915	145449
edb2f4938d954a01eb4c5b26bfa0a8cebdf86901	detecting packed executables using steganalysis	false positive rate packed executable files detection steganalysis obfuscated malware detection false negative rates;machine learning algorithms;wiener filters;accuracy;malware;malware feature extraction accuracy wiener filters support vector machine classification machine learning algorithms entropy;feature extraction;support vector machine classification;entropy;steganography invasive software	This paper proposes a novel method of detecting packed executable files using steganalysis, primarily targeting the detection of obfuscated malware through packing. Considering that over 80% of malware in the wild is packed, detection accuracy and low false negative rates are important properties of malware detection methods. Experimental results outlined in this paper reveal that the proposed approach achieving an overall detection accuracy of greater than 99%, a false negative rate of 1% and a false positive rate of 0%.	algorithm;bitmap;executable compression;feature extraction;heuristic;machine learning;malware;sensor;set packing;steganalysis	Colin James Burgess;Fatih Kurugollu;Sakir Sezer;Kieran McLaughlin	2014	2014 5th European Workshop on Visual Information Processing (EUVIP)	10.1109/EUVIP.2014.7018361	computer science;machine learning;pattern recognition;data mining	Security	-35.466628452473536	23.076747728644257	145491
dea94e10b42d002397b1503e5136ee807416cc7f	a pvs-simulink integrated environment for model-based analysis of cyber-physical systems	haslab haslab uminho;software packages automata analytical models cyber physical systems mathematical model data models;c 3 d real time and embedded systems c 4 d modeling techniques d 2 1 g specification d 2 4 d formal methods	This paper presents a methodology, with supporting tool, for formal modeling and analysis of software components in cyber-physical systems. Using our approach, developers can integrate a simulation of logic-based specifications of software components and Simulink models of continuous processes. The integrated simulation is useful to validate the characteristics of discrete system components early in the development process. The same logic-based specifications can also be formally verified using the Prototype Verification System (PVS), to gain additional confidence that the software design complies with specific safety requirements. Modeling patterns are defined for generating the logic-based specifications from the more familiar automata-based formalism. The ultimate aim of this work is to facilitate the introduction of formal verification technologies in the software development process of cyber-physical systems, which typically requires the integrated use of different formalisms and tools. A case study from the medical domain is used to illustrate the approach. A PVS model of a pacemaker is interfaced with a Simulink model of the human heart. The overall cyber-physical system is co-simulated to validate design requirements through exploration of relevant test scenarios. Formal verification with the PVS theorem prover is demonstrated for the pacemaker model for specific safety aspects of the pacemaker design.	artificial cardiac pacemaker;automata theory;automated theorem proving;component-based software engineering;cyber-physical system;discrete system;formal verification;prototype verification system;requirement;semantics (computer science);simulation;simulink;software design;software development process;software verification;unified modeling language	Cinzia Bernardeschi;Andrea Domenici;Paolo Masci	2018	IEEE Transactions on Software Engineering	10.1109/TSE.2017.2694423	real-time computing;theoretical computer science;formal specification;computer science;software development process;component-based software engineering;formal methods;systems engineering;prototype verification system;formal verification;software design;data modeling	SE	-43.95391467950805	31.93064431993783	145653
1ceb6c2aac982dbbfda4f68a4d84c4d6263276be	ecobas - a tool to develop ecosystem models exemplified by the shallow lake model emmo	interaction analysis;modularization;ecosystem model;shallow lakes;sensitivity analysis;ecobas;graphical model;ecological model;parameter analysis;parameter estimation;modelling and simulation;critical parameter;ecological modelling	The modelling and simulation tool ECOBAS was extended in order to include special features supporting the development of ecological models. The «Graphical Model Editor» allows the connection of at least 2 modules in order to build a whole model to run simulations. With the ECOBAS simulation system the model can be tested extensively in order to find appropriate parameter sets («Parameter analysis» and «Parameter estimation») and to identify critical parameters («Sensitivity analysis»). The «Interaction Analysis» shows the internal dependencies of a model. ECOBAS integrates the steps of ecological modelling and creates well readable and complete documentations within one working step, supports modularization of models and the user is rid of the technical and numerical aspects of modelling. Hence ECOBAS is setting up complete, consistent and syntactical correct models.#R##N##R##N#All new features of the ECOBAS-system will be introduced by applying it on the existing ecosystem model EMMO.	ecosystem model	Torsten Strube;Joachim Benz;Sascha Kardaetz;Rainer Brüggemann	2008	Ecological Informatics	10.1016/j.ecoinf.2008.01.003	biology;simulation;ecosystem model;computer science;modular programming;data mining;graphical model;estimation theory;ecology;sensitivity analysis;statistics;social ecological model	Metrics	-35.03347652795422	25.959393423134166	146144
c8d13b6d2e827726f091948d6386a0432f77f63b	the software architecture of the osmosys multisolution framework	different technique;complex model;heterogeneous analysis technique;osmosys multisolution framework;composing sub-models;complex system;suitable formalism;complex multiformalism model;heterogeneous model;different formalisms;software architecture;common formalism;system modeling;orchestration	The use of multi-formalism techniques is very appealing in modeling complex systems since they allow for building of complex models by integrating or composing sub-models specified by different formalisms. Hence, the most suitable formalism may be used according to the evaluation goals, the level of abstraction of the sub-models and the nature of the sub-systems. Each formalism is usually coupled with efficient solution methods, thus multi-solution approaches are needed to solve multi-formalism models whose analysis involves different techniques and tools. In this paper the software architecture of the OsMoSys Multi-solution Framework (OMF) is presented. OMF was born to provide the support needed to allow for loosely coupled cooperation among heterogeneous analysis techniques and tools, and automates the tasks that must be performed to solve complex multiformalism models. OMF does not require that heterogeneous models are translated into a common formalism in order to be solved, nor that the available tools are modified to be integrated in the framework, but it achieves multisolution by orchestration.	complex systems;loose coupling;oracle database;semantics (computer science);software architecture	Francesco Moscato;Francesco Flammini;Giusy Di Lorenzo;Valeria Vittorini;Stefano Marrone;Mauro Iacono	2007		10.1145/1345263.1345328	software architecture;simulation;systems modeling;computer science;theoretical computer science;orchestration	HPC	-43.79279404610634	24.341877233545976	146159
989b0e873531ffe7f2ce660ae83b4b0adf47d1db	binary activity chain modes for compositional web service and its compliance verification	stateful web services;model checking;composite web services;index terms—specification;operational semantics;service model;specification;business model;indexing terms	Web service composition is most impressing method for development and deployment of e-business. Modeling and analysis of the behavior requirements of compositional Web service plays an important role in behavioral verification. Traditional methods are expressing requirements as LTL like logic specifications which are based on activities or as MSC like graph forms which are based scenarios. In this paper, we propose the concept of behavior specification based on activity chain in which its atomic granularity is between activity and scenario. Four behavioral modes such as chain existence mode, chain absence mode, chain precondition mode and chain response mode are adopted to express usual requirement specifications. Encode them on Labeled Transition System LTS and then give them operation semantics. Check compositional Web services based on LTS corresponds with behavior modes or not. Give the sufficient, necessary condition and algorithm for checking.	activity diagram;activity recognition;algorithm;business process execution language;encode;electronic business;mathematical optimization;multi-core processor;precondition;requirement;service composability principle;software deployment;transition system;web service	Bo Chen;Chungui Li;Qixian Cai	2009	JSW		business model;model checking;web modeling;real-time computing;index term;computer science;operating system;service-oriented modeling;ws-policy;database;programming language;operational semantics;world wide web;specification	SE	-41.85419277264243	28.565357168245537	146184
2e1c1591f34a17a8a6958a1de77a2369a2505100	towards agent-oriented specification of information systems	information system	| Abstract | Objects in information systems usually have a very long lifespan. Therefore, it often happens that during the life of an object external requirements are changing, e.g. changes of laws. Such changes often require the object to adopt another behavior. In consequence, it is necessary to get a grasp of dynamically changing object behavior. Unfortunately, not all possible changes can in general be taken into account in advance at speciication time. Hence, current object speci-cation approaches cannot deal with this problem. Flexible extensions of object speciication are needed to capture such situations. The concept of agent which can be seen as a further development of the concept of object seems to provide a more adequate basis for modeling such information system dynamics. In comparison to traditional objects, agents are exible in that sense they may change their behavior dynamically during system run-time, i.e. the behavior of an agent is not (or can not be) completely determined at compile or speciica-tion time. In order to get a grasp of such properties, we need an agent-oriented speciication framework which goes beyond the existing object-oriented ones. Our approach can be described as follows: We start from a well-known object-oriented speciication framework for information systems which allows us to describe structure as well as long-term behavior of objects in information systems. We extend this object-oriented framework by introducing a certain form of knowledge as part of the internal state of objects. Here, we especially concentrate on the speciication of evolving temporal behavior. For that, we propose an extension (called Evolving Temporal Logic) of classical temporal logic approaches to object speciication. We propose a two-level speciication framework for mod-eling of information systems in terms of agents. The rst level contains usual attributes and events, which describe the xed behavior of an agent. In the second level, the possible evolution of the agent speciication is speciied. Example: In Figure 1 the structure of a possible specii-cation of an agent class Account is sketched. The specii-cation language used here can be considered as an extension of the object-oriented language Troll Jungclaus et al. 1996]. Similar to objects, agents have attributes (e.g. Balance) and events (e.g. Withdraw). The part of the behavior speciication which must not be changed is speciied in the rigid axioms section. In our example the eeect of the events Withdraw and Deposit on the attribute Balance is xed. In addition to the …	compiler;information system;requirement;system dynamics;temporal logic	Stefan Conrad;Can Türker;Gunter Saake	1997		10.1145/267658.267792	executive information system;information engineering;specification language;computer science;information integration;system requirements specification;management information systems;information quality;automated information system;information system	AI	-45.03603064489653	22.72533000930051	146249
dceef4de21c87e78daf124d2881fd9b41d05108e	a multi-agent model and its speech act theory for cooperative mechanical cad	agent modeling;speech acts;agent communication;speech act theory	This paper discusses a multi-agent and its speech act theory supporting cooperative mechanical CAD. The multi-agent is constructed with organizer, agents and communication manager. The structures of the organizer and agent are elaborated. The communication manager consists of central management and dialog management. This speech act theory supports the agents communication involving more than 2 people. The Pr/T net of speech act and firing rules are presented. The multi-agent model has been put into practice of computer integrated autobody development, and make the distributed cooperative autobody design system more flexible and coordinate.	computer-aided design;multi-agent system	Hong Chen;Gengyun Wang;Zhigang Li	1999	J. Intelligent Manufacturing	10.1023/A:1008972530410	speech recognition;engineering;artificial intelligence	Robotics	-41.37895964314107	18.384896130241717	146339
5d7e1d0f14e928a6b48a60f35de010593adef624	virtual enterprises using the collaboration agency infrastructure	groupware;dynamic collaboration agency infrastructure;formal specification;collaborative work;virtual enterprises;virtual enterprises collaborative work computer architecture collaborative software international collaboration web services intelligent agent intelligent robots companies machine intelligence;intelligent robots;open infrastructure;web service;companies;software agents;message exchange;computer architecture;software architecture;multi agent systems;internet;machine intelligence;web services;virtual enterprise;intelligent agent;message passing;web services virtual enterprise dynamic collaboration agency infrastructure open infrastructure agent enhanced architecture machine readable specification message exchange;internet virtual enterprises groupware open systems message passing multi agent systems software agents software architecture formal specification;agent enhanced architecture;open systems;machine readable specification;collaborative software	This paper describes an open and flexible infrastructure to support dynamic collaboration among companies through the entire lifecycle of the virtual enterprise. The proposed approach is an agent-enhanced architecture on which the conversation model is grafted. The collaboration among enterprises is modeled by a collaboration policy which is a machine-readable specification of a pattern of message exchange among agents participating in the collaboration. The proposed system is widely open and highly flexible since various types of software, including Web services, can collaborate through the conversation model.	virtual enterprise;web service	Young-Ho Suh;Kang-Woo Lee;Hyun Jin Kim	2005	Proceedings of the Ninth International Conference on Computer Supported Cooperative Work in Design, 2005.	10.1109/CSCWD.2005.194145	web service;computer science;knowledge management;artificial intelligence;software engineering;multi-agent system;world wide web;intelligent agent;collaborative software	SE	-42.13866647722399	18.2811389774131	146358
3dfb664091f5183562fd733f6bb54752db5e7fe2	a formal transformation method for automated fault tree generation from a uml activity model		Fault analysis and resolution of faults should be part of any end-to-end system development process. This paper is concerned with developing a formal transformation method that maps control flows modeled in unified modeling language activities to semantically equivalent fault trees. The transformation method developed features the use of propositional calculus and probability theory. Fault propagation chains are introduced to facilitate the method. An overarching metamodel comprised of transformations between models is developed and is applied to an understood traffic management system of systems problem to demonstrate the approach. In this way, the relational structure of the system behavior model is reflected in the structure of the fault tree. The paper concludes with a discussion of limitations of the transformation method and proposes approaches to extend it to object flows, state machines, and functional allocations.	behavior model;end system;end-to-end principle;fault tree analysis;function model;householder transformation;map;metamodeling;propositional calculus;software propagation;system of systems;unified modeling language	Charles E. Dickerson;Rosmira Roslan;Siyuan Ji	2018	IEEE Transactions on Reliability	10.1109/TR.2018.2849013	reliability engineering;system of systems;theoretical computer science;probability theory;model transformation;unified modeling language;finite-state machine;fault tree analysis;metamodeling;mathematics;propositional calculus	Robotics	-46.31335139256045	32.249558701570606	146369
0e77788e932157086c21359de6934752b18547af	the macodo middleware for context-driven dynamic agent organizations	application development;integrated approach;organization;multiagent system;life cycle;building block;life cycle management;role;software architecture;middleware;traffic monitoring;context	One of the major challenges in engineering distributed multiagent systems is the coordination necessary to align the behavior of different agents. Decentralization of control implies a style of coordination in which the agents cooperate as peers with respect to each other and no agent has global control over the system, or global knowledge about the system. The dynamic interactions and collaborations among agents are usually structured and managed by means of roles and organizations. In existing approaches agents typically have a dual responsibility: on the one hand playing roles within the organization, on the other hand managing the life-cycle of the organization itself, for example, setting up the organization and managing organization dynamics. Engineering realistic multiagent systems in which agents encapsulate this dual responsibility is a complex task.  In this article, we present a middleware for context-driven dynamic agent organizations. The middleware is part of an integrated approach, called MACODO: Middleware Architecture for COntext-driven Dynamic agent Organizations. The complementary part of the MACODO approach is an organization model that defines abstractions to support application developers in describing dynamic organizations, as described in Weyns et al. [2010].  The MACODO middleware offers the life-cycle management of dynamic organizations as a reusable service separated from the agents, which makes it easier to understand, design, and manage dynamic organizations in multiagent systems. We give a detailed description of the software architecture of the MADOCO middleware. The software architecture describes the essential building blocks of a distributed middleware platform that supports the MACODO organization model. We used the middleware architecture to develop a prototype middleware platform for a traffic monitoring application. We evaluate the MACODO middeware architecture by assessing the adaptability, scalability, and robustness of the prototype platform.	addendum;agent-based model;align (company);business process;digital library;intelligent agent;interaction;middleware;multi-agent system;prototype;scalability;separation of concerns;software architecture;software testing controversies	Danny Weyns;Robrecht Haesevoets;Alexander Helleboogh;Tom Holvoet;Wouter Joosen	2010	TAAS	10.1145/1671948.1671951	biological life cycle;software architecture;middleware;simulation;computer science;organization;knowledge management;message oriented middleware;role;middleware;distributed computing;rapid application development;product life-cycle management	AI	-43.57754243776552	20.738992559718994	146595
37100857c059c190fdca074fabe6d6856b480c51	applied text generation	applied text generation;software design	While we were able to exploit existing research for many of the design issues, it turned out that we needed to develop our own approach to text planning (Rambow 1990). This paper will present the system and a t tempt to show how these design objectives led to particular design decisions. The structure of the paper is as follows. In Section 2, we will present the underlying application and give examples of the output of the System. In Section 3, we will discuss the overall s tructure of Joyce. We then discuss the three main components in turn: the text planner in Section 4, the sentence planner in Section 5 and the realizer in Section 6. We will discuss the text planner in some detail since it represents a new approach to the problem. Section 7 traces the generation of a short text. In Section 8, we address the problem of portability, and wind up by discussing some shortcomings of Joyce in the conclusion.	backdoor (computing);ca-realizer;color gradient;dictionary;joyce;logical connective;nick mckeown;scope (computer science);tracing (software);ulysses iii;user interface;xml schema	Owen Rambow;Tanya Korelsky	1992			computer engineering;software design;computer science	NLP	-46.79179294556028	26.711500518208453	146935
10d026f87c6047b6a5b9c844f2c57ae6b5202a4c	data modeling in delab	query language;object oriented data model;graphical interface;data management;spectrum;product line;network simulator;data model;ease of use;performance metric;simulation experiment;discrete event system;experience management;complex system;object oriented;levels of abstraction;directed graph;graphical representation;special needs;concurrency control;multiple inheritance;distributed processing environment;graphic user interface;communication protocol;simulation study;modeling methodology;database management system;manufacturing system;discrete event;simulation environment	As the size and complexity of processing and manufacturing systems increases, the need for Database Management Systems (DBMS) that meet the special needs of studies that experiment with such systems becomes more current. System analysts who study the performance of modern processing systems have to manipulate large amounts of data in order to profile the behavior of the system. They have to identify the relationship between the properties of a compound system and a wide spectrum of performance metrics. In a recent study in which we have analyzed a set of distributed concurrency control algorithms, we performed more than 1400 simulation experiments. Each experiment was characterized by more than 6000 input parameters and generated more than 400 output values. It is thus clear that powerful means for defining the structure and properties of complex systems are needed, as well as efficient tools to retrieve the data accumulated in the course of the study. We are currently engaged in an effort to develop and implement the DELAB simulation laboratory that aims to provide such means and tools for simulation studies. The goal of the first phase of this effort was to design and implement a simulation language. It ended in 1986 when the DENET (Discrete Event NETwork) simulation language became operational. The language is based on the concept of Discrete Event System Specifications (DEVS). It views the simulator as a collection of self contained objects that communicate via Discrete Event Connectors that provide a unified synchronization protocol In the past two years the language has been used in a number of real life studies. It was used to simulate distributed processing environments, communication protocols, and production lines Several tools have been developed around the language. All tools adhere to the same modeling methodology and thus create a cohesive simulation environment. In the second phase of the DELAB project we have been addressing the data management problem DENET has been interfaced to a special purpose relational DBMS that can store descriptions of simulation runs and provides access to the stored data Based on our experience with thus DBMS, we have reached the conclusion that system analysts need to be provided with a view of the data that differs from the way the DENET program views the data, and thus decided to develop a data model that meets their needs. The M@@@@SE data model, which is the result of this effort, has an object oriented flavor. It was developed with the guidance of potential users and was tested on a number of real life simulation studies. Although the conception of M@@@@SE was motivated by the specific needs of a simulation laboratory, we believe that it addresses the representational needs of many other environments We have decided to support the notion of an object. Every object is assigned a unique identifier. Depending on their properties (attributes), objects can simultaneously belong to several classes, inheriting properties from all of them. Among these classes, one is characterized as the primary class of the object. The notion of a primary class helps achieving a “conceptual” as well as a physical clustering among similar objects. Collections of objects are supported as regular objects in M@@@@SE in the form of sets, multisets (bags), and arrays. The extent of a class, i.e., the objects that are known members of the class, is explicitly stored in the database. Every M@@@@SE database schema has a straightforward directed graph representation. Each node represents a class of objects and is labeled by the class name. Relationships between the classes in the schema are captured by the arcs of the graph. Similarly to most object-oriented data models, M@@@@SE has two major types of arcs component arcs and inheritance arcs. The former capture structural relationships (part-of), whereas the latter capture semantic relationships (is-a) between classes of objects. Although a component arc (A → B) has a direction from the parent to the child class, it relates the two classes in both directions. An object in A has a part that is in B, an object in B is part of an object that is in A. The values of the attributes of an object may be explicitly assigned by the user or derived by the system through rules associated with the attribute. Although not restricted to those, aggregates of collections are the dominant kind of such derived attributes. The values assigned to derived attributes may be explicitly stored in the database (forward application of rules), or may be inferred on demand (backward application of rules). Null values are supported in M@@@@SE and are interpreted as “no related object.” Thus, null is distinct from any other value. Also, default values are supported in their full generality M@@@@SE supports four types of user-defined structural constraints that can be used to control sharing or existence dependence between objects. These are (a) sharing of objects among collections, (b) sharing of objects among their parents, (c) sharing of objects along different paths in the component graph, and (d) existence dependence of a child to its parents. An inheritance arc (A → B) implies that every object in B is in A also B(X) → A(X). This rule is called a generalization rule and is implicitly assumed for every inheritance arc. In addition to an implicit generalization rule, an inheritance arc may be explicitly associated with a specialization rule, which specifies which elements of the parent class belong to the child class A specialized class can be instantiated at all times, or its objects can be retrieved on demand, by applying the corresponding rule(s) on an as-needed basis. Although the semantics of simple specialization rules could be captured by typing information and inheritance, specialization rules can be arbitrarily complex, thus allowing the necessary generality to capture the level of abstraction needed for experiment management. We are currently designing a query language for M@@@@SE that will take advantage of its features and will give the system analyst the capability to express complex queries easily. Multiple inheritance will be a significant feature of the language, and one of the key sources of its power and ease of use. Work planned for the future includes building a graphics user-interface to the DBMS that will take advantage of the graphic representation of a M@@@@SE schema and will allow the user to express queries as paths on the graph. The ability to express all types of constraints in a graphic form will then become very important. Some preliminary work on the subject has shown that focusing on different parts of the database establishes different contexts, within which the same constraint can be expressed in different ways. We are currently studying this relationship between constraints and contexts and plan to incorporate it in the query language as well as in the graphics interface.	arcs (computing);algorithm;cluster analysis;complex systems;concurrency (computer science);connected component (graph theory);devs;data model;data modeling;database schema;directed graph;distributed computing;distributed concurrency control;emoticon;experiment;graph (abstract data type);graphics interface;identifier;is-a;multiple inheritance;partial template specialization;query language;real life;relational database management system;simulation language;software studies;unique key;usability;user interface	Yannis E. Ioannidis;Miron Livny	1988		10.1145/50202.50224	real-time computing;simulation;data management;computer science;theoretical computer science;graphical user interface;database;programming language	DB	-34.348765292243094	26.96890374908557	147037
82722ddc37309818d6f0941669e6f0365dce90c5	an approach to optimization of fault tolerant architectures using hip-hops	multi objective optimization;active safety;fault tolerance;genetic algorithms;dependability analysis	New processes for the design of dependable systems must address both cost and dependability concerns. They should also maximize the potential for automation to address the problem of increasing technological complexity and the potentially immense design spaces that need to be explored. In this paper we show a design process that integrates system modelling, automated dependability analysis and evolutionary optimization techniques to achieve the optimization of designs with respect to dependability and cost from the early stages. Computerized support is provided for difficult aspects of fault tolerant design, such as decision making on the type and location of fault detection and fault tolerant strategies. The process is supported by HiP-HOPS, a scalable automated dependability analysis and optimization tool. The process was applied to a Pre-collision system for vehicles at an early stage of its design. The study shows that HiP-HOPS can overcome the limitations of earlier work based on Reliability Block Diagrams by enabling dependability analysis and optimization of architectures that may have a network topology and exhibit multiple failure modes. Copyright © 2011 John Wiley & Sons, Ltd.	fault tolerance;mathematical optimization;waist–hip ratio	Masakazu Adachi;Yiannis Papadopoulos;Septavera Sharvia;David Parker;Tetsuya Tohdo	2011	Softw., Pract. Exper.	10.1002/spe.1044	reliability engineering;fault tolerance;real-time computing;genetic algorithm;computer science;systems engineering;engineering;multi-objective optimization;active safety;dependability	EDA	-34.818285015207614	21.700012527964326	147109
042d7f656dc7e66dd1451ee8c9e272453de9636b	a general-purpose graph dynamical system modeling framework	application domain;denote interaction;general purpose;modeling framework;agent-based system;large parametric simulation study;flexible framework;million agent;illustrative case study;great expressive power;direct mapping;general-purpose graph dynamical system;simulation;vectors;expressive power;computer model;computational modeling;physics;dynamic system	We describe InterSim, a general purpose flexible framework for simulating graph dynamical systems (GDS) and their generalizations. GDS provide a powerful formalism to model and analyze agent-based systems (ABS) because there is a direct mapping between nodes and edges (which denote interactions) in a GDS and agents and interactions in an ABS, thereby providing InterSim with great expressive power. We describe the design, implementation, capabilities, and features of InterSim; e.g., it enables users to quickly produce simulations of ABS in many application domains. We present illustrative case studies that focus on the simulation of social phenomena. InterSim has been used to simulate networks with 4 million agents and to execute large parametric simulation studies.	agent-based model;general-purpose modeling;graph dynamical system;interaction;semantics (computer science);simulation;systems modeling	Chris J. Kuhlman;V. S. Anil Kumar;Madhav V. Marathe;Henning S. Mortveit;Samarth Swarup;Gaurav Tuli;S. S. Ravi;Daniel J. Rosenkrantz	2011	Proceedings of the 2011 Winter Simulation Conference (WSC)		computer simulation;simulation;computer science;artificial intelligence;dynamical system;computational model;expressive power	HPC	-39.455499003037296	22.42797380704512	147206
f5e4f0565d811085a7611a0ae83aebb8f61157f4	towards an agent architectural description language for information systems	institutional repositories;fedora;multi agent system;model system;architecture description language;vital;bdi agents;information system;agent architecture;vtls;system architecture;peer to peer;ils	This paper identifies the foundations for an architectural description language (ADL) to specify multi-agent system architectures for information systems. We propose a set of system architectural concepts based on the BDI agent model and existing classical ADLs. We then conceptualize SKwyRL-ADL, aimed at capturing a “core” set of structural and behavioral concepts, including relationships that are fundamental in architecture description for BDI-MAS. We partially apply our ADL on a peer-to-peer document sharing example.	agent-based model;information system;multi-agent system;peer-to-peer;requirement;systems architecture	Stéphane Faulkner;Manuel Kolp	2003			agent architecture;architecture description language;computer science;knowledge management;artificial intelligence;multi-agent system;database;software architecture description;world wide web;information system;systems architecture	AI	-43.55627604101871	20.347592947080475	147352
439316b92c754709e251a7ce43af878e04b8c939	software salvaging and the call dominance tree	software;dominance tree;logiciel;call graph;reutilizacion;programmation modulaire;abstraction;programacion modular;abstraccion;reuse;candidature rule;directed graph;graphe oriente;intermodular relation;software component;data abstraction;modular programming;logicial;grafo orientado;dominance relation;reutilisation	Abstract   The main goal of reuse reengineering processes for existing software is to obtain reusable software modules by clustering old software components that implement functional or data abstractions. The first problem to solve in the functional abstraction is how to search old software for components that may constitute a module. This article proposes candidature criteria founded on the dominance relation between the nodes of a call-directed graph. The proposed criteria have been adopted in a real-life reuse reengineering process on PASCAL software.		Aniello Cimitile;Giuseppe Visaggio	1995	Journal of Systems and Software	10.1016/0164-1212(94)00049-S	call graph;verification and validation;directed graph;software sizing;computer science;package development process;backporting;software design;theoretical computer science;software framework;component-based software engineering;software development;software design description;operating system;software engineering;modular programming;software construction;reuse;database;abstraction;software walkthrough;programming language;resource-oriented architecture;software deployment;goal-driven software development process;software metric;software system	OS	-42.32102164305536	25.02639713160773	147414
027063631ae1f8c0b35096ea5cb0ed111f9b080c	ard+ design and visualization tool-chain prototype in prolog		The paper presents a prototype design tool-chain for the ARD+ conceptual design method for rules, called VARDA. The tool-chain is implemented in a Unix environment with the use of Graphviz visualization tool and SWI-Prolog. Introduction An effective design support is a complex issue. It is related to the design methods as well as the human-machine interface. What is often not emphasized, is the role of the design process. Since most of the complex designs are created gradually, and are often refined or refactored, the design method should take this process into account, and the supporting tools should effectively use it. In order to solve these problems, the HeKatE project aims at providing both design methods and tools that support the design process. Currently HeKatE provides the preliminary conceptual design with the ARD+ method (Attribute Relationships Diagrams). The main logical design is conducted with the use of XTT method (eXtended Tabular Trees) (Nalepa & Ligęza 2005). The main focus of the paper is to present the prototype of VARDA (Visual ARD Rapid Development Alloy). It is a rapid prototyping environment for ARD+, built with use of the SWI-Prolog for the knowledge base building, and Graphviz tool for a real-time design visualization. These tools are combined by the Unix environment, where the ImageMagick tool provides an instant visualization of the prototype at any design stage. Conceptual Design of Rules with ARD+ The ARD method aims at capturing relationships between attributes in terms of Attributive Logic (Ligęza 2006). Attributes denote certain system property. A property is described by one or more attributes. ARD captures functional dependencies among these properties. A simple property is a property described by a single attribute, while a complex property is described by multiple attributes. It is indicated that particular system property depends functionally on other properties. Such dependencies form a directed graph with nodes being properties. Copyright c © 2008, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved. There are two kinds of attributes adapted by ARD: Conceptual Attributes and Physical Attributes. A conceptual attribute is an attribute describing some general, abstract aspect of the system to be specified and refined. Conceptual attributes are being finalized during the design process, into possibly multiple physical attributes. A physical attribute is an attribute describing a well-defined, atomic aspect of the system. There are two transformations allowed during the ARD+ design. These are: finalization and split. Finalization transforms a simple property described by a conceptual attribute into a property described by one or more conceptual or physical attributes. It introduces a more specific knowledge about the given property. Split transforms a complex property into a number of properties and defines functional dependencies among them. During the design process, upon splitting and finalization, the ARD model grows. This growth is expressed by consecutive diagram levels, making the design more and more specific. This constitutes the hierarchical model. Consecutive levels make a hierarchy of more and more detailed diagrams describing the system. The implementation of such hierarchical model is provided through storing the lowest available, most detailed diagram level at any time, and additional information needed to recreate all of the higher levels, the so-called Transformation Process History (TPH). Prolog Prototype A software prototype providing the ARD+ design and visualization method has been built. It is designed as a multilayer architecture (see Fig. 1): • knowledge base to represent the design, • low-level primitives: adding and removing attributes, properties and dependencies, • transformations: finalization and split including defining dependencies and automatic TPH creation, • low-level visualization primitives: generating data for the visualization tool-chain, so-called DOT data, • high-level visualization primitives: drawing actual dependency graph between properties and the TPH. As an implementation environment of choice the Prolog language is used. It serves as a proof of concept for the ARD+ design methodology and prototyping environment.	artificial intelligence;code refactoring;design tool;diagram;directed graph;functional dependency;graphviz;hierarchical database model;high- and low-level;imagemagick;knowledge base;prolog;prototype;rapid prototyping;real-time clock;swi-prolog;software prototyping;table (information);toolchain;unix;user interface	Grzegorz J. Nalepa;Igor Wojnicki	2008			visualization;conceptual design;database;computer science;unix;prolog	AI	-46.539190840720025	25.531236736406107	147446
ecc39942a20621051da653ad7fee64d7825f38a7	an integrated simulation study on reliable and effective distributed energy resources in smart grid		The investigation of the reliability, effectiveness, and impact of Distributed Energy Resources (DERs) on smart grid applications (demand-response, real time price, etc.) requires an integrated evaluation framework. In this paper, we design an integrated simulation platform and demonstrate its use via investigating the impact of DERs on smart grid applications (demand-response and energy market) under various adverse conditions, along with network architectures. Using the standard IEEE bus system, we systematically evaluate the integration of DERs and the performance impact on demand response and energy markets with respect to system management, uncertainties and different network architectures. Our experimental results demonstrate the ability of designed co-simulation tool to evaluate the performance of DERs and system management and networking techniques. Our results are comprehensive, providing a concise representation of DER performance for the design and implementation of real smart grid system.	co-simulation;grid computing;ieee 1471;simulation;systems management	Sriharsha Mallapuram;Wei Yu;Paul Moulema;David W. Griffith;Nada Golmie;Fan Liang	2017		10.1145/3129676.3129684	wireless network;smart grid;real-time computing;systems management;network architecture;energy market;computer science;distributed generation;demand response	HPC	-37.55878703919429	21.52165450658286	147714
65f333ab7689fd725f145578dac694dc1dce5495	discovering the inherent interrelationship among contexts in pervasive computing	context aware computing;context awareness;pervasive computing context aware services ubiquitous computing context modeling handheld computers sun educational institutions computer science concurrent computing context awareness;concurrent computing;pervasive computing;sun;ubiquitous computing;computer science;context aware systems;context modeling;handheld computers;context aware services	In recent years, there has been much research on context-aware computing, but there are not enough efforts on the correlation among contexts. The primary focus of this paper is to discover context interrelationship. In a context-aware system, there may be multiple contexts created, activated, utilized and discarded in the system. What is the influence they exert on each other? To answer this question we must discovery their inherent relationship from the time they created. In this paper we study the different kinds of interrelationship among contexts, including independence, concurrency, cascading and hierarchy. We express the different phenomena in detail and propose algorithms to deal with different problems. At last we use a case of study to illuminate our approaches.	algorithm;cascading style sheets;concurrency (computer science);context awareness;formal grammar;ubiquitous computing	Jie Sun;Zhaohui Wu	2006	The Sixth IEEE International Conference on Computer and Information Technology (CIT'06)	10.1109/CIT.2006.80	sun microsystems;context-aware pervasive systems;computer science;theoretical computer science;end-user computing;distributed computing;context model;world wide web;ubiquitous computing	Visualization	-37.14704328255089	18.51169868129981	147983
7fe4e1b36aa7f8e31102c40be7355c12ab55ec58	multi-agent system design verification using knowledge-based reasoning	knowledge base;multi agent system		knowledge-based systems;multi-agent system	Anarosa A. F. Brandão;Viviane Torres da Silva;Carlos José Pereira de Lucena	2005			intelligent verification;systems engineering;model-based reasoning;data mining;software verification;computer science;knowledge base;electronic system-level design and verification;high-level verification;functional verification;legal expert system	Logic	-45.63921874115749	30.806049793807116	148010
3fe275d020e638bbae9c052be0b92390d27aed24	e-cares project: reengineering of telecommunication systems	systeme temps reel;modelizacion;transformacion grafo;e cares project reengineering of telecommunication systems;calculateur embarque;real time;articulo;systems engineering;embedded real time systems;retroingenierie;software systems;graph transformation;modelisation;transformation graphe;graph rewriting;reingenieria;telecomunicacion;reingenierie;rewriting systems;reecriture;temps reel;telecommunication;boarded computer;ingenierie systeme;tiempo real;real time system;sistema tiempo real;rewriting;modeling;reengineering;systeme reecriture;calculador embarque;ingeniera inversa;reescritura;reverse engineering	One important field of application for embedded real-time systems is in the telecommunications industry. In the first phase of the E-CARES reengineering project, we regarded the architecture modeling and the reverse engineering of telecommunication systems. Current work concerns the restructuring of such systems including their re-design and re-implementation. The aim is to provide concepts, languages, methods, and tools to improve the architecture and the real-time performance of the software system. Our reengineering prototype is based on a graph rewriting system by which the underlying application logic is generated. Proceedings of the Summer School on Generative and Transformational Techniques in Software Engineering (GTTSE’05), LNCS 4143, p. 437-448, Springer, 2006 (copyright)	algorithm;business logic;code refactoring;embedded system;graph operations;graph rewriting;high- and low-level;lecture notes in computer science;prototype;real-time clock;real-time computing;real-time operating system;real-time transcription;reverse engineering;software architecture;software engineering;software system;specification language;springer (tank)	Christof Mosler	2005		10.1007/11877028_20	real-time operating system;computer science;programming language;algorithm;graph rewriting;systems design	SE	-41.083081936170956	26.741649619043137	148093
0d3d68d19cf60e37d1b481e74379425d2929b475	specification of software systems	different stage;software system;end-of-chapter bibliographic note;one-semester course;software development;communicating systems;graduate-level text;different type;software specification;formal method;design stage;senior undergraduate level;model-based specification technique;formal specification;basic discrete mathematics;formal specification technique;software engineering;property-oriented specification method;software systems	This extensively revised and updated new edition of Specification of Software Systems builds upon the original focus on software specification with added emphasis on the practice of formal methods for specification and verification activities for different types of software systems and at different stages of developing software systems. Topics and features: provides a wide coverage of formal specification techniques and a clear writing style, supported by end-of-chapter bibliographic notes for further reading; presents a logical structure, with sections devoted to specification fundamentals, basics of formalism, logic, set theory and relations, property-oriented specification methods, and model-based specification techniques; contains end-of-chapter exercises and numerous case studies, with potential course outlines suggested in the Preface; covers ObjectZ, B-Method, and Calculus of Communicating Systems; offers material that can be taught with tool-supported laboratory projects.	b-method;calculus of communicating systems;formal methods;formal specification;model-based specification;semantics (computer science);set theory;software system	Vangalur S. Alagar;Kasilingam Periyasamy	1998		10.1007/978-1-4757-2920-7	software requirements specification;verification and validation;formal methods;specification language;formal verification;computer science;systems engineering;software design;software engineering;system requirements specification;software construction;formal specification;functional specification;specification pattern;software system	SE	-46.14382016233562	29.431530099085656	148111
e662fbed4a700e4c4b5d5d7b479c14661b7dbc2d	explicit aspect composition by part-whole state charts	explicit aspect composition;part-whole state charts	The speci cation of complex systems behavior is required to be, at the same time, both clear and realistic without renouncing to formality and rigor. Finite state automata (FSA) t such a requirement, but, as the dimension of the problem increases, the complexity of the overall representation grows exponentially. A solution to the above problem consists in decomposing the behavior of real-world entities by separate aspects. Two powerful mechanisms are made available by the Statecharts formalism [1]:	automata theory;chart;complex systems;entity;finite-state machine;semantics (computer science);state diagram	Luca Pazzi	1999			complex system;discrete mathematics;formality;finite-state machine;formalism (philosophy);exponential growth;composition (visual arts);mathematics	AI	-40.607407425856714	28.828688753549166	148163
7cbf46401e5632590873443604f6be1a4c32eca8	a practically relevant approach to system level fault diagnosis				Jörn Altmann	1997				AI	-34.79191861456771	21.642000435743608	148195
ffae5e553eced11ef4af57915e563fc29749ec27	robots in the loop: supporting an incremental simulation-based design process	design process;process design robot kinematics computational modeling computer simulation system testing large scale systems virtual environment bridges discrete event simulation computer science;virtual reality;virtual reality incremental simulation based design process robotic convoy system robot in the loop simulation combined robot model real robot cooperative systems;simulation experiment;cooperative systems;multi robot systems;devs robot in the loop simulation incremental design process robotic convoy;virtual reality multi robot systems cooperative systems	This paper presents the results of applying an incremental simulation-based design process to study a robotic convoy system. Robot-in-the-loop simulation, as a major step in this process, allows the system to be measured with combined robot models and real robots. This capability effectively bridges the gap between conventional simulation where models are used and real system experiment where real robots are used. For each step in this incremental process, the simulation/experiment setup is described. The measurement data are then presented and compared. These experiments and results demonstrate the capabilities of robot-in-the-loop simulation and justify the effectiveness of using the incremental simulation-based design process.	experiment;robot;simulation	Xiaolin Hu;Narayanaswami Ganapathy;Bernard P. Zeigler	2005	2005 IEEE International Conference on Systems, Man and Cybernetics	10.1109/ICSMC.2005.1571444	real-time computing;simulation;design process;computer science;artificial intelligence;virtual reality;robot control	Robotics	-37.12394021268459	22.58268881491646	148225
0c631688e6aa25b9e82a6f0336a7619728ecc06a	applying model checking to industrial-sized plc programs	verification;software;programmable logic controller plc;biological system modeling;plc;temporal logic formal verification industrial control programmable controllers safety critical software;iec 61131;nuxmv;automata;iec standards;model checking;automata informatics model checking biological system modeling software iec standards;informatics;modeling;nuxmv plc iec 61131 modeling automata verification model checking;structured text language industrial sized plc program programmable logic controller industrial control system plc software safety critical software automated model checking temporal logic formal verification tool st language sfc language nuxmv model checker cern plc program european organization for nuclear research sequential function language	Programmable logic controllers (PLCs) are embedded computers widely used in industrial control systems. Ensuring that a PLC software complies with its specification is a challenging task. Formal verification has become a recommended practice to ensure the correctness of safety-critical software, but is still underused in industry due to the complexity of building and managing formal models of real applications. In this paper, we propose a general methodology to perform automated model checking of complex properties expressed in temporal logics [e.g., computation tree logic (CTL) and linear temporal logic (LTL)] on PLC programs. This methodology is based on an intermediate model (IM) meant to transform PLC programs written in various standard languages [structured text (ST), sequential function chart (SFC), etc.] to different modeling languages of verification tools. We present the syntax and semantics of the IM, and the transformation rules of the ST and SFC languages to the nuXmv model checker passing through the IM. Finally, two real cases studies of the European Organization for Nuclear Research (CERN) PLC programs, written mainly in the ST language, are presented to illustrate and validate the proposed approach.	computation tree logic;computer;control system;correctness (computer science);embedded system;formal verification;linear programming;linear temporal logic;model checking;modeling language;programmable logic device;real life;sequential function chart;software bug;space-filling curve;structured text;uppaal	Borja Fernandez Adiego;Dániel Darvas;Enrique Blanco Viñuela;Jean-Charles Tournier;Simon Bliudze;Jan Olaf Blech;Víctor M. González Suárez	2015	IEEE Transactions on Industrial Informatics	10.1109/TII.2015.2489184	model checking;embedded system;real-time computing;verification;systems modeling;computation tree logic;computer science;software engineering;programmable logic controller;automaton;programming language;informatics	Logic	-45.93251191542337	31.705545684456208	148236
cf478e471f0e6adf20a7653fc4766fd2b0882ee3	on components with explicit protocols satisfying a notion of correctness by construction	programmation;javabeans;integration information;satisfiability;programacion;interfase;large scale;information integration;network protocols;programmation basee composante;interface;integracion informacion;protocole reseau;escala grande;programming;echelle grande	Component-based programming promises to facilitate the construction of large-scale applications, it is supported by the concept of interfaces. In most current component models, interfaces essentially declare types and sets of services that components implement. However, interfaces are not expressive enough to formulate structural and behavioral properties important for component collaboration. We consider an important class of component collaboration properties: sequencing constraints, which components must obey when calling one another’s services. In this paper, we integrate sequencing properties into interfaces by means of protocols formalized in terms of finite-state machines. We are interested in operators for the construction of components, which satisfy a correctness property which allows a component to be substituted by another one. We present three main contributions. First, we define a set of protocol composition operators, which allow protocols to be constructed while ensuring substitutability. Second, we provide a first step toward the integration of additional abstract state information into protocols. Finally, we show that the model presented can be advantageously applied to the definition and extension of two widely-used component models: JavaBeans and EJB. We show how to make the JavaBeans’ implicit protocols explicit and extend the formulation of EJB’s access-control policies at the interface level.	access control;black box;communications protocol;component-based software engineering;correctness (computer science);enterprise javabeans;finite-state machine;open collaboration;protocol stack;real life	Andrés Farías;Mario Südholt	2002		10.1007/3-540-36124-3_64	communications protocol;programming;computer science;artificial intelligence;information integration;theoretical computer science;operating system;interface;database;mathematics;distributed computing;javabeans;programming language;computer security;algorithm;satisfiability	SE	-39.95263467863285	25.336130645078224	148455
4beb2f6a631353005e97ca13133468c71c97ea64	performance evaluation of complex systems using the sbip framework		In this paper we survey the main experiments performed using the SBIP framework. The latter consists of a stochastic componentbased modeling formalism and a probabilistic model checking engine for verification. The modeling formalism is built as an extension of BIP and enables to build complex systems in a compositional way, while the verification engine implements a set of statistical algorithms for the verification of qualitative and quantitative properties. The SBIP framework has been used to model and verify a large set of real life systems including various network protocols and multimedia applications.	algorithm;amelioration pattern;communications protocol;complex systems;experiment;graphical user interface;linear programming;model checking;numerical analysis;prism (surveillance program);performance evaluation;real life;scalability;semantics (computer science);simulation;statistical model;uppaal	Ayoub Nouri;Marius Bozga;Axel Legay;Saddek Bensalem	2016			real-time computing;simulation;computer science;theoretical computer science	Logic	-36.55164502615716	30.593491440894777	148511
5aaeba560935b9858acb7bd5b99463f0bd263602	contract-based web service composition framework with correctness guarantees	machine abstraite;distributed system;machine language;lenguaje maquina;systeme reparti;xml language;maquina abstracta;service web;web service;indexing terms;abstract machine;web service composition;langage definition contrat;formal verification;sistema repartido;lenguaje descripcion;verification formelle;langage machine;composition operator;langage xml;lenguaje xml;langage description;servicio web;description language	We present formal and practical foundations for Web service composition framework with composition correctness guarantees. We introduce contractual composition model based on two isomorphic description models: Contract Definition Language (XML) and abstract machines (formal notation). Composition operators (patterns) are used to perform composition which is then formally verified with respect to properties described in service contracts. We also describe Java-based implementation of the system, concentrated around Sun’s Java Web Services Development Pack (JWSDP). Indexed terms: Web services, composition, correctness, contracts	abstract machine;correctness (computer science);distributed computing;enterprise javabeans;formal verification;ieee internet computing;information systems;interaction;java platform, enterprise edition;java web services development pack;non-functional requirement;programmer;service composability principle;simulation;systems engineering;tree traversal;trust (emotion);verification and validation;web services metadata for java;web service;xml;yang	Nikola Milanovic	2005		10.1007/11560333_5	web service;xml;index term;machine code;formal verification;computer science;composition operator;operating system;database;abstract machine;programming language;world wide web;algorithm	PL	-42.29339403781666	24.430972016870278	148663
04cc824b85b4ba74bf961ca67838cc1db5746baf	tailoring the domain engineering process of the plus method	unified modeling language finite state machines graphical user interfaces ip networks product development software reusability telecommunication computing;domain engineering;telecommunication computing;product line;state dependence;use case description domain engineering process software product line unified modeling language ip phone graphical user interface dynamic interaction modeling finite state machine modeling;finite state machines;graphical user interfaces;software reusability;unified modeling language;graphic user interface;context modeling automata computer architecture acoustical engineering design engineering software architecture unified modeling language software engineering information science cities and towns;ip networks;interaction model;use case;finite state machine;product development	This paper reports an experimental case study constructing an IP phone product line with the PLUS method. The IP phone product line equips a graphical user interface and interacts with the network. Its behavior is complicated, state dependent, and feature dependent. The original PLUS domain engineering process requires to perform dynamic interaction modeling among objects or finite state machine modeling for objects based on use case descriptions without any comprehensive view of the product line system behavior. However, use case descriptions are too abstract to capture the system behavior of the complicated system. To alleviate this abstraction level gap, we introduce system level finite state machine modeling to provide a comprehensive view describing the feature dependent behavior of the product line system as a finite state machine. That made use case descriptions sounder and dynamic interaction modeling and finite state machine modeling easier in our case study.	abstraction layer;domain engineering;feature model;finite-state machine;graphical user interface;heart rate variability;spatial variability;state diagram;state transition table;user interface modeling	Tsuneo Nakanishi;Mitsunori Fujita;Susumu Yamazaki;Naohito Yamashita;Shuichi Ashihara	2007	14th Asia-Pacific Software Engineering Conference (APSEC'07)	10.1109/APSEC.2007.89	real-time computing;computer science;systems engineering;theoretical computer science;software engineering;graphical user interface;finite-state machine;programming language	SE	-47.95594082050943	30.873741980781737	148741
5430dbe26fb15a0e76f7509cd52a8bd5eba43537	generation and enactment of controllers for business architectures using mda	developpement logiciel;herencia;model based reasoning;model view controller;new technology;raisonnement base sur modele;base donnee;modele entreprise;commande logique;lenguaje uml;heritage;diagramme etat;specification;database;base dato;software development process;langage modelisation unifie;modelo empresa;database management;control logico;business model;software architecture;diagrama estado;especificacion;desarrollo logicial;unified modelling language;software development;relational model;state diagram;architecture basee modele;logic control;functionality;fonctionnalite;inheritance;user interaction;model driven architecture;funcionalidad;architecture logiciel;arquitectura basada modelo	Model Driven Architecture (MDA) is an initiative of the OMG in which the software development process is driven by various software-related models describing the software to be generated. Moreover, the new upcoming UML 2.0 standard promises to support the execution of models based on several types of actions as well as the inheritance of statecharts. We adapt this new technology in order to generate business controllers. By application of the popular Model View Controller (MVC) architecture, these controllers separate core business model functionality like database management from the presentation and control logic that uses this functionality (i.e., interactive user access). In particular, a controller translates user interactions realized by means of an interactive view into actions on the core business model. This paper deals with the generation of business controllers applying MDA and UML 2.0 concepts and presents experiences gained in the background of a bigger industrial project. The focus is on statecharts and actions used for the specification and execution of controllers. In particular, in order to deal with the inheritance of statechart diagrams specified for business controllers, we define a couple of transformation rules. These rules support the transformation of abstract PIM statecharts modelling the functionality of business controllers to a flat PSM statechart describing a business controller in a more implementation-like fashion. We outline the application of the transformation rules by means of a business controller example application.	database;disk controller;interaction;model-driven architecture;model–view–controller;software development process;state diagram;unified modeling language	Günter Graw;Peter Herrmann	2004		10.1007/978-3-540-24769-2_11	business model;unified modeling language;software architecture;relational model;business logic;state diagram;simulation;computer science;artifact-centric business process model;software development;model-based reasoning;database;business process model and notation;model–view–controller;business rule;business process modeling;specification;software development process;logic control;business architecture	SE	-41.83330378388748	25.52998494494822	148870
0f4bd91aebd9806572b3e1a00b9716286b064430	translating alloy specifications to uml class diagrams annotated with ocl	uml;alloy;mde;ocl	Model-Driven Engineering (MDE) is a Software Engineering approach based on model transformations at different abstraction levels. It prescribes the development of software by successively transforming models from abstract (specifications) to more concrete ones (code). Alloy is an increasingly popular lightweight formal specification language that supports automatic verification. Unfortunately, its widespread industrial adoption is hampered by the lack of an ecosystem of MDE tools, namely code generators. This paper presents a model transformation between Alloy and UML Class Diagrams annotated with OCL. The proposed transformation enables current UML-based tools to also be applied to Alloy specifications, thus unleashing its potential for MDE.		Ana Gabriela Garis;Alcino Cunha;Daniel Riesco	2011		10.1007/978-3-642-24690-6_16	unified modeling language;uml tool;computer science;software engineering;applications of uml;database;programming language;engineering drawing;object constraint language	SE	-47.70573734007568	26.577080492845543	148997
a939b166da5e6a03cf6c71275bf563e141710958	service-oriented communication architecture for automated manufacturing system integration	management system;service orientation;plug and play;manufacturing message specification;web service;communication model;control system;design method;system integration;unified modeling language;web services;soca;manufacturing system;protocol data unit	The heterogeneity of industrial environments is one of the most important challenges in the context of automated manufacturing system integration. To realize common industrial messaging services, this study employs service-oriented philosophy to realize manufacturing message specification (MMS) services and proposes a new concept of MMS Web Services, which rediscovers the semantics of MMS. Then, this study presents manufacturing communication model based on MMS and Web Services and provides service-oriented communication architecture (SOCA). On the basis of describing MMS, a protocol data unit (PDU) design based on Web Services and VMD server message transmission interfaces, manufacturing communication subsystem using unified modeling language model is discussed in detail. In particular, to verify the validity of the proposed design method, a prototype system has been achieved. The resulting prototype proves the effectiveness of MMS standard, Web Services middleware and service-oriented concepts in the design of manufacturing communication architecture. The combination of MMS and Web Services can bring truly platform-independent and language-independent communication capability for automated manufacturing system and improve its flexibility, reconfigurability and interoperability. Furthermore, the proposed communication architecture can be seamlessly integrated into manufacturing control systems or management systems in plug-and-play fashion.	service-oriented device architecture;system integration	Bin Wu;Lifeng Xi;Bing-hai Zhou	2008	Int. J. Computer Integrated Manufacturing	10.1080/09511920701370746	web service;embedded system;computer science;systems engineering;engineering;control system;operating system;database;computer-integrated manufacturing;law	Robotics	-44.61887885538034	22.95127398082891	149139
37cf50b3d454cff297bc0e693a7e6664b8ac0de6	a model-driven framework for distributed simulation of autonomous systems	mda;model driven development;distributed simulation;autonomous systems	The adoption of systems with autonomous capabilities is becoming more and more relevant in many real-world operational scenarios, in which risky operations have to be carried out (e.g., a military battlefield or a search-and-rescue operation). In this context, innovative approaches should be introduced at design time to ensure that the system will achieve the mission objectives at operation time. To this purpose, distributed simulation techniques have shown to be effective to deal with the inherent complexity of the environment to be simulated, which generally includes several interacting entities. Unfortunately, currently available distributed simulation standards, such as HLA (High Level Architecture), require a non-negligible effort and significant skills in terms of both simulation methodologies and related implementation technologies. In this respect, this paper focuses on the simulation-based analysis of systems with autonomous capabilities and introduces a model-driven approach to support the automated generation of HLA-based distributed simulations. The proposed approach is founded on the use of model transformation techniques and allows system designers to carry out a timely and cost-effective simulation-based analysis of the operational system without being required to own specific distributed simulation skills	autonomous system (internet);model-driven architecture;simulation	Paolo Bocciarelli;Andrea D'Ambrogio;Andrea Giglio;Emiliano Paglia	2015			simulation;systems engineering;engineering;computer engineering	Robotics	-41.68545093017966	22.345403500152205	149151
b362ac2e4ea1abdcd4808ea816142afff0b39993	formal architecture transformation using heuristics	graph theory;structure methods;formal specification;real world system;design engineering;information technology;predicate calculus;formal heuristic based transformation;design optimization;process design;computer architecture;category theory;graph theory formal specification;control system synthesis;calculus;real world system formal architecture transformation graph theory category theory predicate calculus formal heuristic based transformation;communications technology;system architecture;proposals;conference proceeding;formal architecture transformation;design optimization computer architecture process design information technology communications technology graph theory calculus design engineering proposals control system synthesis	Heuristics have long been a popular and effective mechanism for capturing the knowledge of experts. In recent times, however, the more common use of heuristics has been as a means for communicating ideas at an abstract level, with little consideration to their potential as a structured approach to design improvement. With this paper we present the issues surrounding, and a structured method for, formally capturing architectural change embodied within heuristics. We demonstrate how through the application of graph theory, category theory and predicate calculus we can capture change within a heuristic and then use it to achieve formal heuristic-based transformation of a real-world system. By capturing heuristics in the structured and formal manner discussed in this paper we present ourselves with the opportunity to create a practical and reliable heuristic-based architecture transformation system. This is done within the wider context of achieving a process for optimising the non-functional qualities of a system architecture through design transformation	category theory;consistency model;first-order logic;graph (discrete mathematics);graph theory;heuristic (computer science);systems architecture;world-system	Cameron Maxwell;Tim O'Neill;John Leaney	2007	14th Annual IEEE International Conference and Workshops on the Engineering of Computer-Based Systems (ECBS'07)	10.1109/ECBS.2007.42	process design;information and communications technology;multidisciplinary design optimization;computer science;artificial intelligence;graph theory;theoretical computer science;social heuristics;heuristics;first-order logic;formal specification;programming language;information technology;algorithm;category theory	SE	-43.33831698266086	27.25962173819066	149158
86cd4b2407fa2c329fe320dc8b162f4be43446fa	a test-driven approach for model-based development of powertrain functions	automotive software engineering;test driven development;embedded systems;model based testing	Vehicle functions for engine control units are modeled using a set of software units, so-called modules, specifying the discrete and continuous behavior of the corresponding function. As required by ISO26262, each module needs to be tested separately. Established techniques for model-based testing necessitate a requirements specification from which a test model can be derived. In practice, requirements are specified by natural language and on the level of whole vehicle functions instead of modules so that test models on module level can not be derived directly. Therefore, we propose a systematic model-based, test-driven approach to design a specification on the level of modules, which is directly testable. We demonstrate our approach on a Selective Catalytic Reduction system, a real world case study from automotive software engineering.		Henrik Peters;Christoph Knieke;Oliver Brox;Stefanie Jauns-Seyfried;Michael Krämer;Andreas Schulze	2014		10.1007/978-3-319-06862-6_23	embedded system;software requirements specification;systems engineering;engineering;manufacturing engineering	Robotics	-47.36406040144587	31.34782180907826	149184
b7ba8821259b1da17bfed1effebd32d7b376de1a	an introduction to estelle: a specification language for distributed systems	distributed system;specification language	Estelle is a Formal Description Technique, defined within ISO (International Organization for Standardization) for specification of distributed, concurrent information processing systems. In particular, Estelle can be used to describe the services and protocols of the layers of Open Systems Interconnection (OSI) architecture defined by ISO. Its present ISO status is Draft International Standard (DIS 9074). The article outlines syntactic and semantic aspects of this description technique.	distributed computing;information processing;interconnection;osi model;specification language	Stanislaw Budkowski;Piotr Dembinski	1987	Computer Networks	10.1016/0169-7552(87)90084-5	specification language;computer science;database;programming language;language of temporal ordering specification	DB	-38.8443949674274	27.984972887879454	149323
db6c7a76f67d94718c56b9271868df893d2b43da	dynamic graphical uml views from formal b specifications	formal specification;computacion informatica;information systems;certificate authority;uml;formal specifications;grupo de excelencia;b method;integrated methods;ciencias basicas y experimentales;graphical representation;information system;state transition diagram	This paper addresses the graphical representation of the behaviour of B specifications, using state transition diagrams. These diagrams can help understand the specification for stakeholders who are not familiar with the B method, such as customers or certification authorities. The paper first discusses the principles of the graphical representation on a deterministic example, featuring a small set of states. It then discusses the representation of specifications which feature a large or infinite set of states, or which are non-deterministic. Abstraction techniques are used to overcome these difficulties. They result in a variety of possible representations. Finally, three techniques, based on animation and proof, are presented to help construct the diagrams.	unified modeling language	Akram Idani;Yves Ledru	2006	Information & Software Technology	10.1016/j.infsof.2005.03.008	computer science;theoretical computer science;formal specification;database;programming language;information system;algorithm	SE	-43.40684156696635	28.06560564100688	149407
67d572eaebb69f0395f05724da09fcc1afbe6fee	coherence and robustness in a disturbed mas	security of data distributed processing information systems multi agent systems;reliability;multiagent system;sensor systems;information systems;multi agent system;irrigation;robustness multiagent systems cognition distributed information systems sensor systems monitoring irrigation bonding mobile agents mobile communication;color;mobile agents;distributed processing;multi agent systems;bonding;computational modeling;distributed information systems;monitoring;distributed information system;cognition;mobile communication;coherence;robustness;hypothesis disturbed mas coherence robustness distributed information system multiagent system;hypothesis;security of data;disturbed mas;multiagent systems;robot kinematics	This paper presents a study on how to ensure the coherence of a distributed information system in which information is collected by a multi-agent system with the hypothe sis that some agents of the system are dissonant, i.e. can produc e or communicate incorrect information.	information system;multi-agent system	Quang-Anh Nguyen Vu;Benoit Gaudou;Richard Canal;Salima Hassas	2009	2009 IEEE-RIVF International Conference on Computing and Communication Technologies	10.1109/RIVF.2009.5174630	simulation;computer science;distributed computing;communication	Robotics	-39.44878714404032	18.637455619329668	149608
10497289ef53b74591cd51647a763c2c322910cd	the rosecon system - a computer tool for modelling and analysing of processes	software tool;information systems predictive models information technology information management technology management computer science software tools set theory software systems graphical user interfaces;rough set theory;rosecon system;graphical user interfaces;petri net theory;concurrent system;table lookup concurrency control graphical user interfaces petri nets rough set theory;concurrency control;net model automated discovery;prediction model;petri nets;data table;table lookup;petri net;petri net theory rosecon system concurrent system software tool net model automated discovery data table rough set theory	The paper provides a general description of the ROSECON system - a software tool for automated discovering net models from data tables as well as predicting model changes in time. Especially, we concentrate one's attention on abilities of ROSECON for modelling and analysing of processes. Many of the ROSECON methods and algorithms have originated from the rough set theory introduced by Z. Pawlak in 1982 as well as the Petri net theory proposed by C.A. Petri in 1962	algorithm;petri net;programming tool;rough set;set theory	Zbigniew Suraj;Krzysztof Pancerz	2005	International Conference on Computational Intelligence for Modelling, Control and Automation and International Conference on Intelligent Agents, Web Technologies and Internet Commerce (CIMCA-IAWTIC'06)	10.1109/CIMCA.2005.1631571	computer science;theoretical computer science;machine learning;data mining;database;petri net	Robotics	-46.13500846591546	27.334276504219748	149677
8b022c21aa46b708e9dbe0aee1de3fe7faeaa802	fine-grained integration of access control policies	distributed application;xacml;policy integration;ease of use;expressive power;access control policy;algebra;integrity constraints;access control;grid computing;framework;binary decision diagram	Collaborative and distributed applications, such as dynamic coalitions and virtualized grid computing, often require integrating access control policies of collaborating parties. Such an integration must be able to support complex authorization specifications and the finegrained integration requirements that the various parties may have. In this paper, we introduce an algebra for fine-grained integration of sophisticated policies. The algebra, which consists of three binary and two unary operations, is able to support the specification of a large variety of integration constraints. For ease of use, we also introduce a set of derived operators and provide guidelines for users to edit a policy with desired properties. To assess the expressive power of our algebra, we define notion of completeness and prove that our algebra is complete and minimal with respect to the notion. We then propose a framework that uses the algebra for the fine-grained integration of policies expressed in XACML. We also present a methodology for generating the actual integrated XACML policy, based on the notion of Multi-Terminal Binary Decision Diagrams. Experimental results have demonstrated both effectiveness and efficiency of our approach. In addition, we also discuss issues regarding obligations. a 2010 Elsevier Ltd. All rights reserved.	access control;authorization;binary decision diagram;bitwise operation;distributed computing;grid computing;requirement;unary operation;usability;xacml	Prathima Rao;Dan Lin;Elisa Bertino;Ninghui Li;Jorge Lobo	2011	Computers & Security	10.1016/j.cose.2010.10.006	usability;computer science;access control;theoretical computer science;software framework;data integrity;data mining;database;binary decision diagram;computer security;expressive power;grid computing	DB	-44.04846220412236	19.18613843325417	150152
08790f28b6ffa3b8e755a12d5c3ce0a29a7f92f7	system model optimization through functional models execution: methodology and application to system-level analysis	object oriented methods;formal specification;multidisciplinary design optimization;distributed processing;functional modeling;modelica;object oriented modeling unified modeling language data models optimization solid modeling analytical models computational modeling;object oriented methods distributed processing formal specification;simulation environment system model optimization functional models execution system level analysis functional modeling method design optimization method model based system engineering environment noncommercial tool design phase steps project activity system model behavior simulation model instantiation multidisciplinary design optimization object oriented system analysis multidisciplinary system knowledge model reliability electrical mechanical device space application system requirement design variable distributed modeling;multidisciplinary design optimization mbse functional modeling modelica;mbse	This paper presents the results of a research study related to the application of Functional Modeling and Design Optimization methods in a Model Based System Engineering environment. In particular the potential developments related to the integration of commercial and non commercial tools for the preliminary design phase of a given product are discussed, evaluating the possibility to integrate the functional modeling methodologies studied in the frame of the STEPS1 project activity for a better product definition, through a coherent description of the system model behavior by means of simulation models instantiations. The possibility to introduce the Multidisciplinary Design Optimization approach has been also considered in an object oriented way, aiming for a deeper analysis of the systems under study and to verify the feasibility in improving the multidisciplinary system knowledge, ensuring a better performance analysis without losing the reliability of models. A reference case regarding an electrical-mechanical device for space applications has been developed, to demonstrate the benefits and verify the validity of the selected modeling and simulation approach. To achieve this objective, a scenario is identified and related to specific requirements. Thus the simulation is set to verify that the specified requirements are satisfied by the system model and optimized after a proper selection of the design variables for the system under analysis. A final discussion about the achieved results concludes the article to assess the advantages of the presented approach, integrated in a distributed modeling and simulation environment.	coherence (physics);multidisciplinary design optimization;program optimization;requirement;simulation	Francesco Becherini;Michele Cencetti;Mauro Pasquinelli	2012	2012 IEEE 21st International Workshop on Enabling Technologies: Infrastructure for Collaborative Enterprises	10.1109/WETICE.2012.88	engineering optimization;multidisciplinary design optimization;simulation;computer science;conceptual model;formal specification;modelica;electro-mechanical modeling	EDA	-47.57914441730541	31.51561912695214	150438
385dc2cb3ae1c01d3ef1ddc5a32c42ba6448ba32	smt-based enumeration of object graphs from uml class diagrams	uml;formal methods	This paper presents an encoding of the UML class diagram with OCL invariants in an SMT solver for enumerating all the object graphs from the class diagram. Enumeration of all the object graphs was necessary for our verification of operating systems by model checking, i.e., exhaustively enumerate all the structural variations of the environments to be checked against an operating system. We present our encoding in the SMT solver Yices with the technique of optimization and isomorphism elimination.	class diagram;enumerated type;mathematical optimization;model checking;operating system;solver;unified modeling language	Kenro Yatake;Toshiaki Aoki	2012	ACM SIGSOFT Software Engineering Notes	10.1145/2237796.2237812	unified modeling language;formal methods;computer science;programming language;algorithm	SE	-44.116589997240794	30.461922618314194	150460
1fb5aa36c091279c4986a323da20fb2de03dad65	implementing social norms using policies	ad hoc protocols;agents agent based system mulit agent systems protocols policies social norms;agent interaction;protocols;groupware;collaborative agent system architecture;mulit agent systems;cougaar;multi agent system;policy descriptor language;social norms;darpa;policies;defense agent infrastructure;data mining;social commitment paradigm;inter agent architecture;telecom italia;receivers;bdi paradigm;computer architecture;multi agent systems;fipa standard;agents;registers;ad hoc protocols social norms multiagent systems jade telecom italia cougaar darpa fipa standard defense agent infrastructure collaborative agent system architecture inter agent architecture intra agent architecture policy descriptor language social commitment paradigm bdi paradigm;agent based system;intra agent architecture;protocols standards development programming profession collaboration computer science writing telecommunications multiagent systems abstracts mechanical factors;partial discharges;agent systems;multi agent systems groupware;jade;agent architecture;proposals;development policy;social norm;multiagent systems	Multi-agent systems are difficult to develop. One reason for this is that agents are embedded in a society where all agents must agree to obey certain social norms in order for the society to function. Thus, different programmers, writing different agents, must carefully obey certain agreed-upon protocols. This problem is difficult enough due to the complexity of the interactions, but it is exacerbated by the asynchronous and event-based nature of agent-based systems: agents must asynchronously respond to incoming conversational messages, and may carry on several simultaneous conversations. Several large projects address these issues. Examples are Jade (Telecom Italia) and Cougaar (DARPA). Jade is strictly compliant with the well-known FIPA standard, which makes it useful for commercial agent development and research not directed at certain fundamental aspects of multi-agent systems. Cougaar was developed as a defense agent infrastructure, and while it is not tied to FIPA standards, it is quite prescriptive in both its inter-agent architecture, and its intra-agent architecture. The contribution of CASA (Collaborative Agent System Architecture) is an agent infrastructure that seeks to support agent development, but as much as possible, avoids restricting the inter- or intra-agent architecture or the agent interaction paradigm. This paper describes aspects of the CASA tool that mitigate the aforementioned problems for the research-oriented developer who wants to investigate deviations from standards or alternative architectures. CASA provides a policy descriptor language that abstracts the complexities of conversational interactions away from the programming level, and allows sharing of policies among different agents, even at run time. Thus, an agent programmer is free to concentrate on the properties of the agent, and not on the intricate mechanics of conversational protocols. In addition, policies may be easily modified and distributed as the need arises. Thus, a protocol researcher can concentrate on protocols without having to re-write agent behaviour each time the protocol changes. The policy approach is very flexible, and we have developed policies to support the social commitment paradigm, the BDI paradigm, as well as simpler ad-hoc protocols.	agent architecture;agent-based model;computational auditory scene analysis;cougaar;darpa grand challenge;embedded system;hoc (programming language);interaction;jade;multi-agent system;norm (social);programmer;programming paradigm;run time (program lifecycle phase);whole earth 'lectronic link	Robert Kremer	2009	2009 International Conference on Computational Science and Engineering	10.1109/CSE.2009.229	simulation;computer science;knowledge management;artificial intelligence;multi-agent system;database;computer security;norm	AI	-41.77263063145764	19.40309491250983	150544
3358719afe9bc3a96d61218e1516cb0d5756c567	the uniform workbench - a higher order tool integration framework	developpement logiciel;program transformation;ingenieria logiciel;specification programme;transformation programme;software engineering;functional programming;higher order;development tool;transformacion programa;formal verification;desarrollo logicial;software development environment;software development;genie logiciel;verification formelle;programmation fonctionnelle;tool integration;program specification;programacion funcional;off the shelf;especificacion programa	"""The UniForM Workbench is an open ended tool integration framework for developing (formed) Software Development Environments (SDE) from the basis of pre-fabricated off-the-shelf development tools. The integration framework provides support for data, control and presentation integration as well as utilities for wrapping Haskell interfaces around existing development tools. Entire SDE's are then glued together on the basis of these encapsulations using Concurrent HciskeU as the integration Icinguage, thus cillowing integration to be done at a level of abstraction that is very close to the one offered by constructive formed specifications. So far, the integration framework has successfully been used to integrate tools for Haskell program development as well cis specification and proof tools for Z specifications. During the 80's there were several a t tempts to provide environments for synthesizing tightly integrated SDE's from the basis of abstract language specifications. The Synthesizer Generator (CSG) [46], Gandalf [13], PSG [2] and IPSEN [28] are prominent examples of this approach. They are not perfect solutions, due either to the development costs involved in requiring tools to be developed from scratch in a homogeneous language framevi^ork or due to the inapplicability of the language framework itself (e.g. the a t t r ibute grammars of CSG) in handling the problem domain proper (e.g. proof tools) [25]. More recent systems, such as Centaur [5] and the ASF-I-DSF environment [8], are more open by providing a toolbus for hooking in foreign tools. However, both approaches lack the required features for supporting control and da ta integration """"in the large"""" and """"in the many"""". In the context of a formal program development environment, no single tool or language is believed to be sufficiently powerful enough to support an entire formal development process, rather it is more likely that several loosely coupled and pre-fabricated tools are put together, each supporting a single dedicated task of the overall development [26]. This may suggest that SDE's for formal methods should be based on a loosely coupled architecture [27,48] where pre-fabricated This work has been supported by the Germcin Ministry for Education cind Research (BMBF) as part of the project UniForM under grant No. FKZ 01 IS 521 B2."""	attribute grammar;concurrent haskell;constructive solid geometry;formal methods;hooking;loose coupling;problem domain;programmable sound generator;programming tool;software development;spec#;workbench;wrapping (graphics)	Einar W. Karlsen	1998		10.1007/3-540-48257-1_17	higher-order logic;formal verification;computer science;software development;development environment;programming language;functional programming;algorithm	PL	-46.31304869953614	29.445817230395164	150603
2b53d44b05889c918c2d41babc01763de0ec5232	finite-state testing and analysis of graphical user interfaces	graphical user interfaces analysis finite state testing finite state automata equivalent regular expressions holistic view fault modeling system modeling state transition diagram scalability;system modeling;efficient algorithm;system under test;finite state machines;graphical user interfaces;program testing;finite state automata;software reliability graphical user interfaces finite state machines finite automata program testing;finite automata;graphic user interface;cost effectiveness;fault model;state transition diagram;software reliability;regular expression;graphical user interfaces system testing software testing scalability software design materials testing human computer interaction automatic testing automata modeling	Based on finite-state automata (FSA) and equivalent regular expressions, the paper introduces a holistic view of fault modeling that can be carried out as a complementary step to system modeling, revealing much rationalization potential. Appropriate formal notions will be used to introduce efficient algorithms to systematically generate and select test cases. The completeness of the test can be determined exploiting the link coverage of the state transition diagram of the FSA that models both the desired and undesired behavior of the system under test; this enables a precise scalability of the test and analysis pro??cess, leading to a better cost-effectiveness The elements of the approach will be narrated by realistic examples which will be used also to vali-	algorithm;automata theory;finite-state machine;graphical user interface;holism;regular expression;scalability;state diagram;state transition table;system under test;systems modeling;test case	Fevzi Belli	2001		10.1109/ISSRE.2001.989456	real-time computing;computer science;theoretical computer science;graphical user interface;distributed computing;finite-state machine;programming language	SE	-45.94317971689438	32.20640789495578	151471
136a9387dbdf35bb69f82cdfc989532e5031c4af	differentiating malware from cleanware using behavioural analysis	software;malware feature extraction accuracy classification algorithms software cloud computing monitoring;malware files;cleanware;statistical method malware files cleanware behavioural analysis malicious files distinguishing api call feature automated classification system virtual environment pattern recognition algorithm;api;statistical method;pattern recognition algorithm;accuracy;strings;malicious files distinguishing;statistical analysis;monitoring;malware;api call feature;feature extraction;application program interfaces;behavioural analysis;classification algorithms;classification system;pattern classification;automated classification system;pattern recognition;invasive software;virtual environment;dynamic malware strings api;dynamic;statistical analysis application program interfaces invasive software pattern classification;cloud computing	This paper proposes a scalable approach for distinguishing malicious files from clean files by investigating the behavioural features using logs of various API calls. We also propose, as an alternative to the traditional method of manually identifying malware files, an automated classification system using runtime features of malware files. For both projects, we use an automated tool running in a virtual environment to extract API call features from executables and apply pattern recognition algorithms and statistical methods to differentiate between files. Our experimental results, based on a dataset of 1368 malware and 456 cleanware files, provide an accuracy of over 97% in distinguishing malware from cleanware. Our techniques provide a similar accuracy for classifying malware into families. In both cases, our results outperform comparable previously published techniques.	algorithm;application programming interface;executable;malware;pattern recognition;scalability;virtual reality	Ronghua Tian;Md. Rafiqul Islam;Lynn Margaret Batten;Steven Versteeg	2010	2010 5th International Conference on Malicious and Unwanted Software	10.1109/MALWARE.2010.5665796	computer science;data mining;database;world wide web	SE	-35.77057290736241	22.96643538318015	151756
09a9104bb1bae14c00c12a07860df4b1e21457ed	bounded analysis and decomposition for behavioural descriptions of components	modelizacion;distributed system;sistema transicion;verificacion modelo;systeme reparti;symbolic transition system;analyse statique;behavioral analysis;metodo formal;methode formelle;tipo dato;verification modele;simultaneidad informatica;interface description language;data type;systeme ouvert;program verification;analisis estatica;transition system;formal method;modelisation;verificacion programa;standard model;concurrency;sistema repartido;lenguaje descripcion;systeme transition;model checking;object oriented;analyse comportementale;concurrency control;architecture analysis;component model;oriente objet;analisis conductual;controle concurrence;control concurrencia;static analysis;type donnee;verification programme;open systems;sistema abierto;modeling;simultaneite informatique;orientado objeto;langage description;description language	Explicit behavioural interfaces are now accepted as a mandatory feature of components to address architectural analysis. Behavioural interface description languages should be able to deal with data types and with rich communication means. Symbolic Transition Systems (STS) support the definition of component models which take into account control, concurrency, communication and data types. However, verification of components described with protocol modelled by STS, especially model-checking, is difficult since they possibly involve different sources of infinity. In this paper, we propose the notions of bounded analysis and bounded decomposition. They can be used to test boundedness of systems and to generate finite simulations for them so that standard model-checking techniques may be applied for verification purposes.	component-based software engineering;concurrency (computer science);configuration graph;consistency model;encapsulation (networking);expect;experiment;grand theft auto 2;jean;model checking;petri net;prototype;python;resource reservation protocol;royer oscillator;simulation	Pascal Poizat;Jean-Claude Royer;Gwen Salaün	2006		10.1007/11768869_5	model checking;standard model;interface description language;formal methods;systems modeling;concurrency;data type;computer science;artificial intelligence;concurrency control;component object model;open system;programming language;object-oriented programming;static analysis;algorithm	SE	-39.58788187910707	25.811155761605026	152030
3d4b43e6b81523b16f87a72f8b1645b28fb22542	verifying resource requirements for distributed rule-based systems	rule based system;sensor network;standard model;semantic web;distributed problem solving;business process modelling	Rule-based systems are rapidly becoming an important component of ‘mainstream’ computing technologies, for example in business process modelling, the semantic web, sensor networks etc. However, while rules provide a flexible way of implementing such systems, the resulting system behaviour and the resources required to realise it can be difficult to predict. In this paper we consider the verification of system behaviour and resource requirements for distributed rule-based systems. More specifically, we consider distributed problemsolving in systems of communicating rule-based systems, and ask how much time (measured as the number of rule firings) and message exchanges does it take the system to find a solution. We show how standard model-checking technology can be used to verify resource requirements for such systems, and present preliminary results which highlight complex tradeoffs between time and communication bounds.	business process;experiment;model checking;process modeling;real life;requirement;rule-based system;semantic web;synthetic intelligence;verification and validation	Natasha Alechina;Brian Logan;Nguyen Hoang Nga;Abdur Rakib	2008		10.1007/978-3-540-88808-6_6	rule-based system;business rule management system;standard model;wireless sensor network;computer science;artificial intelligence;theoretical computer science;semantic web;data mining;database;distributed computing;world wide web;business process modeling	SE	-42.134820138187585	22.561089912948695	152204
c0eb70c6f58b76d693f5f1f62283aa2d5fd3041d	ws-mcv: an efficient model driven methodology for web services composition	graph transformation	Web services are available applications on the Web which can be invoked by users to accomplish a potentially business task. However, to meet user’s requirements , it becomes necessary to dynamically organize existent servic es and combine them, responding thus to a new purpose. In this paper, we propose a methodology called WS-mcv (Web Service Modeling, Composing and Verifying) that addresses the main problems arising in Web service composition area. WS-mcv represents an efficient and modular multistep approach achieved by breaking service composition into three processes: service modeling, automatic composition and formal verification. The proposed methodology makes use of the G-Net framework to allow an easiest modeling of basic and existent services. We propose a collection of expressive G-Net based operators that successfully solves complex Web service composition. WS-mcv also defines means to ensure composition correctness. All the processes of WS-mcv have been successfully automated in a model transformation based visual environment.	.net framework;correctness (computer science);formal verification;model transformation;requirement;service composability principle;ws-federation;ws-trust;web service;world wide web	Fayçal Bachtarzi;Allaoua Chaoui;Elhillali Kerkouche	2012	JSW		web service;web modeling;web standards;computer science;operating system;ws-policy;service-oriented architecture;data mining;ws-addressing;database;services computing;world wide web;computer security;graph rewriting	Web+IR	-46.007687838688106	18.28931282965512	152239
688a7bfb4a1bc97d94bd77de7c2f7c178253fac7	formal transducers: models of devices and building bricks for the design of highly interactive systems	user interface;petri net	Producing formal descriptions of low level interaction is necessary to completely capture the behaviour of user interfaces and avoid unexpected behaviour of higher level software layers. We propose a structured approach to formalising low level interaction and scaling up to higher layers, based on the composition of transducers. Every transducer encapsulates the behaviour of a device or software component, consumes and produces events. We describe transducers using a formalism based on Petri nets, and show how this transducer-based model can be used to describe simple but realistic applications and analyse unexpected defects in their design. We also identify properties that are meaningful to the application designer and users, and show how they can be formally checked on a transducer-based model of the application.	component-based software engineering;image scaling;petri net;semantics (computer science);transducer;user interface	Johnny Accot;Stéphane Chatty;Sébastien Maury;Philippe A. Palanque	1997			simulation;computer science;theoretical computer science;engineering drawing	SE	-47.09443929242767	28.967379356878276	152407
98631ccf5594a773e7215bab75c82f23eb8b233b	dsl-dia - an environment for domain-specific languages for database-intensive applications	base donnee;database;base dato;langage dedie;metamodel;metamodele;metamodelo;domain specific language;langage base donnee;database languages;lenguaje dedicado	This paper presents DSL-DIA, an environment that lets a systemfamily vendor define a metamodel for a custom domain-specific language used by customers for specifying properties of family members. Once the metamodel is imported in the environment, the environment allows the customer a flexible way to program in the domain-specific language and translates obtained programs to implementations of family members. In our case, family members are always database-intensive applications with application logic executed in the	business logic;digital subscriber line;domain-specific language;feature-oriented domain analysis;high- and low-level;integrated development environment;metamodeling;software system;test automation	Jernej Kovse;Theo Härder	2003		10.1007/978-3-540-45242-3_31	metamodeling;computer science;domain-specific language;artificial intelligence;operating system;database;distributed computing;programming language;computer security;algorithm;query language	PL	-41.9234612135259	25.052401406052628	152671
d5606e169c7d1970f11c67e87ed0604cd4f68ecf	context-based behavioral equivalence of components in self-adaptive systems	datavetenskap datalogi;computer science	An important challenge to realize dynamic adaptation is finding suitable components for substitution or interaction according to the current context. A possible solution is checking behavioral equivalence of components in different contexts. Two components are equivalent with respect to a context, if they behave equivalently in that context. In this work, we deal with context-specific behavioral equivalence of PobSAM components. PobSAM is a flexible formal model for developing and modeling evolving self-adaptive systems. A PobSAM model is a collection of actors, views, and autonomous managers. Autonomous managers govern the behavior of actors by enforcing suitable context-based policies. Views provide contextual information for managers to control and adapt the actors behavior. Managers are the core components used to realize adaptation by changing their policies. They are modeled as meta-actors whose configurations are described using a multi-sorted algebra called CA. The behavior of mangers depends on the context in which they are executing. In this paper, we present an equational theory to reason about context-specific behavioral equivalence of managers independently from actors. To this end, we introduce and axiomatize a new operator to consider the interaction of managers and the context. This equational theory is based on the notion of statebased bisimilarity and allows us to reason about the behavioral equivalence of managers as well as the behavioral equivalence of the constitutes of managers (i.e., policies and configurations). We illustrate our approach through an example.	adaptive system;autonomous robot;bisimulation;interaction;mathematical model;state transition table;transition system;turing completeness	Narges Khakpour;Marjan Sirjani;Ursula Goltz	2011		10.1007/978-3-642-24559-6_4	simulation;computer science;knowledge management	SE	-42.78595020633581	20.110607305977055	152674
87f68b83ac6205cc66e3e56639e632d142cf2d0b	grid computing and cbr deployment: monitoring principles for a suitable engagement		This paper presents a mathematical technique for modeling the generation of Grid-solutions employing a Case based reasoning system (CBR). Roughly speaking, an intelligent system that tries to be adapted to highly dynamic environment needs an efficient integration of high-level processes (deliberative and time-costly) within low-level (reactive, faster but poorer in quality) processes. The most relevant aspect of our current approach is that, unexpectedly, the performance of the CBR-system do not get worse any time that it retrieves worse cases in situations even when it has enough time to generate better solutions. We concentrate on formal aspects of the proposed Grid-CBR system without establishing which should be the most adequate procedure in a subsequent implementation stage. The advantage of the presented scheme is that it does not depend on neither the particular problem nor a concrete environment. It consists in a formal approach that only requires, on one hand, local information about the averaged-time spent by the system in obtaining a solution and, on the other hand, an estimation about their temporal restrictions. The potential use of industry standard technologies to implement such a Grid-enabled CBR system is discussed here too.	case-based reasoning;grid computing	Luis Fernando Castillo;Gustavo A. Isaza;Manuel Glez Bedia;Miguel Aguilera;Juan David Correa	2012		10.1007/978-3-642-28765-7_42	world wide web;computer security	HCI	-39.004538577482485	20.573062166397023	152770
6780ce1694b52a1fb9c1bf8f4797f98555c240ff	eliciting additional safety requirements from use cases using sfta	control application;software;fault tree;sfta;elevators;hazards;elevators fault trees hazards software floors logic gates;use cases;elevator control application use case based approaches software requirement analysis software development industry functional requirements behavioral requirements nonfunctional requirements additional safety requirement elicitation missing safety requirement elicitation textual description software safety analysis software fault tree analysis hardware safety analysis;non functional requirement;requirement analysis;software requirements;software fault tree analysis;formal verification;safety analysis;logic gates;software safety;safety critical software;software development;use cases sfta software safety analysis ssa;logic gate;use case;software safety analysis ssa;safety critical software fault trees formal verification;floors;fault tree analysis;fault trees	Use case based approaches for software requirement analysis have been used extensively in software development industry to capture functional and behavioral requirements. But use-case based techniques for requirement analysis has not been found to be much effective and supportive enough for capturing non-functional requirements such as safety requirements. To overcome this problem, a systematic approach for eliciting additional and or missing safety requirements from textual description of use cases by the manual application of a well known software safety analysis (SSA) technique named Software Fault Tree Analysis (SFTA) has been proposed and presented in this paper. SFTA has been derived and applied in software from a similar hardware safety analysis technique named Fault Tree Analysis (FTA). The technique presented in this paper operates with the assumption that textual description of the use cases is correct. The effectiveness of the proposed approach has been demonstrated via an application of SFTA on the use case model (UCM) for an Elevator Control application.	fault tree analysis;functional requirement;natural language;non-functional requirement;rational clearcase ucm;requirements analysis;software development	Pankaj Vyas;R. K. Mittal	2012	2012 1st International Conference on Recent Advances in Information Technology (RAIT)	10.1109/RAIT.2012.6194499	reliability engineering;software requirements specification;systems engineering;engineering;software engineering	SE	-46.27051983397017	32.201602694670186	152912
fdbdba0ae046573133b8db7827af94b3e0a33821	formal verification of x-machine models : towards formal development of computer-based systems			formal methods;formal verification;x-machine	George Eleftherakis	2003				Logic	-45.51210175999979	30.51261279677516	153083
5c60ba03224de96fa2898c1ce1b10e900f24f39d	structuring primitives in the callimachus component-based open hypermedia system	structural model;navegacion informacion;callimachus cb ohs;navigation information;specification;serveur informatique;information browsing;systeme ouvert;hypermedia;atomic structure;navigational domain;especificacion;servidor informatico;structural computing;hypermedia domain;informatique structurelle;open hypermedia systems;open systems;sistema abierto;hipermedia;domain specificity;computer server	Driven by the philosophy of the ‘primacy of structure over data’, Component-Based Open Hypermedia Systems (CB-OHS) present an open set of structure servers providing structural abstractions of different hypermedia domains. To address the emergent requirements and to facilitate the development of structure servers, structure should be handled as a first class entity. We propose patterns for structure, called templates, that define the structural model upon which structure servers operate. We present how structure servers are developed and operate in the Callimachus CB-OHS. Development of structure servers within Callimachus is based on the explicit specification of structure with the use of an atomic structural primitive called the structural element. Explicit structure specification eases the development of structure servers in CB-OHS, making such development less error prone and providing the basis for tailoring domain specific abstractions. q 2003 Elsevier Science Ltd. All rights reserved.	cb unix;cognitive dimensions of notations;component-based software engineering;emergence;first-class function;formal specification;hypermedia;hypertext fiction;interoperability;oracle http server;primacy of mind;requirement;server (computing);structural element	Manolis Tzagarakis;Dimitris Avramidis;Maria Kyriakopoulou;Monica M. C. Schraefel;Michalis Vaitis;Dimitris Christodoulakis	2003	J. Network and Computer Applications	10.1016/S1084-8045(02)00064-4	simulation;atom;computer science;artificial intelligence;operating system;database;open system;programming language;world wide web;computer security;specification;server	SE	-40.26776060656984	24.51825165700973	153219
196870448fe4c63782a0ee66cd1e3c0361693546	assurance of system consistency during independent creation of uml diagrams	distributed system;unified modeling language object oriented modeling timing robustness visualization production systems risk management system analysis and design hardware standards development;graph grammar system consistency assurance uml diagrams intuitive formalism distributed systems visualization parallel activity local graph transformation systems;system analysis and design;risk management;system consistency assurance;parallel activity;graph transformation;uml diagrams;data visualisation;visualization;standards development;graph grammar;distributed systems visualization;unified modeling language;intuitive formalism;production systems;robustness;graph grammars;unified modeling language data visualisation graph grammars;object oriented modeling;local graph transformation systems;hardware;timing	Graph transformations are a very intuitive formalism used in visualization, modelling of distributed systems or in support its allocation. The formal description the modelling process (both UML diagram and the trace of designer decisions) complicate its structure; we should be able support both parallel activity of local graph transformation systems and their cooperation for the assurance of the systems consistency. In the paper, the concept of conjugated graphs is introduced for this purpose. Next, the implementation of this concept with the help of aedNLC graph grammar is presented.	diagram;distributed computing;graph rewriting;semantics (computer science);uml state machine;unified modeling language;verification and validation	Lukasz Fryz;Leszek Kotulski	2007	2nd International Conference on Dependability of Computer Systems (DepCoS-RELCOMEX '07)	10.1109/DEPCOS-RELCOMEX.2007.11	computer science;theoretical computer science;applications of uml;database;programming language	Robotics	-46.829328726207244	27.88742550420457	153365
89b4352f540fb28f8a5c33bcf4bb60034493180b	contribution à la multi-modélisation des applications distribuées pour le contrôle de l'évolution des logiciels. (contribution to the multi-modeling of distributed applications for software evolution control)		The software evolution control requires a complete understanding of the changes and their impact on the various system artifacts. We propose a multi-modeling approach for the change impact analysis to provide assistance in understanding the effects of projected or actual changes in distributed software systems. This work elaborate the modeling of software artifacts along with their various interdependencies to build a knowledgebased system, which allows, among others, an assistance for the software developers or maintenance engineers to establish an a priori evaluation of impact of changes. The model we develop integrates two major descriptions of software, at first, the underlying structural description that encompasses the levels of granularity and abstraction of software artifacts, and then the qualitative description designed to integrate the structural description. Initially, the formal models are designed separately for the respective descriptions, and then these are integrated for the objective to study the change impact and its potential propagation through the affected software artifacts. For a change, it is important to establish a qualitative assessment of its impact. The integrated modeling leads to a reasoning based on expert rules. The proposed model is being tested and validated through the development of a platform, implemented in the Eclipse environment.	distributed computing;eclipse;interdependence;linear algebra;software developer;software evolution;software propagation;software system	Adeel Ahmad	2011				SE	-44.171856206597916	24.908197787803935	153379
35894f3551e52c6557b95140093abc9c1e1a981e	a case-based assessment of the fluide framework for specifying emergency response user interfaces	emergency response;user interface specification languages;research report;chapter	In this paper, we report the results from assessing the FLUIDE Framework for model-based specification of user interfaces supporting emergency responders. First, we outline the special challenges faced when developing such user interfaces, and the approach used in the FLUIDE Framework to meet these challenges. Then we introduce the framework, including its two specification languages. Thereafter, we present the case addressing the specification of user interfaces for three existing emergency response applications. Based on these specifications, we discuss how well we succeeded, concluding that we were able to describe the applications in a comprehensive and understandable way taking similarities and difference between the applications into account. The language constructs function as intended, having two languages has proven valuable, and the specifications scale quite well.	component-based software engineering;domain model;model-based specification;round-trip engineering;run time (program lifecycle phase);specification language;traceability;user interface	Erik G. Nilsson;Ketil Stølen	2016		10.1145/2933242.2933253	simulation;systems engineering;engineering;software engineering	HCI	-46.53162820480299	27.812397385527625	153403
7b9c24b5ecfa20063676cf175ccc34a9176882b2	software system verification and program derivation			program derivation;software system		1999				Logic	-45.79394713892303	30.560778165702374	153516
4dffa9845b6236ae156562d9dbc2b09ebe42cc01	ls$$^2$$c - a platform for norm controlled social computers		Social computers have been characterised as goal oriented socio-technical systems comprised of humans as well as computational devices. Such systems can be found in natura in a variety of scenarios, as well as designed to tackle specific issues of social and economic relevance. In the present article we introduce the Lightweight Situated Social Calculus ({(LS^2C)}) as a language to design norm controlled executable specifications of interaction protocols for social computers. Additionally, we describe a platform to process these specifications, giving them a computational realisation. We argue that ({LS{^2C}}) can be used to design, implement and execute algorithms in social computers.		Flávio S. Corrêa da Silva;David Stuart Robertson;Wamberto Weber Vasconcelos	2015		10.1007/978-3-319-27947-3_15	machine learning;situated;artificial intelligence;computer science;theoretical computer science;goal orientation;realisation;executable;norm (social)	ML	-43.059145037046164	19.918186943809484	153522
d1d70065317ad0ed2e878806dc83fd9c759b2707	a cognitive framework based on rewriting logic for the analysis of interactive systems		Interactive systems may appear to work correctly and safely when analysed in isolation from the human environment in which they are supposed to work. In fact, the same cognitive skills that enable humans to perform complex tasks may also become the source of critical errors in the interaction with systems and devices designed as supports for such tasks. It is thus essential to verify the desired properties of an interactive system using a model that not only includes a user-centered description of the task, but also incorporates a representation of human cognitive processes within the task execution. In this paper we consider automatic and deliberate cognitive processes in combination with the use of the Short Term Memory (STM), and pro- vide a formal notation to model the set of basic tasks that a human com- ponent (user or operator) has to carry out to accomplish a goal by inter- acting with an interface. The semantics of the notation is given in terms of a cognitive framework that makes use of rules driven by the basic tasks to rewrite both the system state and the STM until all necessary tasks have been completed. Potential human errors are then detected using model checking. Our notation, which is implemented using the MAUDE rewrite system, and our formal verification methodology are finally illus- trated by two case studies: a user of an Automatic Teller Machine (ATM) and an operator of an Air Traffic Control (ATC) system.	rewriting	Antonio Cerone	2016		10.1007/978-3-319-41591-8_20	simulation;computer science;engineering;theoretical computer science;operating system;software engineering;programming language;algorithm	Logic	-41.12688101630047	29.33073942062204	153574
09bffbdb14023de86f540cbf92f1113fe275d556	eine methodik zur entwicklung von multiagenten-systemen auf basis von geschäftsprozess-modellen		For many years, multi-agent systems have been used as an abstraction for complex and distributed software systems, and have helped in modelling many programs in an understandable and intuitive way. However, fundamental problems of distributed systems often remain: The developer sees just one part of the program code, just one side of the interaction, but not the entirety of the system. In another field of distributed systems, for service-oriented architectures, business process diagrams are being used. Those have many abstractions in common with agents, and are thus well suited for modelling multi-agent systems as a whole. At the same time, agents constitute a powerful execution environment for those processes. This thesis will investigate the question, how multi-agent systems can be modelled holistically by means of business process diagrams, and how agents can be employed for their execution. To this end, we will establish meta-models for both, agents and processes, and describe a mapping specification, how process models can be unambiguously converted into accordant agent systems. This mapping is embedded into a method, combining it with other techniques, in order to simplify and accelerate the agent-oriented software development process. This method is further supported by a special process modelling tool, implementing the described mapping in different ways. Both the mapping and its implementations have been used successfully in a number of research projects.		Tobias Küster	2017				SE	-45.5842798834098	22.42209380707585	153575
2d6c65fc3f6c4bbbbeb3149956b2cebcd5855944	consistency checking in requirements analysis		In the last decade it became a common practise to formalise software requirements using a mathematical language of temporal logics, e.g., LTL. The formalisation removes ambiguity and improves understanding. Formal description also enables various model-based techniques, like formal verification. Moreover, we get the opportunity to check the requirements earlier, even before any system model is built. This so called requirements sanity checking aims to assure that a given set of requirements is consistent, i.e., that a product satisfying all the requirements can be developed. If inconsistencies are found, it is desirable to present them to the user in a minimal fashion, exposing the core problems among the requirements. Such cores are called minimal inconsistent subsets (MISes). In this work, we present a framework for online MISes enumeration in the domain of temporal logics.	algorithm;electronic component;formal verification;linear temporal logic;model checking;requirement;requirements analysis;resultant;software requirements;subroutine	Jaroslav Bendík	2017		10.1145/3092703.3098239	real-time computing;requirement;computer science;theoretical computer science;software requirements specification;ambiguity;software requirements;non-functional testing;system model;formal verification;requirements analysis	SE	-43.3246042684075	29.95897587184127	153724
a7fdb02b5403247857880d66d430f4e6150856fc	xround: bidirectional transformations and unifications via a reversible template language	developpement logiciel;modelizacion;tool support;lenguaje uml;langage modelisation unifie;modelisation;unification;software architecture;desarrollo logicial;unified modelling language;software development;architecture basee modele;modeling;model driven architecture;architecture logiciel;unificacion;arquitectura basada modelo	Efficient tool support for transformations is a key requirement for the industrialisation of MDA. While there is substantial and growing support for unidirectional transformations (e.g., from PIM-to-PSM), for bidirectional transformations there is little. This paper presents tool support for bidirectional transformations, in the form of a language, called XRound, for specifying reversible templates. The language supports round-trip transformations between UML models and predicate logic. Its supporting tool also implements model unification, so that new information encoded in logic can be seamlessly integrated with information encoded in the model.	template processor	Howard Chivers;Richard F. Paige	2005		10.1007/11581741_16	natural language processing;unified modeling language;software architecture;systems modeling;computer science;artificial intelligence;unification;software development;algorithm	Logic	-41.674510182788914	25.60596756387493	153750
83eb69e6f121d7fab1ca9925c7e619b935740157	a norm-governed systems perspective of ad hoc networks	multi agent system;ad hoc network	Ad hoc networks are a type of computational system whose members may fail to, or choose not to, comply with the laws governing their behaviour. We are investigating to what extent ad hoc networks can usefully be described in terms of permissions, obligations and other more complex normative relations, based on our previous work on modelling norm-governed multi-agent systems. We propose to employ our existing framework for the specification of the laws governing ad hoc networks. Moreover, we discuss a software infrastructure that executes such specifications for the benefit of ad hoc network members, informing them of their normative relations. We have been developing a sample node architecture as a basis for norm-governed ad hoc network simulations. Nodes based on this architecture consider the network’s laws in their decision-making, and can be individually configured to exhibit distinct behaviour. We present run-time configurations of norm-governed ad hoc networks and indicate design choices that need to be made in order to fully realise such networks.	hoc (programming language);model of computation;multi-agent system;simulation	Alexander Artikis;Lloyd Daniel Kamara;Jeremy V. Pitt	2006		10.1007/978-3-540-75524-1_8	wireless ad hoc network;adaptive quality of service multi-hop routing;computer science;artificial intelligence;delay-tolerant networking;distributed computing;computer security	Mobile	-42.282001116870234	19.94547958946332	153880
43300da242b077e87011ab969af320574f8dd031	stepwise refinement of processes	components;atomic action;vertical refinenement;abstract data type;process;working paper	Industry is looking to create a market in reliable “plug-and-play” components. To model components in a modular style it would be useful to combine event-based and state-based reasoning. One of the first steps in building an event-based model is to decide upon a set of atomic actions. This choice will depend on the formalism used, and may restrict in quite unexpected ways what we are able to formalise. In this paper we illustrate some limits to developing real world processes using existing formalisms, and we define a new notion of refinement, vertical refinement, which addresses some of these limitations. We show that using vertical refinement we can rewrite a specification into a different formalism, allowing us to move between handshake processes, broadcast processes and abstract data types.	abstract data type;linearizability;plug and play;refinement (computing);rewrite (programming);semantics (computer science);stepwise regression;top-down and bottom-up design	Steve Reeves;David Streader	2006	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2006.05.028	computer science;artificial intelligence;data mining;mathematics;programming language;abstract data type;algorithm;process	Logic	-38.71066649861057	29.10800914117703	153881
5ff0f3d9159cbd3e0d24466564c8c2d1ed19c057	privacy issues in location-aware browsing	location service;location based services;location based service;mobility;positional information;location awareness;privacy	Advances in positioning services and their pervasiveness, e.g., wi-fi based location services, pave the way to the development of innovative LBSs and architectures. In this paper we focus on location-aware browsing, a framework which enables websites to acquire the position of website users. In particular we discuss privacy issues related to the recent W3C proposal for a geolocation API standard. Such specification prescribes that users must give explicit consent to the disclosure of position information to websites. In this paper we argue that stronger and more flexible protection is needed: a) users should be provided with the capability of disclosing coarse regions in place of point coordinates in order to limit the disclosure of personal location data; b) location information should be protected not only against websites but also against location service providers. We discuss a possible approach to address those requirements under the assumption that the position is computed by a wi-fi based positioning service. Finally, we broaden the discussion to include a complementary legal viewpoint.	application programming interface;data protection directive;directive (programming);emoticon;location awareness;location-based service;privacy;requirement;w3c geolocation api	Maria Luisa Damiani;Pierluigi Perri	2010		10.1145/1868470.1868484	computer science;location-based service;database;internet privacy;mobile computing;world wide web;computer security;remote sensing	HCI	-35.84989624060719	18.582944148049997	153990
8de26ef698d35ea755d3b77eb857b73e73df4a8d	wsmo choreography: from abstract state machines to concurrent transaction logic	semantic web service;abstract state machine;web service	Several approaches to semantic Web services, including OWLS, SWSF, and WSMO, have been proposed in the literature with the aim to enable automation of various tasks related to Web services, including discovery, contracting, enactment, monitoring, and mediation. The ability to specify processes and to reason about them is central to these initiatives. In this paper we analyze the WSMO choreography model, which is based on Abstract State Machines (ASMs), and propose a methodology for generating WSMO choreography from visual specifications. We point out the limitations of the current WSMO model and propose a faithful extension that is based on Concurrent Transaction Logic (CTR). The advantage of a CTR-based model is that it uniformly captures a number of aspects that previously required separate mechanisms or were not captured at all. These include process specification, contracting for services, service enactment, and reasoning.	abstract state machines;control flow;interaction;mathematical optimization;owl-s;process (computing);process specification;semantic web service;service discovery;sinewave synthesis;transaction logic;wsmo	Dumitru Roman;Michael Kifer;Dieter Fensel	2008		10.1007/978-3-540-68234-9_48	web service;real-time computing;computer science;artificial intelligence;database;world wide web;abstract state machines	DB	-45.562730066821146	18.825608586964393	154193
f4cc55e8890af957d63608142442a85226127007	behavioral validation of jfsl specifications through model synthesis	algebra;data structures;formal specification;object-oriented programming;specification languages;theorem proving;jfsl specifications;abstract implementation;algebraic axioms;algebraic specifications;automatic small-scope based approach;behavioral validation;complex theorem proving techniques;component behavior;data abstractions;declarative specification technique;incomplete behavioral abstractions;model synthesis;requirement engineering models;behavioral validation;contracts;model synthesis;specifications	Contracts are a popular declarative specification technique to describe the behavior of stateful components in terms of pre/post conditions and invariants. Since each operation is specified separately in terms of an abstract implementation, it may be hard to understand and validate the resulting component behavior from contracts in terms of method interactions. In particular, properties expressed through algebraic axioms, which specify the effect of sequences of operations, require complex theorem proving techniques to be validated. In this paper, we propose an automatic small-scope based approach to synthesize incomplete behavioral abstractions for contracts expressed in the JFSL notation. The proposed abstraction technique enables the possibility to check that the contract behavior is coherent with behavioral properties expressed as axioms of an algebraic specifications. We assess the applicability of our approach by showing how the synthesis methodology can be applied to some classes of contract-based artifacts like specifications of data abstractions and requirement engineering models.	artifact (software development);automated theorem proving;automatic identification and data capture;blum axioms;coherence (physics);interaction;invariant (computer science);linear algebra;model checking;postcondition;requirements engineering;semiconductor industry;state (computer science);static program analysis;turing completeness	Carlo Ghezzi;Andrea Mocci	2012	2012 34th International Conference on Software Engineering (ICSE)		algorithm design;data structure;computer science;theoretical computer science;formal specification;requirements engineering;automated theorem proving;programming language;object-oriented programming;algorithm	SE	-43.256593131057784	29.14622337737708	154290
91a7bcef25f049c65d744f57835adfb53681b92d	simulation fidelity distance: a game-theoretic framework	simulation;alternating games;verification validation;quantitative reachability	The paper addresses one of the fundamental questions in using simulation as a means for system verification and validation, namely, how far the simulation model represents the real system according to the given test objective. Extending studies on quantitative approaches in system refinement based on two player games to the field of system simulation, distance notions for simulation fidelity are proposed. This fidelity distance could be quantified through alternating simulation games between the system model and the simulation model. This paper presents such game theoretic fidelity distance notion for untimed transition systems modeled as automata in the ProDEVS tool. A quantitative reachability graph is then generated using the TINA tool to explore all such player strategies in the game. This quantitative reachability graph could be analyzed to gain further insight into the simulation model behavior with respect to the system model. Further, a relative-weighted fidelity distance metric to account for given test objectives is proposed which penalize cheats on expected simulation model behavior more than the other behavior. In addition, these game notions are presented in the context of derivability of experimental frame formalism, where a global test scenario is consistently refined with respect to the model development cycle.	automata theory;game theory;reachability;refinement (computing);scenario testing;semantics (computer science);simulation;verification and validation	Sangeeth Saagar Ponnusamy;Vincent Albert;Patrice Thebault	2016	2016 Symposium on Theory of Modeling and Simulation (TMS-DEVS)		verification and validation of computer simulation models;simulation;computer science;theoretical computer science;distributed computing	Logic	-40.09953446900279	30.23004423705954	154358
22b9ec8f3ee9b75d75b88b1fd085e7032e0e3099	impact of behavioral forces on knowledge sharing in an extended enterprise system of systems		"""An extended enterprise is both a system of systems (SoS) and a complex dynamical system. We characterize government-run joint and interagency efforts as “government extended enterprises” (GEEs) comprising sets of effectively autonomous organizations that must cooperate voluntarily to achieve desired GEE-level outcomes. Our research investigates the proposition that decision makers can leverage four “canonical forces” to raise the levels of both internal GEE cooperation and SoS-level operational effectiveness, changing the GEE's status as indicated by the """"SoS differentiating characteristics"""" detailed by Boardman and Sauser. Two prior papers described the concepts involved, postulated the relationships among them, and discussed the n-player, iterated """"Stag Hunt"""" methodology applied to execute a real proof-of-concept case (the U.S. Counterterrorism Enterprise's response to the Christmas Day Bomber) in an agent-based model. This paper presents preliminary conclusions from data analysis conducted as a result of ongoing testing of"""	agent-based model;apple sos;autonomous robot;complex dynamics;dynamical system;enterprise system;extended enterprise;iteration;system of systems	Lawrence John;Pat McCormick;Tom McCormick;Gregory R. McNeill;John T. Boardman	2011			enterprise systems engineering;knowledge management;enterprise information system	Robotics	-43.31200342109838	18.85092637547024	154440
89ffa5b4f7b09246d59813083a844689eb6f12fe	time and the web: representing and reasoning about temporal properties of interaction with distributed systems	temporal logic;interface design;world wide web;distributed systems		distributed computing;world wide web	Chris W. Johnson	1995			web modeling;computer science;theoretical computer science;database;distributed design patterns;world wide web	Logic	-47.45279524173454	20.706897563108246	154477
99d54eaf43bb6c013d8b09f93e6731e368d0e488	the integrated application based on real-time extended uml and improved formal method in real-time embedded software testing	software testing;uml;real time embedded software;formal method;test case;efsm;test sequence	In this paper, formal methods were introduced into the real-time embedded software testing field and a real-time extended finite state machine, called rt_EFSM, was studied firstly. And then, the process of the integrated application based on real-time extended Unified Modeling Language (UML) and improved formal method in real-time embedded software testing are put forward. Furthermore, the extension scheme of the real-time UML, including the improvement and extension of state transitions and time constraints described mechanism, and the conversion method from real-time UML to rt_EFSM ware proposed. Finally, combined with the testing process of flight control software of an unmanned aerial vehicle (UAV), a method to generate the time-extended UIO sequence (ex_UIO) was put forward. Finally, the method to generate test cases automatically according to ex_UIO sequence was brought forward. The method proposed in this paper can fully make use of the advantages of tool resources of the UML which has been as the industry standard, but also the advantages of formal methods in accuracy, effectiveness and automation support.	embedded software;extended precision;formal methods;real-time transcription;software testing;unified modeling language	Yongfeng Yin;Bin Liu;Zhen Li;Chun Zhang;Ning Wu	2010	JNW	10.4304/jnw.5.12.1410-1416	unified modeling language;embedded system;real-time computing;formal methods;uml tool;computer science;operating system;applications of uml;software testing;test case	Embedded	-44.2319091622754	31.8213615071062	154492
16eedae6ceac2d9e27937c1c0acde640a10b12f0	supporting communication and cooperation in distributed representation for adaptive design	distributed representation;computer aided design;building information modelling;building information management;hypergraph transformations;multiagent systems	Different types of graphs has been successfully used to represent designs at different stages of the design process. Changes to a model representing a design during the process can be modelled by applying graph transformations. In many real life design tasks the changes/updates can be carried out simultaneously on different parts of the design. Hence a model based on graph transformations is coupled with a multiagent paradigm to enable the parallelisation of these transformations to mimic the real life approach. In this paper a hypergraph representation and transformation model is used as a basis for building a multiagent system supporting distribution and adaptation in computer aided design. This representation can be applicable throughout the lifecycle of the design. It is based on research in formal language theory, like graph grammars, and distributed models including multiagent systems. The motivation for the work presented here is given and possible applications are described. The application of the theoretical results in a graph distribution toolkit proposed as a multiagent framework is also considered. To assure the efficiency of the system it should be implemented as a parallel multiagent system. The hypergraph distribution and partial replication, allowing for its parts to be managed by agents, is also presented. The approach is illustrated by a case study from the domain of building design, where it is used to represent, modify and maintain building information. 2012 Elsevier Ltd. All rights reserved.	agent-based model;artificial neural network;assistive technology;computer-aided design;formal language;graph (discrete mathematics);graph rewriting;multi-agent system;parallel computing;programming paradigm;real life	Leszek Kotulski;Barbara Strug	2013	Advanced Engineering Informatics	10.1016/j.aei.2012.10.002	building information modeling;computer science;artificial intelligence;theoretical computer science;computer aided design;machine learning;multi-agent system;distributed computing	AI	-42.46736171353661	22.469710587138962	154569
d076898c00fa0652cf01a51ca15b3012639458fe	on modelling adaptive service-oriented business processes	content management;semantic web service;transient architectural connectors;large scale systems large scale integration computer science availability mediation computer architecture application software content management kernel context modeling;service composition logic;banking;kernel;service composition;application software;availability;service adaptivity;fine grained activity based perception;service orientation;probability density function;articulo;adaptive service oriented business process;on modelling adaptive service oriented business processes;web service;data mining;transient analysis;connectors;computer architecture;semantic web services;software architecture;large scale integration;mediation;business data processing;business;web services;service technology;web services business data processing software architecture;event driven business rules;computer science;eca driven business rules;service oriented architecture;service adaptivity semantic web services eca driven business rules architectural interactions;net environment adaptive service oriented business process service technology web services fine grained activity based perception event driven business rules transient architectural connectors service oriented architecture service composition logic;context modeling;net environment;architectural interactions;business rules;business process;large scale systems	With the maturing of service technology, most of organizations are implementing their business processes using Web-Services (shortly SO-BPs). Nevertheless, still challenging engineering problems are hindering highly adaptive and realistic composite services. We are proposing a stepwise approach for this purpose. First, we are adopting a fine-grained activity-based perception, where we govern the semantics of any activity using event-driven business rules. We then conceptualize such activity-centric rules as transient architectural connectors. In terms of service-oriented architecture, connector roles will be playing service interfaces, whereas their glues be capturing the service composition logic. We further sketch how this modelling approach can be implemented using the aspectual. Net environment.	.net framework;business process;event-driven finite-state machine;event-driven programming;service composability principle;service-oriented architecture;service-oriented infrastructure;service-oriented modeling;software deployment;stepwise regression;terms of service;web service	Nasreddine Aoumeur;Kamel Barkaoui;Gunter Saake	2009	2009 IEEE/ACS International Conference on Computer Systems and Applications	10.1109/AICCSA.2009.5069297	web service;computer science;knowledge management;database;world wide web	SE	-47.22902295072018	18.48059444682752	154573
2444c7b4313305f716d109be983668e59ca8c6a6	formal virtual modelling and data verification for supervision systems		This paper reports on the use of formal techniques to ensure as far as possible a safe decommissioning of a plant several decades after it was designed and built. Combination of supervised learning, formal modelling, model animation and model checking enabled the recovery of an almost lost specification and the design of a virtual supervision system that could be checked against recorded plant data.		Thierry Lecomte	2015		10.1007/978-3-319-19249-9_41	verification;formal methods	Logic	-43.87595741031958	31.249949756575127	154618
66f50db3fb085b1b0f2e0fefe3f5f7ce11a314d1	a temporal reasoning approach of communication based workflow modelling	temporal reasoning	Implementation of formal techniques to aid the design and implementation of workflow management systems (WfMS) is still required. We believe that formal methods can be applied in the field of properties demonstration of a workflow specification. This paper develops a formalization of the workflow paradigm based on communication (speech-act theory) by using a temporal logic, namely, the Temporal Logic of Actions (TLA). This formalization provides the basic theoretical foundation for the automated demonstration of the properties of a workflow map, its simulation, and fine-tuning by managers.	business process;formal methods;map;programming paradigm;simulation;temporal logic of actions	José Luis Caro;Antonio Guevara;Sergio Gálvez;Antonio Carrillo;Andrés Aguayo	2003			xpdl;computer science;knowledge management;theoretical computer science;workflow management system;workflow technology	DB	-42.962509733864024	23.01517780568664	154648
24afaf3441537252642afe7da5ff3a4298402d20	a formal knowledge level process model of requirements engineering	developpement logiciel;multiagent system;systeme intelligent;formal specification;adquisicion del conocimiento;sistema inteligente;acquisition connaissances;specification formelle;especificacion formal;article letter to editor;desarrollo logicial;knowledge acquisition;requirement engineering;software development;intelligent system;process model;sistema multiagente;article in monograph or in proceedings;systeme multiagent	In current literature few detailed process models for Requirements Engineering are presented: usually high-level activities are distinguished, without a more precise specification of each activity. In this paper the process of Requirements Engineering has been analyzed using knowledgelevel modelling techniques, resulting in a well-specified compositional process model for the Requirements Engineering task.	high- and low-level;knowledge level;process modeling;requirement;requirements engineering	Daniela E. Damian;Catholijn M. Jonker;Jan Treur;Niek J. E. Wijngaards	1999		10.1007/978-3-540-48765-4_92	requirements analysis;software requirements specification;requirements management;performance engineering;computer science;systems engineering;artificial intelligence;software development;requirement;needs analysis;system requirements specification;requirements elicitation;process modeling;formal specification;functional specification;requirements engineering;functional requirement;non-functional requirement;requirements traceability	SE	-40.13566162091195	24.485972522127405	154827
c0a2898862baa3cd65176758f3e7236d42e271a9	ezpetri: a petri net interchange framework for eclipse based on pnml	petri net	Petri net community has suffered with the lack of a standard format to represent Petri net models. This situation led to an undesirable tool incompatibility. In order to solve this drawback, the PNML has been proposed. PNML is an interchange file format for Petri nets based on XML. This paper presents a framework, called EZPetri, based on PNML. The EZPetri framework is a perspective of the Eclipse platform. The union of Eclipse and PNML has demonstrated to be an effective instrument for integrating Petri net tools and applications. The paper discusses the principles of the EZPetri framework, and presents three applications integrated into the EZPetri framework: software power estimation; A SystemC model for Petri nets ; and hard real-time software synthesis. Such applications have been developed with no knowledge about EZPetri. This is a demonstration of the integration facilities provided by EZPetri. The framework is a fertile ground for combining existing of Petri net tools and applications into a single environment, offering Petri net community a new perspective of integration.	eclipse;interoperability;petri net markup language;real-time clock;real-time computing;real-time transcription;software incompatibility;systemc;xml	Gabriel Alves;Adilson Arcoverde;Ricardo Massa Ferreira Lima;Paulo Romero Martins Maciel	2004			software;xml;systemc;eclipse;petri net;stochastic petri net;computer architecture;file format;computer science;distributed computing	SE	-46.79538097968492	23.539214391524354	154860
2f6a783bfa7b83d11ab692c68871256fd985489c	on the design of the new testing language ttcn-3	new testing language ttcn-3;standardisation	This paper gives an overview of the main concepts and features of the new testing language TTCN version 3 (TTCN-3). TTCN-3 is a complete new testing language built from a textual core notation on which a number of different presentation formats are possible. This makes TTCN-3 quite universal and application independent. One of the standardised presentation formats is based on the tree and tabular format from previous TTCN versions and another standardised presentation format is based on MSCs. TTCN-3 is a modular language and has a similar look and feel to a typical programming language. However, in addition to the typical programming constructs it contains all the important features necessary to specify test suites.	look and feel;programming language;ttcn-3;table (information);test suite	Jens Grabowski;Anthony Wiles;Colin Willcock;Dieter Hogrefe	2000			computer science;programming language;engineering drawing;algorithm	PL	-47.204970182346834	30.60135642029748	154869
81c6c8505526205909c60a30c909835819655210	the inav indoor navigation system	location based service;probability density function;middleware;navigation system	COMPASS is a location framework where location sources are realized as plugins that contribute probability density functions to the overall localization result. In addition, COMPASS uses a decentralized location-based service discovery based on Peer-2-Peer distributed hashtables to retrieve semantical data on the determined position. In order to demonstrate the usefulness of COMPASS as a localization middleware, we have developed iNAV, an indoor navigation system that makes extensive use of the previously described mechanisms.	compass;hash table;location-based service;middleware;plug-in (computing);service discovery	Frank Kargl;Sascha Geßler;Florian Flerlage	2007		10.1007/978-3-540-76772-5_9	embedded system;computer vision;probability density function;simulation;computer science;operating system;location-based service;middleware	Mobile	-35.80008637150355	18.459534563874605	154873
c115ed4e7ccc5622f7745684bbffd6f095e0b5c4	deciding on a pattern	software;pragmatics;programmation;logiciel;systeme aide decision;analyse decision forme;connaissance;pragmatica linguistca;analisis decision;object oriented software;conocimiento;sistema ayuda decision;prise decision;decision analysis;software pattern;programacion;knowledge;decision support system;pragmatique;object oriented;oriente objet;logicial;toma decision;orientado objeto;programming;analyse decision	Object-oriented software patterns account for knowledge regarding a solution to a programming problem in a context. Software patterns are increasingly popular and consequently their numbers are growing. Under these circumstances, it is a challenge for the pattern user to decide on which patterns to incorporate into their design. In this paper, we describe a pattern decision analysis approach that provides pragmatic support to making this design decision.	decision analysis;decision problem;software design pattern	Jonathan C. McPhail;Dwight Deugo	2001		10.1007/3-540-45517-5_99	programming;software design pattern;state pattern;decision support system;behavioral pattern;decision analysis;computer science;artificial intelligence;software analysis pattern;data mining;pattern language;knowledge;programming language;algorithm;specification pattern;pragmatics	SE	-38.34058213976119	23.152161050698947	154949
bf1b48ac09af062962898018bc29bdae607cc2e6	towards a system model for ensembles	non-deterministic environment;dynamically adapting;arbitrary preorders;system model;massive number;fitness criterion;complex interaction;software development;precise definition;software-intensive system	Ensembles—software-intensive systems with massive numbers of nodes or complex interactions between nodes, operating in open and non-deterministic environments and dynamically adapting to changes in their environment or requirements—pose many challenges to software development. We present first steps towards a system model for ensembles that allows us to express requirements using a wide variety of logics and fitness criteria over arbitrary preorders. Using this system model we then give a precise definition of “black-box” adaptation and show how this naturally leads to a preorder of adaptability on ensembles.	black box;ensemble forecasting;indeterminacy in concurrent computation;interaction;introspection;model checking;network controllability;process calculus;requirement;self-awareness;sensor;software development	Matthias M. Hölzl;Martin Wirsing	2011		10.1007/978-3-642-24933-4_12	computer science;artificial intelligence;theoretical computer science;machine learning	SE	-38.53878565214162	29.18675081889021	155231
2f3249df197dd9195c2b0b4643c70708afa4eccc	an ocl-based bridge from concrete to abstract syntax		Syntax Adolfo Sánchez-Barbudo Herrera, Edward Willink, Richard F. Paige 1 Department of Computer Science, University of York, UK. {asbh500, richard.paige} at york.ac.uk 2 Willink Transformations Ltd. ed at willink.me.uk Abstract. The problem of converting human readable programming languages into executable machine representations is an old one. EBNF and Attribute grammars provide solutions, but unfortunately they have failed to contribute effectively to model-based Object Management Group (OMG) specifications. Consequently the OCL and QVT specifications provide examples of specifications with significant errors and omissions. We describe an OCL-based internal domain specific language (DSL) with which we can re-formulate the problematic parts of the specifications as complete, checkable, re-useable models. The problem of converting human readable programming languages into executable machine representations is an old one. EBNF and Attribute grammars provide solutions, but unfortunately they have failed to contribute effectively to model-based Object Management Group (OMG) specifications. Consequently the OCL and QVT specifications provide examples of specifications with significant errors and omissions. We describe an OCL-based internal domain specific language (DSL) with which we can re-formulate the problematic parts of the specifications as complete, checkable, re-useable models.	abstract syntax;artifact (software development);computer science;digital subscriber line;domain-specific language;eclipse;executable;human-readable medium;java;large-scale complex it systems;object constraint language;parsing;programming language;qvt;software bug;usability;word-sense disambiguation	Adolfo Sánchez-Barbudo Herrera;Edward D. Willink;Richard F. Paige	2015			programming language;digital subscriber line;abstract syntax;executable;domain-specific language;computer science;rule-based machine translation	PL	-46.7995408965082	26.536156757623004	155409
212720c85dace81a786b65bef51528b6360e4877	improving the aircraft design process using web-based modeling and simulation	cycle time;computacion informatica;multimedia;design and development;modeling and simulation;heterogeneous computing;simulation;web based simulation;object oriented;ciencias basicas y experimentales;matematicas;computerized simulation;aircraft design;world wide web;interoperability;grupo a;simulation model;computer simulation;heterogeneity;java	Designing and developing new aircraft systems is time-consuming and expensive. Computational simulation is a promising means for reducing design cycle times, but requires a flexible software environment capable of integrating advanced multidisciplinary and multifidelity analysis methods, dynamically managing data across heterogeneous computing platforms, and distributing computationally complex tasks. Web-based simulation, with its emphasis on collaborative composition of simulation models, distributed heterogeneous execution, and dynamic multimedia documentation, has the potential to meet these requirements. This paper outlines the current aircraft design process, highlighting its problems and complexities, and presents our vision of an aircraft design process using Web-based modeling and simulation.	computation;documentation;heterogeneous computing;requirement;web-based simulation	John A. Reed;Gregory J. Follen;Abdollah A. Afjeh	2000	ACM Trans. Model. Comput. Simul.	10.1145/353735.353739	computer simulation;interoperability;real-time computing;simulation;web-based simulation;cycle time variation;computer science;heterogeneity;simulation modeling;modeling and simulation;object-oriented programming;java;symmetric multiprocessor system	EDA	-34.58278047611441	27.54292668377267	155411
b551b46c41f3b85daaa35d24fd07474718839bc2	inducing metaassociations and induced relationships	uml;software engineering;metamodels;mof;article;domain specificity	In the last years, UML has been tailored to be used as a domainspecific modelling notation in several contexts. Extending UML with this purpose entails several advantages: the integration of the domain in a standard framework; its potential usage by the software engineering community; and the existence of supporting tools. In previous work, we explored one particular issue of heavyweight extensions, namely, the definition of inducing metaassociations in metamodels as a way to induce the presence of specific relationships in their instances. Those relationships were intended by the metamodel specifier but not forced by the metamodel itself. However, our work was restricted to the case of induced associations. This paper proposes an extension to the general case in which inducing metaassociations may force the existence of arbitrary relationships at M1. To attain this goal, we provide a general definition of inducing metaassociation that covers all the possible cases. After revisiting induced associations, we show the inducement of the other relationship types defined in UML: association classes, generalization and dependencies.	metamodeling;software engineering;unified modeling language	Xavier Burgués Illa;Xavier Franch;Josep M. Ribó Balust	2009		10.1007/978-3-642-04840-1_14	unified modeling language;uml tool;computer science;artificial intelligence;software engineering;applications of uml;database;algorithm	SE	-44.12520161645809	26.046978348418637	155429
3c7a5b30df7801a8142bead4ed825e764182596f	deep android malware detection	android;deep learning;malware detection	In this paper, we propose a novel android malware detection system that uses a deep convolutional neural network (CNN). Malware classification is performed based on static analysis of the raw opcode sequence from a disassembled program. Features indicative of malware are automatically learned by the network from the raw opcode sequence thus removing the need for hand-engineered malware features. The training pipeline of our proposed system is much simpler than existing n-gram based malware detection methods, as the network is trained end-to-end to jointly learn appropriate features and to perform classification, thus removing the need to explicitly enumerate millions of n-grams during training. The network design also allows the use of long n-gram like features, not computationally feasible with existing methods. Once trained, the network can be efficiently executed on a GPU, allowing a very large number of files to be scanned quickly.	android;artificial neural network;convolutional neural network;end-to-end principle;enumerated type;grams;graphics processing unit;malware;n-gram;network planning and design;opcode;static program analysis	Niall McLaughlin;Jesús Martínez del Rincón;BooJoong Kang;Suleiman Y. Yerima;Paul C. Miller;Sakir Sezer;Yeganeh Safaei;Erik Trickel;Ziming Zhao;Adam Doupé;Gail-Joon Ahn	2017		10.1145/3029806.3029823	computer science;internet privacy;world wide web;computer security	ML	-35.36466552018981	23.4912156470411	155510
c488fef78f3790d382796f4d4718b61a33936f17	designing devs visual interfaces for end-user programmers	cognitive dimensions;visual programming;end user programming;discrete event simulation	Although the Discrete EVent System specification (DEVS) has over recent decades provided systems engineers with a scalable approach to modeling and simulation, the formalism has seen little uptake in many other disciplines where it could be equally useful. Our observations of end-user programmers confronted with DEVS theory or software suggest that learning barriers are largely responsible for this lack of utilization. To address these barriers, we apply ideas from Human-Computer Interaction to the design of visual interfaces intended to promote their users’ effective knowledge of essential DEVS concepts. The first step is to propose a set of names that make these concepts easier to learn. We then design and provide rationale for visual interfaces for interacting with various elements of DEVS models and simulation runs. Both the names and interface designs are evaluated using the Cognitive Dimensions of Notations framework, which emphasizes trade-offs between fourteen aspects of information artifacts. As a whole, this work illustrates a generally applicable design process for the development of interactive formalism-based simulation environments that are learnable and usable to those who are not experts in simulation formalisms.	cognitive dimensions of notations;devs;design rationale;human–computer interaction;programmer;scalability;semantics (computer science);simulation;systems engineering	Maryam M. Maleki;Robert F. Woodbury;Rhys Goldstein;Simon Breslav;Azam Khan	2015	Simulation	10.1177/0037549715598570	cognitive dimensions of notations;real-time computing;simulation;computer science;engineering;artificial intelligence;theoretical computer science;discrete event simulation;operating system;visual programming language;programming language	HCI	-45.25609864180023	24.71408382614553	155608
3f4dd08b9b2ae70b8590621ed9cb60b8c6750efd	integrating uml statechart and collaboration diagrams using hierarchical predicate transition nets	groupware;game theory;real time;virtual reality;collaboration virtual reality virtual environment artificial intelligence collaborative work educational technology paper technology computer science education distributed computing large scale systems;team working;artificial intelligent;dynamic environment;multi agent systems;social sciences computing;artificial intelligence;virtual reality team working groupware artificial intelligence multi agent systems game theory social sciences computing;joint intention model hierarchical relationship computer generated action team virtual environment multiagent model artificial intelligence team member structure hierarchical collaboration model planned team activity model hierarchical tree dynamic environment computer generated actor game theory social science belief desire intention model cognitive operators;virtual environment;hierarchical model	UML has become the standard object-oriented analysis and design language in software industry. However UML lacks a precise semantics that hinders error detection in the early stages of system development. Even worse, there is no clear definition of consistency criteria among various UML notations, and there are few examples of illustrating the use of various notations together. In this paper, we present an approach of using Hierarchical Predicate Transition Nets (HPrTNs) to define and integrate UML statechart diagrams and collaboration diagrams. Our approach establishes a basis for relating various UML models together and for carrying out formal analysis.	error detection and correction;software industry;state diagram;uml state machine;unified modeling language	Zhijiang Dong;Xudong He	2001		10.1109/IAT.2003.1241111	simulation;human–computer interaction;engineering;knowledge management	SE	-45.36686865665826	22.89196671335714	155706
dc76b8cdaec1bf76d04d42bfa485b673d3f5d25e	model transformations in the upes/upsoc development process for embedded systems	unified process;programming language;unified modeling language uml;code generation;model transformation;model based development mbd;development process;modeling language;embedded system;model transformations;uml profile;embedded system design;system on chip;system design;unified modeling language;model based development;system development;model based design;systemc	Model-based development (MBD) aims at combining modeling languages with model transformers and code generators. Modeling languages, like profiles of the Unified Modeling Language (UML), are increasingly being adopted for specific domains of interest to alleviate the complexity of platforms and express domain concepts effectively. Moreover, system development processes based on automatic model transformations are widely required to improve the productivity and quality of the developed systems. In this paper, we show how MBD principles and automatic model transformations provide the basis for the unified process for embedded systems (UPES) development process and its unified process for system-on-chip (SoC) (UPSoC) subprocess. They have been defined to foster in a systematic and seamless manner a model-based design methodology based on the UML2 and UML profiles for the C/SystemC programming languages, which we developed to improve the current industrial system design flow in the embedded systems and system-on-chip area.	bachelor of computer application;child process;embedded system;library (computing);model transformation;model-based definition;principle of abstraction;profile (uml);programming language;refinement (computing);seamless3d;system on a chip;systemc;systems design;transformers;unified modeling language;unified process	Elvinia Riccobene;Patrizia Scandurra	2009	Innovations in Systems and Software Engineering	10.1007/s11334-009-0080-9	system on a chip;unified modeling language;real-time computing;computer science;systems engineering;engineering;unified process;modeling language;programming language;model-based design;software development process;code generation;systems design	Embedded	-48.12930469329781	29.63407565690888	155751
ab33f10770de2eb36c29da44df381cea7b66e09d	detection of false data attacks in smart grid with supervised learning	ieee 30 bus system false data attacks detection false data injection supervised learning classifiers smart grid fdi detectors false measurement data false state data direct fdi attack stealth fdi attack;detectors jacobian matrices supervised learning support vector machines smart grids state estimation topology;smart power grids learning artificial intelligence pattern classification power engineering computing power system security security of data	The threat of false data injection (FDI) attacks have raised wide interest in the research and development of smart grid security. This paper presents a comparative study on the utilization of supervised learning classifiers to detect direct and stealth FDI attacks in the smart grid. A detailed formulation of the problem for detection with classifiers is first described with proper assumptions and justifications. Three widely used supervised learning (SL) based classifiers are chosen to design corresponding FDI detectors. The performance are tested against false measurement data (direct FDI attack) and false state data (stealth FDI attack) on both balanced and imbalanced cases, with consideration of the influence of FDI resources and magnitudes. Simulations on IEEE 30-bus system have shown that the SL based detectors can effectively detect both direct and stealth FDI attacks, especially for the more severe attacks with large amount or magnitude of compromised measurements.	computer simulation;fault detection and isolation;sl (complexity);sensor;stealth;supervised learning	J. J. Yan;Bo Tang;Haibo He	2016	2016 International Joint Conference on Neural Networks (IJCNN)	10.1109/IJCNN.2016.7727361	computer science;machine learning;data mining;computer security	EDA	-34.01613445506164	22.573132445331886	155779
0fafc8b9251570a1877c2d74b714dd52894ea63e	type systems for modular programs and specifications	thesis or dissertation;kb thesis scanning project 2015;type system	ii		David Aspinall	1997			computer science;software engineering;algorithm;computer engineering	Logic	-46.15489241440026	30.433084535979653	156422
3aad3168988438800eb13c4be8dd7b23260e8a6a	pi-method: a model-driven formal method for architecture-centric software engineering	software tool;formal model;component based software engineering;architecture description language;software systems;formal methods;software engineering;architecture description languages;formal method;model driven development;software architecture;mobile environment;rewriting logic;architecture analysis;architecture centric software engineering;architecture transformation refinement languages;architecture analysis languages;software architectures;formal language	Software systems have become increasingly complex and are often used in highly dynamic, distributed and mobile environments. Formal development of such software systems in order to guarantee their completeness and correctness is a large research challenge. This article presents the π-Method, a novel formal method that has been designed in the ArchWare European Project to address model-driven development of safe software systems. It is a well-founded theoretically method relying on formal foundations: its formal language for architecture description is based on the π-calculus, for architecture analysis on the μ-calculus, and for architecture transformation and refinement on the rewriting logic. The π-Method, like formal methods such as B, FOCUS, VDM, and Z, aims to provide full support for formal development of software systems. However, unlike these methods that do not provide any architectural support, the π-Method has been built from scratch to formally support architecture-centric component-based model-driven development. Furthermore, a major impetus behind defining formal languages and method is that their formality renders them suitable to be manipulated by software tools. Indeed, a comprehensive toolset supporting formal model-driven engineering has been developed.	component-based software engineering;correctness (computer science);focus;formal language;formal methods;mathematical model;model-driven architecture;model-driven engineering;model-driven integration;programming tool;refinement (computing);rendering (computer graphics);rewriting;software system;vienna development method	Flávio Oquendo	2006	ACM SIGSOFT Software Engineering Notes	10.1145/1127878.1127885	grammar systems theory;software architecture;architecture description language;verification and validation;formal language;formal methods;formal verification;rewriting;computer science;systems engineering;engineering;package development process;component-based software engineering;software development;software design description;software engineering;formal specification;refinement;programming language;software development process;software system	SE	-44.763689150941666	30.491308395689966	156441
5b3ca5bdd8dd4e685c91d06c4f0ace5b9860b0a5	formal construction model and specification of fault tree	cafeobj;fault tree analysis;formal specifications;software engineering;fault tree		fault tree analysis	Jianwen Xiang;Kokichi Futatsugi;Yanxiang He	2004			event tree;reliability engineering;fault tree analysis;computer science	Logic	-46.731207398517384	32.166560911205956	156452
b0daf53035a485747a31e52329c91236817e5388	towards the formalisation of object-oriented methodologies	uml;object oriented formal methods oofms;specification;software systems;formal methods;specification language;ease of use;formal method;z;thesis;object oriented;levels of abstraction;object orientation	Formal methods have been shown to be beneficial in increasing the quality of and confidence in software systems. The adoption of formal methods in industry has however been limited where the use of informal and semi-formal notations is favoured. To bridge the gap between the ease-of-use of semi-formal notations and correctness of formal methods, a number of approaches to the formalisation of semi-formal notations have been proposed. Two of these approaches are discussed in this paper on the strength of a case study. It is shown that each approach offers results that differ in terms of levels of abstraction, requisite knowledge of the formal target specification language and potential for automation.	correctness (computer science);formal methods;principle of abstraction;semiconductor industry;software system;specification language	Ayodele A. Adesina-Ojo;John A. van der Poll;Lucas M. Venter	2011		10.1145/2072221.2072252	formal methods;object language;specification language;formal verification;computer science;systems engineering;formal specification;refinement;programming language;algorithm	SE	-43.53494023139638	26.54082055068852	156481
05017bb3176484f63bcc9cdaa53792479cdf17d9	ltsa-msc: tool support for behaviour model elaboration using implied scenarios	tool support;model checking	We present a tool that supports the elaboration of behaviour models and scenario-based specification by providing scenario editing, behaviour model synthesis, and model checking for implied scenarios.	behavioral modeling;local tangent space alignment;model checking	Sebastián Uchitel;Robert Chatley;Jeff Kramer;Jeff Magee	2003		10.1007/3-540-36577-X_44	model checking;simulation;computer science;programming language;algorithm	SE	-42.461825226844454	29.30591336838325	156588
a463bb2cd9b3fb0bdae49742d7963c620e2edbe7	performance specification and evaluation with unified stochastic probes and fluid analysis	analytical models;software metrics;probes stochastic processes analytical models algebra computational modeling semantics syntactics;formal specification;software performance evaluation;semantics;probes;computational modeling;passage time analysis performance modeling performance evaluation tools stochastic process algebra measurement probes fluid approximation;stochastic processes;algebra;stochastic process algebra;syntactics;software performance evaluation formal specification process algebra software metrics;measurement probes;process algebra;fluid approximation;performance modeling;performance evaluation tools;passage time analysis;complex distributed wireless network performance specification mechanism performance evaluation mechanism unified stochastic probes fluid analysis software system performance metrics process algebra model state based activation action based activation location based specification many probe specification immediate signaling stochastic probe language common response time measure	Rapid and accessible performance evaluation of complex software systems requires two critical features: the ability to specify useful performance metrics easily and the capability to analyze massively distributed architectures, without recourse to large compute clusters. We present the unified stochastic probe, a performance specification mechanism for process algebra models that combines many existing ideas: state and action-based activation, location-based specification, many-probe specification, and immediate signaling. These features, between them, allow the precise and compositional construction of complex performance measurements. The paper shows how a subset of the stochastic probe language can be used to specify common response-time measures in massive process algebra models. The second contribution of the paper is to show how these response-time measures can be analyzed using so-called fluid techniques to produce rapid results. In doing this, we extend the fluid approach to incorporate immediate activities and a new type of response-time measure. Finally, we calculate various response-time measurements on a complex distributed wireless network of O(10129) states in size.	computer cluster;performance evaluation;process calculus;software system;stochastic probe	Richard A. Hayden;Jeremy T. Bradley;Allan Clark	2013	IEEE Transactions on Software Engineering	10.1109/TSE.2012.1	process calculus;real-time computing;computer science;theoretical computer science;formal specification;semantics;programming language;computational model;software metric	SE	-36.3365326613111	31.0184816787733	157071
03ff80d374dffd2804913c95005b30a7a0c792bb	infrastructure for forensic analysis of multi-agent based simulations	multi agent system;aspect oriented programming;multi agent based simulation	The Multi Agent Systems (MAS) theory has methodical approaches to analyze, understand and debug the social level of agents. This paper aims to argue that technologies for the analysis of MAS can be used in the field of Multi-agent based simulation (MABS). In particular, forensic analysis is proposed. It is explained the creation of an infrastructure for forensic analysis to assist the analysis of any model independently of its scope and framework of development. To achieve this genericity, the proposal is based in the use of Aspect Oriented Programming (AOP). In addition, it is given the key ideas used in the implementation of this infrastructure on the MABS platform MASON, giving a great power of analysis to this framework.	computer simulation	Emilio Serrano;Juan A. Botía Blaya;José Manuel Cadenas	2009		10.1007/978-3-642-14843-9_12	simulation;aspect-oriented programming;computer science;artificial intelligence;multi-agent system;programming language	NLP	-42.60795939610141	21.687954869083395	157090
58883cf32da2bdb06f7351ece6d44d58636a0e01	multiscale three-phase flow simulation dedicated to model based control	model based process control;three phase flow;modeling and simulation;real time;software systems;multiscale modelling;model based control;process control;flow simulation;multiphisics and multiscale modelling and simulation;particle movement	Multiphysics and multiscale three-phase flow simulation is proposed for model based control. Three-phase flow is considered by means of particles movement in a pipe with two-phase gas and liquid vacuum pumping. The presented model and simulation algorithm were implemented using a software system working in real-time mode. The software system can simulate a part of the pipe net with configured pipe profile, pump station and valve parameters and also inlet mixture composition. In addition, the system includes algorithm for pressure control.		Dariusz Choinski;Mieczyslaw Metzger;Witold Nocon	2008		10.1007/978-3-540-69387-1_29	simulation;computer science;theoretical computer science;process control;modeling and simulation;software system	EDA	-35.69809350136262	28.06842914783979	157141
54a4c5fc56c532f7a10425952865f6c20f6a90b9	dynamic modules: software integration in mupad	software integration;data exchange;open system	The poster introduces the concept of dynamic modules of the computer algebra system (CAS) MuPAD [1]. It is used to integrate user-defined C / C + + code as well as complete software packages into MuPAD and offers an alternative to interprocess communication (IPC) for many applications. The concept is demonstrated by showing the integration of the N A G C [2] library, the polynomial factorizat~on package MAGNUM [3] and the IPC protocols A S A P [4] and MP [6] into MuPAD. The variety of different packages and algorithms which can be utilized simultaneously from within MuPAD increases drastically. I n this sense dynamic modules apply the principle of software integration to the broad field of mathematical applications [9].	algorithm;computer algebra system;inter-process communication;mips magnum;mupad;polynomial;system integration	Andreas Sorgatz	1997	ACM SIGSAM Bulletin	10.1145/271130.271200	data exchange;system integration testing;software development;operating system;software construction;database;open system;resource-oriented architecture;software system;system integration	Theory	-34.04307929822856	27.98952597617826	157229
2cb254e4e51205b192b808554de14953f139a403	realising reusable agent behaviours with alpha	lenguaje programacion;multiagent system;programming language;reutilizacion;intelligence artificielle;reuse;code reuse;agent oriented programming;langage programmation;artificial intelligence;inteligencia artificial;sistema multiagente;reutilisation;systeme multiagent	This paper describes a revision to the design of Agent-Oriented Programming (AOP) that introduces the concept of a role. The proposed AOP framework introduces the notion of a role template and describes how these templates can be used to engender code reuse. We then use this framework to extend the ALPHA programming language and illustrate the use of this extension via a simple case study.	agent-oriented programming;code reuse;dec alpha;ibm 7950 harvest;programming language	Rem W. Collier;Robert J. Ross;Gregory M. P. O'Hare	2005		10.1007/11550648_19	simulation;computer science;artificial intelligence;reuse;programming language	HCI	-39.11664933901137	24.29416750721217	157471
918699bc47da2a6e451cfd7afa31bc0ddfcaec26	towards industrially applicable modeling technique for agent-based systems	modeling technique;agent oriented software engineering;agent based system;industrial application		agent-based model	Arnon Sturm;Onn Shehory	2002		10.1145/544741.544750	computer science;computer engineering;agent-oriented software engineering;distributed computing	Logic	-42.59166712431486	22.285104796319306	157762
060edf2d4e48d4b66810addb047a24e6f08712fb	a domain specific transformation language to bridge concrete and abstract syntax		Existing language workbenches, such as Xtext, support bridging the gap between the concrete syntax (CS) and abstract syntax (AS) of textual languages. However, the specification artefacts – i.e. grammars – are not sufficiently expressive to completely model the required CS-to-AS mapping, when it requires complex name resolution or multiway mappings. This paper proposes a new declarative domain specific transformation language (DSTL) which provides support for complex CS-to-AS mappings, including features for name resolution and CS disambiguation. We justify the value of and need for a DSTL, analyse the challenges for using it to support mappings for complex languages such as Object Constraint Language, and demonstrate how it addresses these challenges. We present a comparison between the new DSTL and the state-of-the-art Gra2Mol, including performance data showing a significant improvement in terms of execution time.	abstract syntax;bridging (networking);domain-specific language;eclipse xtext;language workbench;large-scale complex it systems;metamodeling;minimal mappings;modeling language;object constraint language;parse tree;prototype;run time (program lifecycle phase);technical support;transformation language;word-sense disambiguation	Adolfo Sánchez-Barbudo Herrera;Edward D. Willink;Richard F. Paige	2016		10.1007/978-3-319-42064-6_1	natural language processing;abstract syntax;programming language	PL	-47.68613532381445	25.90172638011721	157795
a88255e9f3b9500194b9e699bec08730aa3ae732	a neural embeddings approach for detecting mobile counterfeit apps		Counterfeit apps impersonate existing popular apps in attempts to misguide users to install them for various reasons such as collecting personal information, spreading malware, or simply to increase their advertisement revenue. Many counterfeits can be identified once installed, however even a tech-savvy user may struggle to detect them before installation as app icons and descriptions can be quite similar to the original app. To this end, this paper proposes to use neural embeddings generated by state-of-the-art convolutional neural networks (CNNs) to measure the similarity between images. Our results show that for the problem of counterfeit detection a novel approach of using style embeddings given by the Gram matrix of CNN filter responses outperforms baseline methods such as content embeddings and SIFT features. We show that further performance increases can be achieved by combining style embeddings with content embeddings. We present an analysis of approximately 1.2 million apps from Google Play Store and identify a set of potential counterfeits for top-1,000 apps. Under a conservative assumption, we were able to find 139 apps that contain malware in a set of 6,880 apps that showed high visual similarity to one of the top-1,000 apps in Google Play Store.	artificial neural network;baseline (configuration management);convolution;convolutional neural network;executable;gramian matrix;malware;mobile app;personally identifiable information;play store;scale-invariant feature transform	Jathushan Rajasegaran;Suranga Seneviratne;Guillaume Jourjon	2018	CoRR		convolutional neural network;theoretical computer science;computer science;machine learning;counterfeit;malware;scale-invariant feature transform;personally identifiable information;artificial intelligence	NLP	-35.467606456956034	24.250250122486875	157853
30f212c5fc45ab30471aed88b4dd9c816bea0d4d	benchmarking simulation models for dynamic hybrid systems		This paper will address the difference between mathematical models and simulation models of a particular simulation environment for Dynamic Hybrid Systems (DHS). From the mathematical point of view, there are different environments available to introduce models for DHS. The simulation environments offer a more restricted set of modelling opportunities. In this contribution the difference of the mathematical model and the simulation model will be discussed, the influence in different case studies analysed and a benchmarking proposal presented which relates possibilities and restrictions.	benchmark (computing);class diagram;hybrid system;mathematical model;microsoft outlook for mac;simulation;vii	Andreas Körner;Stefanie Winkler;Felix Breitenecker	2017	2017 UKSim-AMSS 19th International Conference on Computer Modelling & Simulation (UKSim)	10.1109/UKSim.2017.23	simulation modeling;object-oriented modeling;hybrid system;theoretical computer science;mathematical model;benchmarking;computer science	Robotics	-35.7689577094727	27.520351332285852	158011
5790817ee55a03eaecc97cfcabfe52584102971a	augmenting the industrial internet of things with emojis		Technologies such as Augmented Reality (AR) and Fog Computing permeate more and more areas of our daily lives. These technologies are used in various domains such as eHealth, Gaming and Smart Cities. However, within the Industrial Internet of Things (IIoT), these technologies are slowly finding their way into the market, although they can be drivers of resource efficient and sustainable production economies. By combining these technologies with shared knowledge resources, such as Emojis, new interactions within the industrial domain can be created. These simplify the analysis of conditions of industrial machines and allow the derivation of preventive maintenance measures. In recent years, an increasing number of IoT devices has been observed in the industrial environment. However, the large number of sensors and actuators in industrial plants also pose challenges for employees. Augmented Reality enables new interaction scenarios to facilitate the daily work of employees by presenting machine states in a new way. Emojis and graphs are options for visualizing these states. Downtimes can be reduced by viewing and analyzing the data. The saving of seconds or minutes has a real impact on the business and is of great interest. In this paper, we describe the approach of Augmenting IIoT devices with Emojis to visualize states and conditions of production lines. We present a prototype that we have implemented, our experiences with it as well as the challenges we have uncovered.	as-interface;augmented reality;emoji;fog computing;interaction;internet of things;prototype;requirement;sensor;smart city;smartphone;social network	Andreas Seitz;Dominic Henze;Jochen Nickles;Markus Sauer;Bernd Brügge	2018	2018 Third International Conference on Fog and Mobile Edge Computing (FMEC)	10.1109/FMEC.2018.8364073	data visualization;computer engineering;ehealth;industrial internet;cloud computing;augmented reality;graph;computer science;edge computing;internet of things	HCI	-33.711631071765716	19.32411461095393	158096
1aff0219b3e2648f8dbcbef79d4ead782926993e	enriching textual xtext-dsls with a graphical gef-based editor		Xtext is a widely accepted framework to develop domain-specific languages (DSLs). However, these DSLs are bound to be purely textual, what is appropriate in many but not all cases. Sometimes, one wishes to have another concrete syntax for a DSL. For example, a model should be represented only by graphical elements (i.e., a purely graphical syntax) or by a mixture of graphical elements and textual annotations (i.e., a hybrid syntax).	eclipse xtext;graphical editing framework;graphical user interface	Marcel Toussaint;Thomas Baar	2017		10.1007/978-3-319-74313-4_29	programming language;syntax;computer science	HCI	-47.747427119319774	25.617701005533824	158117
61589e4bc1199ef292438745121be1c50f57e4f0	simulation as a decision-making tool for real-time control of flexible manufacturing systems	flexible manufacturing systems;operational efficiency decision making tool real time control flexible manufacturing systems discrete event simulation shop floor control system;real time control;production control discrete event simulation flexible manufacturing systems real time systems;control system;decision making real time systems flexible manufacturing systems control systems automatic control control system synthesis manufacturing systems discrete event simulation computational modeling computer aided manufacturing;production control;flexible manufacturing system;shop floor control system;real time systems;discrete event simulation	Describes the use of discrete event simulation as the decision-making component of a shop floor control system for flexible manufacturing systems (FMS). The control software is the critical component that determines the operational efficiency of an FMS and the decision-making component largely determines the overall flexibility of the system. A methodology for the development, maintenance, and operation of FMS based on this control system is presented and implementation experience in a full-scale FMS laboratory is provided.	real-time transcription;simulation	Jeffrey S. Smith;Brett A. Peters	1998		10.1109/ROBOT.1998.677036	manufacturing execution system;control engineering;real-time computing;real-time control system;process development execution system;computer science;engineering;control system;discrete event simulation;instrumentation and control engineering;computer-integrated manufacturing	Robotics	-37.19321548323382	22.60270743855367	158127
3f93f49971907a50c64138566701a20afcc46f78	on the role of context in the design of mobile mashups		This paper presents a design methodology and an accompanying platform for the design and fast development of Context-Aware Mobile mashUpS (CAMUS). The approach is characterized by the role given to context as a first-class modeling dimension used to support i) the identification of the most adequate resources that can satisfy the users’ situational needs and ii) the consequent tailoring at runtime of the provided data and functions. Context-based abstractions are exploited to generate models specifying how data returned by the selected services have to be merged and visualized by means of integrated views. Thanks to the adoption of Model-Driven Engineering (MDE) techniques, these models drive the flexible execution of the final mobile app on target mobile devices. A prototype of the platform, making use of novel and advanced Web and mobile technologies, is also illustrated.		Valerio Cassani;Stefano Gianelli;Maristella Matera;Riccardo Medana;Elisa Quintarelli;Letizia Tanca;Vittorio Zaccaria	2016		10.1007/978-3-319-53174-8_7	database;internet privacy;world wide web	SE	-46.65321656919427	21.51067309389316	158152
b68bf144b0561cf3d30abcdb38e2c173691aa16f	mtw: a control mechanism for parallel discrete simulation.	discrete simulation			Lisa Sokol;Brian K. Stucky;Vincent S. Hwang	1989			computer science;discrete event simulation	Theory	-35.9685148094116	27.851083321559297	158336
43059818dfd67168d91ba6b5ac79e73794775130	generalised environment for process management in cooperative software engineering	iterative refinement;workflow management;programming environments software engineering distributed processing project management open systems software development management software agents;programming environments;project management;genesis project;software agent;project manager;distributed processing;software development cooperative software engineering open source platform distributed software engineering genesis project process management workflow management software agents;software engineering;process management;technology management;software agents;informal communication;level of detail;engineering management;software development;process control;on the fly;cooperative software engineering;distributed software engineering;communication system control;open systems;environmental management engineering management software engineering project management communication system control open source software software development management process control technology management software agents;open source platform;environmental management;software development management;software process;open source software;open source;document management	In this paper we present an open source platform supporting distributed software engineering processes, which is currently under development in the GENESIS project (generalised environment for process management in cooperative software engineering). It supports the definition, enactment and control of software processes in a distributed manner and the formal and informal communication among distributed software engineer teams using workflow and document management technologies. We make use of software agents as technological glue to control and monitor the activities execution at different sites (low invasive approach). The highly flexible process definition language allows the project manager to define a software process at different levels of detail supporting both iterative refinement and on the fly activities flow modification.	software engineering	Matteo Gaeta;Pierluigi Ritrovato	2002		10.1109/CMPSAC.2002.1045147	project management;personal software process;verification and validation;team software process;software engineering process group;software sizing;software project management;computer science;systems engineering;knowledge management;package development process;technology management;software design;social software engineering;software framework;component-based software engineering;software development;software agent;software engineering;process control;software construction;software walkthrough;empirical process;management;software deployment;goal-driven software development process;software development process;software system	SE	-42.14012280756715	19.98951436491003	158431
672097b70733bbe9f81ac5338a736fdfdb60d32e	yaml: a tool for hardware design visualization and capture	hardware visualization object oriented modeling unified modeling language microelectronics libraries java embedded computing embedded system software tools;front end;object oriented methods;hardware synthesis;data visualisation;embedded systems;c language;embedded system design;structure and function;specification languages;levels of abstraction;system design;hardware design;hardware synthesis yaml tool hardware design visualization system design structural entities functional entities uml yet another uml front end embedded system design c code simulation;logic cad;specification languages data visualisation logic cad object oriented methods embedded systems c language	"""Design visualization is an important part of the system design process. In practice, systems are often visualized using a combination of structural and functional entities. In this paper, we describe an approach that helps to capture the structural aspects of a design at a high level of abstraction and enables the system designer to enter designs """"schematically"""" using predefined structural and functional entities conforming to UML notation. The corresponding tool, YAML (Yet Another UML front end) provides support for modeling objects and a range of object relationships that are crucial to real-life embedded system designs. A YAML design entry can then be automatically translated into synthesizable C++ code for simulation and hardware synthesis."""	c++;embedded system;entity;high-level programming language;real life;simulation;systems design;unified modeling language;yaml;yet another	Vivek Sinha;Frederic Doucet;Chuck Siska;Rajesh K. Gupta;Stan Y. Liao;Abhijit Ghosh	2000		10.1145/501790.501793	computer architecture;computer science;theoretical computer science;programming language	EDA	-47.834619192584775	30.127528772095154	158511
6e2bda8fa520eecc0a7cdee5064f506e0aa5406c	fsp modeling of a generic distributed swarm computing framework		Swarm computing emerged as a computing paradigm for solving complex optimization problems using a nature-inspired approach. A swarm of particles populates a virtual space that mimics the physical environment. Virtual particles modeled as computational objects are behaving in the virtual space according to the laws of nature, seeking to solve a mathematical optimization problem. In this paper we propose a formal model of a generic distributed framework for swarm computing based on Finite State Process algebra. The model is simple, clear and technology-independent, and it can serve as a basis for concurrent or distributed implementation using available software technologies.	swarm	Amelia Badica;Costin Badica;Marius Brezovan	2015		10.1007/978-3-319-25017-5_17	real-time computing;theoretical computer science;distributed computing	HPC	-40.82678911891027	20.563958965985726	158668
41a8f572cb68c203f44cc1b78ba41e005c91d5bf	object oriented safety analysis of an extra high voltage substation bay	developpement logiciel;modelizacion;lenguaje programacion;formal specification;monitoring control system;programming language;systeme controle commande;ingenieria logiciel;sistema control mando;software engineering;specification language;analisis programa;specification formelle;modelisation;especificacion formal;generador alta tension;safety analysis;system synthesis;object oriented;desarrollo logicial;synthese systeme;software development;object oriented approach;sintesis sistema;genie logiciel;langage programmation;oriente objet;lenguaje especificacion;extra high voltage;program analysis;analyse programme;generateur haute tension;high voltage generator;modeling;orientado objeto;langage specification;object model	Experiences of application of the object oriented approach to safety analysis of an extra high voltage substation bay are presented. As the first step the object model of the whole application is developed. Then the model is subjected to three safety analysis methods. The analyses are supported by an existing tool. The paper illustrates the application of the proposed methods and also gives some observations on the performance of the tool.		Bartosz Nowicki;Janusz Górski	1998		10.1007/3-540-49646-7_24	program analysis;simulation;systems modeling;object model;specification language;computer science;software development;formal specification;programming language;object-oriented programming;algorithm	EDA	-41.953373770713426	26.608845185230315	158695
11e457cffc7ad947ded558c9515232e782bf8c38	hybrid objects	hybrid objects	Combining the modelling power of hybrid automata and the principles of object-orientation, the concept of hybrid objects is introduced. Hybrid objects are general, reusable and encapsulated models of physical systems. Furthermore, the principles of an algorithm, which automatically generates correct control code given the desired behavior of the object, are presented.	algorithm;automata theory;encapsulation (networking);hybrid automaton;hybrid system;programming paradigm	Michael Tittus;Bo Egardt	1994		10.1007/3-540-60472-3_25		Robotics	-38.13471422985291	29.461312554544463	158705
8f0a3652e1ff612bf57a28f20db78f0d4a32c60c	analyzing and comparing architectural styles	specifications formelles;formal specification software architecture distributed processing;styles architecturaux;formal specification architectural styles design patterns system design style formalization mediator broker specialization software architecture presentation abstraction control pattern distributed architecture interactive applications;broker;formal specification;specialization;distributed processing;formal specifications;skeleton;style formalization;graphical user interfaces skeleton specification languages;architectural styles;pac;software architecture;mediator;graphical user interfaces;interactive application;schemas de conception;presentation abstraction control pattern;specification languages;control architecture;system design;design pattern;architectural styles and patterns;relation de specialisation;design patterns;interactive applications;lotos;distributed architecture;architectural style	In the existing catalogues of either design patterns or architectural styles, numerous are very analogous. They show little differences because they have been developed and used by different people and for different applications. Therefore it is really very difficult, for practical use, to select the right pattern or style for a specific design problem. In general, the criteria given for selection are based on examples or case studies. The formalization of these patterns provides a criteria of comparison. In this paper, a context for style formalization that takes into account characteristic properties, is described first. Two styles, Mediator and Broker, are formalized. Then the relation of specialization is defined and applied to show that Broker is a particular case of Mediator. As an example, taking advantage of the distribution characterized by Broker, it is shown that in the PAC (Presentation-AbstractionControl) architectural pattern, the usage of Broker as the control of the application, instead of Mediator, allows to define a distributed architecture for interactive applications, a distributed PAC style.	architectural pattern;design pattern;distributed computing;mediator pattern;partial template specialization	Nicole Lévy;Francisca Losavio	1999		10.1109/SCCC.1999.810158	real-time computing;computer science;database;programming language	SE	-38.77119319472123	28.339056485204306	158764
773fef505119a340d177bce5574d14a50ae008e7	modeling and multi-agent specification of if-based distributed goal ontologies	modelizacion;aspect dynamique;distributed system;automatic;ontologie;multiagent system;haute performance;systeme reparti;functional models;multi agent system;service web;intelligence artificielle;automatico;sistema complejo;web service;grid;modelisation;information flow;sistema repartido;systeme complexe;dynamic aspect;complex system;rejilla;grid service;functional model;alto rendimiento;grille;automatique;artificial intelligence;ontologia;aspecto dinamico;inteligencia artificial;information system;sistema multiagente;modeling;high performance;ontology;systeme information;servicio web;systeme multiagent;modele fonctionnel;sistema informacion	The concept of service is central in the design of distributed systems. In this approach for example, the web is developing web services and grid services. Nowadays, it is essential to take into account the crucial aspects of the dynamic services, that is to say their ability to adapt and to be composed in order to complete their task. To this end, the first part of the present paper aims to describe the implementation of a methodology which deals the automatic composition of services in distributed systems. Each service is related to a goal and is represented by a functional model called an Ontology. The model relies on a core reasoning process between interacting functional components of the complex system following the Information Flow (IF) approach. Afterwards, in the second part, we propose an algorithm describing the mechanism of the dynamic composition, basing on the first part and using Multi Agent System (MAS), where the agents support the functional components of the complex systems.	agent architecture;algorithm;behavioral modeling;causal filter;complex system;complex systems;cougaar;distributed computing;event calculus;formal ontology;function model;goal programming;high- and low-level;information flow;interaction;map;multi-agent system;ontology (information science);pattern matching;software deployment;web service	Nacima Mellal;Richard Dapoigny;Patrick Barlatier;Laurent Foulloy	2006		10.1007/11779568_4	web service;simulation;systems modeling;information flow;computer science;function model;artificial intelligence;ontology;grid;automatic transmission;operations research;information system	AI	-39.23284084596535	24.237230885969748	158842
b699724c1983f1305129eac2278074215ae5b1a8	model checking contractual protocols	dynamic system;software engineering;model checking;logic in computer science;petri net	. This paper discusses how model checking, a technique used for the verification of behavioural requirements of dynamic systems, can be usefully deployed for the verification of contracts. A process view of agreements between parties is taken, whereby a contract is modelled as it evolves over time in terms of actions or more generally events that effect changes in its state. Modelling is done with Petri Nets in the spirit of other research work on the representation of trade procedures. The paper illustrates all the phases of the verification technique through an example and argues that the approach is useful particularly in the context of precontractual negotiation and contract drafting. The work reported here is part of a broader project on the development of logic-based tools for the analysis and representation of legal contracts [4].	content negotiation;dynamical system;model checking;petri net;requirement	Aspassia Daskalopulu	2001	CoRR		model checking;reliability engineering;computer science;systems engineering;dynamical system;software engineering;database;petri net	SE	-44.047527751295604	21.543161612543898	159222
1b205323a9e2338f68a186109357b17f61b440e2	partial order reduction for verification of real-time components	real time;computer and information science;datorsystem;computer systems;partial order reduction;component model;timed automata;composite structure;data flow;data och informationsvetenskap;reachability analysis;hierarchical model;real time systems;local time	We describe a partial order reduction technique for a realtime component model. Components are described as timed automata with data ports, which can be composed in static structures of unidirectional control and data flow. Compositions can be encapsulated as components and used in other compositions to form hierarchical models. The proposed partial order reduction technique uses a local time semantics for timed automata, in which time may progress independently in parallel automata which are resynchronized when needed. To increase the number of independent transitions and to reduce the problem of re-synchronizing parallel automata we propose, and show how, to use information derived from the composition structure of an analyzed model. Based on these ideas, we present a reachability analysis algorithm that uses an ample set construction to select which symbolic transitions to explore. The algorithm has been implemented as a prototype extension of the real-time model-checker Uppaal. We report from experiments with the tool that indicate that the technique can achieve substantial reduction in the time and memory needed to analyze a real-time system described in the studied component model.	algorithm;automata theory;bayesian network;component-based software engineering;control flow;dataflow;experiment;heuristic (computer science);model checking;partial order reduction;prototype;reachability;real-time clock;real-time computing;real-time transcription;state space;timed automaton;uppaal	John Håkansson;Paul Pettersson	2007		10.1007/978-3-540-75454-1_16	partial order reduction;data flow diagram;real-time computing;computer science;theoretical computer science;operating system;local time;component object model;timed automaton;algorithm;hierarchical database model	Embedded	-35.93688523926347	31.929208247589834	159559
b3132cbea9d86eee7967210c6e3368b908e6bf6f	agent-based modeling of supply chains in critical situations	agent based;agent based model;decentralized system;supply chain	Supply chains are discussed in this article. They are viewed as intelligent decentralized systems that meet the agent paradigm. Thus possibility of arising critical situations in the chains can be analyzed in the agent-based manner. The work is focused on applying an overall methodology dedicated to the discovery of crises and support of anti-crisis activities. The agent-based model is proposed that incorporates majority of features of supply chains so that the modeling of crises can be wide-ranging and easy. As an illustration some simulation results are presented.	agent-based model;crisis (dynamical systems);experiment;interdependence;markov chain;programming paradigm;simulation	Jaroslaw Kozlak;Grzegorz Dobrowolski;Edward Nawarecki	2007		10.1007/978-3-540-72586-2_131	simulation;decentralised system;computer science;supply chain	Robotics	-41.38721659840174	21.65263567539919	159797
af07cebd27ae42558b97b231f7ec28892fb24640	defining and decomposing safety policy for systems of systems	sistema operativo;seguridad funcionamiento;fiabilidad;reliability;multiagent system;surete fonctionnement;orientado agente;securite;safety systems;system of systems;abstraction;air transportation;oriente agent;abstraccion;software engineering;refinement method;transport aerien;transporte aereo;operating system;levels of abstraction;fiabilite;dependability;safety;genie logiciel;systeme securite;systeme exploitation;agent oriented;methode raffinement;sistema multiagente;seguridad;metodo afinamiento;ingenieria informatica;emergent behaviour;systeme multiagent	A ‘system of systems’ (SoS) comprises many other systems operating collectively with a shared purpose. Individual system autonomy can give rise to unpredictable, and potentially undesirable, emergent behaviour. A policy is a set of rules that bounds the behaviours of entities. Policy can be expressed at various levels of abstraction. By building on existing goal-based decomposition approaches this paper proposes policy as a means of achieving safety in SoS. The decomposition of policy to lower levels of abstraction must be carried out in a consistent, complete and systematic manner. The approach is agent-oriented and emphasises the recognition of contextual assumptions (such as knowledge of other agents’ behaviour) in decomposing policy. To this end we present patterns of decomposition based on KAOS tactics of refinement. The application of these patterns, expressed in the Goal Structuring Notation, is illustrated using existing civil aerospace policy (the Rules of the Air Regulations).	apple sos;emergence;entity;formal specification;kaos;principle of abstraction;refinement (computing);simulation;system of systems	Martin Hall-May;Tim Kelly	2005		10.1007/11563228_4	reliability engineering;simulation;system of systems;engineering;artificial intelligence;policy analysis;reliability;dependability;abstraction;system safety;aviation	AI	-39.85070582850233	24.5216052161432	159864
bc188e69559b166aba83fd2968746b4a2e21cdb0	practical application of functional and relational methods for the specification and verification of safety critical software	developpement logiciel;logiciel a securite critique;ingenieria logiciel;specification programme;program verification;software engineering;verificacion programa;specification and verification;desarrollo logicial;safety critical software;software development;relational model;functional model;genie logiciel;verification programme;program specification;especificacion programa	In this paper we describe how a functional version of the 4-variable model can be decomposed to improve its practical application to industrial software verification problems. An example is then used to illustrate the limitations of the functional model and motivate a modest extension of the 4-variable model to an 8-variable relational model. The 8-variable model is designed to allow the system requirements to be specified as functions with input and output tolerance relations, as is typically done in practice. The goal is to create a relational method of specification and verification that models engineering intuition and hence is easy to use and understand.		Mark Lawford;Jeff McDougall;Peter Froebel;Greg Moum	2000		10.1007/3-540-45499-3_8	software requirements specification;relational model;software verification;computer science;function model;software development;software engineering;database;high-level verification;functional verification	SE	-42.8861705631586	26.624698616868226	159936
b875269e0f9e262c28f1d6300236a1530f097e8e	a formal approach to domain-oriented software design environments	solar system kinematics domain oriented software design environments declarative domain theories formal specifications deductive program synthesis intuitive graphical interface reuse formal specification amphion kbse system;domain theory;software design environments;solar system kinematics;impedance;programming environments;formal specification;kbse system;amphion;graphical interface;application software;deductive program synthesis;formal specifications;programming environments formal specification knowledge based systems;software design formal specifications algorithms solar system kinematics impedance explosions application software space technology artificial intelligence;program synthesis;software engineering;kinematics;specification language;reuse;subroutine libraries computers;solar system;domain oriented;user requirements;artificial intelligence;algorithms;explosions;space technology;declarative domain theories;software design;intuitive graphical interface;program development;knowledge based systems;subroutines	This paper describes a formal approach to domain-oriented software design environments, based on declarative domain theories, formal specifications, and deductive program synthesis. A declarative domain theory defines the semantics of a domain-oriented spec8cation language and its relationship to implementation-level subroutines. Formal specification development and reuse is made accessible to users through an intuitive graphical interjiie that guides them in creating diagrams denoting formal speci@cations. Deductive program synthesis ensures that specifications are correctly implemented. This approach has been implemented in AMPHION, a generic KBSE system that targets scientific subroutine libraries. AMPHION has been applied to the domain of solar system kinematics. AMPHION enubles space scientists to develop, nwdifi, and reuse specifications an order of magnitude more rapidly than manual program development. Program synthesis is eficient and completely automatic.	declarative programming;diagram;domain theory;formal specification;graphical user interface;library (computing);program synthesis;programming paradigm;software design;subroutine	Michael R. Lowry;Andrew Philpot;Thomas Pressburger;Ian Underwood	1994		10.1109/KBSE.1994.342678	computer science;systems engineering;theoretical computer science;software engineering;knowledge-based systems;formal specification;programming language	PL	-47.287757812121114	29.759125413477147	160065
bf1c3c788241e67eb88e1246bb7c6420d2ab0849	exploring an approach to model-based testing from behavior trees	programming language model based testing behavior trees system correctness test execution bt notation tree like graphical notation ttcn 3;microwave ovens testing educational institutions microwave communication computer languages adaptation models;trees mathematics formal verification program testing programming languages;behavior trees;automated test generation;trees mathematics;formal verification;program testing;model based testing;automated test generation behavior trees model based testing;programming languages	One of the most important methods to ensure system correctness is testing. Test execution can often be automated. However, the generation of tests from original requirements is an open area of research. In this paper, we propose an approach to generate test cases from requirements. We use a Behavior Tree (BT) to model the requirements of a system. The BT notation is a tree-like graphical notation to capture the requirements of a system. We use TTCN-3 as our testing language. TTCN-3 is a programming language with test-specific extensions. From the BT model, we generate test cases in TTCN-3. These test cases combined with an adapter layer in TTCN-3 will be executed against an implementation of the model to test that implementation.	apl;behavior tree;correctness (computer science);diagram;graphical user interface;microwave;model-based testing;programming language;requirement;system under test;ttcn-3;test case;timeout (computing)	Niusha Hakimipour;Paul A. Strooper	2012	2012 19th Asia-Pacific Software Engineering Conference	10.1109/APSEC.2012.95	exploratory testing;model-based testing;white-box testing;manual testing;formal verification;classification tree method;computer science;theoretical computer science;programming language;graphical user interface testing;behavior trees;test management approach;algorithm	SE	-46.029157305025294	31.41742865172114	160104
7eb5c6d6e5ce1271ceb4b00ecb03bb9a19acd014	visualizing graphical and textual formalisms	computacion informatica;automatic generation;ciencias basicas y experimentales;reactive system;grupo a;verification and validation;requirement specification	Several requirements specification styles for the specification of reactive systems have been proposed in the literature. Informal specifications are the most widely used in the software industry nowadays, mainly because they are “understandable” by domain experts and software engineers, and therefore can be included as part of a software contract. Unfortunately, because of the inherent ambiguity of natural language, these documents are difficult to interpret and maintain. Formal specifications on the other hand, make use of mathematical notations that offer precise syntax and semantics. Unfortunately, because of the complexity of the formal description these documents may not be acceptable to many stakeholders. Visual formalisms bridge the gap between informal and formal specifications by offering graphical notations with semantics. Unfortunately, hand made diagrams become easily unreadable when the requirements complexity increases. In addition, visual formalisms do not enjoy the powerful verification, code optimization, or model-checking techniques that are common to formal notations. The purpose of this work is to combine the advantages of using visual formalisms for the specification of reactive systems with that of using formal verification and program transformation tools developed for textual formalisms. We have developed a tool suite called ViSta [1, 3, 2] that automatically produces statechart layouts based on information extracted from an informal specification. In this paper, we discuss how ViSta is augmented with a tool that automatically translates statecharts [4] to Z specifications. The informal, statechart and Z specifications are inter-related. This ensures consistency between the different representations, and therefore facilitates the verification and validation effort.	design by contract;formal verification;graphical user interface;mathematical optimization;model checking;natural language;program optimization;program transformation;requirement;software engineer;software industry;software requirements specification;state diagram;verification and validation;z notation	Rodolfo Castelló;Rym Mili	2003	Inf. Syst.	10.1016/S0306-4379(02)00081-9	verification and validation;reactive system;computer science;operating system;database;programming language	SE	-45.22327698914072	28.070574875069468	160136
684e071329add692cc9da49bff6f39d332552e02	fast and accurate business process drift detection		Business processes are prone to continuous and unexpected changes. Process workers may start executing a process differently in order to adjust to changes in workload, season, guidelines or regulations for example. Early detection of business process changes based on their event logs – also known as business process drift detection – enables analysts to identify and act upon changes that may otherwise affect process performance. Previous methods for business process drift detection are based on an exploration of a potentially large feature space and in some cases they require users to manually identify the specific features that characterize the drift. Depending on the explored feature set, these methods may miss certain types of changes. This paper proposes a fully automated and statistically grounded method for detecting process drift. The core idea is to perform statistical tests over the distributions of runs observed in two consecutive time windows. By adaptively sizing the window, the method strikes a trade-off between classification accuracy and drift detection delay. A validation on synthetic and real-life logs shows that the method accurately detects typical change patterns and scales up to the extent that it works for online drift detection.	baseline (configuration management);business process;cyber-security regulation;feature vector;microsoft windows;model selection;process modeling;real life;scalability;sensor;synthetic intelligence;window function	Abderrahmane Maaradji;Marlon Dumas;Marcello La Rosa;Alireza Ostovar	2015		10.1007/978-3-319-23063-4_27	real-time computing;simulation;engineering;data mining	SE	-35.59524571051833	21.093422699708324	160574
14f008719a69af70194efd1cd206dbbb4eba89dc	a timed automata semantics for real-time uml specifications	graph theory;formal specification;automata unified modeling language real time systems clocks object oriented modeling application software formal verification mathematics computer science tree graphs;real time;program verification;computation tree logic;formal specification real time systems uml unified modeling language object oriented language extended timed graphs xtg timed automata semantics formal verification;model checking;specification languages;automata theory;timed automata;graph theory specification languages object oriented languages formal specification program verification automata theory real time systems;object oriented languages;real time systems	We introduce extensions of the UML class, object and statechart diagrams and define the semantics of the UML extensions by means of extended timed graphs (XTG), a timed automata variant. This approach opens the possibility to specify properties of the UML specifications using the timed computation tree logic. The transformation of the UML-specification into XTG allows the verification the system by model checking using the LPMC model checker tool, which uses XTG as its input language.		Hans Toetenel;Ella E. Roubtsova;Jan van Katwijk	2001		10.1109/HCC.2001.995243	formal methods;formal verification;computer science;theoretical computer science;applications of uml;automata theory;programming language;algorithm	Embedded	-43.328375895804015	30.52193704219344	161118
f0480fdf9f441b924e66f9635582b699fb902b18	taking advantages of modern distributed infrastructures in modelling and simulation		During the last years, we are experiencing the overwhelming growth of on-line services. Web applications are able to provide such services, by using cooperative, heterogeneous, decentralized and distributed infrastructures and several technologies like consolidated Service-Oriented Architectures (WSDL, WSMO, SOAP, etc.) or emerging Resource-Ori-ented Architectures (e.g. RESTful, etc.). When we talk about Modelling and Simulation, HLA is the de-facto standard for what concerns interoperability: such a standard, like others less used, gives different simulations the capability to interoperate together, but nothing is done for what concern the implementation or the exploitation of services in order to give added value to the already existing simulations. This paper investigates the capabilities and benefits provided by modern infrastructures currently adopted in the Web world, highlighting which kind of resources are available today online and can be accessed to enhance the quality of the simulation; then presents Selex ES approach to simulation, the SYENA synthetic environment, which by integrating the traditional HLA standard with modern Web technologies allows to realise more convincing and impressive simulations.	simulation	Giovanni Battista Buora;Christian Giusti;Marco Barbina	2014		10.1007/978-3-319-13823-7_7	computer science	AI	-40.06054517022553	21.138831725434745	161186
04bff17879955f06320993c7c1c2f32ff43139bf	towards controlling refinements of statecharts		In incremental development strategies, modelers frequent ly refine Statecharts models to satisfy requirements and changes. Althou gh several solutions exist to the problem of Statecharts refinement, they provide such levels of freedom that a statechart cannot make assumptions or guarantees about its future structure. In this paper, we propose a set of bounding rules t o limit the allowable Statecharts refinement operations such that certain assump tions will hold.	case preservation;finite-state machine;iterative and incremental development;refinement (computing);requirement;semantics (computer science);software development process;state diagram	Conner Hansen;Eugene Syriani;Levi Lucio	2015	CoRR		reliability engineering;computer science;engineering drawing;algorithm	SE	-42.602336940923756	29.179704082307914	161189
eb815229eafbe3c44fefec6c63cec2dba319ead8	statechart-based verification of object-oriented design models	design model;object oriented design;object oriented modeling logic power system modeling software engineering unified modeling language graphics;object oriented programming;program verification;theorem proving object oriented programming program verification;theorem proving;theorem proving system object oriented design model statechart based program verification automatic source code generation;source code	Recently, design models that precise behavior of objects is specified are proposed. Though, currently, they are mainly used for their execution and automatic source code generation, they also have potential to allow us to verify them in the design phase. In this paper, we propose a method to verify such design models in the design phase. In addition, we adopt theorem proving systems to rigorously and efficiently verify it.	action language;automated theorem proving;automatic programming;class diagram;code generation (compiler);software design;state diagram	Toshiaki Aoki;Takuya Katayama	2007	14th Asia-Pacific Software Engineering Conference (APSEC'07)	10.1109/APSEC.2007.86	idef4;computer science;theoretical computer science;object-oriented design;automated theorem proving;programming language;object-oriented programming;algorithm;functional verification;source code	EDA	-43.62811196508245	30.324348018304125	161305
72d8d1354893635eac0963f76bd614c7035ec90b	modeling systems using discrete event simulation	model system;statistical model;model development;technical report;discrete event simulation	In this article, we present an introduction to discrete event modeling and discuss some of the important issues related to model development. We are not talking about simulation codes nor statistical models for the outputs from such programs. Rather we will focus on the interface between a real system and a simulation code where we describe the system.	qr code;simulation;statistical model	Lee W. Schruben	1983			statistical model;real-time computing;simulation;discrete event dynamic system;computer science;technical report;theoretical computer science;discrete event simulation;discrete system;world wide web;activity cycle diagram;statistics;simulation language	Robotics	-36.255957744213255	28.38332523936356	161364
d272e0cc3e151afd60de09c26ef84d029864c31f	cheops: a tool-integration platform for chemical process modelling and simulation	cosimulation;co simulation;componente logicial;implementation;representation fonction;simulation;composant logiciel;simulacion;corba;chemical process modelling;modelisation processus chimique;function representation;software reusability;process modelling;cosimulacion;software component;computer aid;representacion funcion;reutilisation logiciel;mathematical model;plateforme cheops;asistencia ordenador;tool integration;process model;implementacion;heterogeneous implementation;common object request broker architecture;assistance ordinateur;tool integration co simulation;steady state	A large number of modelling tools exist for the construction and solution of mathematical models of chemical processes. Each (chemical) process modelling tool provides its own model representation and model definition functions as well as its own solution algorithms, which are used for performing computer-aided studies for the process under consideration. However, in order to support reusability of existing models and to allow for the combined use of different modelling tools for the study of complex processes, model integration is needed. This paper presents a concept for an integration platform that allows for the integration of modelling tools, combining their models to build up a process model and performing computer-aided studies based on this integrated process model. In order to illustrate the concept without getting into complicated algorithmic issues, we focus on steady-state simulation using models comprising only algebraic equations. The concept is realized in the component-based integration platform CHEOPS, which focuses on integrating and solving existing models rather than providing its own modelling capabilities.	algebraic equation;algorithm;blue (queue management algorithm);channel (communications);common object request broker architecture;component-based software engineering;cross-platform audio creation tool;dynamic simulation;general-purpose modeling;integration platform;mathematical model;mathematical optimization;numerical analysis;numerical method;process modeling;steady state;stochastic process;wrapper library	G. Schopfer;Aidong Yang;Lars von Wedel;Wolfgang Marquardt	2004	International Journal on Software Tools for Technology Transfer	10.1007/s10009-004-0157-6	simulation;computer science;common object request broker architecture;process modeling;programming language	SE	-36.11333075915022	26.308700488919893	161403
c487c6be87068db154f02ebd0d4ce2f744909856	holonic coordination obtained by joining the contract net protocol with constraint satisfaction	coloured petri nets;holonic manufacturing systems;contract net protocol;distributed constraint satisfaction problem	Present manufacturing systems are facing significant challenges concerning their adaptability. Holonic manufacturing systems are among the technologies that can provide solutions to such requests, if certain conditions are met. As being included in the class of semi-heterarchical control architectures, holonic systems need appropriate coordination and planning schemes, together with validation tools to increase the beneficiaries’ trust. This paper proposes a coordination scheme for holonic systems, based on a mix between contract net protocol and distributed constraint satisfaction problems. The distinct phases of this method are explained, with details referring to the adaptation of contract net protocol. About the constraint satisfaction mechanism, a guide is provided on how a manufacturing problem can be expressed according to this formalism. To validate the introduced coordination scheme, a coloured Petri net model was developed. This allowed several simulation experiments for scenarios regarding a manufacturing system with four robots to be carried out. The obtained solutions showed that the proposed method can determine both the right holarchy related to the manufacturing goal, and optimal plans for robots. Moreover, as proven by the reachability graphs obtained for different goals, the proposed method reached correct results for all goals and diverse constraints, and it determined all possible solutions. An advantage is about how knowledge possessed by different types of holons is efficiently used, without producing an increased communication load. In conclusion, our method can ensure the right trade-off between complexity and optimality, and the attached model can constitute the required link between design and implementation, thus contributing to an easier deployment of holonic	coloured petri net;complexity;constrained optimization;constraint satisfaction problem;contract net protocol;distributed constraint optimization;distributed manufacturing;experiment;holarchy;holon (philosophy);industrial robot;mathematical optimization;prototype;reachability;scheduling (computing);semantics (computer science);semiconductor industry;simulation;software deployment;token reconfiguration	Doru Panescu;Carlos Pascal	2016	Computers in Industry	10.1016/j.compind.2015.08.010	simulation;systems engineering;engineering;operations management;database;contract net protocol	Robotics	-41.91213125108949	20.99874029222048	161459
7e8d2298ee2e2d7039411ac5baf3a1a042c7c14c	symbiotic simulation and its application to complex adaptive systems	analytical models;simulation adaptive systems decision support systems multi agent systems pattern classification;nanyang technological university complex adaptive systems simulation based decision support tool physical systems symbiotic simulation system classification agent based generic framework;symbiosis;computer model;simulation;complex adaptive system;data model;multi agent systems;computational modeling;adaptive systems;decision support systems;adaptive system;pattern classification;adaptation models;analytical model;data models;real time systems;adaptation models analytical models symbiosis computational modeling data models adaptive systems real time systems	Simulation-based decision support is an important tool in business, science, engineering, and many other areas. Although traditional simulation analysis can be used to generate and test possible plans, it suffers from a long cycletime for model update, analysis and verification. It is thus very difficult to carry out prompt “what-if” analysis to respond to abrupt changes in the physical systems being modeled. Symbiotic simulation has been proposed as a way of solving this problem by having the simulation system and the physical system interact in a mutually beneficial manner. The simulation system benefits from real-time input data which is used to adapt the model and the physical system benefits from the optimized performance that is obtained from the analysis of simulation results. This talk will present a classification of symbiotic simulation systems with examples of applications from the literature. An analysis of these applications reveals some common aspects and issues that are important for symbiotic simulation systems. From this analysis, we have specified an agent-based generic framework for symbiotic simulation. We show that it is possible to identify a few basic functionalities that can be provided by corresponding agents in our framework. These can then be composed together by a specific workflow to form a particular symbiotic simulation system. Finally, the talk will discuss the use of symbiotic simulation as a decision support tool in understanding and steering complex adaptive systems. Some examples of current applications being developed at Nanyang Technological University will be described. 2011 15th IEEE/ACM International Symposium on Distributed Simulation and Real Time Applications 1550-6525/11 $26.00 © 2011 IEEE DOI 10.1109/DS-RT.2011.36 3	agent-based model;complex adaptive system;decision support system;real-time transcription;simulation	Stephen John Turner	2011	2011 IEEE/ACM 15th International Symposium on Distributed Simulation and Real Time Applications	10.1109/DS-RT.2011.36	simulation;systems engineering;engineering;artificial intelligence	Arch	-38.70877804803935	22.085231044493725	161644
d3eb2ff0b12c60a0e8c9377c372eea2ea6c93905	analysis of initial use case descriptions	use case	1. To become familiar use cases / use case diagrams / use case flows of events 2. To become familiar with early specification of functional test cases Materials:	diagram;functional testing;test case	Padmanabhan Krishnan	2004				Embedded	-46.896878821435116	30.876901556089813	161719
23b47f6f518d6072b902dd132c4f37f7af55cac7	model checking data-aware workflow properties with ctl-fo+	data aware properties;pspace complete complexity;web services logic context aware services formal languages distributed computing web and internet services standards organizations councils simple object access protocol guidelines;temporal logic;model checking data aware temporal workflow properties;syntactical checking;web service;data aware web service constraints;message exchange;computation tree logic;first order;model checking;linear temporal logic;computational complexity;web services;workflow management software;user controlled lightpath initiative;data aware properties model checking data aware temporal workflow properties syntactical checking message exchange user controlled lightpath initiative data aware web service constraints first order quantification pspace complete complexity linear temporal logic;first order quantification;workflow management software computational complexity temporal logic web services	"""Most works that extend workflow validation beyond syntactical checking consider constraints on the sequence of messages exchanged between services. However, these constraints are expressed only in terms of message names and abstract away their actual data content. Using the context of the User-controlled Lightpath initiative (UCLP) hosted by the CANARIE consortium, we provide examples of real- world """"data-aware"""" web service constraints where the sequence of messages and their content are interdependent. We present CTL-FO+, an extension over Computation Tree Logic that includes first-order quantification on state variables in addition to temporal operators. We show how CTL- FO+ is adequate for expressing data-aware constraints, give a complete model checking algorithm for CTL-FO+ and establish its complexity to be PSPACE-complete. This makes using CTL-FO+ for validating workflow properties no harder than using the Linear Temporal Logic (LTL) already used by some web service tools. Finally, we show how the modelling of data-aware properties is an increase in expressiveness that cannot be efficiently simulated by these tools."""	algorithm;ctl*;cobham's thesis;computation tree logic;first-order predicate;interdependence;linear temporal logic;model checking;nusmv;pspace-complete;service composability principle;simulation;web service	Sylvain Hallé;Roger Villemaire;Omar Cherkaoui;Boubker Ghandour	2007	11th IEEE International Enterprise Distributed Object Computing Conference (EDOC 2007)	10.1109/EDOC.2007.36	web service;computer science;theoretical computer science;data mining;database;distributed computing;programming language	SE	-44.86644230419861	18.48294809011966	161811
8139621cdb62c299181a49d54b81358da6f8c964	behavioural types and component adaptation	developpement logiciel;adaptacion;formal specification;component based software engineering;behavioral analysis;componente logicial;composant logiciel;software engineering;algebre;specification formelle;especificacion formal;algebra;heterogeneidad;desarrollo logicial;adaptation;analyse comportementale;software development;software component;genie logiciel;analisis conductual;ingenieria informatica;heterogeneity;heterogeneite	Component adaptation is widely recognised to be one of the crucial problems in Component-Based Software Engineering. The objective of this paper is to set a formal foundation for the adaptation of heterogeneous components that present mismatching interaction behaviour. The proposed adaptation methodology relies on: (1) the inclusion of behavioural types in component interfaces, to describe the interaction behaviour of components, (2) a simple high-level notation for adaptor specification, to express the intended connection between component interfaces, and (3) a formal definition of adaptor, a component-in-the-middle capable of making two components interoperate successfully according to a given specification.	component-based software engineering;high- and low-level;interoperability	Antonio Brogi;Carlos Canal;Ernesto Pimentel	2004		10.1007/978-3-540-27815-3_8	computer science;artificial intelligence;component-based software engineering;programming language;algorithm	SE	-40.02047726763713	25.508863836260215	161817
be1ff221ed66f0574ebfed93f1c64f6185296718	formal methods vs. heuristics: clarifying a controversy	formal method		formal methods;heuristic (computer science)	Robert L. Glass	1991	Journal of Systems and Software	10.1016/0164-1212(91)90047-A	formal methods;computer science;software engineering;management science;programming language;algorithm	Logic	-45.714288565804445	30.143814355129276	162383
d4575ec6ea3fe1beabba45dd14bb681c34a9f274	research on e-commerce application architecture based on the integration of workflow and agile service	software;electronic commerce;complexity theory;information systems;workflow oriented architectural style;agile service;e commerce;web;workflow oriented architectural style e commerce application architecture workflow integration agile service web business environment software development heavy soa style;rest;computer architecture;business environment;software architecture;integration of workflow and agile service;business service oriented architecture computer architecture web services complexity theory software information systems;internet;software architecture electronic commerce internet;business;software development;web services;e commerce application architecture;rest integration of workflow and agile service e commerce application architecture;service oriented architecture;workflow integration;heavy soa style;architectural style	In the current e-commerce applications, the existence of a large number of complex issues is mainly due to the complexity of e-commerce applications' own problem domain and the complication caused by building them on Web. In addition, constant changes in business environment have increased the difficulty of software development. Many styles such as heavy SOA style, the workflow-oriented architectural style, and original rest style are created to solve these problems. Unfortunately, the previous studies did not take into account all aspects, and made a number of assumptions excluding the realistic complexity and mutability to facilitate research. This paper attempts to find out the architectural constraints contained in the architectural styles by analyzing the styles mentioned above and to design a set of architectural constraints, which can induce desirable architectural properties for e-commerce applications - e-commerce application architectural style based on the integration of workflow and agile service. In this paper, we evaluate the effectiveness of this architectural style by theoretical derivation and implementation experience.	agile software development;e-commerce;immutable object;problem domain;service-oriented architecture	Xing Wan;Lei Huang	2008	2008 International Symposium on Electronic Commerce and Security	10.1109/ISECS.2008.78	e-commerce;web service;software architecture;the internet;architectural geometry;architectural pattern;computer science;knowledge management;software development;service-oriented architecture;architectural technology;database;representational state transfer;rest;world wide web;information system	Arch	-47.70902937023918	18.260991584996116	162462
2e58f6a2c7d4324afeb1bdce7290ee145dffbfa4	evaluation of random projection for malware classification	data mining random projection evaluation malware classification malicious application detection algorithms n gram analysis feature extraction binary files machine learning algorithms the curse of dimensionality feature reduction technique;accuracy vectors mutual information feature extraction malware data mining support vector machines;data mining;computer security;feature extraction;pattern classification;invasive software;learning artificial intelligence;feature extraction computer security data mining;pattern classification data mining feature extraction invasive software learning artificial intelligence	"""Research efforts to develop malicious application detection algorithms have been a priority ever since the discovery of the first """"viruses"""". Various methods are used to search and identify these malicious applications. One such method, n-gram analysis, can be implemented to extract features from binary files. These features are then be used by machine learning algorithms to classify them as malicious or benign. However, the resulting high dimensionality of the features makes accurate detection in some cases impossible. This is known as """"the curse of dimensionality"""". To counteract this effect, a feature reduction technique known as randomized projection was implemented. Through this reduction, not only are classification times decreased but also an increase in true positive and decreases false positive rates are observed. By varying the n-gram size and target feature size it is possible to fine-tune the accuracy of machine learning algorithms to reach an average accuracy of 99%."""	binary file;curse of dimensionality;data mining;executable;experiment;machine learning;malware;mutual information;n-gram;random projection;randomized algorithm;static program analysis;support vector machine	Stanislav Ponomarev;Jan Durand;Nathan Wallace;Travis Atkison	2013	2013 IEEE Seventh International Conference on Software Security and Reliability Companion	10.1109/SERE-C.2013.29	feature learning;feature vector;feature;feature extraction;computer science;machine learning;linear classifier;pattern recognition;data mining;k-nearest neighbors algorithm;feature;dimensionality reduction	ML	-35.47386978546839	23.086915450335656	162525
48529eade69d61a2e1a4daf48e00edd7f24fab67	towards light-weight deep learning based malware detection		The explosive amount of malware continues threating the security of operating systems and networks. Traditional malware detection approaches fail to meet the requirements of detecting polymorphic and new samples. Existing neural network based detection approaches performs better, but consuming much more time in both feature extraction and training. In this paper, we propose a light-weight PC malware detection system which is based on deep convolutional neural network (CNN). The raw inputs of our system are sequences of grouped instructions, which were generated by our Instruction Analyzer in according to different functionalities of the instructions. The network will automatically learn features of malware from the grouped instruction sequences. The experiment results suggest that in a large dataset which contains roughly 70,000 samples, our detection system can achieve an overall accuracy of 95\%. The training time of our system with single convolutional layer was only about 10 hours, which is one order of magnitude less than traditional methods.	artificial neural network;convolutional neural network;deep learning;feature extraction;malware;operating system;requirement;sensor	Zeliang Kan;Haoyu Wang;Guoai Xu;Yao Guo;Xiangqun Chen	2018	2018 IEEE 42nd Annual Computer Software and Applications Conference (COMPSAC)	10.1109/COMPSAC.2018.00092	spectrum analyzer;real-time computing;convolutional neural network;artificial neural network;deep learning;feature extraction;malware;machine learning;computer science;artificial intelligence	Security	-35.36585803363377	23.45706125791816	162591
bdb2be53ea50af6e201f6da0daaf7322c3b0d7bb	an extension to data-flow-oriented formal specification language for specifying concurrent software systems	formal specification;concurrent computing;multiprocessing programs;software systems concurrent computing availability computational modeling programming message passing;multiprocessing programs formal languages formal specification;availability;data flow oriented formal specification language;concurrent software systems;formal specification language;software systems;formal languages;concurrent software;specification language;channel;formal method;practical software systems;practical software systems data flow oriented formal specification language concurrent software systems industrial applications;computational modeling;sofl specification language;software development;region;message passing;industrial application;industrial applications;data flow;region concurrent software sofl specification language channel;programming	Data-flow-oriented formal specification languages, such as SOFL, bridge formal methods to industrial applications, allowing software developers to effectively use formal methods in developing practical software systems. In this paper, we introduce an extension to SOFL specification language for specifying concurrent software systems. SOFL is designed by integrating different notations and techniques on the basis that they are all needed to work together effectively in a coherent manner for specification constructions and verifications. We mainly introduce two notions, region and channel, to the SOFL language so that concurrency can be specified both graphically and formally, thus making SOFL specifications both intuitive and precise.	coherence (physics);concurrency (computer science);dataflow;formal methods;formal specification;graphical user interface;lock (computer science);message passing;race condition;software developer;software system;specification language;verification and validation	Yuting Chen;Shaoying Liu;Linzhang Wang	2010	2010 10th International Conference on Quality Software	10.1109/QSIC.2010.49	data flow diagram;availability;programming;computer architecture;formal language;message passing;region;concurrent computing;specification language;computer science;software development;software engineering;formal specification;database;programming language;computational model;software system;channel	SE	-42.997593907828374	30.56566297686275	162687
3393a3eef6c38b2015d3befbf570068c6a713c0c	the mova tool: a rewriting-based uml modeling, measuring, and validation tool	articulo;measuring;and validation tool;the mova tool a rewriting based uml modeling		mova (camera system);rewriting;uml tool;unified modeling language	Manuel Clavel;Marina Egea;Viviane Torres da Silva	2007			uml tool;applications of uml	Logic	-44.887711986866684	30.136171431786185	162853
2deaeb06ec307806695b9ec9fd060fa2eccb2d29	requirement analysis and automated verification: a semantic approach.				Animesh Dutta;Prajna Devi Upadhyay;Sudipta Acharya	2012			high-level verification;intelligent verification;functional verification	SE	-45.26256219801951	30.672541428903866	162866
28a066a0e5ad9081a8a5c8f0e35ce78ccfd23f10	using a process algebra to control b operations	control b operations;process algebra;b method;formal method	The B-Method is a state-based formal method that describes system behaviour in terms of MACHINES whose state changes under OPERATIONS. The process algebra CSP is an event-based formalism that enables descriptions of patterns of system behaviour. This paper is concerned with the combination of these complementary views, in which CSP is used to describe the control executive for a B Abstract System. We discuss consistency between the two views and how it can be formally established. A typical avionics system motivates the work. Its speci cation and control executive are presented in the paper. The relationship with other approaches is also discussed.	avionics;b-method;formal methods;formal system;process calculus	Helen Treharne;Steve A. Schneider	1999			b-method;process calculus;formal methods;computer science;theoretical computer science;programming language;algorithm	SE	-39.59857155493776	29.13451979424307	162922
cbaa019b98ef0f99c3eac15ac77fefafd4e5fd39	the design of a coordination language for multi-agent systems	multi agent system;agent based;coordination language;levels of abstraction;cooperative work	The agent view provides a level of abstraction at which we envisage computational systemscarrying out cooperative work by interoperating across networked people, organizations and machines. A major challenge in building such systems is coordinating the behavior of the individual agents to achieve the individual and shared goals of the participants. In this paper we propose a conceptualization of the coordination task around the notion of structured ”conversation” amongst agents. Based on this notion we build a complete multiagent programming language and system for explicitly representing, applying and capturing coordination knowledge. The language provides KQML-based communication, an agent definition and execution environment, support for describing interactions as multiple structured conversations among agents, rule-based approaches to conversation selection, conversation execution and event handling, a model and an interactive graphical tool for in context acquisition and debugging of coordination knowledge. The major application of the system is the construction and integration of multiagent supply chain systems for manufacturing enterprises. This application is used throughout the paper to illustrate the introduced concepts and language constructs.	agent-based model;conceptualization (information science);debugging;event (computing);graphical user interface;intelligent agent;interaction;knowledge query and manipulation language;logic programming;multi-agent system;programming language	Mihai Barbuceanu;Mark S. Fox	1996		10.1007/BFb0013596	natural language processing;computer science;knowledge management;artificial intelligence;multi-agent system	AI	-41.5220120443991	18.395250761974392	162931
70309d4e5a5ef44fe6d43f654a2e60fafa0b607d	a ui-driven approach to facilitating effective development of rich and composite web applications			model-driven architecture;user interface;web application	Jin Yu	2008				Web+IR	-48.26682461834849	22.31493415360112	162955
7dec65e3e91f8116576db416aaad3f0c50581f53	modelling component dependencies to inform their selection	developpement logiciel;modelizacion;multiagent system;composant logiciel;satisfiability;modelisation;software architecture;complex system;desarrollo logicial;scheduling;agent based system;software development;software component;software package;ordonamiento;progiciel;system architecture;sistema multiagente;modeling;ordonnancement;architecture logiciel;systeme multiagent	Selecting multiple, interdependent software components to meet complex system requirements is difficult. This paper reports the experimental application of the i* agent-based system approach to model a system architecture in terms of dependencies between components to achieve goals, satisfy soft goals, complete tasks and provide and consume resources. It describes two treatments, at the architecture and component levels, that can be applied to these architecture models to determine important system properties that inform multiple component selection. The modelling approach and treatments are demonstrated throughout using the example of a meeting scheduler system.	agent-based model;complex system;component-based software engineering;interdependence;requirement;scheduling (computing);system requirements;systems architecture	Xavier Franch;Neil A. M. Maiden	2003		10.1007/3-540-36465-X_8	software architecture;complex systems;real-time computing;simulation;systems modeling;computer science;component-based software engineering;software development;scheduling;systems architecture;satisfiability	SE	-39.6339612144516	24.558446376451972	163054
4aa79f98435687f5b7c5d744093103ced60827aa	efcoss: an interactive environment facilitating optimal experimental design	heterogeneous environment;distributed computing;objective function;optimization problem;computational science and engineering;large scale simulation;automatic differentiation;software package;interactive environment;parameter estimation;optimal experimental design;problem solving environment;problem solving environments;numerical simulation	An interactive software environment is proposed that combines numerical simulation codes with optimization software packages in an automated and modular way. It simplifies the experimentation with varying objective functions for common optimization problems such as parameter estimation and optimal experimental design that are frequently encountered in computational science and engineering. The design philosophy takes into consideration the need for derivatives of potentially large-scale simulation codes via automatic differentiation as well as distributed computing in a heterogenous environment via CORBA.	automatic differentiation;code;common object request broker architecture;computation;computational engineering;computational science;computer simulation;design of experiments;distributed computing;estimation theory;mathematical optimization;optimal design	Arno Rasch;H. Martin Bücker	2010	ACM Trans. Math. Softw.	10.1145/1731022.1731023	automatic differentiation;computer simulation;optimization problem;computational science;mathematical optimization;simulation;computer science;computational science and engineering;theoretical computer science;mathematics;estimation theory	Graphics	-36.05709899913741	26.24926597610171	163342
efa9ebe475414c4b85197b8d1fcc115e65e8627a	yawl2dve: an automated translator for workflow verification	workflow management;model checking program;automated translator;time budget;yawl2dve;workflow verification;logic;program interpreters;yawl;conference management;software fault tolerance;parallel model checker;program verification;divine;runtime;development cycle cost;system properties;technology management;yet another workflow language;verification facilities;parallel models;computational modeling;adaptation model;formal verification;model checking;systems analysis;synchronization;system design;business;system development process;unified modeling language;yet another workflow language yawl2dve automated translator workflow verification workflow management systems information system development verification facilities runtime executions system development process development cycle cost time budgets model checking program system properties system design graphical workflow model divine parallel model checker state explosion problem;runtime executions;xml;state explosion problem;workflow management software;logic power system modeling formal verification costs explosions conference management software development management technology management management information systems runtime;management information systems;time budgets;system development;workflow management system;workflow management systems;explosions;graphical workflow model;state explosion;power system modeling;workflow management software program interpreters program verification software fault tolerance systems analysis;yawl workflow management formal verification model checking;algorithm design and analysis;software development management;information system development;health care	"""Workflow management systems (WfMSs) have gained increasing attention recently as an important technology to improve information system development in dynamic and distributed organizations. However the absence of verification facilities in most WfMSs causes the resulting implementation of large and complex workflow models to be at risk of undesirable runtime executions. This problem of design validation ensuring the correctness of the design at the earliest stage possible is a major challenge for any responsible system development process, and the activities intended for its solution occupy an ever increasing portion of the development cycle cost and time budgets. Model checking is a popular technique to systematically and automatically verify system properties, but it requires a substantial effort to convert the system design into a specific model checking program. In this paper, we present an automated translator (YAWL2DVE) which can convert a graphical workflow model into DVE, the input language of DiVinE. DiVinE is a distributed and parallel model checker, which can effectively handle the well known """"state explosion problem"""" of this domain. We show the effectiveness of this translator with a case study on a real world health care workflow model."""	correctness (computer science);digital video effect;graphical user interface;information system;model checking;systems design;whole earth 'lectronic link	Fazle Rabbi;Hao Wang;Wendy MacCaull	2010	2010 Fourth International Conference on Secure Software Integration and Reliability Improvement	10.1109/SSIRI.2010.31	reliability engineering;real-time computing;computer science;systems engineering;technology management;operating system;software engineering;database;programming language;workflow management system;workflow engine;workflow technology	SE	-45.433898775476045	32.24649205529205	163543
8fabfd5e6d67fb85a53cd8fef1387cfdf53e6d5c	evidence traces for multi-agent declarative rule-based policy simulation	multiagent declarative rule software toolbox simple simulation models policy modeling policy simulation evidence traces;agent based simulation systems;simulation framework;multi agent systems;data models random access memory analytical models charge coupled devices engines numerical models buildings;multi agent systems digital simulation;digital simulation	"""In the field of policy modeling, a trend to growing complexity and complication of simulation models can be observed. One of the reasons for this development is the fact that for many policy cases of practical interest there are no theories available from which """"simple"""" simulation models could be derived. Instead a sometimes vast amount of information-scenarios describing stakeholders views, documents providing background information - has to be taken into account by the simulation model. Methods and tools for utilizing such evidence bases have a great importance for the success of respective modeling activities. This paper outlines a novel approach in that regard which has been developed within the OCOPOMOproject and basically consists of a policy development process specification, and a software toolbox supporting this process. Main focus of this paper are simulation related aspects of both the process and the toolbox, with the aim to demonstrate the impact of trace ability for modeling, simulation and result analysis."""	declarative programming;process specification;simulation;theory;tracing (software)	Ulf Lotzmann;Maria Wimmer	2013	2013 IEEE/ACM 17th International Symposium on Distributed Simulation and Real Time Applications	10.1109/DS-RT.2013.20	verification and validation of computer simulation models;simulation;computer science;theoretical computer science;systems simulation;simulation modeling	Embedded	-35.68498687314963	27.21898697587006	163711
1000ba1b7c0732771ec68b28f7dc54cf0fbf41a1	hierarchical object nets-a methodology for graphical modeling of discrete event systems			graphical user interface;object process methodology	Carsten Thomas	1993		10.1109/WSC.1993.718303		Robotics	-36.41037191379734	28.001423772330675	164209
ee10cd85dbeb072a4373fff6ef37127e3e72322a	composition de modèles pour la modélisation multi-paradigme du comportement des systèmes. (composition of models for the multi-paradigm modeling of the behavior of systems)		In the context of Model Driven Engineering, the use of multiple modeling paradigms for developing complex systems is both unavoidable and essential. It results in the heterogeneity of the models representing the considered system and makes global reasoning about the system difficult. The objective of multi-paradigm modeling is to ease the joint use of heterogeneous models during the development cycle. In the work presented in this dissertation, we focus on the study of the heterogeneity of models and propose an approach to multi-paradigm modeling. We first qualify the causes of the heterogeneity of models with respect to the development cycle and we identify several types of heterogeneity. On this basis, we propose a framework for the study of the domain of multi-paradigm modeling with several research axis. The multidisciplinarity of multi-paradigm modeling allows the use of techniques from various fields. We propose a survey and a classification of the techniques which are relevant with respect to heterogeneity. The range of the techniques that we present includes model transformation, meta-model composition, model composition, component adaptation, co-simulation and megamodels. Then we present ModHel’X, the approach to the composition of models for multi-paradigm modeling that we developed. It relies on the concept of model of computation and allows: 1. the specification of the semantics of a modeling language in an executable way by specializing an abstract semantics for models of computation that we developed; 2. the explicit specification of the composition mechanism between heterogeneous models through a special modeling structure called interface block; 3. the simulation of the global behavior of heterogeneous models thanks to a generic execution algorithm that we defined. ModHel’X has been implemented in a framework based on EMF (Eclipse Modeling Framework).		Cécile Hardebolle	2008				SE	-43.985436426914994	24.82885043021706	164474
74bb3c57004184864020914540d0652363371919	echem++--an object-oriented problem solving environment for electrochemistry. 2. the kinetic facilities of ecco--a compiler for (electro-)chemistry.	object oriented;kinetics;problem solving environment	We describe a modeling software component Ecco, implemented in the C++ programming language. It assists in the formulation of physicochemical systems including, in particular, electrochemical processes within general geometries. Ecco's kinetic part then translates any user defined reaction mechanism into an object-oriented representation and generates the according mathematical model equations. The input language, its grammar, the object-oriented design of Ecco, based on design patterns, and its integration into the open source software project EChem++ are discussed. Application Strategies are given.		Kai Ludwig;Bernd Speiser	2004	Journal of chemical information and computer sciences	10.1021/ci0497814	simulation;computer science;artificial intelligence;theoretical computer science;object-oriented programming;algorithm;kinetics	PL	-34.65312267684829	26.061518820832845	164586
900e1f0968d6de1aa33c54e5a1f2afd13f63a505	planning agent for geriatric residences		Agents and Multi-Agent Systems (MAS) have become increasingly relevant for developing distributed and dynamic intelligent environments. The ability of software agents to act somewhat autonomously links them with living animals and humans, so they seem appropriate for discussion under nature-inspired computing (Marrow, 2000). This paper presents AGALZ (Autonomous aGent for monitoring ALZheimer patients), and explains how this deliberative planning agent has been designed and implemented. A case study is then presented, with AGALZ working with complementary agents into a prototype environment-aware multi-agent system (ALZ-MAS: ALZheimer Multi-Agent System) (Bajo, Tapia, De Luis, Rodríguez & Corchado, 2007). The elderly health care problem is studied, and the possibilities of Radio Frequency Identification (RFID) (Sokymat, 2006) as a technology for constructing an intelligent environment and ascertaining patient location to generate plans and maximize safety are examined. This paper focuses in the development of natureinspired deliberative agents using a Case-Based Reasoning (CBR) (Aamodt & Plaza, 1994) architecture, as a way to implement sensitive and adaptive systems to improve assistance and health care support for elderly and people with disabilities, in particular with Alzheimer. Agents in this context must be able to respond to events, take the initiative according to their goals, communicate with other agents, interact with users, and make use of past experiences to find the best plans to achieve goals, so we propose the development of an autonomous deliberative agent that incorporates a Case-Based Planning (CBP) mechanism, derivative from Case-Based Reasoning (CBR) (Bajo, Corchado & Castillo, 2006), specially designed for planning construction. CBP-BDI facilitates learning and adaptation, and therefore a greater degree of autonomy than that found in pure BDI (Believe, Desire, Intention) architecture (Bratman, 1987). BDI agents can be implemented by using different tools, such as Jadex (Pokahr, Braubach & Lamersdorf, 2003), dealing with the concepts of beliefs, goals and plans, as java objects that can be created and handled within the agent at execution time.	adaptive system;autonomous agent;autonomous robot;autonomy;belief–desire–intention software model;case-based reasoning;deliberative agent;experience;intelligent environment;java;multi-agent system;prototype;radio frequency;radio-frequency identification;run time (program lifecycle phase);software agent	Javier Bajo;Dante I. Tapia;Sara Rodríguez;Juan Manuel Corchado	2009		10.4018/978-1-59904-849-9.ch193	adaptive system;autonomous agent;radio-frequency identification;software agent;human–computer interaction;ambient intelligence;multi-agent system;case-based reasoning;computer science;intelligent environment	AI	-41.481921690666326	19.183962870656746	164660
7e361d7905f80f9c59002c8cdf4b5ae208c99f42	generating mscs from an integrated formal specification language	developpement logiciel;sistema interactivo;formal specification;meetings and proceedings;integrable model;asynchrone;diagrama secuencia mensaje;book chapter;metodo formal;formal specification language;methode formelle;transformacion;semantics;lenguaje especializado;msc;sistema complejo;semantica;semantique;specification language;multiple views;formal method;systeme conversationnel;specification formelle;multiple view;especificacion formal;tcoz;message sequence chart;systeme complexe;complex system;interactive system;desarrollo logicial;requirement engineering;envoi message;software development;message passing;vue multiple;lenguaje especificacion;transformation;langage specialise;special purpose language;langage specification;diagramme sequence message;lenguaje formal;formal language;asincrono;asynchronous;vista multiple;langage formel	The requirements capture of complex systems requires powerful mechanisms for specifying system state, structure and interactive behaviors. Integrated formal specification languages are well suited for presenting more complete and coherent requirement models for complex systems. Given an integrated model, one can project it into multiple views for specialized analysis. Message Sequence Charts (MSCs) is a popular graphical notation for presenting interactive viewpoints of a system. In this paper, we investigate the semantic based transformation from an integrated formal specification language TCOZ to MSCs. An automated tool has also been developed for generating MSCs from TCOZ models. Furthermore, by inserting operation constraints (as assertions) into the generated MSCs, system testing requirements can be obtained.	coherence (physics);complex systems;formal specification;graphical user interface;message passing;message sequence chart;requirement;specification language;system testing	Jin Song Dong;Shengchao Qin;Jun Sun	2004		10.1007/978-3-540-24756-2_10	transformation;formal language;message passing;formal methods;specification language;computer science;software development;operating system;asynchronous communication;formal specification;database;semantics;programming language;message sequence chart;algorithm	SE	-39.71427932402091	26.255560924689163	164813
528a36e43a43c820461cf0ce94ab0d392224c769	software development approach for discrete simulators	time scale;object oriented model;computer model;simulation;distributed computing;c computer program language;software engineering;electronic data processing distributed processing;data model;computer programming;computer architecture;c software development approach discrete simulation time scale fixed length time slots simulation packages;c language;computational modeling;discrete time systems computer simulation;programming simulation distributed computing;software development;software engineering c language digital simulation;peer to peer computing computational modeling object oriented modeling computer architecture data models programming;discrete simulation;peer to peer computing;programming;computer simulation;digital computer simulation;object oriented modeling;digital simulation;data models	Simulation is the most common approach to perform the problem research. Among several types of simulation, the most common way is the discrete simulation, which assumes the division of the time scale into fixed length time slots. Depending on investigated problem, simulation packages may be used or it could be necessary to design and create own simulation system. In this paper, we propose the complete pre-study scheme and the most commonly appearing implementation problems with suggested solutions. We also describe how to implement the exemplary simulator in C++.	c++;simulation;software development process	Grzegorz Chmaj;Dawid Zydek	2011	2011 21st International Conference on Systems Engineering	10.1109/ICSEng.2011.56	computer simulation;computational science;programming;simulation;data model;computer science;theoretical computer science;software development;computer programming	Robotics	-35.21715311700044	27.45604163738579	164924
9373a3b9b8672e8c75fb0f4bce69a88b4eb35ade	patterns for designing configurability into domain-specific language elements	configurability;language element;domain specific language	Nowadays, designing a domain-specific language is easier than ever before. Nevertheless, finding the right balance concerning the configurability of concepts represented by language elements is a complicated design task. With this paper we provide four patterns that discuss different kinds of configurability that can also be combined. In the end, we show the application of these patterns using an example we had to deal with in our research project.	domain-specific language	Johannes Iber;Andrea Höller;Tobias Rauter;Christian Kreiner	2016		10.1145/3011784.3011785	natural language processing;computer science;programming language;communication	PL	-47.43244652956158	24.77507229421674	164983
400ad65f9959daa364d1390d9cc762da7d67d9cd	efficient graph-oriented smart transportation using internet of things generated big data	iot;graph iot big data smart transportation;big data;smart transportation;graph;internet of things graph theory intelligent transportation systems;big data sensors vehicles cities and towns roads real time systems;graph oriented smart transportation hadoop parallel nodes spark tool real time intelligent decisions graph algorithms processing servers giraph tool iot devices iot based networks road sensors smart transportation system big data internet of things	The rapid growth in the population density in urban cities and the advancement in technology demands real-time provision of services and infrastructure. Citizens, especially travelers, want to be reached within time to the destination. Consequently, they require to be facilitated with smart and real-time traffic information depending on the current traffic scenario. Therefore, in this paper, we proposed a graph-oriented mechanism to achieve the smart transportation system in the city. We proposed to deploy road sensors to get the overall traffic information as well as the vehicular network to obtain location and speed information of the individual vehicle. These Internet of Things (IoT) based networks generate enormous volume of data, termed as Big Data, depicting the traffic information of the city. To process incoming Big Data from IoT devices, then generating big graphs from the data, and processing them, we proposed an efficient architecture that uses the Giraph tool with parallel processing servers to achieve real-time efficiency. Later, various graph algorithms are used to achieve smart transportation by making real-time intelligent decisions to facilitate the citizens as well as the metropolitan authorities. Vehicular Datasets from various reliable resources representing the real city traffic are used for analysis and evaluation purpose. The system is implemented using Giraph and Spark tool at the top of the Hadoop parallel nodes to generate and process graphs with near real-time. Moreover, the system is evaluated in terms of efficiency by considering the system throughput and processing time. The results show that the proposed system is more scalable and efficient.	algorithm;apache hadoop;big data;ecosystem;graph theory;internet of things;parallel computing;population dynamics;real-time clock;real-time computing;real-time transcription;real-time web;spark;scalability;sensor;smart city;throughput	M. Mazhar Rathore;Awais Ahmad;Anand Paul;Gwanggil Jeon	2015	2015 11th International Conference on Signal-Image Technology & Internet-Based Systems (SITIS)	10.1109/SITIS.2015.121	simulation;big data;computer science;operating system;database;graph;world wide web;computer security;internet of things	Robotics	-33.83213645605466	18.591375669815857	165052
b1d9eff8bfa99894533f18965a2854b7a6b8b1d4	towards cooperative ess for distribution systems with high penetration of res and ev the storage4grid vision		Storage4Grid (S4G) is a 36-months project funded by the European Commission under the call LCE-01-2016, area 1 (Storage). S4G proposes an innovative holistic methodology for modelling, planning, integrating, operating and evaluating distributed Energy Storage Systems (ESS) including storage at user premises and storage at substation level, Electrical Vehicles (EV), innovative energy metering and energy routing technologies. This paper presents a systematic strategy used by S4G to generate the use cases for two scenarios related to two test sites: in Bolzano focused on cooperative EV charging and in Fur addressing the impact of user and grid side storage coordination to the medium and low voltage distribution network. The paper summarizes the S4G vision, solutions, and approaches for evolving the cooperative and coordinated ESS scenarios into use-cases and related requirements.	battery management system;cooperative multitasking;extended validation certificate;holism;intelligent systems for molecular biology;requirement;routing;traction substation;universal powerline bus	Jinyong Fu;Riccardo Tomasi;Maurizio Fantino;Maurizio A. Spirito;Mihai Sanduleac;Veronika Kraus;Otilia Werner-Kytölä;Gitte Wad Thybo;Giovanni Paolucci	2017	2017 International Conference on Engineering, Technology and Innovation (ICE/ITMC)	10.1109/ICE.2017.8279961	grid;distributed generation;smart grid;energy storage;low voltage;use case;computer network;business	HPC	-35.793286920333145	19.954729013436964	165366
5360f9486642dba21b0cb63b3f46c79570621c54	automatic derivation of daml-s service specifications from uml business models	gestion integrada;gestion integree;commerce electronique;gestion entreprise;fiabilidad;reliability;modele entreprise;comercio electronico;red www;lenguaje uml;reseau web;firm management;semantics;automatisation;integrated management;langage modelisation unifie;automatizacion;modelo empresa;semantica;semantique;business model;lenguaje descripcion;internet;fiabilite;unified modelling language;world wide web;administracion empresa;langage description;electronic trade;description language;automation	Today's trend in Web engineering is the automation of Web service interoperation. With this aim, web content is noted with semantic information, using Web Semantic languages. Web Services is becoming the leading technology that provides functionality of an enterprise. This functionality carries out the activities that form a process. Business processes are a set of activities that can be seen as offered business services. Therefore, this article presents a process to derive web services specifications and service composition from business models. The paper considers DAML-S as the web services markup language to represent the description of web services and specify their composition. Rational Unified Process business model is the language used as input. The article shows the set of derivation rules that allows the atomatic generation of DAML-S modules from business models.	daml-s;unified modeling language	Rubén Darío Franco;Víctor Anaya;Ángel Ortiz Bas	2003		10.1007/3-540-45068-8_79	web service;business model;unified modeling language;web development;web modeling;the internet;simulation;business process execution language;data web;web standards;computer science;automation;ws-policy;service-oriented architecture;semantic web;social semantic web;reliability;ws-addressing;semantic web stack;semantics;services computing;web intelligence;ws-i basic profile;web 2.0;business rule;world wide web;owl-s;business process modeling	Web+IR	-46.291940244823834	19.752370307086696	165375
5d6a9cb4757f4257d5828b369cb1d0fa699af887	model driven engineering	developpement logiciel;qa 76 software;language family;familia lenguaje;computer programming;object oriented;desarrollo logicial;software development;model driven engineering;object management group;oriente objet;machine model;orientado objeto;famille langage;lenguaje formal;location model;model driven architecture;formal language;langage formel	The Object Management Group’s (OMG) Model Driven Architecture (MDA) strategy envisages a world where models play a more direct role in software production, being amenable to manipulation and transformation by machine. Model Driven Engineering (MDE) is wider in scope than MDA. MDE combines process and analysis with architecture. This article sets out a framework for model driven engineering, which can be used as a point of reference for activity in this area. It proposes an organisation of the modelling ‘space’ and how to locate models in that space. It discusses different kinds of mappings between models. It explains why process and architecture are tightly connected. It discusses the importance and nature of tools. It identifies the need for defining families of languages and transformations, and for developing techniques for generating/configuring tools from such definitions. It concludes with a call to align metamodelling with formal language engineering techniques.	class diagram;code generation (compiler);computational complexity theory;correctness (computer science);data integrity;formal verification;large;model-driven engineering;object constraint language;scalability;software development process;unified modeling language;verification of theories;cell transformation	Stuart Kent	2002		10.1007/3-540-47884-1_16	model-driven architecture;formal language;simulation;computer science;artificial intelligence;software development;computer programming;programming language;algorithm	SE	-41.54749915185106	25.677356408225602	165406
e94e541b145931160f44a0df8d4d5dc6bd521911	semi-automatic test suite generation from estelle	lap d protocol;software tool;formal specification language estelle;automatic testing;conformance testing software requirements and specifications isdn protocols software tools specification languages;specification languages conformance testing formal specification isdn protocols software tools;control flow graph;ttcngen;integrated services digital network;semiautomatic test suite generation;test suite specification language ttcn;estelle;integrated services digital network semiautomatic test suite generation estelle formal specification language estelle test suite specification language ttcn control flow graph software tool ttcngen lap d protocol	Overviews of the standard formal specfication language Estelle and test suite specification language TTCN are provided. Steps involved in semi-automatic generation of TTCN test suites from Estelle are introduced. Details of TTCN test step generation from Estelle transitions are explained. Test cases are obtained from these test steps by way of ordering them using the control flow graph. The implementation of a software tool called TTCNGEN, which largely automates the methodology, is explained and examples are provided from the LAP-D protocol of the integrated services digital network. Related research is discussed, and various ideas are highlighted for future research.		Behdad Forghani;Behçet Sarikaya	1992	Software Engineering Journal	10.1049/sej.1992.0031	reliability engineering;computer science;software engineering;integrated services digital network;programming language;language of temporal ordering specification;control flow graph	SE	-46.50752928973883	30.708950080137136	165427
d072233cd755a9aac70168bf3863398ccebe9cac	object-oriented programming in control system design: a survey	developpement logiciel;modelizacion;concepcion asistida;systeme commande;database system;interfase usuario;sistema control;computer aided design;programming environments;programmation;articulo sintesis;sintesis control;object oriented design;maintenance;programming environment;user interface;article synthese;informing science;computerized control systems;object oriented programming;database management;programacion;modelisation;medio ambiente programacion;control system;software design methods;design method;object oriented;desarrollo logicial;synthese commande;software development;computerized simulation;software component;conception assistee;control system design;programming methods;oriente objet;design;interface utilisateur;systeme gestion base donnee;computer aided control system design;review;modeling;sistema gestion base datos;orientado objeto;database management system;programming;data base management;user interfaces;control synthesis;modelling support;environnement programmation;computer aided control systems design;object oriented paradigm;mathematics computers information science management law miscellaneous	The object-oriented paradigm shows great potential as a means for revolutionizing software development. In the last decade, much research has been directed towards the development of design methods, languages, environments, reusable libraries of software components and database systems to support this paradigm. The first part of the paper presents the terminology of the object-oriented paradigm, reviews the state-of-the-art in object-oriented programming and discusses class libraries and object-oriented design. The second part of the paper discusses its application in the area of computer-aided control system design. It is argued that the adoption of these ideas will increase greatly the productivity of software developers in this field and improve the facilities that will be offered to users. 215 refs.	control system;systems design	C. P. Jobling;Phil W. Grant;H. A. Barker;Peter Townsend	1994	Automatica	10.1016/0005-1098(94)90106-6	software design pattern;simulation;computer science;systems engineering;control system;software design;software framework;software development;object-oriented programming;user interface;resource-oriented architecture	Robotics	-37.391532531867846	24.13763198733286	165474
1ac85d6303f436be4236177b82216bd345ff51a6	functional debugging of equation-based languages	concept design;simulation;functional modeling;cyber physical systems;equationbased languages;debuggers	State-of-the-art debugging techniques for equation-based languages follow a low-level approach to interface users with the complex interactions between equations and algorithms that describe cyber-physical processes. Although these techniques are useful for understanding the low-level behaviors, they do not provide the means for creating a system-level understanding that is often necessary during the early concept product design phase. In this paper, we present a novel debugging technique for equation-based languages based on a high-level approach to facilitate the system-level understanding of complex cyber-physical processes. Our debugging interface is based on functional models that describe what the system does in a formal language that uses natural language elements to improve inter-disciplinary communication. Our novel technique, referred to as functional debugging, can be used in the context of the current systems engineering industrial practice in order to identify system-level problems and explore design alternatives during the early concept design phase. We present a working implementation of our functional debugger and we discuss the benefits of our approach using an automotive use-case.	algorithm;debugger;debugging;formal language;high- and low-level;interaction;natural language;systems engineering	Arquimedes Canedo;Ling Shen	2013			computer science;theoretical computer science;programming language	SE	-42.9940751820514	29.245988053610482	165488
0452b24d9afc8aa9acb6f71fa7c296f56da60bda	using refinement in formal development of os security model		The paper presents work in progress on formal development of an operating system security model for the purpose of its deductive verification. We consider two approaches to formalize the security model. The first one is to build a monolithic model, another one is to build a hierarchical model using the refinement technique. The main criteria for comparison are costs of development, simplicity of maintenance and confidence in the quality of the formal model. The results are twofold. On the one hand, refinement helped us to deal with complexity of the formal model, to improve its readability and to simplify automatic proofs. However, deep understanding of the security model details and careful planning were absolutely necessary to build a reasonable hierarchical model. The monolithic approach allowed to quickly start formalization and helped to study the details of the security model, but the resulting formal model became hard to maintain and explore.	operating system	Petr N. Devyanin;Alexey V. Khoroshilov;Victor V. Kuliamin;Alexander K. Petrenko;Ilya V. Shchepetkov	2015		10.1007/978-3-319-41579-6_9	computer security model;work in process;management science;readability;mathematical proof;hierarchical database model;formal verification;computer science	Crypto	-44.48885110600197	28.56345076417952	165520
6b650ea72ef68671127cc5d8edf9e20a9ddfefb2	model-driven development of a web service-oriented architecture and security policies	informatica;mda;electronic mail;dsl;telecomunicaciones;prototypes;distributed computing;soa;web service;model driven development;nonfunctional aspects;service oriented architecture security web services access control proposals productivity unified modeling language dsl distributed computing electronic mail;software architecture;computational modeling;ws securitypolicy mda ws soa;electronica;unified modeling language;web services;ws;ws securitypolicy;access control;productivity;service oriented architecture;security;security policy;proposals;security of data;web services security of data software architecture;nonfunctional aspects model driven development web service service oriented architecture security policy	Applying model-driven development methodologies provide inherent benefits such as increased productivity, greater reuse, and better maintainability, to name a few. Efforts on achieving model-driven development of web services already exist. However, there is currently no complete solution that addresses non-functional aspects of these services as well. This paper presents an ongoing work which seeks to integrate these non-functional aspects in the development of web services, with a clear emphasis on security.	model-driven engineering;model-driven security;service-oriented architecture;service-oriented device architecture;web service	Juan Pedro Silva;Miguel A. de Miguel;Javier Fernández Briones;Alejandro Alonso	2010	2010 13th IEEE International Symposium on Object/Component/Service-Oriented Real-Time Distributed Computing	10.1109/ISORC.2010.34	web service;computer science;information security;operating system;software engineering;ws-policy;service-oriented architecture;database;distributed computing;services computing;web engineering;world wide web	SE	-47.681204588299316	18.84013763203045	165690
de07a0cee02f0c70e460c489e7e3155a3f4d74c6	a brief observation-centric analysis on anomaly-based intrusion detection	anomaly;modelizacion;intruder detector;raisonnement base sur cas;razonamiento fundado sobre caso;fonction potentiel;analisis estadistico;observable;anomaly detection;securite informatique;intrusion detection;probabilistic approach;anomalie;anomalia;computer security;modelisation;induccion;statistical analysis;induction;enfoque probabilista;approche probabiliste;seguridad informatica;analyse statistique;funcion potencial;intrusion detection systems;information system;case based reasoning;detecteur intrus;potential function;modeling;detector intruso;systeme information;systeme detection intrusion;sistema informacion	This paper is focused on the analysis of the anomaly-based intrusion detectors' operational capabilities and drawbacks, from the perspective of their operating environments, instead of the schemes per se. Based on the similarity with the induction problem, anomaly detection is cast in a statistical framework for describing their general anticipated behaviors. Several key problems and corresponding potential solutions about the normality characterization for the observable subjects from hosts and networks are addressed respectively, together with the case studies of several representative detection models. Anomaly detectors' evaluation are also discussed briefly based on some existing achievements. Careful analysis shows that the fundamental understanding of the operating environments is the essential stage in the process of establishing an effective anomaly detection model, which therefore worth insightful exploration, especially when we face the dilemma between the detection performance and the computational cost.	anomaly detection;intrusion detection system	Zonghua Zhang;Hong Shen	2005		10.1007/978-3-540-31979-5_16	intrusion detection system;anomaly detection;telecommunications;computer science;artificial intelligence;computer security	Security	-36.15197580561378	19.308228726166654	165765
d4c06606dac62fbe6ce4fab7eca4ff61b4e8f4f7	animated graphical user interface generator framework for input-output place-transition petri net models	supervisory control and data acquisition system;hierarchical structure;behavior modeling;petri net markup language;automatic generation;embedded system;input output;development environment;embedded system design;graphic user interface;petri net	"""The paper presents a development framework allowing the automatic generation of animated graphical user interface associated with specific embedded system controllers, and allowing the association of the characteristics of its behavioral model with specific characteristics of the graphical user interface through a set of dedicated rules. The behavioral model of the system is specified by means of an IOPT (Input-Output Place-Transition) Petri net model, which is represented using a PNML (Petri Net Markup Language) notation. Two main tools are described: the """"Animator"""", and the """"Synoptic"""". The first one is the development environment and allows the definition of the graphical characteristics of the synoptic, and their association with dynamic and static characteristics of the Petri net model (the """"Animator""""); this tool also supports hierarchical structuring of the synoptic and definition of platform dependent code to link the physical world to the Petri net model signals and events. The second one is responsible for the execution part including embedded control and on-line animation of the graphical user interface (the """"Synoptic""""). Current main usage of the tool is to support teaching of Petri nets and their application to automation and embedded systems design; yet, application as a SCADA (Supervisory, Control, and Data Acquisition) system is envisaged. The application of the tools to a Petri net model of a parking lot controller is briefly presented."""	graphical user interface;petri net	João Lourenço;Luís Gomes	2008		10.1007/978-3-540-68746-7_27	behavioral modeling;input/output;embedded system;real-time computing;simulation;computer science;graphical user interface;development environment;petri net	HCI	-38.474088115878224	31.56028549192093	165846
fb09a569803c3aee590e82d0d2bbce8b0dcf6969	expert-vsim (abstract only): an expert simulation environment	ada;modeling and simulation;object oriented design;graphical interface;rule based;intelligent environment;software systems;real time embedded system;confidence interval;statistical analysis;probability distribution;network model;artificial intelligence;interactive environment;frame;inference engine;parallel inference engine;forward backward chaining;simulation environment;blackboard driven;expert system	Expert-VSim is the intended product of a current research effort. It is a software system that provides a complete, intelligent environment for the construction and simulation of discrete event models. The initial stage consisted of the construction of a simulation environment called VSim [1] and the second involves the integration of an expert system. VSim provides a highly interactive environment. Included is a graphics interface which constitutes the main model construction tool. Network models are used to describe real-world systems through an entity-activity world view. Models can be built and tested incrementally, increasing the confidence of correctness. In addition, the multi level structure of VSim allows the user to define subnetworks as nodes within a larger network. A definition language complements the graphics interface and is used to describe the details of the model as well as to create user-defined nodes. A prototype for the VSim stage has been completed and thoroughly tested. The design of the second stage is in active development and near completion. This design includes the creation of a simulation and statistics expert system to be integrated with VSim to obtain the final software product: Expert-VSim. This expert system is rule-based implemented in Prolog. The presence of such an expert system is of significant importance in the modeling and simulation process. It provides database and inference capabilities that assist the user in:the selection of probability distributions for input variables using common heuristics and procedures [2] to choose from the known theoretical distributions and estimate their parameters (with or without that availability of data), or to allow the user to fit a distribution to experimental data; the analysis of the simulation results, the construction of confidence intervals for the observed variables, and the comparison of simulation runs; the construction of the model itself by providing an on-line database containing the descriptions of the standard and user-defined node types together with the ability to traverse and inspect the multi-level structure of the model; the extension of the expert system itself by allowing the user to add to the set of rules and facts through the Prolog interface; the independent use of the statistical analysis functions and procedures available to analyze and process data; and the management of experimental and simulation data through the database capabilities of the system. 	correctness (computer science);expert system;graphics interface;heuristic (computer science);intelligent environment;level structure;logic programming;multi-storey car park;online and offline;prolog;prototype;simulation;software system;traverse;world-system	Enrique V. Kortright	1987		10.1145/322917.323079	probability distribution;frame;simulation;ada;confidence interval;computer science;artificial intelligence;theoretical computer science;object-oriented design;network model;software engineering;data mining;modeling and simulation;graphical user interface;database;programming language;expert system;inference engine;software system	AI	-34.64072649847023	27.011813555072493	166143
e313f8dda0560b313c2536ee1d211758b434e87a	just like paper and the 3-colour protocol: a voting interface requirements engineering case study	protocols;radiofrequency;formal specification;prototypes;prototypes nominations and elections protocols radiofrequency identification usability cameras arrays;requirements;arrays;finite state machines;prototyping;requirement engineering;nominations and elections;validation;user interfaces finite state machines formal specification government data processing protocols;usability;user interfaces;government data processing;validation prototyping requirements evolution;radiofrequency identification;cameras;traffic light colour scheme just like paper 3 colour protocol voting interface requirements engineering process electronic vote machine interface operational prototyping approach voting process passive voting protocol 3 state machine;evolution	We report on the development of a novel electronic vote machine interface, with emphasis on the requirements engineering process. In particular, we review how we followed an operational prototyping approach in order to gain a better understanding of requirements in an incremental fashion. Our most interesting observations are concerned with the evolution of our most fundamental requirement: that the voting process followed by the voter should be just like paper. We comment on how the weakening of this requirement was deemed necessary by the addition of other requirements that were identified during our prototype evaluation. This weakening was minimized through the specification of a passive voting protocol that provides feedback to voters without obliging them to follow a voting process any different from that which is normally done using a traditional paper vote. The protocol is based on a simple 3-state machine where we naturally represent the states using the familiar traffic light colour scheme: thus the interaction between voter and interface became known as the three colour protocol.	prototype;requirement;requirements engineering;three-state logic	J. Paul Gibson;Damien MacNamara;Ken Oakley	2011	2011 International Workshop on Requirements Engineering for Electronic Voting Systems	10.1109/REVOTE.2011.6045917	simulation;engineering;computer security;engineering drawing	SE	-36.29572978147748	21.616213060076706	166153
2b14f212b81f5b11fd5999c94d9f343f688f75c2	supervisory control for modal specifications of services	modal specifications;supervisory control;discrete event systens;services;partial observation	In the service oriented architecture framework, a modal specification, as defined by Larsen in [5], formalises how a service should interact with its environment. More precisely, a modal specification determines the events that the server may or must allow at each stage in an interactive session. In this paper, we investigate the adaptation of the supervisory control theory of Ramadge and Wonham to enforce a modal specification (with final states marking the ends of the sessions) on a system modelled by a finite LTS. We prove that there exists at most one most permissive solution to this control problem. We also prove that this solution is regular and we present an algorithm for the effective computation of the corresponding controller.	algorithm;architecture framework;audio feedback;automaton;computation;computer security;confidentiality;control theory;data integrity;exptime;item unique identification;modal logic;server (computing);service-oriented architecture;smoothing;time complexity	Philippe Darondeau;Jérémy Dubreil;Hervé Marchand	2010		10.3182/20100830-3-DE-4013.00069	control engineering;real-time computing;engineering;control theory	Logic	-34.95201775154138	31.50815866274664	166209
4437af3f4d7cbae6c0a9fb7b9567138b38a7df64	modelling and validating the man-machine interface	requirements validation;interactive systems testing;realtime systems modelling;requirements specification;interactive systems modelling;man machine interface;man machine interface modelling	Abstract#R##N##R##N#This paper describes a formal model for expressing the functional requirements of the man-machine interfaces of interactive systems. It also shows how this model can facilitate the automation of other useful activities such as checking for inconsistency, redundancy, and incompleteness in the specification, and validating the implementation of the interface against its original requirements. Finally, the paper comments on the authors' experience in developing an interactive system using this formal model.		Bernice E. Casey;B. Dasarathy	1982	Softw., Pract. Exper.	10.1002/spe.4380120607	human–machine interface;software requirements specification;simulation;human–computer interaction;computer science;systems engineering;system requirements specification	SE	-46.189970356637225	28.40364490603156	166626
4b489d623028ca91643eb3cd7b5acedcb63583be	principles in formal specification of object oriented design and architecture	formal specification;object oriented design;object oriented programming;software architecture;formal foundations;object oriented;software patterns	Progress was made in the understanding of object-oriented (O-O) architectures through the introduction of patterns of design and architecture. Few works, however, offer methods of precise specification for O-O architectures.This article provides a well-defined ontology and an underlying framework for the formal specification of O-O architectures: We observe key regularities and elementary design motifs in O-O design and architectures; define architectural model in logic; and formulate relations between specifications. We demonstrate how to declare and reason with the representations. Finally, we use our conceptual toolkit to compare and evaluate proposed formalisms.	decorator pattern;formal specification	Amnon H. Eden;Yoram Hirshfeld	2001		10.1145/782096.782099	formal methods;database-centric architecture;computer science;software engineering;formal specification;programming language;object-oriented programming	SE	-44.31187097576489	27.524003902169223	166735
afcf31551eca46bf9c501045d1c001d3b01c8ad4	what is a trace? a runtime verification perspective		Runtime Monitoring or Verification deals with traces. In its most simple form a monitoring system takes a trace produced by a system and a specification of correct behaviour and checks if the trace conforms to the specification. More complex applications may introduce notions of feedback and reaction. The notion that unifies the field is that we can abstract the runtime behaviour of a system by an execution trace and check this for conformance. However, there is little uniform understanding of what a trace is. This is most keenly seen when comparing theoretical and practical work. This paper surveys the different notions of trace and reflects on the related issues.	conformance testing;feedback;reaction gui;runtime verification;tracing (software)	Giles Reger;Klaus Havelund	2016		10.1007/978-3-319-47169-3_25	runtime verification	SE	-42.28130016665018	29.17677025359714	166785
7e6e5f1223c94c8907f7247cbb96e9b41db25372	a collection of method fragments automated with model transformations in agent-orientedmodeling	method engineering;multi agent system;method fragment;model transformation;agent oriented software engineering	The Foundation for Intelligent Physical Agents (FIPA) Methodology Technical Committee recommends the method engineering approach for Multi-agent System (MAS) development. This approach consists in defining method fragments for agent-oriented software engineering, and then developers combine these fragments to define customized development processes. In this line of research, the contribution of this paper is a collection of novel method fragments that are assisted with model transformations, in order to allow engineers to better develop MASs in an automated way. Some of these fragments also include explicit advices for incorporating artificial intelligence in the development. In the experiments, two processes have been composed with these method fragments for two different agent-oriented methodologies (i.e. Ingenias and Adelfe). This paper shows how these processes are respectively used to develop two known MASs (i.e. Delphi MAS and Timetable MAS). Furthermore, the presented approach is evaluated with 24 developers that were randomly divided into two groups. Each developer designed a MAS satisfying the same common requirements. One group applied the current approach, while the other group did not. The results show that this approach reduces the 63.3% of the designing time in average forMASs.		Iván García-Magariño	2013	Eng. Appl. of AI	10.1016/j.engappai.2012.09.005	method engineering;computer science;artificial intelligence;multi-agent system	AI	-44.53999699205066	22.598894125022145	166930
abd8816962e5357f519dc5ffa8501ec83f3b0699	modelling temporal behaviour in complex systems with timebands	utp;time bands;complex real time systems;circus	Complex real-time systems exhibit dynamic behaviours on many different time levels. To cope with the wide range of time scales and produce more dependable computer-based systems, we develop a timebands model that can explicitly recognise a finite set of distinct time bands in which temporal properties and associated behaviours are described. We formalise the timebands model by using the semantics of TCSPM to guarantee soundness of each operator and maintain consistency and coordination between different time bands. By means of a complicated example, we demonstrate how significantly the timebands model contributes to describing complex real-time systems with multiple time scales.	automata theory;complex system;complex systems;dependability;real-time clock;real-time computing;real-time locating system;sociotechnical system;timed automaton;way to go	Kun Wei;Jim Woodcock;Alan Burns	2013	Formal Methods in System Design	10.1007/s10703-013-0193-5	real-time computing;simulation;computer science;twisted pair;algorithm	Embedded	-38.444597636568986	29.986514804816128	167083
435adc50e8ad842afe5083b7817d8ac5ce025f89	a 3d, performance-driven generative design framework: automating the link from a 3d spatial grammar interpreter to structural finite element analysis and stochastic optimization			finite element method;mathematical optimization;stochastic optimization	Luca Zimmermann;Tian Chen;Kristina Shea	2018	AI EDAM	10.1017/S0890060417000324	stochastic optimization;systems engineering;simulated annealing;machine learning;finite element method;engineering;artificial intelligence;generative design;grammar;interpreter	AI	-34.63255679392816	25.687041763227505	167090
7d5dc1aa0b7df1eb1a2b376b3c8afb77f46d1c87	formal specification and analysis of zeroconf using uppaals	industrial case study;formal model;zeroconf protocol;commission report or memorandum;uppaal;mutual exclusion;article letter to editor;formal verification;model checking;compositional abstraction;timed automata;compositional reasoning;simulation relation;dynamic configuration	The model checker Uppaal is used to formally model and analyze parts of Zeroconf, a protocol for dynamic configuration of IPv4 link-local addresses that has been defined in RFC 3927 of the IETF. Our goal has been to construct a model that (a) is easy to understand by engineers, (b) comes as close as possible to the informal text (for each transition in the model there should be a corresponding piece of text in the RFC), and (c) may serve as a basis for formal verification. Our modeling efforts revealed several errors (or at least ambiguities) in the RFC that no one else spotted before. We present two proofs of the mutual exclusion property for Zeroconf (for an arbitrary number of hosts and IP addresses): a manual, operational proof, and a proof that combines model checking with the application of a new abstraction relation that is compositional with respect to committed locations. The model checking problem has been solved using Uppaal and the abstractions have been checked by hand.	emoticon;formal specification;formal verification;link-local address;model checking;mutual exclusion;uppaal;zero-configuration networking	Jasper Berendsen;Biniam Gebremichael;Frits W. Vaandrager;Miaomiao Zhang	2011	ACM Trans. Embedded Comput. Syst.	10.1145/1952522.1952527	model checking;mutual exclusion;formal verification;computer science;theoretical computer science;operating system;database;programming language;algorithm	Embedded	-33.925549819598025	31.42510782086069	167370
5145b2f5fa2a145de8fe1717e1c7af20a4ac9a81	malicioius software detection using multiple sequence alignment and data mining	program diagnostics;viruses medical;training;rule extraction;training grippers viruses medical accuracy malware testing data mining;testing;data mining;viral signatures malware sequence alignment;genetic diversity;viral signatures;genetics;program diagnostics bioinformatics computer viruses data mining genetics;computer security;accuracy;computer viruses;malware;grippers;sequence analysis;sequence alignment;multiple sequence alignment;gene function;symbolic rule extraction method malicioius software detection multiple sequence alignment data mining information security computer security security defenses software patches software upgrades antiviral packages sequence analysis bioinformatics genetic diversity organisms gene functions annotation genetic regions malware recognition sequence alignment techniques variable length computer viral worm code alignment patterns ann malware code;bioinformatics	Malware is currently a major threat to information and computer security, with the volume and growing diversity of its variants causing major problems to traditional security defenses. Software patches and upgrades to anti-viral packages are typically released only after the malware's key characteristics have been identified through infection, by which time it may be too late to protect systems. Multiple sequence analysis is widely used in bioinformatics for revealing the genetic diversity of organisms and annotating gene functions through the identification of common genetic regions. This paper adopts a new approach to the problem of malware recognition, which is to use multiple sequence alignment techniques from bioinformatics to align variable length computer viral and worm code so that core, invariant regions of the code occupy fixed positions in the alignment patterns. Data mining (ANNs, symbolic rule extraction) can then be used to learn the critical features that help to determine into which class the aligned patterns fall. Experimental results demonstrate the feasibility of our novel approach for identifying malware code through multiple sequence alignment followed by analysis by ANNs and symbolic rule extraction methods.	align (company);bioinformatics;computer security;data mining;malware;multiple sequence alignment;patch (computing);rule induction;sequence analysis	Yi Chen;Ajit Narayanan;Shaoning Pang;Ban Tao	2012	2012 IEEE 26th International Conference on Advanced Information Networking and Applications	10.1109/AINA.2012.62	multiple sequence alignment;computer science;bioinformatics;sequence analysis;sequence alignment;data mining;database;accuracy and precision;software testing;malware;world wide web;computer security;genetic diversity;alignment-free sequence analysis;computer virus	SE	-35.17035824244582	23.13843492801331	167425
6eaeb74bb582593dd741a99e6e84d11cc764b3f9	study of interaction property testing of distributed system based on petri net	petri net interaction property test;reachability analysis distributed processing petri nets program testing;distributed processing;会议论文;test;program testing;interaction property;testing educational institutions firing peer to peer computing complexity theory computer science electronic mail;implementation under test interaction property testing distributed systems petri net state explosion formal model reachability graph test sequence generation algorithm test execution;petri nets;petri net;reachability analysis	Interaction property is a natural feature of many distributed systems which finish their work on network. But most of them face state explosion when the test work is analyzed and developed with a formal model such as Petri net. In order to avoid such problems, test based on interaction property is considered. It can focus on the interesting features of a system and ignore the other irrelevant part. In this paper, some definitions related to interaction property are given. Petri net is employed to model the IUT to make use of its reachability graph. Furthermore a test sequence generation algorithm is proposed and analyzed in detail. The coverage of a test sequence is discussed according to the interaction property and the corresponding verdict methods are given. During the process of test generation, the feasibility of test execution is simultaneously considered. In order to speed up the test execution, the generated test sequences are classified by the test scenarios. The approach is illustrated on several examples.	algorithm;distributed computing;formal language;petri net;property testing;reachability;relevance;speedup	Hua Li;Yi Xing;Xinming Ye	2012	2012 IEEE Eighth World Congress on Services	10.1109/SERVICES.2012.40	real-time computing;stochastic petri net;computer science;theoretical computer science;distributed computing;petri net	SE	-42.221365344375116	31.28004631728358	167992
aacb776b8d62e013c05806d12699173bbfcf558c	a timed extension of property sequence chart	linear time temporal logic;software;formal specification;clocks;temporal logic;real time specification pattern timed property sequence chart semantics concurrent system linear time temporal logic computation tree logic real time system timed buchi automaton;web service;real time specification pattern;manganese;expressive power;automata;computation tree logic;formal verification;concurrent systems;concurrent system;unified modeling language;concurrency control;temporal properties;temporal logic automata theory concurrency control formal specification formal verification real time systems;timed property sequence chart semantics;automata theory;real time system;timed buchi automaton;logic real time systems computer science power engineering and energy unified modeling language systems engineering and theory sun automata power measurement context aware services;tin;real time systems	Property sequence chart (PSC) is a novel scenarios based notation, which is proposed to represent the temporal properties for concurrent system. It represents a first step toward languages that try to balance expressive power and simplicity of use. Thus, PSC is more intuitive and easily understandable than the traditional temporal logic, such as linear-time temporal logic or computation tree logic. However, the current version of PSC just represents the order of eventpsilas occurrence and lacks the ability to express timed properties. In real-time systems, it is well known that some timed requirements are also very important and need to be specified clearly. Thus, in this paper, in order to make PSC have timed expressiveness, we extend PSC into Timed PSC (TPSC) and give the semantics of TPSC in terms of timed Buchi automaton. Then, we measure the expressive power of TPSC by the use of recently proposed real-time specification pattern. Finally, we illustrate the use of TPSC in the context of a Web service application which requires special timed requirements.	büchi automaton;computation tree logic;concurrency (computer science);expressive power (computer science);formal grammar;linear temporal logic;model checking;multi-function printer;real-time clock;real-time computing;requirement;software engineer;specification pattern;time complexity;timed automaton;web service	Pengcheng Zhang;Bixin Li;Mingjie Sun	2008	2008 11th IEEE High Assurance Systems Engineering Symposium	10.1109/HASE.2008.20	web service;unified modeling language;real-time computing;real-time operating system;temporal logic;formal verification;computation tree logic;tin;computer science;manganese;theoretical computer science;concurrency control;automata theory;formal specification;programming language;expressive power;algorithm	Embedded	-43.523093388184634	30.541572466820824	168251
04950cb63e0f194802a8a21d8f8ac058993222f3	specifications.: formal and informal-a case study	formal specifications;informal specifications	Formal specifications (algebraic) are given for an informally specified small subsystem of the Change Management Automatic Build System. A comparison of the two specifications shows that although informal specifications are easier to read, the formal specifications are clearer, specify operation domains precisely, define the interaction between the operations, show the incompleteness of the informal specifications and are devoid of implementation details. The formal specifications pointed to the need of a function not in the subsystem whose inclusion would improve the system design. This inclusion is now being considered. However, the use of algebraic specifications requires practice and experience. Although the formal specification of large systems is somewhat impractical at the moment, experience in using formal specifications can lead to better informal specifications.	build automation;formal specification;modulo operation;systems design	Narain H. Gehani	1982	Softw., Pract. Exper.	10.1002/spe.4380120505	reliability engineering;computer science;systems engineering;formal specification;programming language	SE	-46.20140841421541	29.772672910585364	168290
