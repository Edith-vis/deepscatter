id	title	keywords	abstract	entities	authors	year	journal	doi	fos	area	x	y	ix
1f35ab8d7f048b0a85b367fa3b16ad18c095e9f5	tinyxxl: language and runtime support for cross-layer interactions	layered architecture;wireless sensor networks electronic data interchange operating systems computers telecommunication computing;data exchange;telecommunication computing;exchange of cross layer data for tinyos tinyxxl cross layer interactions wireless sensor networks programming abstractions data exchange;wireless sensor network;cross layer;reusable component;runtime computer languages application software wireless sensor networks routing communications society wireless communication read write memory peer to peer computing batteries;operating systems computers;wireless sensor networks;electronic data interchange	In the area of wireless sensor networks, cross-layer interactions are often preferred to strictly layered architectures. However, architectural properties such as modularity and the reusability of components suffer from such optimizations. In this paper we present TinyXXL that provides programming abstractions for data exchange, a form of cross-layer interaction with a large potential for optimizations. Our approach decouples components providing and using data, and it allows for automatic optimizations of applications composed of reusable components. Its runtime representation is efficient regarding memory consumption and processing overhead	compiler;data dependency;declaration (computer programming);hood method;interaction;modularity (networks);nesc;overhead (computing);program optimization;programming language;random-access memory;run time (program lifecycle phase);source lines of code;tinyos	Andreas Lachenmann;Pedro José Marrón;Daniel Minder;Matthias Gauger;Olga Saukh;Kurt Rothermel	2006	2006 3rd Annual IEEE Communications Society on Sensor and Ad Hoc Communications and Networks	10.1109/SAHCN.2006.288422	embedded system;real-time computing;wireless sensor network;computer science;operating system;distributed computing;key distribution in wireless sensor networks;wi-fi array;computer network	Embedded	-37.06769041933872	45.676596915884865	54840
71f3dae6ed815fc8a859ba756cd5cac4bff24e7e	schedulability analysis of msc-based system models	automotive engineering;distributed system;control systems;model specification;task graph based models;formal specification;message sequence charts;message sequence charts graphs;system modeling;application software;building block;processor scheduling;real time;formal methods;performance analysis techniques;schedulability analysis;modeling specification techniques;timing analysis techniques;formal method;upper bound;systems analysis formal specification scheduling;message sequence chart;distributed real time system;systems analysis;system design;scheduling;real time systems timing processor scheduling communication system control control systems automotive engineering delay upper bound application software computer science;timing analysis;computer science;task graphs;worst case response time;communication system control;distributed real time systems;electronic control unit;message sequence charts graphs schedulability analysis;timing analysis techniques schedulability analysis message sequence charts distributed real time systems performance analysis techniques modeling specification techniques formal methods task graph based models;real time systems;timing	Message sequence charts (MSCs) are widely used for describing interaction scenarios between the components of a distributed system. Consequently, worst-case response time estimation and schedulability analysis of MSC-based specifications form natural building blocks for designing distributed real-time systems. However, currently there exists a large gap between the timing and quantitative performance analysis techniques that exist in the real-time systems literature, and the modeling/specification techniques that are advocated by the formal methods community. As a result, although a number of schedulability analysis techniques are known for a variety of task graph-based models, it is not clear if they can be used to effectively analyze standard specification formalisms such as MSCs. In this paper we make an attempt to bridge this gap by proposing a schedulability analysis technique for MSC-based system specifications. We show that compared to existing timing analysis techniques for distributed real-time systems, our proposed analysis gives tighter results, which immediately translate to better system design and improved resource dimensioning. We illustrate the details of our analysis using a setup from the automotive electronics domain, which consist of two real-life application programs (that are naturally modeled using MSCs) running on a platform consisting of multiple electronic control units (ECUs) connected via a FlexRay bus.	best, worst and average case;distributed computing;flexray;formal methods;message sequence chart;profiling (computer programming);real life;real-time clock;real-time computing;real-time locating system;response time (technology);scheduling analysis real-time systems;static timing analysis;systems design	Lei Ju;Abhik Roychoudhury;Samarjit Chakraborty	2008	2008 IEEE Real-Time and Embedded Technology and Applications Symposium	10.1109/RTAS.2008.9	embedded system;systems analysis;electronic control unit;application software;real-time computing;formal methods;systems modeling;computer science;operating system;formal specification;distributed computing;upper and lower bounds;programming language;scheduling;specification;static timing analysis;message sequence chart;systems design	Embedded	-39.401848887910376	34.137670452169694	54921
a93aee53564caf699dbc8cf3b3ad0b16b4a63982	using aspect-oriented state machines for detecting and resolving feature interactions	conflict detection;formal methods;domain specific aspect languages;object oriented programming;state machines;aspect interactions;aspect oriented programming;feature interactions;conflict resolution	Composing different features in a software system may lead to conflicting situations. The presence of one feature may interfere with the correct functionality of another feature, resulting in an incorrect behavior of the system. In this work we present an approach to manage feature interactions. A formal model, using Finite State Machines (FSM) and Aspect-Oriented (AO) technology, is used to specify, detect and resolve features interactions. In fact aspects can resolve interactions by intercepting the events which causes troubleshoot. Also a Domain-Specific Language (DSL) was developed to handle Finite State Machines using a pattern matching technique.	aspect-oriented programming;aspect-oriented software development;digital subscriber line;domain-specific language;finite-state machine;interaction;mathematical model;pattern matching;sensor;software system	Tom Dinkelaker;Mohammed Erradi;Meryeme Ayache	2012	Comput. Sci. Inf. Syst.	10.2298/CSIS111216033D	formal methods;aspect-oriented programming;computer science;theoretical computer science;machine learning;conflict resolution;data mining;programming language;object-oriented programming	SE	-40.27968938536888	35.93967737906829	55033
39815feb47e0d524261464de4ff1e8e4dc9a5246	using object-oriented techniques to develop reusable components	ada 95;distributed objects;object oriented;cryptography;compression;distributed systems;reusable component;security	This paper presents several groups of reusable components and subsystems that were designed and implemented to combine object-oriented techniques with Ada 95 features. These components and subsystems demonstrate how to use object-oriented techniques to develop reusable artifacts. The object oriented techniques of generic approach, aggregation and decomposition were adapted and Ada 95 features of abstraction, encapsulation, inheritance and polymorphism were used.	a* search algorithm;ada;artifact (software development);encapsulation (networking)	Huiming Yu	1997		10.1145/269629.269642	embedded system;real-time computing;computer science;distributed computing;distributed object	PL	-37.44420338112235	39.11948646201016	55392
cbbfae2041823ce03d049eb303f34f37733e0b95	integrating realistic simulation engines within the morse framework	robot sensing systems;standards;actuators;computer architecture;computational modeling	The complexity of robotics comes from the tight interactions between hardware, complex softwares, and environments. While real world experience is the only way to assess the efficiency and robustness of a robotics system, simulations help to pave the way to actual experiments. But an overall robotics system requires simulations at a level of realism which no holistic simulator can provide, given the wide spectrum of disciplines and physical processes involved. This paper presents a way to integrate various simulators, in a distributed, scalable and repeatable way, to benefit from their different advantages and get the best fitted and accurate simulation for a given robotics system. It depicts how the MORSE open-source robotics simulator is adapted to comply with the High Level Architecture standard, thus allowing the reuse of numerous dedicated realistic simulators. Two examples of the integration of simulators are provided.	experiment;holism;interaction;open-source robotics;open-source software;scalability;simulation	Arnaud Degroote;Pierrick Koch;Simon Lacroix	2016	2016 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)	10.1109/IROS.2016.7759423	simulation;computer science;theoretical computer science;computational model;computer engineering;actuator	Robotics	-46.169640674607564	38.437798406517985	55413
b75f5d9d3695caacd32c8b1372411d32aee93b1a	cormos: a communication-oriented runtime system for sensor networks	resource allocation;sensor network;sensor systems prototypes sensor systems and applications computer science concurrent computing random access memory read write memory radio transceivers scattering ubiquitous computing;scheduling;random access storage;transceivers;runtime system;scheduling wireless sensor networks random access storage transceivers resource allocation;130 bytes cormos communication oriented runtime system sensor network generic runtime system support system interface program memory ram random access memory radio transceiver;wireless sensor networks	Recently there has been a lot of activity in building sensor prototypes with processing and communication capabilities. Early efforts in this area focused on building the devices themselves and on understanding network issues. An issue that has not received as much attention is generic runtime system support. In this paper, we present CORMOS, a communication-oriented runtime system for sensor networks. CORMOS is tailored: (i) to provide easy-to-use abstractions and treat communication as a first class citizen rather than an extension, (ii) to be highly modular with unified application and system interfaces, and (iii) to deal with sensor limitations on concurrency and memory. We describe the design of CORMOS, discuss various design alternatives, and provide a prototype implementation on a real system. We present preliminary results for resource requirements of CORMOS using a pair of sensor devices. We find that the runtime system and a simple network stack can fit in 5.5 KBytes of program memory, occupying about 130 Bytes of RAM. On the specific devices we use, the system is able to process events at a rate of 2500 events/sec. When communicating over the radio transceiver, CORMOS achieves a maximum rate of 20 packets/sec.	byte;concurrency (computer science);first-class citizen;first-class function;kilobyte;protocol stack;prototype;random-access memory;read-only memory;requirement;runtime system;sensor;transceiver	John Yannakopoulos;Angelos Bilas	2005	Proceeedings of the Second European Workshop on Wireless Sensor Networks, 2005.	10.1109/EWSN.2005.1462026	embedded system;real-time computing;wireless sensor network;telecommunications;computer science;operating system;distributed computing;key distribution in wireless sensor networks;computer network	Mobile	-37.08911405424506	45.82673469242272	55597
0107eb9baba0739c1c2e8cbc35f2d724877d0c70	rfid composite event definition and detection	information filtering;hospitals;radiofrequency identification middleware blood information filters information filtering hospitals reactive power;blood;middleware;information filters;investment timing;radiofrequency identification;reactive power	RFID systems generate large volume of data about localization of people and objects; this information is filtered by a middleware and sent to upper level applications so they can detect events happening in the environment and react properly. This approach implies two drawbacks: firstly, developers invest time programming how to analyze data; secondly, network resources could be unnecessarily wasted when middleware sends data which is irrelevant for the application. To overcome these drawbacks, we present an approach where applications define composite events of interest through a XML-based language, and filtered information is analyzed by a new layer in order to notify applications only when interesting events occur. We present our language called RFID-CEDL for defining interesting events using RFID data and we describe the mechanism used to recognize such events. As demonstration of our approach, we present examples for a hospital environment.	application level events;complex event processing;middleware;radio-frequency identification;relevance;xml	Omar Gonzalez-Padilla;Félix F. Ramos Corchado;Herwig Unger	2008	2008 IEEE International Conference on Information Reuse and Integration	10.1109/IRI.2008.4583074	real-time computing;computer science;artificial intelligence;operating system;middleware;data mining;database;ac power;world wide web	SE	-40.08623516794584	42.25753717740038	55776
94e7448138a523d04481bcbe096c78c99241a05b	model-based runtime monitoring of smart city systems		Abstract The pace of proliferation for smart systems in city wide applications is unmatched. The introduction of Internet of Things (IoT), an enabler of smart city phenomenon, has incubated a productive environment for such innovations. Smart things equipped with IoT capabilities, allow for developing smart city applications at such large scale that each application can be represented as a system of systems (SoS). Nevertheless, the complexity of engineering such SoS has been a major challenge in developing and maintaining smart city applications. One of the engineering challenges that industry face today is the verification of a SoS smart city application at runtime. We introduce utilization of a model-based runtime monitoring approach for providing reliable service. We propose to use message sequence charts for representing a smart city application, later allow the practitioners to express expected behavior of an application in terms of complex-event processing patterns. We demonstrate the fidelity of our approach on a sample smart parking system. Our approach is one of its kind in enabling a non-intrusive monitoring of IoT behavior at runtime (online).	smart city	Koray Inçki;Ismail Ari	2018		10.1016/j.procs.2018.07.146	computer engineering;data mining;smart city;system of systems;fidelity;smart system;internet of things;computer science;phenomenon	Logic	-45.660369817697166	38.6541238840932	55843
2d74be16fb5ef67a4551bed913e9693010076509	a flexible infrastructure for the development of a robot companion with extensible hri-capabilities	distributed system;xml robot architecture human robot interaction system integration distributed system;control systems;software systems;data exchange;mobile robots;human robot interaction;computer architecture;robot control;system integration;xml;robot kinematics human robot interaction communication system control mobile robots computer architecture xml robot control computer science control systems software systems;computer science;communication system control;robot architecture;robot kinematics	The development of robot companions with nat ural human-robot interaction (HRI) capabilities is a challeng ing task as it requires incorporating various functionalities. Consequently, a flexible infrastructure for controlling module operation and data exchange between modules is proposed, taking into account insights from software system integration. This is achieved by combining a three-layer control architec ture containing a flexible control component with a powerful communication framework. The use of XML throughout the whole infrastructure facilitates ongoing evolutionary develop ment of the robot companion's capabilities.	human–robot interaction;multitier architecture;network address translation;robot;software system;system integration;ural (computer);xml	Jannik Fritsch;Marcus Kleinehagenbrock;Axel Haasch;Sebastian Wrede;Gerhard Sagerer	2005	Proceedings of the 2005 IEEE International Conference on Robotics and Automation	10.1109/ROBOT.2005.1570637	data exchange;human–robot interaction;control engineering;mobile robot;embedded system;xml;simulation;computer science;control system;artificial intelligence;robot control;robot kinematics;software system;system integration	Robotics	-38.18933030994813	43.31231842729305	56038
3651d7bc04c1842b839d348f77ea232808be4a43	enhancing residential gateways: osgi service composition	home computing;residential gateways;service composition;business process execution language;software architecture home automation home computing internetworking;variable speed drives engines proposals fires runtime smart homes security web services medical services mobile handsets;residential gateway;indexing terms;software architecture;osgi service registry;service oriented architecture smart homes web services runtime proposals buildings communication system control control systems protocols acceleration;osgi services composition;osgi service registry residential gateways osgi services composition;internetworking;open service gateway initiative;business process execution language residential gateways osgi service composition bpel style solution semantic osgi platform open service gateway initiative;semantic osgi platform;bpel style solution;osgi service composition;home automation	We propose a scheme to support the composition of OSGi services as result of orchestrating atomic services at run-time. With this proposal the OSGi potentiality increases because of the huge amount of new services that can be offered as a result of appropriate combinations. To specify the service composition we propose a totally transparent BPEL-style solution which does not break the OSGi standard. However, the syntactic matchmaking provided by the OSGi standard does not enable a flexible enough automatic service composition. Thus, we propose to define a semantic OSGi platform, which combined with the BPEL-style solution fits all the OSGi service composition requirements.	business process execution language;fits;osgi;requirement;residential gateway;service composability principle	Rebeca P. Díaz Redondo;Ana Fernández Vilas;Manuel Ramos Cabrer;José Juan Pazos-Arias	2007	IEEE Transactions on Consumer Electronics	10.1109/TCE.2007.339507	embedded system;home automation;software architecture;business process execution language;index term;computer science;engineering;residential gateway;world wide web;devices profile for web services;computer network	Visualization	-42.440812488607534	43.7093052837949	56293
af235ad2f3697ab9da9a68724a2232d832a95c6a	agent-based intelligent middleware for user-centric services in ubiquitous computing environments		With the emergence of the ubiquitous computing era, it has become increasingly important for a middleware that fully exploits Human Computer Interaction (HCI)friendly characteristics in order to support user-centric services. Many studies about HCIfriendly middleware designed to support user-centric services have been performed. However, most of the existing research focuses on functional improvements to middleware that concentrates on a specific application rather than on general user-centric services. In this paper, we propose an agent-based intelligent middleware that provides usercentric services in ubiquitous computing environments. We introduce various HCIfriendly middleware projects that support user-centric services, and propose a design for a middleware architecture that effectively supports several functions, such as context awareness, context management, pattern inference based on user behavior, and dynamic agent generation. We also suggest service scenarios that illustrate the adaptive User Interface (UI), spontaneous UI migration for collaboration between users, and UI migration according to the changes of the user’s task environments in smart spaces. We implemented a prototype of our middleware architecture, called Agent-based Intelligent Middleware (AIM), based on our scenarios, in order to show the benefits by verifying the feasibility of user-centric services with minimal user intervention in ubiquitous computing environments.	aim alliance;adaptive user interface;agent-based model;context awareness;emergence;enterprise output management;fault tolerance;human computer;human–computer interaction;intelligent agent;interoperability;interoperation;linkage (software);middleware;modality (human–computer interaction);prototype;reflection (computer programming);scalability;spontaneous order;ubiquitous computing;unified framework;verification and validation;xml	Hyun-Su Jang;Changhwan Song;Moon Jeong Kim;Young Ik Eom	2011	J. Inf. Sci. Eng.			HCI	-40.42176160934205	45.05179201966485	56453
f3d2c1beccf32148d39970f5f3f1643fe35541bc	combining sysml and systemc to simulate and verify complex systems	sciences pour l ingenieur et microtechniques en francais	Heterogeneous Systems are complex and become very critical. These systems integrate software andhardware components with intensive interaction between them. In this context, there is a strongnecessity to develop methodologies and techniques to specify and validate these systems.In engineering, the requirements are the expression of needs on what a particular product or a serviceshould be or to make. They are used most of the time in a formal sense in the systems engineering.In this kind of systems, several types of requirements are present: non-functional requirements suchas the performance and the reliability and functional requirements such as the liveliness. To validatethese requirements of a system, an environment to simulate and to check the properties is essential.In our work, we propose a methodology based on SysML combined with SystemC and Promela/SPINto specify and validate complex systems. This approach is based on Model Driven Engineeringtechniques to irstly translate SysML models to systemC with the aim of simulation and to mapSysML behavioral diagrams to Promela/SPIN in order to verify temporal properties extracted fromthe requirements. The approach is experimented on case studies to demonstrate its feasibility.	complex systems;systemc;systems modeling language	Abbas Abdulhameed	2016			computer science;programming language;algorithm	EDA	-42.14468123792534	32.87149604219643	56840
8f20fa94593ced1b9bffb8dc10b4ce1728797adc	candy-tm: comparative analysis of dynamic thermal management in many-cores using model checking		Dynamic thermal management (DTM) techniques based on task migration provide a promising solution to mitigate thermal emergencies and thereby ensuring safe operation and reliability of Many-Core systems. These techniques can be classified as central or distributed on the basis of a central DTM controller for the whole system or individual DTM controllers for each core or set of cores in the system, respectively. However, having a trustworthy comparison between central (c-) and distributed (d-) DTM techniques to find out the most suitable one for a given system is quite challenging. This is primarily due to the systemic difference between cDTM and dDTM controllers, and the inherent non-exhaustiveness of simulation and emulation methods conventionally used for DTM analysis. In this paper, we present a novel methodology called CAnDy-TM (stands for Comparative Analysis of Dynamic Thermal Management) that employs Model Checking to perform formal comparative analysis for cDTM and dDTM techniques. We identify a set of generic functional and performance properties to provide a common ground for their comparison. We demonstrate the usability and benefits of our methodology by comparing state-of-the-art cDTM and dDTM techniques, and illustrate which technique is good w.r.t. thermal stability and other task migration parameters. Such an analysis helps in selecting the most appropriate DTM for a given chip.	distributed computing;emulator;model checking;qualitative comparative analysis;simulation;thermal management of high-power leds;usability	Syed Ali Asadullah Bukhari;Faiq Khalid Lodhi;Osman Hasan;Muhammad Shafique;Jörg Henkel	2017	Design, Automation & Test in Europe Conference & Exhibition (DATE), 2017		thermal stability;control engineering;model checking;reliability engineering;simulation;engineering;thermal analysis	EDA	-43.884750140387055	36.10716625240341	56946
5d079f499aa7dda3fb17682213c7cd73452c7491	a modular and scalable application platform for testing and evaluating its components	software;vehicle to x;vehicles computer architecture monitoring humans testing automation software;test automation;service oriented middleware;its component;road traffic;intelligent transportation system;mosaic;testing;scalable;computer architecture;its;road traffic mobile communication;monitoring;automotive systeme;scalable vehicle to x application platform its modular;mobile communication;modular;humans;vehicles;application platform;automation function wireless vehicular communication intelligent transportation system its component mosaic service oriented middleware traffic light assistance system;automation function;wireless vehicular communication;traffic light assistance system;automation	Introduction of wireless vehicular communications enables a variety of new Intelligent Transportation System (ITS) use-cases [1, 2], allowing the services to cooperate between vehicles and infrastructure. Furthermore modern vehicles feature an increasing number of driving automation functions. This paper identifies requirements for cooperative and automated ITS, with a special emphasis on the setup of the test environment to test and evaluate them. Subsequently two architectural designs for the test platform called MoSAIC based on DLR's service-oriented middleware DOMINION are described. Finally the concepts are assessed with respect to the identified requirements and by the use of a prototype implementation for a traffic light assistance system.	deployment environment;dynamic language runtime;human interface device;ncsa mosaic;prototype;requirement;scalability;scenario testing;service-oriented device architecture;service-oriented middleware;simulation;usability	Tobias Lorenz;Martin R. K. Baumann;Klaus Jaschke;Frank Köster	2011	2011 IEEE 20th International Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprises	10.1109/WETICE.2011.33	embedded system;intelligent transportation system;mosaic;scalability;simulation;mobile telephony;computer science;operating system;automation;software testing;modular design;computer security	Mobile	-37.209491756017385	44.58808193811432	57052
5d56944bc9d763a2b735c8462fa300047804d666	validation of sdl-based architectural design models: new coverage criteria	automatic code generation;quality assurance;software;architectural design;specification languages program compilers program testing quality assurance software architecture software quality;coverage testing;code generation;architectural design models;specification and description language;industries;testing;architectural design models sdl specification and description language white box testing coverage testing;sdl based architectural design models;sender receiver round trip;automatic generation;software architecture;computational modeling;program testing;specification languages;test coverage;unified modeling language;n step message transfer;automatic test generation;sdl specification and description language;white box testing;program compilers;unified modeling language testing computational modeling software computer bugs telecommunications industries;simulation based black box testing strategies;computer bugs;sender receiver round trip sdl based architectural design models quality assurance automatic code generation simulation based black box testing strategies white box testing strategies specification and description language n step message transfer;white box testing strategies;software quality;telecommunications	As the capability to automatically generate code from different models becomes more sophisticated, it is critical that these models be adequately tested for quality assurance prior to code generation. Although simulation-based blackbox testing strategies exist for these models, it is important that we also employ white-box testing strategies similar to those used to test implementation code. More precisely, we apply coverage testing to architectural design models represented by SDL (Specification and Description Language). Our previous study [30] defined a methodology for automatic test generation with respect to structural-based criteria such as all-node and all-edge. Now, we propose new coverage criteria such as n-step message transfer and sender-receiver round-trip, aiming at the communication between SDL processes.	black-box testing;bluetooth;code coverage;code generation (compiler);eisenstein's criterion;experiment;fault detection and isolation;interaction;message passing;simple directmedia layer;simulation;software bug;specification and description language;subsumption architecture;test case;test set;white-box testing	Andy Restrepo;W. Eric Wong	2011	2011 Fifth International Conference on Secure Software Integration and Reliability Improvement	10.1109/SSIRI.2011.29	reliability engineering;unified modeling language;quality assurance;software architecture;real-time computing;software bug;white-box testing;computer science;operating system;software engineering;software testing;code coverage;programming language;computational model;software quality;code generation	SE	-47.819087022502	33.235596878797374	57378
a2f95189eb11f2d14c7b295374d99e818fb247d4	towards a model level replication technique for fault tolerant systems using aadl		The replication, a technique widely used for fault tolerance purposes, is defined as the redundancy of software, hardware or both units and their consideration in the execution of the application. In this paper, we propose a new technique to design replication using the AADL language and its extensibility with property sets. We choose AADL to take advantage of its strong semantics at architecture level. We enable the designer to model his application using AADL and to enrich it with the property set Replication_Properties. We defined this property set to describe the adopted concepts of replication. Then, based on a set of transformation rules, we generate an intermediate AADL model enriched with different replicas. Currently, we are extending the Ocarina tool suite to support automatic generation of the target model.		Wafa Gabsi;Bechir Zalila	2015		10.1007/978-3-319-23509-7_12	reliability engineering;embedded system;real-time computing	EDA	-42.57349515080972	33.86315491742514	57549
243087106d0568770994edadf681b0719d296615	rethinking 'things' - fog layer interplay in iot: a mobile code approach		A client-server architecture style is one of the common approaches enabling separation of concerns in distributed systems. In the Internet of Things architecture, this approach exists in different configuration of sensors, actuators, gateways in the Fog layer and servers in the Cloud. This configuration affects the degree of interoperability, scalability and other functional and non-functional system requirements. In this paper, we reflect on best practices in the web and REST style to address IoT challenges; one of the constraints in REST, Code on Demand, is used for IoT to enhance the flexibility and interoperability of resource constrained clients at the perception layer. Scripts written in a domain specific language, DoS-IL, are organized and stored at the Fog layer for sensor and actuators nodes to request and execute the incoming script. A generic application layer protocol and RESTful server are presented along with experimental results.		Behailu Negash;Tomi Westerlund;Pasi Liljeberg;Hannu Tenhunen	2017		10.1007/978-3-319-94845-4_14	application layer;cloud computing;separation of concerns;architecture;interoperability;code on demand;system requirements;distributed computing;server;computer science	Robotics	-40.002395839773655	41.210690317049036	57597
74d260e519576366bec8c4bce9d315c7a7ae61f3	evaluation of a web-based programming environment	vm virtual machine;vm virtual machine cloud computing paas platform as a service webos sde server side development environment;paas platform as a service;software engineering;browsers;online front ends;embedded systems;servers;graphical user interfaces;virtual machines;cloud computing web based programming environment platform as a service system server webos web based software development environment software application embedded machine web browser renewable system embedded system virtual machine;servers browsers graphical user interfaces java cloud computing;webos;virtual machines cloud computing embedded systems online front ends programming software engineering;programming;cloud computing;sde server side development environment;java	On most PaaS (Platform as a Service) systems, applications that are developed on a server are executed on the same server. As such, portability of these applications is not considered as is the case with a WebOS. This paper proposes a Web-based Software Development Environment (WSDE) for developing applications. The WSDE provides a web-based development environment for software applications that can be executed on a server, local and/or embedded machine. Thus, it is unnecessary for each developer to install software for developing applications on the local system or to set the environment variables of the local system. With the WSDE, developers can use the same environment via a Web browser anytime, anywhere. Moreover, this paper proposes a renewable system for embedded systems. To develop application programs for embedded systems, application developers have to prepare a software development environment for each target embedded system. The WSDE allows software developers to develop software applications on a server using a virtual machine.	apl;anytime algorithm;collaborative development environment;compiler;embedded system;environment variable;integrated development environment;malware;management system;platform as a service;programming language;server (computing);software developer;software development;software portability;virtual machine;web application;webos	Hideaki Yanagisawa	2012	2012 15th International Conference on Network-Based Information Systems	10.1109/NBiS.2012.67	embedded system;programming;application software;cloud computing;computer science;virtual machine;package development process;software framework;component-based software engineering;software development;operating system;middleware;graphical user interface;database;java;world wide web;application server;server;software system;avionics software	SE	-34.44150958661971	40.2614857649934	57616
8fdccfd6a3a46f6fcdd48dc83b426f9d969abcf4	design and implementation of a mobile actor platform for wireless sensor networks		Wireless sensor networks (WSNs) promise the ability to monitor physical environments and to facilitate control of cyber-physical systems. Because sensors networks can generate large amounts of data, and wireless bandwidth is both limited and energy hungry, local processing becomes necessary to minimize communication. However, for reasons of energy efficiency and production costs, embedded nodes have relatively slow processors and small memories. This makes programming sensor networks harder and requires new tools for distributed computing. We have developed ActorNet, an implementation of the Actor model of computing for sensor networks which facilitates programming by treating a sensor network as an open distributed computing platform. ActorNet provides a high-level actor programming language: users can write dynamic applications for a single cross-platform runtime environment with support for heterogeneous and physically separated WSNs. This shields application developers from some hardware-specific concerns. Moreover, unlike other programming systems for WSNs, ActorNet supports agent mobility and automatic garbage collection. We describe the ActorNet language and runtime system and how it achieves reasonable performance in a WSN.	actor model;central processing unit;cyber-physical system;distributed computing;embedded system;garbage collection (computer science);high- and low-level;programming language;runtime system;sensor	YoungMin Kwon;Kirill Mechitov;Gul A. Agha	2014		10.1007/978-3-662-44471-9_13	embedded system;real-time computing;computer science;distributed computing;key distribution in wireless sensor networks	Mobile	-37.27157439405129	45.80430338325515	57721
3144b94f48267a45e57e3d383194835dcf6c2380	a client-server protocol for the composition of petri nets	client server;object oriented approach;communication protocol;petri net	Modelling the behavior of a system as a set of cooperating nets requires to define a high-level communication protocol which takes into account the very nature of their interactions. This paper proposes to adapt the client-server protocol promoted by the object-oriented approach to Petri nets, and to compose Petri nets according to this protocol.This protocol relies upon four basic rules which assert the honesty and discretion of clients and servers. A class of nets respecting these rules, called clientserver nets, is defined, as is the composition of these nets according to a Use function. The possibility to compose client-server nets while preserving the nets' language and liveness is studied. This possibility comes down to very simple relationships between the main characteristics of client-server nets: the demand and the confidence degree as a client, and the supply and the reliability degree as a server. These relationships are preserved by the composition of nets, so the client-server protocol allows for the incremental design of systems and favors the reuse of nets. 1	autonomous robot;client–server model;coloured petri net;communications protocol;continuous design;high- and low-level;interaction;liveness;loose coupling;one-way function;petri net;polystation;semantics (computer science);server (computing);turing completeness	Christophe Sibertin-Blanc	1993		10.1007/3-540-56863-8_57	communications protocol;real-time computing;computer science;database;distributed computing;process architecture;petri net;client–server model	SE	-37.35992756313984	39.694540634752165	58054
620aca25861690a4a5f70efdc9eb14f91f7f9dd7	refresh: a self-adaptation framework to support fault tolerance in field mobile robots	self adjusting systems control engineering computing fault tolerant computing mobile robots operating systems computers real time systems;target tracking task self adaptation framework field mobile robot system urban search and rescue failure modes robot reliability mission objectives fault tolerance unpredictable environments system safety system effectiveness refresh fault detection fault mitigation diagnosable infrastructure support maintainable infrastructure support real time operating system task performance port based object framework estimation mechanisms functional component faults location task level decision mechanism faults mitigation software functionality hardware functionality software self adaptation hardware self adaptation;robots fault tolerance fault tolerant systems software runtime hardware computer architecture	Mobile robots are being employed far more often in extreme environments, such as urban search and rescue, with greater levels of autonomy; yet recent studies on field robotics show that numerous failure modes affect the reliability of the robot in meeting mission objectives. Therefore, fault tolerance is increasingly important for field robots operating in unpredictable environments to ensure safety and effectiveness of the system. This paper demonstrates a self-adaptation framework, ReFrESH, that contains mechanisms for fault detection and fault mitigation. The goal of ReFrESH is to provide diagnosable and maintainable infrastructure support, built into a real-time operating system, to manage task performance in the presence of unexpected uncertainties. ReFrESH augments the port-based object framework by attaching evaluation and estimation mechanisms to each functional component so that the robot can easily detect and locate faults. In conjunction, a task level decision mechanism interacts with the fault detection elements in order to generate and choose an optimal approach to mitigating faults. Moreover, to increase flexibility of the fault tolerance, ReFrESH provides self-adaptation support for both software and hardware functionality. To our knowledge, this is the first framework to support both software and hardware self-adaptation. A demonstrative application of ReFrESH illustrates its applicability through a target tracking task deployed on a mobile robot system.	attachments;autonomous robot;autonomy;embedded system;fault detection and isolation;fault tolerance;interpreter (computing);mobile robot;real-time clock;real-time operating system;robotics;run time (program lifecycle phase);virtual machine	Yanzhe Cui;Richard M. Voyles;Joshua T. Lane;Mohammad H. Mahoor	2014	2014 IEEE/RSJ International Conference on Intelligent Robots and Systems	10.1109/IROS.2014.6942765	embedded system;real-time computing;simulation;engineering;software fault tolerance	Robotics	-43.07447091332946	38.27710151014766	58805
126b5f3c71a8a25890688ff49cd155cfdff36e88	slca, composite services for ubiquitous computing	composite web service;component based software engineering;service orientation;web service;web services for devices;ubiquitous computing;computer application;service oriented architecture;event driven architecture;software composition	Main concepts to handle in ambient computing applications are hard to integrate at the same time. After studying middlewares handling a part of the challenge, and after studying possiblities of main paradigms in name of CBSE and SOA, we present our Service Lightweight Component Architecture (SLCA) model, based on three main paradigms: Web services, enabling entities interoperability, dynamic discovery, and distribution, lightweight component assemblies to create composite Web services, allowing a high dynamicity, and events, giving applications reactivity and a maximal decoupling between entities, thus enabling an even higher dynamicity. This leads to conciliate both service oriented and event driven approaches in a new way to manage a graph of cooperating services in ubiquitous systems.	component-based software engineering;coupling (computer programming);entity;interoperability;maximal set;service-oriented architecture;ubiquitous computing;web service	Vincent Hourdin;Jean-Yves Tigli;Stephane Lavirotte;Gaëtan Rey;Michel Riveill	2008		10.1145/1506270.1506284	web service;computer science;component-based software engineering;service-oriented architecture;database;distributed computing;function composition;services computing;world wide web;ubiquitous computing	Web+IR	-38.552611199031624	43.00961244694156	58828
95bfd05f7aea97e227c22043121b1d3ff46072e1	from sensing to alerting: a pathway of restful messaging in ambient assisted living	sensor systems;senior citizens;context aware services sensor systems actuators wireless sensor networks senior citizens assisted living ambient networks;hospitals;actuators;stakeholders;sensors assisted living electronic messaging geriatrics;context;restful communication ambient assisted living message transfer	Sensing and alerting are fundamental to AAL. It is a long way from sensing to alerting, where lots of messages are interchanged among different processing units. Starting from the transfer of sensed data to the data processor and all the way to the alert generator, messages change in format, type, and size when intended for different stakeholders. Along this way, it becomes important to decide which messages to transfer, how to transfer, and when to transfer, taking into account the dependability requirements for a reliable AAL system. This article highlights AAL communication from various message transfer perspectives and proposes a general framework of alert/response in an AAL environment addressing these messaging requirements. The cornerstone of the proposed framework is the consideration of dependable RESTful communication throughout the message trail within a local and cloud-based environment. This is coupled with a publish-subscribe mechanism that offers a lightweight solution to address the variability of message transfers in AAL.	atm adaptation layer;central processing unit;cloud computing;dependability;gene regulatory network;heart rate variability;publish–subscribe pattern;representational state transfer;requirement	M. Anwar Hossain;Jorge Parra;Sk. Md. Mizanur Rahman;Atif Alamri;Sana Ullah;H. T. Mouftah	2016	IEEE Wireless Communications	10.1109/MWC.2016.7462491	embedded system;stakeholder;telecommunications;operating system;computer security;computer network;actuator	Visualization	-42.78027696565749	46.28900003960218	58842
8761a7a9874dda6e547b56c2cae5b82b35f65e1c	rapid functional modelling and simulation of coarse grained reconfigurable array architectures	simulation;functional modelling;journal article;modelling framework;cgra;optimal design;design space exploration;modelling and simulation;coarse grained;java	Increases in the complexity of Coarse Grained Reconfigurable Array (CGRA) architectures have made implementation of new architectures difficult and time consuming. Due to the large number of design options available, it is difficult for designers to make optimal design decisions in the early stages of the design cycle. This paper proposes a novel functional modelling framework for CGRA architectures which makes the design space exploration process easier and faster. The framework allows architecture modelling, application mapping and simulation in a single environment, avoiding development of a complex tool set. The proposed approach provides flexibility which allows users to quickly investigate many design options without remodelling. The usefulness and extensibility of the framework is illustrated by presentation of a case study and associated design metrics.		Kunjan Patel;Séamas McGettrick;Chris J. Bleakley	2011	Journal of Systems Architecture - Embedded Systems Design	10.1016/j.sysarc.2011.02.006	computer architecture;simulation;computer science;optimal design;theoretical computer science;programming language;java	EDA	-42.183098610751664	34.40878802050537	58877
bf102464242ae5f183885d2b5e8fe5eed550a216	functionality and structure of the service broker in advanced service architectures	service architecture	This paper discusses the service broker, a function introduced into next-generation networks to manage interactions among applications, to reuse existing applications in a combined fashion, and/or to enable existing applications with capabilities such as presence, location, and policy. With the service broker, a minimal set of applications can be configured in a multiplicity of ways as its elements are brought into play in mix and match arrangements. For the degree of flexibility needed for the service broker to support unique service combinations, the service broker must be programmable. Various functional subcomponents enable these service broker capabilities. These subcomponents include service descriptors, the mechanisms to identify the logic that governs how the applications interact; user and endpoint data managers, the entities that present user-specific and endpoint-specific information; and session contexts, the transient entities that contain the context associated with an instance of call/session or multi-call/session. The session context includes state information and provides multi-session awareness that allows both simultaneous and sequential state-dependent sequential activity to be managed. This paper introduces a lightweight, programmable, Session Initiation Protocol (SlP)-centric service broker architecture and the concept of the “steplet,” which is central to this architecture.	communication endpoint;entity;interaction;service-oriented architecture	Nicholas M. DeVito;Richard T. Emery;Kristin F. Kocan;William D. Roome;Byron J. Williams	2005	Bell Labs Technical Journal	10.1002/bltj.20076	service level requirement;broker pattern;differentiated service;computer science;service delivery framework;operating system;service-oriented architecture;service design;database;world wide web;computer security;computer network	Networks	-37.8643261129148	44.72000078330269	58903
3747d6e28a1b5f322b2b17630e147d216b0350ef	a context-aware component registry for ubiquitous and mobile applications	user interface	Abstract. Dynamic discovery and binding of application constituents is an important aspect of service-oriented and component-based architec-tures. Semantic descriptions of the components and query mechanisms based on these descriptions have been recognised to be crucial. We believe that the integration of context information is equally important, espe-cially for ubiquitous and mobile applications. We present a context-aware registry for service-oriented or component-based architectures, particu-larly suited to mobile and ubiquitous information environments. The reg-istry features a semantic description of services and components, which includes both static properties and classi cations, as well as dynamic context information. It o ers a context-aware query mechanism for the discovery of services and user interface components. 		Rudi Belotti;Corsin Decurtins;Moira C. Norrie;Emmanuel Python	2005			mobile database;mobile search;world wide web;service-orientation;computer science;internet privacy;mobile web;mobile computing;user interface	HCI	-39.916500954762064	44.90145602239798	58953
0cc4ab535772e7e7e80e220a93c94f8cbca6881d	building iot systems using distributed first-class reactive programming		Contemporary IoT systems are challenging to develop, deploy, and maintain. This is because of their ever-increasing scale, dynamic network topologies, heterogeneity and resource constraints of the involved devices, and failures that may occur as a result of these characteristics. Existing approaches are either not at the right level of abstraction, require developers to learn specialized languages, or miss certain key features to address all these challenges in a uniform manner. In this paper we leverage reactive programming and code mobility to support the entire life-cycle of large-scale IoT systems. Our approach is based on existing programming technologies and offers simple and composable abstractions to developers. We implemented our approach in a middleware called Potato and used it to develop and deploy an IoT application on a Raspberry Pi cluster. We found that using Potato reduces much of the accidental complexity associated with developing and deploying IoT systems, resulting in clean and maintainable programs.		Christophe De Troyer;Jens Nicolay;Wolfgang De Meuter	2018	2018 IEEE International Conference on Cloud Computing Technology and Science (CloudCom)	10.1109/CloudCom2018.2018.00045	dynamic network analysis;network topology;distributed computing;code mobility;reactive programming;computer science;first class;internet of things;middleware;abstraction	Embedded	-40.63790512948533	39.43654022772297	59225
6a48235f122b8ab3da788e81e68739c378402298	survivability-aware configuration management of service-oriented system based on service dependency	distributed application;directed graphs;directed acyclic graph;system engineering;three dimensions;system configuration;videoconference;application software;service orientation;information technology;distributed processing;systems engineering;distributed computing;runtime;service dependency;systems engineering and theory;mobile video conference;technology management;acoustical engineering;distributed computing application software videoconference systems engineering and theory technology management information technology acoustical engineering real time systems runtime security;service oriented computing;service oriented system engineering;mobile video conference survivability aware configuration management service dependency service oriented computing distributed application service oriented system engineering directed acyclic graph weighted system configuration graph;survivability aware configuration management;coarse grained;security;configuration management;weighted system configuration graph;mobile video;systems engineering configuration management directed graphs distributed processing;real time systems	Service-oriented computing (SOC) emerging as a new computing diagram that supports the rapid and low-cost development of distributed applications by composing platform-independent, coarse-grained and loosely coupled services. With the prevalence of service-oriented system, how to build survivable applications in the immature research field of service-oriented system engineering (SOSE) has become a big challenge. An approach of configuration management based on service dependency is presented in this paper to analyze and optimize the survivability of applications. Three dimensions, i.e. distance, strength and criticality, are defined to describe the survivability of service dependency. A directed acyclic graph called weighted system configuration graph (WSCG) is proposed to model the survivability of an application, where each direct dependency between two services is assigned a weight which is calculated based on the three dimensions. Then we give an algorithm in WSCG to obtain the maximal survivability system configuration from redundant service configurations. The mobile video conference (MVC) scenario is illustrated to show the effectiveness and the soundness of our approach and algorithms. At last, the conclusion is drawn with future work given.	asp.net mvc;algorithm;configuration graph;configuration management;diagram;directed acyclic graph;distributed computing;loose coupling;maximal set;self-organized criticality;service-oriented device architecture;service-oriented software engineering;system configuration;systems engineering	Tun Lu;Ning Gu	2007	First Joint IEEE/IFIP Symposium on Theoretical Aspects of Software Engineering (TASE '07)	10.1109/TASE.2007.48	three-dimensional space;application software;real-time computing;directed graph;acoustical engineering;computer science;technology management;theoretical computer science;software engineering;service-oriented architecture;distributed computing;configuration management;videoconferencing;information technology;directed acyclic graph	SE	-41.32165249856032	40.33702918284996	59231
1f700f2b7adb17912d98fee3c7dbe9c516ccd54c	guest editors' introduction: special issue on time-critical systems design		Time-critical computing systems are required to meet real-time deadlines. Currently, there is widespread popularity and adoption of Internet-of-Things (IoT) and cyber-physical systems, where the computing systems need to continuously interact with the physical environment. Often, this interaction demands precise timing guarantees. Examples of such time-critical systems range from control systems to smart drones, medical devices, autonomous vehicles, robots, industrial IoT, and smart grid. The software execution time in response to external stimuli in such systems is no longer a performance metric, but instead an issue of functional correctness. However, modern computing platforms with their complex system stack, including the processor architecture, the operating system, and the sophisticated programming language features, are all geared toward improving performance at the cost of timing predictability. Thus, designing systems that can provide predictable timing remains a conundrum.	systems design	Tulika Mitra;Jürgen Teich;Lothar Thiele	2018	IEEE Design & Test	10.1109/MDAT.2018.2796037	complex system;computer engineering;systems design;cyber-physical system;smart grid;software;performance metric;computer science;microarchitecture;control system	EDA	-45.14800193156708	38.07251813265922	59338
84a2f97ecdf5bc41a24bd5c4ed99cd043da31ad0	a prototype model for self-healing and self-reproduction in swarm robotics system	swarm intelligence;neural nets;consequence oriented prescription;mobile agents;distributed processing;self adjusting systems;virtual neurons;null;prototypes neurons autonomic nervous system orbital robotics intelligent robots large scale systems biology computing distributed computing particle swarm optimization virtual prototyping;robot cooperation;trusted electronics and grid obfuscation research center swarm robotics system wide area distributed system large scale distributed system robot cooperation swarm intelligence selfhealing function selfreproduction function virtual neurons autonomous selfdiagnosis consequence oriented prescription autonomous selfcuring;wide area distributed system;autonomous selfcuring;swarm robotics system;autonomous selfdiagnosis;trusted electronics and grid obfuscation research center;multi agent systems;selfreproduction function;large scale distributed system;self adjusting systems distributed processing mobile agents multi agent systems neural nets;selfhealing function;swarm robotics;large scale distributed systems	A swarm robotics system is a special type of wide-area and large-scale distributed system, which focuses on a group of robots cooperating to achieve the same goal using swarm intelligence. To treat the swarm robotics system with the self-healing and self-reproduction functions, this paper studied a prototype model based on the virtual neurons, autonomous self-diagnosis, consequence-oriented prescription, autonomous self-curing, and self-reproduction. This prototype system with self-healing has been implemented in the Trusted Electronics and Grid Obfuscation (TEGO) research center. Several practical cases were studied to show the effectiveness and efficiency of the model. The results demonstrate that the self-healing mechanism makes the system more reliable and the performance much improved, not only against failures, but also against failure propagations	autonomic computing;autonomous robot;computer;distributed computing;neuron;prototype;real-time clock;swarm intelligence;swarm robotics	Yuan-Shun Dai;Michael G. Hinchey;Manish Madhusoodan;James L. Rash;Xukai Zou	2006	2006 2nd IEEE International Symposium on Dependable, Autonomic and Secure Computing	10.1109/DASC.2006.10	swarm robotics;simulation;ant robotics;swarm intelligence;computer science;engineering;artificial intelligence;distributed computing	Robotics	-43.986880442917105	40.172379445317894	59620
15d29704b3f24ed2c7237c047e64f559f512e949	a flexible architecture for enforcing and composing policies in a service-oriented environment	service composition;service orientation;policy language;open architecture;execution environment;enterprise service bus;service oriented architecture	Service Oriented Architectures (SOA’s) enable powerful application and end user service composition from independently defined services. The effective deployment of such composed services requires adaptation of and interoperability between services. This challenge can be approached by specifying service composition in policies, and by enforcing these policies in a sophisticated run-time architecture. In this paper, we present an open architecture for enforcing and composing complex policies that can depend on the available services in the environment. Complex polices have typically been studied in the context of policy languages, yet they have never been fully supported in a SOA-based execution environment. We have created a flexible run-time architecture that maximizes interoperability, adaptability and evolution. We have prototyped our architecture on an Enterprise Service Bus and we illustrate how our solution supports realistic and complex policies.	enterprise service bus;information flow (information theory);interoperability;open architecture;run time (program lifecycle phase);service composability principle;service-oriented architecture;service-oriented device architecture;software deployment	Tom Goovaerts;Bart De Win;Wouter Joosen	2007		10.1007/978-3-540-72883-2_19	enterprise architecture framework;reference architecture;real-time computing;open architecture;differentiated service;computer science;architecture domain;applications architecture;service delivery framework;operating system;service-oriented architecture;service;solution architecture;distributed computing;enterprise architecture;world wide web;data architecture	HPC	-40.55704922991685	41.05383452049475	59689
f757d5c780b398a76ca18b16076f52573c011905	integrated design-stage failure analysis of software-driven hardware systems	analytical models;software;reliability engineering;model based reasoning;management system;hardware software codesign;system modeling;product life cycle;failure propagation analysis;integrated design;software hardware reliability engineering software reliability analytical models redundancy;redundancy management system design stage failure analysis software driven hardware systems software driven hardware configuration safety critical complex systems software component product life cycle high level system modeling model based reasoning approach failure propagation model function failure identification and propagation analysis ffip analysis framework reaction control system jet selection nasa space shuttle;failure analysis;control system;conceptual design;redundancy;aerospace computing;complex system;safety critical software;safety critical system;software component;background knowledge;safety critical systems integrated design stage analysis software hardware reliability formalisms failure propagation analysis;system analysis;integrated design stage analysis;software design;software specification;space vehicles aerospace computing hardware software codesign safety critical software;software hardware reliability;software reliability;analytical model;safety critical systems;space vehicles;formalisms;hardware	Software-driven hardware configurations account for the majority of modern safety-critical complex systems. The often costly failures of such systems can be attributed to software specific, hardware specific, or software/hardware interaction failures. The understanding of how failures propagate in such complex systems might provide critical information to designers, because, while a software component may not fail in terms of loss of function, a software operational state can cause an associated hardware failure. The least expensive phase of the product life cycle to address failures is during the design stage. This research presents a means to evaluate how a combined software/hardware system behaves and how such failures propagate to result in potential failures downstream, during the conceptual design stage. In particular, this paper proposes the use of high-level system modeling and model-based reasoning approaches to model failure propagation in combined software-hardware systems, introducing the Function-Failure Identification and Propagation (FFIP) analysis framework to help formalize the design of safety-critical systems. The fact that the hardware and software designers do not share the same background, knowledge, methods, or language contributes significantly to software/hardware interaction failures. A high-level systems analysis method, such as FFIP, is geared toward the unification of language and modeling concepts and may help to more seamlessly bridge such a gap. The technique is applied to the design of the Reaction Control System Jet Selection of the NASA space shuttle to evaluate failure propagation within the Reaction Control System Jet selection, specifically for the redundancy management system. The paper concludes with the extensions and mappings to the software domain that are required for a truly integrated methodology.	complex systems;component-based software engineering;control system;downstream (software development);failure analysis;high- and low-level;model-based reasoning;software propagation;systems modeling;unification (computer science)	Irem Y. Tumer;Carol S. Smidts	2011	IEEE Transactions on Computers	10.1109/TC.2010.245	embedded system;failure analysis;software requirements specification;parallel computing;real-time computing;systems modeling;control system;software design;product lifecycle;component-based software engineering;software development;operating system;model-based reasoning;hardware architecture;conceptual design;management system;system analysis;life-critical system;systems development life cycle;redundancy;fail-fast;software quality;software fault tolerance;software system	SE	-46.585341964485174	33.53231644270428	59803
466c8d0f73246e41f155cf60e5c77aec111018bd	towards a generic and adaptable publish/subscribe middleware to facilitate pervasive computing applications			middleware;publish–subscribe pattern;ubiquitous computing	Thirunavukkarasu Sivaharan	2008				HPC	-38.96036522271098	45.57336115858218	59823
23be0cff2f12ff386cd604b3d08c523c6795d06b	a formal methodology for compositional cross-layer optimization	system evolves dynamically;formal methodology;different abstraction layer;light-weight formal verification;formal specification;executable formal specification;mobile real-time embedded system;statistical analysis;system execution result;formal analysis;trade-off analysis;compositional cross-layer optimization	The xTune framework employs iterative tuning using lightweight formal verification at runtime with feedback for dynamic adaptation of mobile real-time embedded systems. To enable trade-off analysis across multiple layers of abstraction and predict the possible property violations as the system evolves dynamically over time, an executable formal specification is developed for each layer of the system under consideration. The formal specification is then analyzed using statistical analysis, to determine the impact of various policies for achieving a variety of end-to-end properties in a quantifiable manner. The integration of formal analysis with dynamic behavior from system execution results in a feedback loop that enables model refinement and further optimization of policies and parameters. Finally, we propose a composition method for coordinated interaction of optimizers at different abstraction layers. The core idea of our approach is that each participating optimizer can restrict its own parameters and exchange refined parameters with its associated layers. We also introduce sample application domains for future research directions.	abstraction layer;application domain;embedded system;end-to-end principle;executable;feedback;formal specification;formal verification;iterative method;mathematical optimization;real-time clock;refinement (computing);run time (program lifecycle phase)	Minyoung Kim;Mark-Oliver Stehr;Carolyn L. Talcott;Nikil D. Dutt;Nalini Venkatasubramanian	2011		10.1007/978-3-642-24933-4_10	real-time computing;simulation;formal verification;computer science;theoretical computer science;formal specification;refinement	EDA	-42.44206909724138	34.27094112615129	60353
aee2ae8c90cfc82a11f98c89c0a37aadbd6e8cd0	automated analysis and verification of agent behavior	debugging;integrated approach;maintenance;unmanned aerial vehicle;software systems;agent oriented software engineering;tracer;verification of agent systems;agent based system;agent systems;software comprehension;reverse engineering	Comprehending and analyzing agent behavior is an arduous task due to complexities in agent systems and sophistication of agent behaviors, in addition to the common difficulties with any complex software system. This paper presents an integrated approach for the analysis and verification of behaviors of agent-based systems. The approach is a result of collaboration between the Tracer Tool and the TTL Checker, which together automate the analysis and verification of agents in an implemented agent system with the aim of aiding the user in redesigning, debugging, and maintaining the software system. The Tracer Tool ensures that the user's comprehension of the system behavior is accurate and provides explanations of anomalous behavior, which can be detected as a failed behavioral property by the TTL Checker. The integrated approach has been applied successfully in a case study in the domain of Unmanned Aerial Vehicles.	agent-based model;debugging;multi-agent system;software system;transistor–transistor logic;unmanned aerial vehicle	Tibor Bosse;Dung N. Lam;K. Suzanne Barber	2006		10.1145/1160633.1160876	real-time computing;simulation;software verification;computer science;multi-agent system;debugging;reverse engineering;software system	SE	-46.86486148195398	35.37453161341476	60467
56118d9530d932f48b56db69470ed11da6d9e8bb	a formal approach to mobility modeling	mobility management mobile radio;mobile communication authentication servers analytical models mobile computing protocols system recovery;data deadlocks mobility modeling formal mechanism handoff systems handoff optimization customized mobility protocol resource constraints data dependency;mobility model	In the absence of any formal mechanism to analyze the dynamics of handoff systems, it is difficult to predict or verify the systems performance of un-optimized handover or any specific handoff optimization technique. Without an existing mobility system model, it is difficult to design a new customized mobility protocol or design new optimization techniques for an existing mobility protocol in a systematic way. This paper introduces a model of the handover process that identifies the intrinsic operations of a handover event and allows to predict performance for both an un-optimized handover and for specific optimization methodologies under resource constraints. This model also allows to study the behavioral properties of the handoff system such as data dependency and deadlocks. The model-based approach provides the ability to determine the extent of parallelism and proactive operations that are possible among the handoff components.	data dependency;deadlock;mathematical optimization;parallel computing;proactive parallel suite	Ashutosh Dutta;Bryan Lyles;Henning Schulzrinne	2011	2011 Third International Conference on Communication Systems and Networks (COMSNETS 2011)	10.1109/COMSNETS.2011.5716488	real-time computing;computer science;mobility model;computer security;statistics;computer network	Robotics	-45.92165260773237	34.515712261439084	61063
b5d224a48b6443e428a60963d17c5b624aad76ea	elastic multi-tenant business process based service pattern in cloud computing	elasticity;elasticity business cloud computing measurement adaptation models concrete;cloud architecture elastic multitenant business process based service pattern cloud computing service providers cloud resources servicing cost reduction dynamic requests business process elasticity partner service autonomy partner service variability autoscaling approach multitenancy architecture decision making middleware layer middleware as a service;cloud workflow management;measurement;service patterns;service patterns cloud workflow management elasticity multi tenancy auto scaling;multi tenancy;middleware business data processing cloud computing decision making;business;adaptation models;auto scaling;concrete;cloud computing	Elasticity is an essential property of cloud computing. It helps service providers to efficiently exploit cloud resources and reduce servicing costs. Therefore, the multitenant business processes are long-running and they are concurrently accessed by dynamic requests from tenants. However, ensuring business process elasticity at the infrastructure and the platform levels may only result in significant resources waste due to the partner services autonomy and variability. For this purpose, we tackle the problem of handling elasticity at the process and services levels to scale-out and scale-in their service instances whenever possible. To do this, we propose an auto-scaling approach to hold the promise of ensuring the elasticity of the multitenant business process. This research is based on service patterns for integrating multi-tenancy architecture and making ecisions on the execution of the elasticity mechanisms. Furthermore, we encapsulate our approach into a middleware layer (Middleware as a Service) between the application layer and the platform layer in the cloud architecture. Provided experimental evaluations show that our approach is efficient for ensuring elasticity under various workloads variation of the business process in cloud computing.	algorithm;autoscaling;business process;cloud computing;cloud computing architecture;computer architecture;dynamic web page;elasticity (cloud computing);elasticity (data store);essence;heart rate variability;image scaling;middleware;multicloud;multitenancy;scalability;software as a service	Wael Sellami;Hatem Hadj Kacem;Ahmed Hadj Kacem	2014	2014 IEEE 6th International Conference on Cloud Computing Technology and Science	10.1109/CloudCom.2014.151	simulation;concrete;cloud computing;computer science;operating system;multitenancy;cloud testing;elasticity;computer security;measurement	HPC	-46.50300220672119	43.739295684980625	61155
1991c0177547d4a51efa40a4a3836f544ace537f	concept of symbiotic computing and its agent-based application to a ubiquitous care-support service	healthcare;agent based;health care support service;symbiotic computing;ubiquitous computing;agent software	In this paper, a concept of “symbiotic computing” is formalized to bridge gaps between Real Space (RS) and Digital Space (DS). Symbiotic computing is a post-ubiquitous computing model based on an agent-oriented computing model that introduces social heuristics and cognitive functions into DS to bridge the gaps. The symbiotic functions and agent-based architecture of symbiotic applications are also discussed. Based on the concept, functions, and architecture of symbiotic applications, we develop an agent-based care-support service to enable supervision of persons by their families and friends easily while protecting privacy. In this application system, a hierarchical structure of multi-agents is organized dynamically using heuristics in agents based on the situation of a watched person and watching persons. The system appropriately alters the contents and quality of the live video. The flexible system construction scheme using a multiagent framework facilitates the symbiosis of RS and DS by bridging the gaps in the care-support service domain.	agent-based model;bridging (networking);cognition;heuristic (computer science);multi-agent system;norm (social);privacy;ubiquitous computing	Takuo Suganuma;Kenji Sugawara;Tetsuo Kinoshita;Fumio Hattori;Norio Shiratori	2009	IJCINI	10.4018/jcini.2009010103	context-aware pervasive systems;computer science;knowledge management;artificial intelligence;software agent;distributed computing;world wide web;ubiquitous computing	HCI	-41.676050001866834	44.18297808878294	61173
e6d7c5c5241596fd5f30bd9be06873bd9439d111	service migration scenarios for embedded networks	application development;distributed system;service orientation;tellurium;service migration scenario;actuators;soa;sensor network middleware service migration scenario embedded networks service oriented paradigm heterogeneous network infrastructures process automation building automation service based application development paradigm;runtime;sensor network;embedded system;building automation;embedded systems;software architecture;general solution;web services embedded systems middleware software architecture;embedded networks;process automation;service based application development paradigm;service oriented architecture embedded system middleware costs ip networks web services automation runtime hardware tellurium;web services;service oriented paradigm;middleware;ip networks;sensor network middleware;environmental change;esoa embedded systems embedded networks soa service migration;service oriented architecture;esoa;heterogeneous network infrastructures;heterogeneous network;hardware;automation;service migration	More and more devices are becoming network enabled and are integrated within one large, distributed system. The service-oriented paradigm is the predominant concept for the implementation of this approach and helps to deal with heterogeneous network infrastructures. For long term deployments, e. g., in process and building automation, installations have to be adaptable over time. During runtime new services will be added to the network, old services will be replaced and deployed services will be relocated to adapt the network to environmental changes and new application fields. Handling these updates is challenging, because the impact on the currently executed applications has to be minimized. In general, such tasks are very application specific. However, the service based application development paradigm allows applying a generic approach for most of the scenarios. This paper presents such a generic solution by adding mechanisms, which are capable of handling service migration and service updates, to a sensor network middleware.	autostereogram;bottleneck (software);centralized computing;dfa minimization;distributed computing;embedded system;middleware;programming paradigm;scalability;service-oriented device architecture;tinyos	Stephan Sommer;Andreas Scholz;Irina Gaponova;Alois Knoll;Alfons Kemper;Christian Buckl;Gerd Kainz;Jörg Heuer;Anton Schmitt	2010	2010 IEEE 24th International Conference on Advanced Information Networking and Applications Workshops	10.1109/WAINA.2010.84	embedded system;real-time computing;computer science;service-oriented architecture;computer network	HPC	-39.24491390131357	40.6498034023846	61402
a49ec70766a0232bedb11b59a72f0b5c0daca75f	a bio-chemical approach to awareness in pervasive systems	bio chemical;situation awareness;pervasive systems	The emerging proliferation of devices with sensing and networking technologies offers opportunities for delivering pervasive services through interactions between spatially local resources. Here, applications are challenged to become aware of their surroundings: to discover, filter and reason on information relevant to their goals. Without centralised services to control information flow, decentralised mechanisms must partition these responsibilities across the environment. This paper explores a bio-chemically inspired approach to realising awareness in an open, dynamic setting, building towards complex self-organising awareness algorithms for data collection, reasoning, and querying. Through simulation we provide a preliminary evaluation of the proposed approach.	algorithm;british informatics olympiad;centralisation;interaction;pervasive informatics;self-organization;simulation;ubiquitous computing	Graeme Stevenson;Juan Ye;Simon A. Dobson;Gabriella Castelli;Alberto Rosi;Franco Zambonelli	2013		10.1145/2536714.2536721	simulation;engineering;knowledge management;data mining	HCI	-42.12497120163427	46.02136673780286	61690
0852e734480851824ed15261ed5eb13975cf3888	reducing configuration overhead with goal-oriented programming	goal orientation;ubiquitous computing configuration management music;pervasive computing;goal oriented programming;configuration overhead reduction;ubiquitous computing;tv portable computers programming profession computer architecture pervasive computing communication system control technology management prototypes appropriate technology explosions;user interaction;configuration management;music configuration overhead reduction goal oriented programming pervasive computing;music	The rapid increase in the number and variety of consumer-level electronic devices without the corresponding development of device management technology has lead to a configuration nightmare. We propose to use goal-oriented programming over a substrate of network-portable objects to help reduce the amount of configuration users must do in order to have their applications use their devices efficiently. We detail an architecture and describe a prototype system using existing pervasive computing technology that plays music on the most appropriate devices without requiring user interaction and configuration	human–computer interaction;overhead (computing);prototype;ubiquitous computing	Justin Mazzola Paluska;Hubert Pham;Umar Saif;Chris Terman;Steve Ward	2006	Fourth Annual IEEE International Conference on Pervasive Computing and Communications Workshops (PERCOMW'06)	10.1109/PERCOMW.2006.116	embedded system;real-time computing;context-aware pervasive systems;simulation;human–computer interaction;computer science;operating system;end-user computing;goal orientation;music;configuration management;ubiquitous computing	Robotics	-40.38617483952967	43.19333385023999	61796
ccac928863b6546079b5af15368d24d54ec7432a	migration of rule inference engine to mobile platform. challenges and case study		Mobile devices are valuable sources of information about their user location, physical and social activity, profiles and habits. Such an information can be used to build context-aware applications, that are able to adapt their functionality to user needs and preferences. A lot of research have been done in this field of science, providing multiple context-modelling approaches like rules, ontologies, probabilistic graphical models, etc. There were also several solutions developed that allow for efficient context-based reasoning. However, there is still lack of tools and research done in the area of context-awareness with respect to mobile environments. The solutions that were constructed for the desktop platforms cannot be directly migrated to the mobile systems, as the requirements and characteristics of this two environments are disjoint. In this paper we focus on migrating a lightweight rule-based inference engine to a mobile platform. We define the requirements that have to be fulfilled by the mobile reasoning system in order to be efficient and universal with respect to the variety of mobile operating systems available nowadays.	business rules engine;context awareness;desktop computer;graphical model;inference engine;information needs;logic programming;mobile device;mobile operating system;ontology (information science);prolog;reasoning system;requirement;semantic reasoner;software portability	Mateusz Slazynski;Szymon Bobek;Grzegorz J. Nalepa	2014			mobile search;ontology (information science);data mining;reasoning system;inference engine;mobile computing;mobile device;distributed computing;disjoint sets;graphical model;engineering	Web+IR	-41.45921561568993	45.02865881707926	61805
40ccb2d96393c6576c62866be2bf539c92f05af9	simulating architectures of situational-aware cyber-physical space		Situational aware cyber-physical space seamlessly incorporates computational and physical parts to monitor what is going on in the environment and utilize this data to choose and act. Graphical Modeling, Code generation and simulation help in diminishing the cost of building a situational aware cyber-physical space application since the architects can automatically get an executable application from the architectural model by applying the automatic transformation. In this paper, we present CAPS environment in which an architect can make diverse models to catch distinctive concerns in cyber-physical spaces, simulate and get an energy consumption and data traffic evaluation for their architectures.	computer graphics;executable;simulation	Mohammad Sharaf;Moamin Abughazala;Henry Muccini;Mai Abusair	2017		10.1145/3129790.3129807	real-time computing;computer science;simulation;energy consumption;cyber-physical system;situational ethics;executable;code generation;situation awareness;architectural model	PL	-42.775182185019986	35.95906792402712	62073
6fbfac6a65bd59e22c58b512cbbdf62bf291f5b0	iq-services: resource-aware middleware for heterogeneous applications	distributed application;service level;heterogeneous computing;resource allocation;data management;multimedia application;multimedia computing;program compilers middleware resource allocation multimedia computing;performance improvement;execution environment;middleware;resource availability;program compilers;resource aware middleware heterogeneous computing platform application software service morphing iq services data manipulation multimedia application application specific services;middleware application software cellular phones distributed computing runtime collaborative work international collaboration educational institutions availability resource management;large data	"""Summary form only given. Heterogeneous computing platforms constitute a challenging execution environment for distributed applications. This article presents a 'systems' view of effective platform usage, by demonstrating the need for application software to be continuously 'aware' of the resources currently available on their underlying heterogeneous computing platforms. Our approach to the implementation of resource awareness is one that (1) provides a 'thin' middleware layer of resource aware services that permit applications to react to changes in resource availability and resources to be managed in accordance with application needs, and that (2) develops compiler- and application-level techniques for dynamic 'service morphing', the goal being to make it easy for application-level services to adjust to runtime changes in application needs or in platform resources. The specific results presented in this article are focused on large-data applications, for which the IQ-services """"morphing"""" layer implements the data manipulations necessary to permit wide-area interactive or multimedia applications to proceed smoothly despite variations in underlying computing and network resources. Experimental results demonstrate substantial performance improvements attained by coordinating network-level with service-level adaptations of the data being transported and by permitting end users to dynamically deploy and use application-specific services for manipulating data in ways suitable for their current needs."""	code generation (compiler);decimation (signal processing);distributed computing;embedded system;heterogeneous computing;interaction;java;mathematical optimization;middleware;morphing;object-based language;overlay network;partial template specialization;publish–subscribe pattern;quality of service;soap;self-modifying code;smoothing;software architecture;software deployment;web application	Zhongtang Cai;Greg Eisenhauer;Christian Poellabauer;Karsten Schwan;Matthew Wolf	2004	18th International Parallel and Distributed Processing Symposium, 2004. Proceedings.	10.1109/IPDPS.2004.1303050	parallel computing;real-time computing;service level;data management;resource allocation;computer science;operating system;middleware;database;distributed computing;symmetric multiprocessor system;computer network	HPC	-36.77630922433073	43.018538242685636	62080
3dce315f49fd5250afc0f95077ffa0bb1987c0bf	on the schedulability of a data-centric real-time distribution middleware	distributed system;marte standard;distribution middleware;data distribution service;real time;real time embedded system;schedulability analysis;remote procedure call;embedded systems;dds standard;model driven engineering;middleware;point of view;real time application;real time systems;real time and embedded systems	This work presents an analysis of the Data Distribution Service for Real-Time Systems (DDS), a data-centric distribution middleware that supports the development of predictable applications, from the schedulability point of view. The study focuses on how DDS intends to guarantee the real-time behavior through the mechanisms included in the standard, and proposes some extensions to this standard. Furthermore, the paper looks at other approaches to build distributed systems based on object distribution and remote procedures calls which can guarantee predictability, and shows how to use DDS to obtain real-time applications. A set of concepts defined in the Modelling and Analysis of Real-Time and Embedded systems (MARTE) standard has been integrated into DDS in order to allow using Model-Driven Engineering (MDE) and schedulability analysis techniques. Finally, to emphasize the results obtained from the analysis, the paper also performs a brief evaluation to validate the predictability of a particular DDS implementation.	built-in self-test;canonical account;documentation;dynamical system;entity;loose coupling;middleware;modeling and analysis of real time and embedded systems;overhead (computing);quality of service;real-time clock;real-time computing;real-time transcription;scheduling (computing);scheduling analysis real-time systems	Héctor Pérez;J. Javier Gutiérrez	2012	Computer Standards & Interfaces	10.1016/j.csi.2011.08.005	embedded system;model-driven architecture;real-time computing;computer science;operating system;middleware;remote procedure call	Embedded	-40.23599883754007	33.48208440505192	62163
acf4098606e9199c257a163118ab5f00e91b572a	an error control agent running on rcsm for smart festival management system	hybrid software architecture;festival management system;error control agent;smart festival management;standardized communication protocol;object data;error control model;reconfigurable context sensitive middleware;smart festival management system;various information	This paper proposes an error control model running on RCSM (Reconfigurable Context Sensitive Middleware) for smart festival management by analyzing errors of the object data. RCSM provides standardized communication protocols to interoperate an application with others under dynamically changing situations. It describes a hybrid software architecture that is running on situation-aware middleware such as RCSM which has an error or object with a various information for each session and it also supports multicasting with this information for festival management system.	error detection and correction;management system	Soongohn Kim;Eungnam Ko	2012		10.1007/978-3-642-35585-1_11	simulation;engineering;advertising;computer security	AI	-35.41620372151917	45.996764873357435	62361
67cd1637735200589be52a1c2e0ca7ae238c1ba6	a generalized framework for distributed intelligent process automation	distributed processing;automation automatic control logic application software artificial intelligence engines hardware scalability computer interfaces control systems;intelligent control;cognitive architecture;production engineering computing;intelligent control production engineering computing process control software reusability user interface management systems discrete event systems distributed processing;software reusability;reusable standardized tools generalized framework distributed intelligent process automation auto mate soar generic interfaces software components hardware interconnection discrete events;software component;discrete event systems;process control;user interface management systems;discrete event	Rapid advancements in computing have lead to sophisticated solutions for real world problems requiring complex logic, hefty interfaces and growing need of intelligence. This elaborates the importance of isolation of logic from interfaces and the availability of reusable standardized tools for tasks, most commonly required by various processes. Auto-Mate is a generic framework aimed at meeting these requirements. A novel approach has been adopted by employing Soar (a general cognitive architecture and AI engine) as a dedicated element for controlling the functionality of the system. The framework also focuses on providing standardized and generic interfaces for software components as well as physical links for hardware interconnection. The framework is made extendible, scalable and compatible with multiple platforms and services for supporting applications of variant magnitudes and scope. Auto-Mate is most suitable for process automation based on discrete events.	auto-tune;cognitive architecture;component-based software engineering;extensibility;interconnection;requirement;scalability;soar (cognitive architecture)	S. Enam-ur-Rehman;A. Sikander;U. Shafique	2004	Proceedings of the Fourth International Workshop on Robot Motion and Control (IEEE Cat. No.04EX891)	10.1109/ROMOCO.2004.240966	embedded system;real-time computing;computer science;software framework;hardware architecture;computer engineering	Robotics	-34.969702718141065	38.240410564038996	62588
038a25caccb36898f93ce3b5a3149bd2c19b78ae	adaptive semantic support provisioning in mobile internet environments	demand appropriate semantic support;context information;mobile devices exhibit;semantic support functionalities;dynamically adapting semantic support;semantic language;context-aware application;mobile internet environments;different user access device;adaptive semantic support;user access device;heavyweight support facility;support function;application software;mobile computing;operating systems;ontologies;operating system;internet;middleware;search engines;mobile device	The Mobile Internet scenario encourages the design and development of context-aware applications that provide results depending on context information, such as the relative position of users, user preferences, device capabilities and available resources. A key requirement for the provisioning of context-aware applications is to give computer systems the ability to understand context information. Semantic languages are well suited to leverage the possibility to express, process and reason about context information and to facilitate knowledge sharing and interoperability among previously unknown entities accessing services from heterogeneous devices. However, the exploitation of semantic languages for the design and deployment of context-aware applications raises new challenges, mainly due to the high degree of heterogeneity that mobile devices exhibit in terms of computing power, memory, operating system, and supported software. Semantic languages require complex and heavyweight support facilities, e.g. metadata interpreters, reasoning engines and ontology repositories, that may not fit the capabilities of all user access devices, especially of the resource-limited ones. Novel solutions are required that are capable of transparently and dynamically adapting semantic support functionalities to the properties of the different user access devices. The paper proposes a novel middleware solution that exploits the visibility of two kinds of metadata, user/device profiles and policies, to tailor semantic support functionalities and that offers a wide set of mechanisms for providing on demand appropriate semantic support to mobile portable devices.	computation;computational resource;entity;interoperability;middleware;mobile device;operating system;provisioning;software deployment;ubiquitous computing;user (computing)	Antonio Corradi;Rebecca Montanari;Alessandra Toninelli	2005	2005 Symposium on Applications and the Internet Workshops (SAINT 2005 Workshops)	10.1109/SAINTW.2005.26	semantic interoperability;support function;semantic computing;application software;the internet;semantic integration;semantic grid;computer science;ontology;operating system;middleware;mobile device;database;multimedia;mobile computing;world wide web;computer security;computer network	OS	-40.11513301990668	46.010737394651	62811
48b7cbaa00203cde2dfa0d097a77213433daab9b	device-independent middleware for industrial wireless sensor networks	european fp7 ginseng project device independent middleware industrial wireless sensor networks proprietary protocols client applications heterogeneous sensor network platforms complex closed loop techniques performance control guarantees wsn infrastructure;wireless sensor networks sensors protocols logic gates valves ip networks computer architecture;protocols;sensors;device independent;telecommunication computing;device independent wireless sensor network middleware;wireless sensor network;computer architecture;logic gates;middleware;ip networks;valves;wireless sensor networks;wireless sensor networks middleware protocols telecommunication computing	Wireless sensor networks (WSNs) are deployed to sense, monitor and act on the environment. Deployments in scenarios such as industrial sense and react environments require a set of functionality, and for both ease and reconfiguration capabilities it is important to offer an appropriate framework. We propose a framework for interaction with real-world devices by abstracting proprietary protocols, allowing the interaction between client applications and heterogeneous sensor network platforms and protocols. The framework allows the (re)configuration of alarms, actions or closed-loop techniques, offering flexibility and the possibility to modify for providing performance control guarantees. It allows users to configure and apply various operations, including complex closed-loop techniques that monitor and act over any actuator in the WSN, independently of the underlying WSN infrastructure. The framework is being deployed in a real scenario in the context of European FP7 GINSENG project (wireless networks with performance control guarantees).	application programming interface;middleware;usability;user interface;web service	José Cecílio;Marly G. F. Costa;Pedro Martins;Pedro Nuno San-Bento Furtado	2011	2011 IEEE Ninth International Symposium on Parallel and Distributed Processing with Applications	10.1109/ISPA.2011.16	embedded system;real-time computing;wireless sensor network;heterogeneous network;computer science;operating system;wireless network;distributed computing;key distribution in wireless sensor networks;wi-fi array;mobile wireless sensor network;computer network	Embedded	-38.917808867104505	46.18667176190168	62854
a7f25bef78ff7074ad6ccda325629ade54966251	more accurate semantics defining constraint combination for software systems having client-server relationships	scheduling;job graph;client- server systems;task graph;precedence constraints;constraint combination;client server;software systems	In this paper we present a new method of combining multiple precedence constraints for a single task to support software systems having client-server relationships. In these types of software systems, the combination of the precedence constraints must support the dynamic job structure of the system. Existing formalisms do not offer this support while accurately representing the desired behavior of the software. Additionally, the application of existing formalisms to software systems having periodic clients is ill defined. The new semantics presented here can be applied at the task graph level of description, support the underlying dynamic job structure of these systems, accurately represent the desired behavior of these software systems including those with periodic workloads, and easily map to commercial-off-the-shelf, asynchronous, event-driven, priority-based scheduling environments.	client–server model;event-driven programming;scheduling (computing);server (computing);software system	Kenneth G. Ricks;David Jeff Jackson;B. Earl Wells	2003			commercial off-the-shelf;software;software system;distributed computing;client–server model;computer science;periodic graph (geometry);real-time computing;scheduling (computing);asynchronous communication;semantics	SE	-39.62473650999135	37.94758589664459	63124
35b6beb2fb2b430347ce21167ffc26dcda163780	verification and semantic parallelization of goal-driven autonomous software	certification cost;certification artifact;concurrent software;complex software interaction;mds goal networks;mission-critical software;semantic parallelization;autonomous space system;goal-driven autonomous software;autonomous flight system;complex man-rated autonomous software;c;real time;software systems;level of detail;space missions	Future space missions such as the Mars Science Laboratory demand the engineering of some of the most complex manrated autonomous software systems. According to some recent estimates, the certification cost for mission-critical software exceeds its development cost. The current processoriented methodologies do not reach the level of detail of providing guidelines for the development and validation of concurrent software. Time and concurrency are the most critical notions in an autonomous space system. In this work we present the design and implementation of a first concurrency and time centered framework for verification and semantic parallelization of real-time C++ within the JPL Mission Data System Framework (MDS). The end goal of the industrial project that motivated our work is to provide certification artifacts and accelerated testing of the complex software interactions in autonomous flight systems. As a case study we demonstrate the verification and semantic parallelization of the MDS Goal Networks.	artifact (software development);autonomous robot;c++;concurrency (computer science);data system;interaction;level of detail;mission critical;parallel computing;real-time transcription;software system	Damian Dechev;Nicolas Rouquette;Peter Pirkelbauer;Bjarne Stroustrup	2008		10.1145/1487652.1487685	embedded system;verification and validation;real-time computing;simulation;software verification;computer science;theoretical computer science;software development;space exploration;operating system;level of detail;software construction;distributed computing;software system	SE	-45.19414174581679	36.51277618753566	63211
aabc3e572139a16009e24a7acad3d2d79a79966e	service-oriented adaptation in ubiquitous computing environments	context aware;adative systems ubiquitous computing service oriented computing;context aware adaptive application;service orientation;component based modeling approach service oriented adaptation ubiquitous computing environment quality of service software development context aware adaptive application;service oriented adaptation;object oriented programming;software engineering;adative systems;computational modeling;adaptation model;adaptive applications;ubiquitous computing context aware services application software pervasive computing quality of service runtime delay programming information technology batteries;service oriented computing;software development;web services;ubiquitous computing;planning;ontologies;web services object oriented programming quality of service software engineering ubiquitous computing;component based modeling approach;quality of service;context;ubiquitous computing environment	Ubiquitous computing environments may offer dynamically discoverable services that can be utilized by adaptive applications to improve their functionality and quality of service. We have developed a general software development framework for context-aware adaptive applications. In this paper we present our novel modeling concepts that extend an existing component-based modeling approach by service-oriented adaptation concepts. With our new extensions a dynamically discovered service may replace an application component if it increases the overall utility of the application. We discuss open questions and point to potential solution approaches.	component-based software engineering;discoverability;quality of service;service-oriented architecture;service-oriented device architecture;software development;software framework;ubiquitous computing	Kurt Geihs;Roland Reichle;Michael Wagner;Mohammad Ullah Khan	2009	2009 International Conference on Computational Science and Engineering	10.1109/CSE.2009.373	planning;web service;real-time computing;quality of service;computer science;ontology;software development;service-oriented architecture;distributed computing;object-oriented programming;computational model;world wide web;ubiquitous computing	HPC	-40.72349013418093	40.518021145905976	63271
81229faae1c2130f4db6256618f3ffc7d802d8b1	self-adaptability and organization for pervasive computing and sensor network environments using a biologically-inspired approach	ubiquitous computing distributed sensors self adjusting systems;sensor network environments;ambient intelligence;pervasive computing;local activities;biological system modeling;self adaptive system pervasive computing sensor network environments self organization biologically inspired approach;self adjusting systems;ambient intelligence self adaptability self organization pervasive computing;maintenance engineering;biology;self adaptive system;sensor network;distributed sensors;pervasive computing biosensors computer architecture ambient intelligence stability differential equations distributed processing biology information science biological systems;computer architecture;self adaptability;biologically inspired approach;adaptive system;biological systems;ubiquitous computing;self organization;noise	In this paper we propose an architecture which integrates the notion of self-adaptability and self-organization in the pervasive computing architecture. Furthermore we describe how a biologically-inspired approach may be a good candidate for this purpose in order to provide a resilient, self-adaptive system similar to living biological systems. Additionally the emergent intelligence that would ultimately encompass the human being and its environment would inevitably assist us where our consciousness is not present.	adaptive system;biological system;computer architecture;connection-oriented ethernet;emergence;pervasive informatics;self-organization;ubiquitous computing;far-play	Ehssan Sakhaee;Naoki Wakamiya;Masayuki Murata	2008	2008 IEEE International Symposium on Parallel and Distributed Processing with Applications	10.1109/ISPA.2008.97	context-aware pervasive systems;self-organization;wireless sensor network;ambient intelligence;computer science;noise;artificial intelligence;theoretical computer science;distributed computing;ubiquitous computing	Arch	-38.42245110671858	43.536883968001206	63466
d4e2c0478c700ac0184d6c49a7ae25c15214c454	creating self-adaptive service systems with dysoa	formal specification;service system;separation of concern;object oriented programming;service architecture;dynamic environment;software architecture;adaptive systems;software architecture formal specification adaptive systems quality of service object oriented programming;system development;quality of service;service oriented architecture;component modeling self adaptive service systems dysoa service centric systems qos requirements service architecture dynamic service oriented architecture process modeling;quality of service runtime control systems delay security simple object access protocol web services context aware services	Service-centric systems exist in a very dynamic environment, which requires these systems to adapt at runtime in order to keep fulfilling its QoS requirements to its users. In order to create self-adaptive service-centric systems, developers not only design the service architecture, but need to design the self-adaptability aspects in a structured way. Current service standards and technologies do not provide a general architecture in which all aspects for self-adaptability can be designed. In this paper we propose DySOA (dynamic service-oriented architecture), an architecture that extends service-centric applications to make them self-adaptive. DySOA allows developers to explicitly model the process and components that deal with determining the QoS of the running system, with evaluating the QoS, and with reconfiguring the system when necessary. Having the DySOA elements explicit enables separation of concerns, making the DySOA elements adaptable at runtime and reusable in next versions. We demonstrate how to use DySOA with an example.	quality of service;requirement;run time (program lifecycle phase);separation of concerns;service-oriented architecture	Ivor Bosloper;Johanneke Siljee;Jos Nijhuis;Dieter K. Hammer	2005	Third European Conference on Web Services (ECOWS'05)	10.1109/ECOWS.2005.10	enterprise architecture framework;reference architecture;software architecture;space-based architecture;real-time computing;mobile qos;database-centric architecture;differentiated service;computer science;applications architecture;service delivery framework;adaptive system;service-oriented modeling;service-oriented architecture;service design;service;solution architecture;distributed computing;programming language;data as a service;view model;data architecture;systems architecture;systems design	Embedded	-40.53793243427126	40.30667745279852	63546
55cc0710509a7decd8729abb066090ecd69f256b	modeling, analysis and implementation of actor-based multimedia systems.	model analysis;distributed multimedia system;time synchronization;multimedia systems;video recording	This paper presents an approach centered on a time-sensitive Actor framework suited to the modeling, analysis and implementation of multimedia systems. A distributed multimedia system consists of a collection of autonomous media actors interacting to one another to fulfil a common goal, e.g., interactive videoconference, video recording on-demand, etc. Timing synchronization activities rest on reflective Actors (QoSsynchronizers) which filter inter-communication messages and constrain them according to application-dependent QoS parameters. The synchronizers have a link with a constraint-directed scheduling structure that can be customized through programming. In order to support timing QoS constraints validation and to analyze the time-dependent dynamic behavior of a multimedia system and its associated parameters, the modeled media actors are prototyped under simulation, by exploiting a flexibility of the adopted actor framework to be transparently operated under real or virtual time. The approach smoothes the transition of media actors from the prototyping to the real operating environment, by changing the time notion in the scheduler. The transition from the modeling, to analysis, down through to the implementation stages is seamless. The proposed methodology is applied to the development and analysis of an application-level inter-media stream synchronization filter of multimedia sessions both live and on-demand.	actor model;autonomous robot;end-to-end principle;experiment;interaction;internet;java;mathematical model;mbone;operating environment;operating system;partial template specialization;quality of service;scheduling (computing);seamless3d;simulation;smoothing;synchronization (computer science);tracing (software);video	Giancarlo Fortino;Libero Nigro	1999			real-time computing;distributed computing;multimedia;wireless multimedia extensions	Embedded	-36.8181268665134	41.59634604070972	63994
8aea815d47c67f78b8cb82e469b75c4c527451f2	identification and management of inconsistencies in dynamically adaptive software systems	institutional repositories;fedora;vital;vtls;ils	Computing devices now enable access to rich information about their surrounding execution environment gathered through sensor networks or system monitors. This ability allows software systems to be conceived with context in mind, instead of being created in isolation as in traditional approaches for software development. Services provided by software systems can be adapted to sensed conditions rendering such services more appropriate to the surrounding execution environment. Adaptations to the system’s behavior take place unannounced over time. However, if not dealt with carefully, the behavior provided by such adaptations could lead to inconsistencies in the system’s behavior. In order to avoid such inconsistencies, dependencies between adaptations must be carefully managed so that interactions gathered for the surrounding execution environment are not rendered incompatible. This dissertation investigates how to provide more guarantees about the predictability of the system’s behavior when it is adapted dynamically at run time. Based on the observation of different dynamically adaptive software systems, we put forward a set of requirements that software systems should satisfy to ensure consistency of its behavioral adaptations. We propose a formal basis to support the development of consistent software systems in the presence of dynamic behavioral adaptations, called context Petri nets. This formal basis complies with the requirements for consistent dynamically adaptive software systems, and in particular context-oriented programming, on three levels: formalization, execution, and analysis. Context Petri nets offer a formalization for the definition of adaptations, the interactions between them, and the notion of consistency of a system in the presence of dynamic behavioral adaptations. Interactions between adaptations are formalized by a well-defined set of rules that capture the intention of programmers at a high-level, while enabling the low-level representation and automatic verification of those rules. Consistency verification of the system is provided at two levels. At design-time, system properties can be analyzed for the identification of possible incoherence in the definition of interactions between adaptations. At run-time the satisfiability of all interaction rules between adaptations is verified, hence, it can be ensured that no inconsistencies occur. Based on the proposed formal basis, we offer a tool for the design, manipulation, and simulation of adaptations and their interactions. This work is validated by demonstrating its usefulness in analyzing existing context-aware applications, its appropriateness in broadening the frontiers of context-oriented programming, and its extensibility by expanding the formal basis itself.	extensibility;high- and low-level;interaction;norm (social);petri net;programmer;requirement;run time (program lifecycle phase);simulation;software development;software system;verification and validation	Nicolás Alvarez	2013			real-time computing;simulation;computer science;data mining	SE	-42.20681852685004	36.90087411993436	64139
8302703e4cdfb94fd34a2585cf36792823ac49f3	combining semi-formal and formal methods for the development of distributed reconfigurable control systems		This research paper deals with combining semi-formal and formal methods to develop distributed reconfigurable control systems. The reconfiguration consists in modifying the system behavior to adapt it to the changes in its related environment caused by user needs and operating constraints. A DRCS which consists of networked reconfigurable control systems (RCSs), is a set of functional operations such that only a subset is executed by adding or removing operations after a well-defined reconfiguration scenario. To dynamically handle reconfiguration scenarios at run-time, a defined multi-agent architecture is proposed and affects a reconfiguration agent (RA) for the local reconfiguration of each RCS and a global coordination agent to harmonize the different RCSs for a required coherence. To provide a documented and safe reconfigurable system, we propose a new methodology called DRec-UML-B that covers all software development phases from modeling and verification to code generation using UML and B. The DRec-UML-B development process consists of two complementary phases: UML specification and B specification. In the first phase, we model the different agents with UML to specify the static and dynamic aspects of the DRCS. The second phase translates the UML specification to obtain the B abstract model using defined DRec-rules and reduces the number of operations to be transformed from a UML class diagram to B ones. Then, we apply successive refinements to obtain the C code and we check the system using Atelier B and Check R-B tools for the consistency and accuracy of the specification, refinement, and code generation levels to avoid the redundant control of B machines that share similar sequences of operations. We apply all the proposed contributions to two benchmark production systems FESTO and EnAS to discuss the benefits of DRec-UML-B methodology in terms of the number of generated B operations.		Raja Oueslati;Olfa Mosbahi;Mohamed Khalgui;Zhiwu Li;Ting Qu	2018	IEEE Access	10.1109/ACCESS.2018.2878896	software development process;code generation;real-time computing;distributed computing;computer science;unified modeling language;control reconfiguration;formal methods;architecture;class diagram;software	SE	-42.90245154533906	32.90511227925131	64156
b95f81e7783eb1530a7130d809eac90391657bdd	combining model checking and runtime verification for safe robotics		A major challenge towards large scale deployment of autonomous mobile robots is to program them with formal guarantees and high assurance of correct operation. To this end, we present a framework for building safe robots. Our approach for validating the end-to-end correctness of robotics system consists of two parts: 1) a high-level programming language for implementing and systematically testing the reactive robotics software via model checking; 2) a signal temporal logic (STL) based online monitoring system to ensure that the assumptions about the low-level controllers (discrete models) used during model checking hold at runtime. Combining model checking with runtime verification helps us bridge the gap between software verification (discrete) that makes assumptions about the low-level controllers and the physical world, and the actual execution of the software on a real robotic platform in the physical world. To demonstrate the efficacy of our approach, we build a safe adaptive surveillance system and present software-in-the-loop simulations of the application.	autonomous robot;correctness (computer science);end-to-end principle;high- and low-level;high-level programming language;mobile robot;model checking;robotics;run time (program lifecycle phase);runtime verification;simulation;software deployment;software verification;temporal logic	Ankush Desai;Tommaso Dreossi;Sanjit A. Seshia	2017		10.1007/978-3-319-67531-2_11	theoretical computer science;software deployment;model checking;real-time computing;correctness;computer science;software;mobile robot;runtime verification;software verification;robotics;artificial intelligence	Robotics	-45.18270668749904	36.03317996570014	64165
1e9ea82d33f8c957fdce72a30904625d29e6dfe9	web federates - towards a middleware for highly scalable peer-to-peer services	net framework;code generation;web service;distributed objects;client server;publish subscribe;middleware;service oriented architecture;peer to peer	Starting from the classical Client/Server paradigm, in the last couple of years Peer-To-Peer approaches have evolved and proven their power. Currently we see an evolution from the distributed object access paradigm represented e.g. by middleware architectures like CORBA, DCOM or RMI towards Service Oriented Architectures (SOA), entailing a retrogression to the Client/Server paradigm. In this paper we want to present how Peer-To-Peer Applications can to a large extend benefit from intrinsic Web Service properties like loose coupling, declarative interface definition and interoperability, thus incorporating advantages from SOA and the Peer-To-Peer approach, opening new fields of application to both of them. For this purpose, WebFederate, a prototype middleware based on Microsoft’s .NET Framework has been implemented and will be presented in	.net framework;common object request broker architecture;distributed component object model;distributed object;emergence;federation (information technology);interoperability;loose coupling;middleware;multitier architecture;peer-to-peer;programming paradigm;prototype;soap;scalability;self-organization;service-oriented architecture;web service;windows communication foundation;world wide web	Ingo Scholtes;Peter Sturm	2006		10.1007/978-3-540-74063-6_11	web service;middleware;computer science;service-oriented architecture;middleware;database;distributed object;publish–subscribe pattern;law;world wide web;application server;code generation;client–server model;computer network	Networks	-34.353002953793855	43.73733701577465	64172
02ba06ce6195cbd48ec0a9e09c78b36957f467dc	a decentralized model-based diagnostic tool for complex systems	model based reasoning;diagnostic tool;model based diagnosis;model based reasoning discrete event systems diagnostic reasoning;decentralized approach decentralized model based diagnostic tool complex discrete event systems model based diagnosis approaches global model;discrete event system;complex system;telecommunication computing discrete event systems merging electronic switching systems fault diagnosis computer networks proposals condition monitoring diagnostic expert systems project management;discrete event systems;diagnostic reasoning;telecommunication networks	We address the problem of diagnosing complex discreteevent systems such as telecommunication networks 1. Given a flow of observations from the system, the goal is to explain those observations by identifying and localizing pos sible faults. Several model-based diagnosis approaches deal with this problem but they need the computation of a global model which is not feasible for complex systems like telecommunication networks. Our contribution is the proposal of a decentralized approach which permits to carry out an on-line diagnosis without computing the global model. This paper describes the implementation of a tool based on this approach. Given a decentralized model of the system and a flow of observations, the program analyzes the flow and computes the diagnosis in a decentralized way. We also present experimental results based on a real system.	algorithm;complex systems;composer;computation;decentralised system;interaction;internationalization and localization;microsoft windows;online and offline;real-time operating system;requirement	Yannick Pencolé;Marie-Odile Cordier;Laurence Rozé	2001		10.1109/ICTAI.2001.974453	complex systems;real-time computing;simulation;computer science;artificial intelligence;model-based reasoning	AI	-36.19445847429377	35.583575844470126	64228
639276bcde9f8296fb2f7f3fc5e6f429ae68337c	managing runtime adaptivity through active rules: the bellerofonte framework	adaptive web applications;context awareness;context aware web applications;eca rules;adaptivity;eca web	Modern Web development is more and more moving towards the production of fullfledged, complex Web applications, possibly equipped with active and/or adaptive behaviors. On the one side, this evolution implies higher development costs and times; on the other side, such implications are contrasted by the dynamics of the modern Web, which demands for even faster application development and evolution cycles. In this paper we focus on the above problem, considering adaptive Web applications. We defined an Event-Condition-Action (ECA) rule-based approach aimed at facilitating the management and evolution of adaptive application features and we developed an engine, namely Bellerofonte, to process ECA rules. In our approach, we decouple the active logic (i.e. the adaptivity rules) from the execution of the actual application by means of a decoupled rule engine capturing events and autonomously enacting the adaptivity actions.	business rules engine;event condition action;logic programming;web application;web development	Florian Daniel;Maristella Matera;Giuseppe Pozzi	2008	J. Web Eng.		web modeling;real-time computing;simulation;engineering;knowledge management	Web+IR	-41.59369466292801	41.86102332020192	64410
61af41f6be4e1f565f6ed570409c5679a2c0990c	networked vehicles for automated fault detection	vehicle condition;radio networks;automotive engineering;automated fault detection software;mechatronic system;vehicle condition networked vehicles automated fault detection software mechatronic system wireless communication consensus self organized modeling methodology backoffice server;sensors;application software;availability;prior information;software fault tolerance;telecommunication computing;data mining;backoffice server;wireless communication;network servers;engineering and technology;computational modeling;teknik och teknologier;monitoring;compact representation;traffic engineering computing data mining network servers radio networks software fault tolerance telecommunication computing;fault detection;networked vehicles;self organization;traffic engineering computing;vehicles fault detection mechatronics automotive engineering hardware availability wireless communication application software monitoring costs;vehicles;atmospheric modeling;modeling methodology;mechatronics;mechatronic systems;consensus self organized modeling methodology;data models;hardware	Creating fault detection software for complex mechatronic systems (e.g. modern vehicles) is costly both in terms of engineer time and hardware resources. With the availability of wireless communication in vehicles, information can be transmitted from vehicles to allow historical or fleet comparisons. New networked applications can be created that, e.g., monitor if the behavior of a certain system in a vehicle deviates compared to the system behavior observed in a fleet. This allows a new approach to fault detection that can help reduce development costs of fault detection software and create vehicle individual service planning. The COSMO (COnsensus Self-organized MOdeling) methodology described in this paper creates a compact representation of the data observed for a subsystem or component in a vehicle. A representation that can be sent to a server in a backoffice and compared to similar representations for other vehicles. The backoffice server can collect representations from a single vehicle over time or from a fleet of vehicles to define a norm of the vehicle condition. The vehicle condition can then be monitored, looking for deviations from the norm. The method is demonstrated for measurements made on a real truck driven in varied conditions with ten different generated faults. The proposed method is able to detect all cases without prior information on what a fault looks like or which signals to use.	fault detection and isolation;mechatronics;server (computing)	Stefan Byttner;Thorsteinn S. Rögnvaldsson;Magnus Svensson;George Bitar;Wesley Chominsky	2009	2009 IEEE International Symposium on Circuits and Systems	10.1109/ISCAS.2009.5117980	embedded system;data modeling;availability;atmospheric model;application software;real-time computing;self-organization;simulation;mechatronics;vehicle tracking system;computer science;engineering;sensor;operating system;computational model;fault detection and isolation;software fault tolerance;wireless	Robotics	-36.05761465653502	37.26568969371377	64598
d4e083b47f000d48df67d8a901c0fbc36751358d	the design of an autonomic controller for self-managed emergency departments		Improving the operational efficiency of an Emergency Department (ED) is a complex task due the very large number of ED configurations that involve human and physical resources and due to the unpredictable nature of the ED’s workload. Thus, managing the performance of EDs becomes difficult and expensive when carried out by human beings alone. A new approach, called self-managed EDs, consists of building into the ED the mechanisms required to self-adjust the ED’s configuration parameters so that its Quality of Service (QoS) is constantly met. This paper presents the design of an autonomic controller for a self-managed Emergency Department and evaluates its effectiveness in maximizing a utility function of the ED subject to cost-constraints. The controller uses a combination of combinatorial search techniques with simulation models. Experimental results illustrate the operation of the controller and how it reacts to variations of patient interarrival times.	autonomic computing;combinatorial search;quality of service;simulation;utility	Serene Almomen;Daniel A. Menascé	2012			emergency department;reliability engineering;simulation modeling;data mining;workload;quality of service;operational efficiency;combinatorial search;computer science;control theory;computer security	AI	-43.73458981979443	38.45785388380121	64725
2e3e8b35c65d792c13ab5e00ddc513797e690094	submission of transactions from mobile workstations in a cooperative multidatabase processing environment	workstations mobile computing distributed computing computer networks telecommunication computing distributed processing application software environmental management portable computers database systems;protocols;groupware;global transaction completion;transaction management;multidatabase system;application software;distributed processing;distributed computing;data exchange;mobile computer;telecommunication computing;transaction subqueues;computer networks;mobile workstations;processing independence transaction submission mobile workstations cooperative multidatabase processing environment mobile computers global transaction completion network disconnection architectural framework transaction management message and queuing facility communication protocol data exchange protocol transaction subqueues processing parallelism;message and queuing facility;data exchange protocol;portable computers;workstations;processing independence;database systems;distributed databases;architectural framework;electronic data interchange groupware distributed databases executive workstations portable computers transaction processing protocols;processing parallelism;communication protocol;executive workstations;transaction processing;mobile computing;cooperative multidatabase processing environment;environmental management;electronic data interchange;transaction submission;mobile computers;network disconnection	In a multidatabase environment with mobile computers involved, the nature of computing is such that the user may not wait for the submitted global transaction to complete before disconnecting from the network. In this paper, a basic architectural framework to support transaction management in multidatabase systems is proposed and discussed. A simple Message and Queuing Facility is suggested which provides a common communication and data exchange protocol to effectively manage global transactions submitted by mobile workstations (MWS). The state of global transactions is modelled through the use of transaction sub-queues. The proposed strategy allows an MWS to submit global transactions and then disconnect itself from the network to perform some other tasks thereby increasing processing parallelism and independence.	autonomous robot;component-based software engineering;computer;distributed transaction;enterprise architecture framework;entity;heterogeneous database system;host (network);mobile computing;operating environment;parallel computing;prototype;requirement;stationary process;workstation	L. H. Yeo;Arkady B. Zaslavsky	1994		10.1109/ICDCS.1994.302439	communications protocol;real-time computing;distributed transaction;computer science;operating system;database;distributed computing;online transaction processing;mobile computing;computer network	DB	-34.09309166676469	45.47337327583541	64789
6f7d16a3ac5b6aaa01d39cc3a22bf548331e9173	an algebra-based reliability prediction approach for composite web services	software;algebraic specification;reliability engineering;reliability prediction semantics;composite web service;reliability;owl s;service composition;web service discovery;component based systems;maude;web services algebraic specification knowledge representation languages object oriented programming software architecture software reliability;object oriented programming;web service;component based software;algebra based reliability prediction approach;web service composition;software requirement;knowledge representation languages;software architecture;algebra;owl s specification;web services software architecture logic software reliability reliability engineering computer network reliability process control probability density function systems engineering and theory computer science;rewrite logic;rewriting logic;web services;service discovery;rewrite logic reliability algebra web service owl s maude;software reliability;credit cards;software requirement algebra based reliability prediction approach composite web service component based software web service discovery web service composition software architecture owl s specification reliability prediction semantics	As the most attractive realization of component-based software, composite Web service asks a heavy demand for reliability prediction in the early stage for service discovery and service composition. Although it is believed that input should be one of the most important aspects affecting the reliability of a component-based system, research of both giving more details on an operational profile and considering software architecture to get more accurate reliability prediction is scant. This paper describes an algebra-based reliability prediction approach in three aspects: (i) a sub-set of OWL-S that provides reliability estimation information is discussed; (ii) a framework that describes syntax and reliability prediction semantics of the sub-set is explained and implemented in Maude; (iii) an example of how to use the framework to calculate reliability is studied.	component-based software engineering;maude system;owl-s;service composability principle;service discovery;software architecture;web service	Ning Huang;Xiaoguang Jia	2008	2008 19th International Symposium on Software Reliability Engineering (ISSRE)	10.1109/ISSRE.2008.40	web service;reliability engineering;computer science;software engineering;database;programming language	SE	-47.139748723573234	38.86740395963	64946
85c4a9732bbca840d29afa03f9da960d35296c8e	multicast control of mobile measurement systems	software portability;multicast communication;control systems mobile computing java software measurement internet computer architecture testing software architecture mobile agents mobile communication;virtual instrumentation;real time systems computerised instrumentation mobile communication internet software engineering;dynamic reconfiguration;transport protocols mobile computing software architecture software agents multicast communication measurement systems open systems java internet software portability virtual instrumentation;measurement systems;measurement system;mobile computer;indexing terms;software engineering;open distributed measurement system multicast control mobile measurement software architecture flexible distributed measurement m sup 3 a centres internet mobile computing actor based framework java portable systems dynamically re configurable systems;software agents;transport protocols;internet technology;software architecture;internet;data acquisition mobile measurement systems multicast mobile measurement architecture m sup 3 a architecture software architecture flexible distributed measurement systems internet technologies mobile computing multicast communication actor based framework java framework dynamically reconfigurable systems open portable system mobile agents test portability voyager;mobile communication;computerised instrumentation;mobile computing;open systems;control systems mobile computing java monitoring testing network servers software measurement software architecture internet computer architecture;java;real time systems	This paper proposes MA -Multicast Mobile Measurement Architecturea software architecture for the development of flexible distributed measurement systems. MA centres at the large level on nowadays Internet technologies such as multicast and mobile computing and at the small level on a Java and Actor-based Framework. MA allows the building of open, portable and dynamically re-configurable systems. The paper describes the architecture and exemplifies it by some examples.	actor model;experiment;java;mobile agent;mobile computing;multicast;ncr voyager;programming language;programming paradigm;prototype;real-time clock;software architecture;software portability;system of measurement	Giancarlo Fortino;Domenico Grimaldi;Libero Nigro	1998	IEEE Trans. Instrumentation and Measurement	10.1109/19.746573	embedded system;real-time computing;computer science;system of measurement;distributed computing;mobile computing	SE	-34.4373930640773	45.80697711559314	65043
3341c9ffb026f65f040750bc97b755866d83425e	microprocessors in railway signalling: the solid-state interlocking		Abstract   The paper reviews some of the techniques available to the designer of safety-critical systems and describes their application to the complex engineering requirements of main-line railway signalling, in the form of British Rail's Solid-State Interlocking (SSI). The design of central interlocking and track-side interface equipment is described in terms of the redundancy techniques used and the organization of their hardware and software.		A. H. Cribbens	1987	Microprocessors and Microsystems - Embedded Hardware Design	10.1016/0141-9331(87)90269-9	real-time computing;software;redundancy (engineering);computer engineering;solid-state;railway signalling;embedded system;fault tolerance;requirements engineering;interlocking;computer science	EDA	-35.50901007079669	36.466650126295185	65366
5ba2a2494dfec76c316e76065b49a74bec3932a6	formal design of dynamic reconfiguration protocol for cloud applications	verification;dynamic reconfiguration;distributed applications;fault tolerance;cloud computing	Cloud applications are complex applications composed of a set of interconnected software components running on different virtual machines, hosted on remote physical servers. Deploying and reconfiguring this kind of applications are very complicated tasks especially when one or multiple virtual machines fail when achieving these tasks. Hence, there is a need for protocols that can dynamically reconfigure and manage running distributed applications. In this article, we present a novel protocol, which aims at reconfiguring cloud applications. This protocol is able to ensure communication between virtual machines and resolve dependencies by exchanging messages, (dis)connecting, and starting/stopping components in a specific order. The interaction between machines is assured via a publish-subscribe messaging system. Each machine reconfigures itself in a decentralized way. The protocol supports virtual machine failures, and the reconfiguration always terminates successfully even in the presence of a finite number of failures. Due to the high degree of parallelism inherent to these applications, the protocol was specified using the LNT value-passing process algebra and verified using the model checking tools available in the CADP toolbox. The use of formal specification languages and tools helped to detect several bugs and to improve the protocol.	cloud computing;component-based software engineering;construction and analysis of distributed processes;degree of parallelism;distributed computing;formal specification;inter-process communication;model checking;parallel computing;process calculus;publish–subscribe pattern;software bug;virtual machine	Rim Abid;Gwen Salaün;Noel De Palma	2016	Sci. Comput. Program.	10.1016/j.scico.2015.12.001	embedded system;fault tolerance;real-time computing;verification;cloud computing;computer science;distributed computing;programming language	OS	-40.192611118493794	38.14575291681547	65368
9292286e9924f27c5d8e8d5d0f1f2a29c24c34a6	towards trust in desktop grid systems	databases;self organisation;trust;volunteer computing;bottom up;agent based simulation;agent based simulation desktop grid systems organic computing interconnected subsystems distributed subsystems interoperability;measurement;self organisation trust grid desktop grid volunteer computing trust metric organic computing;system configuration;interconnected systems;organic computing;distributed computing;dynamic system;runtime;system performance;systems engineering and theory;grid;computer architecture;standards development;computational modeling;interconnected systems grid computing;trust metric;communities;peer to peer computing;modeling;grid computing;grid computing computer architecture distributed computing systems engineering and theory cloud computing modeling system performance standards development hardware embedded software;grid system;desktop grid;embedded software;cloud computing;hardware	The Organic Computing (OC) Initiative deals with technical systems, that consist of a large number of distributed and highly interconnected subsystems. In such systems, it is impossible for a designer to foresee all possible system configurations and to plan an appropriate system behaviour completely at design time. The aim is to endow such technical systems with the so-called self-X properties, such as self-organisation, self-configuration or self-healing. In such dynamic systems, trust is an important prerequisite to enable the usage of Organic Computing systems and algorithms in market-ready products in the future. The OC-Trust project aims at introducing trust mechanisms to improve and assure the interoperability of subsystems. In this paper, we deal with aspects of organic systems regarding trustworthiness on the subsystem level (agents) in a desktop grid system. We develop an agent-based simulation of a desktop grid to show, that the introduction of trust concepts improves the system's performance, in such that they speed up the processes on the agent level. Specifically, we investigate a bottom-up self-organised development of trust structures that create coalition groups of agents that work more efficiently than standard algorithms. Here, an agent can determine individually to what extent it belongs to a Trusted Community.	agent-based model;agent-based social simulation;algorithm;bottom-up parsing;computational trust;desktop computer;dynamical system;interoperability;organic computing;self-organization;trust (emotion)	Yvonne Bernard;Lukas Klejnowski;Jörg Hähner;Christian Müller-Schloer	2010	2010 10th IEEE/ACM International Conference on Cluster, Cloud and Grid Computing	10.1109/CCGRID.2010.73	real-time computing;systems modeling;embedded software;cloud computing;computer science;theoretical computer science;operating system;dynamical system;top-down and bottom-up design;database;distributed computing;computer performance;trustworthy computing;grid;computational model;computational trust;grid computing;measurement	HPC	-43.9369092460758	40.1877814217441	65531
125146315cf01d84286c563107c4e537544d25a1	structural specification for the slas in cloud computing (s3lacc)		Cloud service providers generally offer service level agreements (SLAs) in descriptive format which is not directly consumable by a machine/system. The SLA written in natural language may impede the utility of rapid elasticity in a cloud service. Automation of different phases of the SLA life cycle (e.g. negotiation, monitoring and management) is also dependent on the availability of a machine readable SLA. In this work, we propose a Structural Specification for the SLAs in Cloud Computing (S3LACC) for the automation of complete SLA life cycle i.e. negotiation, monitoring, management and recycling. S3LACC is specifically designed for cloud domain to meet latest standards and complex requirements of the cloud services such as service composition, dynamic negotiations, automated monitoring and formalization of qualitative parameters. Additionally, S3LACC defines a single SLA structure to be used as an SLA template and as a final agreement as well.	cloud computing	Waheed Aslam Ghumman;Alexander Schill	2016		10.1007/978-3-319-61920-0_4	computer science;automation;real-time computing;elasticity (economics);database;service-level agreement;natural language;cloud computing;service level	HPC	-47.13868642683583	43.41761039587466	65606
3d8090d6daf6540fc6706440db4811e258541567	analytic real-time analysis and timed automata: a hybrid method for analyzing embedded real-time systems	real time;embedded real time systems;state dependence;embedded system;performance metric;hybrid approach;formal verification;hybrid method;hard real time system;performance analysis;real time calculus;development methodology;timed automata;model of computation;coarse grained;compositional analysis;state space explosion;analytical model;hard real time systems	This paper advocates a strict compositional and hybrid approach for obtaining key (performance) metrics of embedded systems. At its core the developed methodology abstracts system components by either flow-oriented and purely analytic descriptions or by state-based models in the form of timed automata. The interaction among the heterogeneous components is modeled by streams of discrete activity-triggers. In total this yields a hybrid framework for the compositional analysis of embedded systems. It supplements contemporary techniques for the following reasons: (a) state space explosion as intrinsic to formal verification is limited to the level of isolated components; (b) computed performance metrics such as buffer sizes, delays and utilization rates are not overly pessimistic, because coarse-grained purely analytic models are used for components only which conform to the stateless model of computation. For demonstrating the usefulness of the presented ideas we implemented a corresponding tool-chain and investigated the performance of a two-staged computing system, where one stage exhibits state-dependent behavior only coarsely coverable by a purely analytic and stateless component abstraction.	automata theory;embedded system;emoticon;formal verification;html5 in mobile devices;model of computation;real-time clock;real-time computing;state space;stateless protocol;timed automaton;toolchain	Kai Lampka;Simon Perathoner;Lothar Thiele	2009		10.1145/1629335.1629351	model of computation;embedded system;real-time computing;formal verification;computer science;theoretical computer science;operating system;distributed computing;programming language	Embedded	-38.69348118618969	32.64611466304117	65833
4e5bedd10a75dbb87386f81e9bb80092c75da090	tanc: towards autonomic network connectivity: guidelines for extending the network & it infrastructure at the edge		Thanks to virtualization, network operators are opening their network u0026 IT infrastructure and offering network u0026 IT Cloud services. Soon after this trend spreads within endusers devices, the edge will be able to instantiate virtual resources on-the-fly, share connectivity, computing and storage resources with edge devices or even be integrated as fully part of the infrastructure. In this article, we provide architectural guidelines and depict the typical phases required for enabling this extension at the edge. After having defined the concepts of resource node and domain, we present the Resource Discovery, Domain Orchestration, Resource Federation and Domain Supervision phases. The actions required to fulfill the phases are highlighted. An illustrating example and running proof-of-concept named TANC: Towards Autonomic Network Connectivity is depicted. This demonstration shows how edge resource nodes can firstly be embedded in the network u0026 IT infrastructure, before being dynamically specialized and modelled depending on the instantaneous needs. In particular, software components are dynamically fetched from a component repository. Furthermore, before specialization, the resource nodes cannot be distinguished one from the other, just like a stem cell is firstly generic before becoming a specific cell. Our work is a first step towards the marking out of edge usages, which are currently drastically evolving.	autonomic computing;autonomic networking;component-based software engineering;embedded system;enterprise resource planning;item unique identification;partial template specialization;platform as a service	Nathalie Omnès;Karine Guillouard;Meryem Ouzzif;Roland Picard;Pierrick Seite	2018	2018 21st Conference on Innovation in Clouds, Internet and Networks and Workshops (ICIN)	10.1109/ICIN.2018.8401607	virtualization;edge device;operator (computer programming);component-based software engineering;orchestration (computing);information technology management;cloud computing;computer science;server;distributed computing	HPC	-40.519668829586415	41.60701999991877	65881
41432969dbc85eaa7cdcb243a73f2d3493d2c4b7	an automated software verification tool for model-based development of embedded systems with simulink®	automated testing;libraries;control application;software;black box testing strategy;mathematics computing;software in the loop sil;software verification;real time;model in the loop test;matlab simulink software in the loop sil model in the loop mil hardware in the loop hil software verification programmable logical controler plc;testing;program verification;data mining;software in the loop;real time workshop;embedded system;programmable logical controler plc;embedded systems;graphical user interfaces;program testing;hardware in the loop;automated software verification tool;mathematical model;model based development;software tools embedded systems mathematics computing program testing program verification;software tools;model test;matlab simulink;model in the loop test automated software verification tool model based development embedded systems matlab simulink black box testing strategy software in the loop real time workshop;model in the loop mil;programmable logic;embedded software software tools embedded system mathematical model automatic testing software testing automatic control application software algorithm design and analysis software performance;hardware in the loop hil;algorithm design;buildings	This paper describes the implementation of an automated test tool developed in Matlabreg/Simulinkreg environment that supports model testing and software verification in model-based development of control applications. This tool based on `black box' testing strategy serves on the one hand to check the ldquosemanticrdquo or ldquofunctionalrdquo correctness (SiL: software-in-the-loop) of automatically with RTW (real time workshopreg) generated C-code for algorithms designed and modelled in Simulinkreg and on the other hand to compare the obtained results with the results of the simultaneously running model-in-the-loop test (MiL). The aim behind this tool is to develop reliable software that fulfils system requirements, assure quality and can perform satisfactorily in the intended deployment environment.	algorithm;black box;black-box testing;correctness (computer science);deployment environment;embedded system;model-driven engineering;requirement;simulink;software deployment;software release life cycle;software verification;system requirements;test automation	Josef Börcsök;Walid Chaaban;Michael H. Schwarz;Huiyun Sheng;Oleksandr Sheleh;Batsuren Batchuluun	2009	2009 XXII International Symposium on Information, Communication and Automation Technologies	10.1109/ICAT.2009.5348445	embedded system;real-time computing;computer science;computer engineering	Embedded	-46.532355370768464	34.08972793660818	65965
7edc0e2ddf8f2b8c94294f15bed6d96d15e83e95	model checking for sentient computing: an axiomatic approach		Sentient Computing allows applications to best interact with their physical environment, by becoming aware of their surroundings. Awareness is achieved by means of a sensor infrastructure that helps maintain a model that represents the current state of the dynamically changing world. This model can be seen as a concrete interpretation of the physical environment and conceptually stands between the physical world and the abstract view of applications. A number of factors such as the non-homogeneity of physical space and the precision of the sensor technology may introduce errors and inconsistencies between the physical world and the model. On the other hand, the abstract view of the application domain needs to be correct and compatible with the concrete model, especially in the case of distributed, heterogeneous environments where applications need to interact seamlessly with several different concrete models. The contribution of the work described in this paper is that it looks at the above problem as a constraint-satisfaction problem to which it applies classical, logical satisfiability, in order to produce a model-based solution. Our system is similar to a classical model-checker ; it checks the satisfiability of the application requirements against the world model, as well as the consistency of the world model with the properties of the actual physical environment. Because it is model-based, it is appropriate for distributed, heterogenous environments. Our system forms part of SCAFOS, a generic, distributed middleware framework for contextawareness, implemented in the first author’s PhD dissertation. An implementation that uses the theorem prover system SPASS, is also discussed in this paper.	application domain;automated theorem proving;awareness;constraint satisfaction problem;middleware;model checking;requirement;spass;sensor;sentience;sentient computing	Eleftheria Katsiri;Alan Mycroft	2005			theoretical computer science;model checking;sentient computing;axiomatic system;computer science;distributed computing	PL	-37.89073964566934	35.74375541219001	66018
acaae1c564b3d07ebceec07773a64c8a1f65d81f	an architecture for virtual worlds	virtual worlds	This paper presents a system architecture for creating interactive, multisensory, three-dimensional environments called virtual worlds. The architecture specifically addresses the requirements of virtual worlds for high performance, flexibility, and coordination of concurrent events. Performance is enhanced by a distributed client/server system structure and by efficient overlap of processing time and input/output delay. All processes communicate via asynchronous messages. The functional partitioning of a virtual world requires relatively low bandwidth among the individual processes and the system can be implemented over a conventional local-area network. A key element of this architecture is a central, event-driven dialogue manager that coordinates concurrent input and output events. The dialogue manager provides a clear separation of the interaction techniques from the content of the virtual world as defined by the application. The system is flexible and easily reconfigurable. An interaction technique can be readily changed or replaced because each interaction device is modularized into a separate server and each interaction modality into a separate subdialogue. Subdialogues can be loaded and dropped dynamically, enabling input/output device remapping and the selection of interaction techniques while a virtual world is running. As an initial test of this architecture we have implemented a virtual world for interacting with data from a computational fluid dynamics simulation.	asynchronous i/o;client–server model;computational fluid dynamics;dialog system;event-driven programming;input/output;interaction technique;modality (human–computer interaction);output device;reconfigurable computing;requirement;server (computing);simulation;systems architecture;virtual world	Perry A. Appino;J. Bryan Lewis;Lawrence Koved;Daniel T. Ling;David A. Rabenhorst;Christopher F. Codella	1992	Presence: Teleoperators & Virtual Environments	10.1162/pres.1992.1.1.1	real-time computing;simulation;computer science;operating system;metaverse;distributed computing	HPC	-37.231408169053566	41.014330388246904	66087
0817cde8d4587e40389b6e62457b259c27facce9	hermes: a software architecture for visibility and control in wireless sensor network deployments	application development;software architecture wireless sensor networks application software software prototyping software design lighting control software tools runtime computer architecture system testing;deployed sensor network application debugging;deployed sensor network application testing;sos;performance evaluation;resource policing;sensor operating system;resource allocation;software design reliability;network operating systems;telecommunication control;telecommunication computing;wireless sensor network control;object oriented programming;sensor network;software components;wireless sensor network;software architecture;telecommunication traffic;network traffic shaping;transparent software updates;visibility;sensor networks;network traffic;interposition;sos sensor networks software reliability interposition visibility control;software component;wireless sensor networks network operating systems object oriented programming resource allocation software architecture software reliability telecommunication computing telecommunication control telecommunication traffic;sensor nodes;control;software reliability;wireless sensor networks;hermes;resource policing hermes software architecture wireless sensor network control software design reliability software components sensor operating system sensor nodes deployed sensor network application debugging deployed sensor network application testing transparent software updates network traffic shaping	Designing reliable software for sensor networks is challenging because application developers have little visibility into, and understanding of, the post-deployment behaviorof code executing on resource constrained nodes in remoteand ill-reproducible environments. To address this problem,this paper presents HERMES, a lightweight framework and prototype tool that provides fine-grained visibility and control of a sensor node’s software at run-time. HERMES’sarchitecture is based on the notion of interposition, which enables it to provide these properties in a minimally intrusive manner, without requiring any modification to software applications being observed and controlled. HERMES providesa general, extensible, and easy-to-use framework forspecifying which software components to observe and controlas well as when and how this observation and control is done. We have implemented and tested a fully functional prototype of HERMES for the SOS sensor operating system. Our performance evaluation, using real sensor nodesas well as cycle-accurate simulation, shows that HERMES successfully achieves its objective of providing fine-grained and dynamic visibility and control without incurring significant resource overheads. We demonstrate the utility and flexibility of HERMES by using our prototype to design, implement,and evaluate three case-studies: debugging and testing deployed sensor network applications, performing transparent software updates in sensor nodes, and implementingnetwork traffic shaping and resource policing.	component-based software engineering;debugging;emulator;noise shaping;operating system;patch (computing);performance evaluation;prototype;sensor node;simulation;software architecture;software deployment;software development;traffic shaping	Nupur Kothari;Kiran Nagaraja;Vijay Raghunathan;Florin Sultan;Srimat T. Chakradhar	2008	2008 International Conference on Information Processing in Sensor Networks (ipsn 2008)	10.1109/IPSN.2008.61	embedded system;real-time computing;wireless sensor network;computer science;operating system;computer network	Mobile	-36.903117805874246	45.044771101374344	66184
4a46e6edd12d36de17889fa348fba035ff06a4d4	relspec: a framework for reliability aware design of component based embedded systems		With the increase in the complexity of safety-critical embedded applications, the reliability analysis of such systems have also become increasingly difficult. For such complex system specifications, if the reliability provisions are declared upfront in the design flow then the overall system level reliability can be easily inferred given that the system components satisfy their individual reliability requirements. Moreover, such an early-stage specification and analysis paves newer and scalable ways for synthesis of reliable systems. This paper develops a reliability specification and analysis framework, RELSPEC, which enables system level reliability analysis at an early-stage of design by leveraging automatically constructed intermediate probabilistic models of the system. In addition to this, we provide a mechanized method of system synthesis with the objective of satisfying a target reliability value for the overall system. To this end, we explore the application of existing optimization methods and also provide domain specific techniques which outperform such existing methods. Experiments over a few automotive case-studies show the efficacy of this methodology.	complex system;embedded system;experiment;mathematical optimization;requirement;scalability	Saurav Kumar Ghosh;P. Vishnuvardhan;Satya Gautam Vadlamudi;Aritra Hazra;Soumyajit Dey;P. P. Chakrabarti	2017	Design Autom. for Emb. Sys.	10.1007/s10617-017-9183-y	reliability engineering;embedded system;real-time computing	EDA	-42.69256713909665	34.44733601510839	66846
147ed9f73bff0513be17a6026cad14dea68186f7	palm: easing the burden of analytical performance modeling	application modeling;palm;model development;annotation languages	Analytical (predictive) application performance models are critical for diagnosing performance-limiting resources, optimizing systems, and designing machines. Creating models, however, is difficult because they must be both accurate and concise. To ease the burden of performance modeling, we developed Palm (Performance and Architecture Lab Modeling tool), a modeling tool that combines top-down (human-provided) semantic insight with bottom-up static and dynamic analysis. First, Palm provides a source code modeling annotation language for abstracting or expressing complexity. Second, Palm generates hierarchical models according to well-defined rules. Since a model's hierarchy is defined by static and dynamic source code structure, there is a link between a program's organization and its model. By coordinating models and source code, Palm's models are 'first-class' and reproducible. Third, Palm incorporates measurements to focus attention, represent constant behavior, and validate models. We discuss generating models for three different applications.	analytical performance modeling;bayesian network;bottom-up proteomics;palm os;performance prediction;top-down and bottom-up design	Nathan R. Tallent;Adolfy Hoisie	2014		10.1145/2597652.2597683	palm;simulation;artificial intelligence;data mining	SE	-43.632527710526695	34.24838290879187	66922
e48e3312b5fcd641ab82bcd03b76495e811ad508	on benchmarking the dependability of automotive engine control applications	automotive electronics;mechanical engineering computing;generic model;engine control;embedded systems;internal combustion engines;automotive engineering engines control systems;automotive components;mechanical engineering computing control engineering computing internal combustion engines automotive electronics automotive components embedded systems benchmark testing;cost effectiveness;control engineering computing;electronic control unit;commercial off the shelf dependability benchmarking automotive engine control electronic control units automotive systems vehicle engines control software;benchmark testing	The pervasive use of ECUs (electronic control units) in automotive systems motivates the interest of the community in methodologies for quantifying their dependability in a reproducible and cost-effective way. Although the core of modern vehicle engines is managed by the control software embedded in engine ECUs, no practical approach has been proposed so far to characterise the impact of faults on the behaviour of this software. This paper proposes a dependability benchmark for engine control applications. The essential features of such type of applications are first captured in a general model, which is then exploited in order to specify a standard procedure to assess dependability measures. These measures are defined taking into account the expectations of industrials purchasing engine ECUs with integration purposes. The benchmark also considers the current set of technological limitations that the manufacturing of modern engine ECUs imposes to the experimental process. The approach is exemplified on two engine control applications.	benchmark (computing);dependability;embedded system;purchasing	Juan-Carlos Ruiz-Garcia;Pedro Yuste;Pedro J. Gil;Lenin Lemus	2004	International Conference on Dependable Systems and Networks, 2004	10.1109/DSN.2004.1311956	embedded system;benchmark;electronic control unit;cost-effectiveness analysis;computer science;automotive engineering	Embedded	-43.47025250448736	35.429015112174014	67026
fe65724d56e55fdf2893366a533678db2301ca6e	abstractions to support interactions between self-managed cells	body area network;architectural pattern	Management of pervasive systems cannot rely on human intervention nor centralised decision-making functions due to their complex and intrinsically mobile nature. In previous work, we proposed the concept of a self-managed cell (SMC) as an architectural pattern for building ubiquitous applications. A SMC consists of hardware and software components that form an autonomous administrative domain. SMCs may be realised at different scales, from body-area networks, to an entire room or larger settings. However, to scale to larger systems it is necessary for SMCs to collaborate with each other, to federate or compose in larger SMC structures. We describe here the main abstractions we have defined and explore future directions towards this goal.	interaction	Alberto E. Schaeffer Filho;Emil C. Lupu	2007			real-time computing;simulation;architectural pattern;computer science;operating system;body area network;database;computer security	SE	-39.19467558547962	44.02707313434606	67241
b2cda6fc3f17ca9cd7ae99bfea70e0c2099547ed	consistent design of embedded real-time systems with uml-rt	design model;real time constraints;timing constraints;design engineering;sequence diagrams;processor allocation;processor scheduling;real time consistency;real time;diagram types;real time systems object oriented modeling timing processor scheduling embedded software unified modeling language software engineering software design productivity design engineering;embedded real time systems;uml rt;diagrams;object oriented programming;schedulability analysis;software engineering;statechart diagrams;embedded systems;consistency model;worst case execution time;specification languages;scheduling;consistency concept;unified modeling language;system components;embedded real time systems design;worst case execution time analysis;processor scheduling embedded systems object oriented programming specification languages diagrams;productivity;software design;schedulability analysis embedded real time systems design uml rt design model sequence diagrams system components real time constraints statechart diagrams consistent model consistency concept diagram types timing constraints real time consistency processor allocation scheduling worst case execution time analysis;sequence diagram;object oriented modeling;consistent model;embedded software;real time systems;timing;time constraint	Modeling embedded real-time systems consisting of different components with UML-RT leads to a design model using various diagrams. Sequence diagrams describe possible interactions between system components and may be annotated with specific real-time constraints. Statechart diagrams are used for describing each component’s behavior. In order to be able to get a consistent model, a consistency concept for different diagram types is needed that takes into account real-time constraints. In this paper, a consistency concept for sequence diagrams and statechart diagrams is presented which focuses on the establishment of timing constraints. Our consistency concept distinguishes between syntactical, semantic and real-time consistency and takes into account the influence of processor allocation and scheduling. Using the consistency concept we describe a method for ensuring the consistency based on worst case execution time analysis of statecharts and schedulability analysis of tasks, thereby enabling a precise answer of the question of consistency.	best, worst and average case;embedded system;interaction;real-time clock;real-time computing;real-time operating system;run time (program lifecycle phase);scheduling (computing);scheduling analysis real-time systems;sequence diagram;state diagram;time consistency;uml tool;unified modeling language;worst-case execution time	Jochen Malte Küster;Joachim Stroop	2001		10.1109/ISORC.2001.922815	sequence diagram;parallel computing;real-time computing;computer science;consistency model;operating system;software engineering;programming language;sequential consistency;local consistency	Embedded	-39.46959415363269	33.427053764231104	67270
4d801dc439bc5c4aab6e384f94d904acdec9b3c8	a semantic framework to support resource discovery in future cloud markets	resource discovery;cloud markets;service level agreements;cloud resources;cloud ontology;supply demand matching;cloud pricing models;quality of service;semantic discovery;semantic models;sla negotiation capabilities;qos levels;cloud computing	The market of cloud resources is currently dominated by proprietary solutions for what concerns resource delivering, pricing models and service level agreements. In the future cloud markets, when cloud standards will get mature and full interoperability among cloud systems will be a reality, the competition challenge among providers will be played on the capability of supplying high and differentiated QoS levels. In this new scenario advanced and flexible mechanisms to support the matchmaking between what providers offer and what customers demand must be devised. Along with an analysis of the current cloud offering in terms of pricing model, SLA negotiation capabilities, service performance levels and cloud application requirements, this work proposes the definition of a semantic model to support the supply-demand matchmaking process in future cloud markets. Leveraging on a semantic description of the cloud resources' features, customers will be able to discover cloud offers that best suit their own business needs. Tests conducted on an implementation prototype proved the viability of the approach.		Giuseppe Di Modica;Orazio Tomarchio	2015	IJCSE	10.1504/IJCSE.2015.067054	cloud computing security;quality of service;cloud computing;computer science;operating system;database;world wide web	Mobile	-47.1242044835687	43.91425822857709	67328
b2d66af76aaad32a2109cbd1a4fde7ea72007c25	aspect-oriented programming for web controller layer	biomedical monitoring;session management;page transitions;page requests;web pages;history;domain specific aspect oriented programming;web pages prototypes software engineering informatics access control programming profession logic html scattering java;web controller layer;prototypes;session management events;object oriented programming;servers;internet;web application development aspect oriented programming;aspect oriented programming;crosscutting concerns;access control;web application development;web specific events;programming;performance tuning;object oriented programming internet;domain specificity;java;session management events web controller layer domain specific aspect oriented programming crosscutting concerns web specific events page requests page transitions	We propose a new domain-specific aspect-oriented programming (AOP) mechanism for Web application development. A variety of crosscutting concerns such as access control and performance tuning are found in typical Web applications, but it is not easy to concisely modularize the concerns as aspects in current AOP languages because they do not provide pointcut mechanisms for directly handling events in the Web controller layer. To deal with this problem, we propose a Web-specific AOP mechanism called AOWP and a PHP-based AOWP framework. Using this framework, a programmer can easily address Web-specific crosscutting concerns triggered by Web-specific events, including page requests, page transitions, and session management events.	access control;aspect-oriented programming;cross-cutting concern;load balancing (computing);php;performance tuning;pointcut;programmer;session (computer science);web application development	Keiji Hokamura;Naoyasu Ubayashi;Shin Nakajima;Akihito Iwai	2008	2008 15th Asia-Pacific Software Engineering Conference	10.1109/APSEC.2008.69	programming;the internet;aspect-oriented programming;computer science;access control;software engineering;web page;database;prototype;programming language;object-oriented programming;web application development;java;world wide web;server	SE	-35.85888748174467	41.60964465137858	67478
f109531c5de1710f6cf39e49c71af1b682d4de79	a case study of self-adaptive software in the dynamic reconfiguration of it ecosystem	software fault tolerance cloud computing program assemblers scheduling;software;it ecosystem;dynamic reconfiguration;self adaptive software dynamic reconfiguration it ecosystem;collaboration;self adaptive software environmental change o mase assembly system environments paradigm shift system operation paradigm shift cloud computing iot it ecosystem dynamic reconfiguration;roads;ecosystems;self adaptive software;ecosystems software modeling roads adaptation models collaboration;adaptation models;modeling	As new technologies such as IoT, Cloud Computing appeared, the paradigm shift of system operation is occurring. Many researches that see a system as a group of systems like IT Ecosystem is being going on according to the paradigm shift. In addition, the research of Self-adaptive software to fulfill the users' goal and expectation is progressed. The existing Self-adaptive Software proposes ways to control various environments for a system to adapt to the environment change. However, it does not propose ways to control the system in Assembly system environments. A meta model in the base of O-MaSE which changes the system operating according to the changing environment was proposed to solve this problem. This paper proposed optimum scheduling scenario of environmental change to verify the expandability of the proposed model, and verified the proposed scenario by applying it to the meta model.	autonomous robot;cloud computing;ecosystem;emergence;metamodeling;metaobject;plan 9 from bell labs;programming paradigm;scheduling (computing)	Seungmin Lee;Young B. Park;Soojin Park	2016	2016 International Conference on Big Data and Smart Computing (BigComp)	10.1109/BIGCOMP.2016.7425982	real-time computing;simulation;systems engineering;engineering;component-based software engineering;software development;resource-oriented architecture;software deployment	SE	-41.93974784500955	40.14728423067108	67710
2195473a9bfb204622af16b76208fe6b59ba8f11	adaptability metric for adaptation of the dynamic changes		Adapting dynamic changes in the user needs or in the environment is considered as one of the important quality attributes of a system in the pervasive or ubiquitous environment. An aspect-oriented framework to modularize the dynamic changes using aspects is considered as a solution for creating dynamic adaptable systems. This framework allows the system to reflect the dynamic changes on the associated components through aspects without altering the structure of the components. For evaluating the adaptability of this framework, a new adaptability metric has been proposed using the principles of coupling. In this work, coupling is defined as a Conceptual coupling between Aspects and Classes (CBAC), which represents the semantic association between the aspects that are used to represent dynamic changes and the components that are associated with the dynamic changes at the architecture level. The adaptable efficiency of the system that is the ability of reflecting the dynamic changes on the components associated with those changes is measured using the proposed conceptual coupling metric. Based on the measures it is concluded that adaptability efficiency of the system is increased with increasing the coupling between the aspect and the components. The proposed CBAC metric is evaluated and demonstrated by measuring the adaptability of the dynamic changes in the requirements of the various software systems.	aspect-oriented software development;context-based access control;coupling (computer programming);definition;list of system quality attributes;middleware;pervasive informatics;programming paradigm;reflection (computer graphics);requirement;software metric;software system	Subbian Suganthi;Rethanaswamy Nadarajan	2015	Int. Arab J. Inf. Technol.		artificial intelligence;adaptability;architecture;machine learning;software system;computer science	SE	-41.900145430087115	40.955665381741106	67762
22bf4d8f7358ff98f18aa84fb21c65b57ebeba3f	formal verification of mixed synchronous asynchronous systems using industrial tools		Asynchronous circuits are pervasive in modern synchronous systems, but they are still designed and verified in isolation, using dedicated asynchronous design flows, formalisms and tools. We describe a method to verify gate-level asynchronous circuit implementations using formal verification tools and property languages for synchronous logic. We report observations and findings from applying this method to use case designs using an industrial and an open source formal verification tools for synchronous logic, and compare performance and verification capabilities against two verification tools for asynchronous circuits. Finally, we discuss the advantages and practical considerations of bridging synchronous logic verification tools to the domain of asynchronous circuits. Our main conclusion is that, while there are performance penalties, there is still significant value in enabling users to verify asynchronous circuits using tools that may be more familiar, trusted or more widely adopted.		Ghaith Tarawneh;Andrey Mokhov	2018	2018 24th IEEE International Symposium on Asynchronous Circuits and Systems (ASYNC)	10.1109/ASYNC.2018.00022	implementation;electronic circuit;asynchronous circuit;theoretical computer science;formal verification;design flow;asynchronous communication;bridging (networking);computer science	EDA	-37.21362659603331	33.45491559631485	68429
ccef4c64c3322477e236ffb8ade6613616c4bcfe	towards an aspect oriented language compliant with real time constraints	real time systems aspect oriented programming;real time constraints;ada;aop;aspectada;real time constraints aop aspectada ada;aspect oriented programming;aspect oriented language compliant language grammar aspectada language real time systems software application aop aspect oriented programming real time constraints;weaving real time systems syntactics runtime programming grammar libraries;real time systems	The Aspect-Oriented Programming (AOP) supports the modularization of concerns that cut across the implementation of a software application to avoid scattering and tangling. We focus on the integration of aspect-oriented paradigm in the development of real-time systems. The AOP is based on the weaving process to automatically integrate segments of code created separately into the application. In the context of real-time systems, this can endanger determinism by including constructs that may violate real-time constraints beyond the control of the developer. In this paper, we study and test the AspectAda language, an existing aspect mechanism, in order to adapt and modify it to respect real-time constraints. We are interested studying this language's grammar, Runtime and especially weaving operation. Finally, we extract its limits and define our solutions to adapt it to support real time constraints.	ada;aspect-oriented programming;compiler;programming paradigm;prototype;real-time clock;real-time computing;real-time locating system;real-time transcription;runtime library	Wafa Gabsi;Rahma Bouaziz;Bechir Zalila	2013	2013 Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprises	10.1109/WETICE.2013.65	real-time computing;aspect-oriented programming;computer science;programming language;algorithm	Embedded	-33.933354430110164	34.31712478960331	69026
8a063b24ca2eea0f490640b088d1735305ae05b1	handling identification and maintenance information of intelligent field devices using web based enterprise management	maintenance engineering;intelligent field device identification information handling maintenance information handling maintenance function identification function profinet field bus system profibus it device management management protocol call device maintainer heterogeneous field buses automation system web based enterprise management;field buses;production engineering computing;distributed management task force;internet;production engineering computing automation dp management field buses internet maintenance engineering;dp management;computer integrated manufacturing object recognition protocols standards servers maintenance engineering;automation	In modern automation systems, where a large amount of devices and a set of inter-operating heterogeneous field buses exist, the management of all the devices is still done device-by-device. Complex functions like “call device maintainer after reaching a device's service hour counter” for a group of devices within the network are still missing. Common management protocols like SNMP are not suitable for realizing such commands. With the introduction of Web Based Enterprise Management (WBEM) by the Distributed Management Task Force, an extensible system for the management of IT devices has been developed. This paper describes an approach how WBEM can be used for the management of PROFIBUS and PROFINET field bus systems using PROFIBUS International's “Identification & Maintenance” functions.	bus (computing);fieldbus;profibus;simple network management protocol;wbem services specification	Roman Frenzel;Robert Lehmann;Martin Wollschlaeger	2011	ETFA2011	10.1109/ETFA.2011.6059145	maintenance engineering;embedded system;real-time computing;the internet;engineering;computerized maintenance management system;operating system;automation;computer network	OS	-35.481419371922215	39.40615737141224	69057
cca3a3a6b57c6e4612f7b51712b1efa909111ae1	an automated security-aware approach for design of embedded systems on mpsoc		MPSoC-based embedded systems design is becoming increasingly complex. Not only do we need to satisfy multiple design objectives, we increasingly need to address potential security risks. In this work, we propose a security-aware systematic design approach which explores the design space, given a system-level application description, by generating potential architecture configurations of execution platform nodes that are interconnected using a NoC. We then perform automated security analysis to check the generated configurations against designer-specified security constraints. Following the analysis, we use an automated architecture configuration refinement process to generate a list of security additions that are inserted into the initial configuration so that the security constraints are satisfied. By performing this refinement on several candidate configuration options, we can explore the trade-off between resource cost and security. In this paper, we illustrate the proposed approach using a Smart Home Control System application.	cluster analysis;control system;embedded system;mpsoc;refinement (computing);systems design	Benjamin Tan;Morteza Biglari-Abhari;Zoran A. Salcic	2017	ACM Trans. Embedded Comput. Syst.	10.1145/3126553	computer security model;architecture;real-time computing;mpsoc;security analysis;computer science;design objective;home automation;embedded system;control system	EDA	-42.596735715260955	34.71659057004045	69173
a5f28c52d6084d2a3190ce3c4bafce570e02917b	poster: model-based run-time variability resolution for robotic applications	adaptation models robots context computer architecture context modeling engines software architecture;model based approach;pres model;robots;runtime adaptation;variability resolution;model based approach variability resolution runtime adaptation;equivalence checking;fsmd model;model driven approach model based run time variability resolution robotic applications robotics run time adaptation rra	In this paper we present our ongoing work on Robotics Run-time Adaptation (RRA). RRA is a model-driven approach that addresses robotics runtime adaptation by modeling and resolving run-time variability of robotic applications.	heart rate variability;model-driven integration;robot;run time (program lifecycle phase)	Luca Gherardi;Nico Hochgeschwender	2015	2015 IEEE/ACM 37th IEEE International Conference on Software Engineering	10.1109/ICSE.2015.269	robot;real-time computing;simulation;computer science;artificial intelligence;formal equivalence checking	Robotics	-42.81104401262271	37.50731835289221	69175
754ab8d721d1e6b4a127248b29bbf9d14f49a02f	reflective object-oriented distributed system for heterogeneous multimedia environments	distributed system;application framework;distributed multimedia applications;distributed objects;object oriented;reflection model;multimedia environment;object request broker;reflective architecture model;management policy	In this paper, object-oriented techniques and concepts (e.g. object migration, inheritance, delegation) and reflection are applied to the design of a distributed system called the Reflective Object-oriented Distributed System (RODS). RODS hides object distribution and underlying platform heterogeneity to simplify the development of distributed multimedia applications. RODS has two major components: The Flexible Multimedia Object Adaptor (FMOA) and the Reflective Object Request Broker (RORB). The FMOA is an application framework of classes to facilitate the construction of distributed multimedia applications. The RORB is a CORBA Object Request Broker that integrates additional features such as smart proxies, delegation, migration, and sharing. By utilizing a reflective model, RORB allows the application programmer and the system to dynamically modify distributed object management policies.	application framework;c++;common object request broker architecture;delegation (computer security);distributed computing;distributed object;operating system;programmer;system migration	Larry T. Chen;Leslee Xu;Tatsuya Suda;Tetsuya Yamamoto;Koji Obinata	1996	Computer Communications	10.1016/S0140-3664(96)01102-4	common data representation;real-time computing;computer science;object request broker;operating system;common object request broker architecture;database;distributed computing;distributed object;object-oriented programming	PL	-34.621813294277835	43.07465812054112	69180
8c13b4c9f31b52ee104824bec347d7da18a75a08	stakecloud: stakeholder requirements communication and resource identification in the cloud	cloud service;stakeholder;formal verification cloud computing;requirements engineering;cloud resources marketplace stakeholder requirements communication resource identification cloud computing cloud service providers stakecloud community platform;requirements communication;formal verification;cloud computing communities context service oriented architecture memory;cloud service requirements communication requirements engineering cloud computing stakeholder;cloud computing	With the recent emergence of cloud computing, the number of cloud service providers is constantly increasing and consumers' needs are becoming more sophisticated. This situation leads to an evident need for methods which enable providers to correctly elicit requirements coming from very heterogeneous consumers. Moreover, consumers demand ways to find the cloud services which best meet their needs. We propose to address the issues identified by creating the StakeCloud community platform, capable of working as a cloud resources marketplace. It will allow users to input their resource needs and provide them with matching cloud services. Additionally, in case these are not met, they can be communicated as new requirements to cloud providers. Such a contribution will improve the requirements communication and resource identification in cloud systems, bridging the gap between consumers and providers.	bridging (networking);cloud computing;emergence;requirement	Irina Todoran Koitz	2012	2012 20th IEEE International Requirements Engineering Conference (RE)	10.1109/RE.2012.6345837	cloud computing security;cloud computing;computer science;knowledge management;cloud testing;requirements engineering;world wide web;computer security	HPC	-46.36602825394141	44.08108843975611	69193
ea5a3b9abd5b35437e830b3aee0a085464d0bec2	self-healing on the cloud: state-of-the-art and future challenges	fault localization;self healing fault localization cloud computing spectrumbased fault localization;spectrumbased fault localization;software fault tolerance cloud computing program debugging program testing;run time environment cloud computing software hardness development time automatic testing tool debugging tool self healing system system availability system survivability system maintainability system reliability software complexity internet spectrum based fault localization sfl algorithm;self healing;cloud computing	Despite the enhancement on software hardness induced by development-time automatic testing and debugging tools, it remains practically impossible to create fault-free applications. The research on self-healing systems emerged to enable applications to cope with unexpected events at run-time in order to maximize their availability, survivability, maintainability, and reliability, while minimizing human intervention. With the increase in software's complexity, in part triggered by the advent of the Internet and Cloud Computing, self-healing properties in applications are becoming a necessity. The main focus of this position paper is on presenting the issues that render unusable or ineffective the usage of the development-time Spectrum-based Fault Localization(SFL) algorithm in run-time environments. We concluded that, despite the issues found, it should be possible to devise an SFL algorithm for run-time environments that can also achieve the good results yielded by SFL at development-time.	algorithm;byzantine fault tolerance;categorization;cloud computing;computer performance;debugging;internet;risk management;runtime system;sensor;simulation;software bug;trustworthy computing;usability	Nuno Cardoso;Rui Abreu	2012	2012 Eighth International Conference on the Quality of Information and Communications Technology	10.1109/QUATIC.2012.54	reliability engineering;real-time computing;cloud computing;computer science;engineering;cloud testing;distributed computing;software fault tolerance	HPC	-47.094610132561755	40.02443580849582	69387
86b4d5a9ef5e7c5292b4c810db0ff2e6c33593d2	experiments with an architecture for reflective middleware	qa75 electronic computers computer science;reflective middleware	Middleware platforms have emerged as an effective answer to the requirements of open distributed processing. Existing middleware standards, however, do not fulfil important requirements of new application areas like multimedia and mobile computing, which require dynamic adaptability of the underlying platform. In our opinion, these requirements can be met by adopting an open engineering approach, allowing for inspection and adaptation of the platform's configuration. This paper presents an architecture for configurable and open middleware platforms based on computational reflection and multiple orthogonal meta-models. It also describes a first prototype, which implements the main points of the architecture and demonstrates its practicality.	middleware	Fábio M. Costa;Gordon S. Blair;Geoff Coulson	2000	Integrated Computer-Aided Engineering		embedded system;middleware;real-time computing;computer science;message oriented middleware;middleware;distributed computing	EDA	-41.125098417124796	41.79775142241518	69437
5b80156f06196aa1076231bcbbe8ffe9f351829b	towards a layered architecture for object-based execution in wide-area deeply embedded computing	middleware instantiations layered architecture object based execution wide area deeply embedded computing distributed computing network level programming languages global system abstractions general purpose communication protocols distributed real time interaction wide area communication infrastructure global sensor network architecture interoperability internet layered communication stack tcp ip stack communication interfaces programming interfaces network communication global sensor networks;object based execution;sensor systems and applications;protocols;layered architecture;network level programming languages;computer languages;layered communication stack;programming language;communication interfaces;real time;computer architecture embedded computing distributed computing protocols sensor systems and applications computer languages physics computing lan interconnection ip networks tcpip;general purpose communication protocols;tcpip;distributed computing;network communication;object oriented programming;physics computing;sensor network;lan interconnection;wireless sensor networks embedded systems middleware object oriented programming open systems protocols wide area networks;computer architecture;embedded systems;programming interfaces;tcp ip stack;internet;wide area deeply embedded computing;communication protocol;middleware;ip networks;network architecture;interoperability;middleware instantiations;global sensor network architecture;wide area communication infrastructure;open systems;distributed real time interaction;global sensor networks;wireless sensor networks;wide area networks;embedded computing;global system abstractions	Sensor networks introduce a new application domain and set of challenges in distributed computing including new network-level programming languages, global system abstractions, and general-purpose communication protocols. These challenges are brought about by the tight integration of computation, communication, and distributed real-time interaction with the physical world. With the growing interest in interconnecting different sensor networks across a wide-area communication infrastructure, an overarching challenge becomes one of arriving at an agreed-upon global sensor network architecture that ensures interoperability. Unlike the Internet, where a layered communication stack (namely, the TCP/IP stack) defines the network architecture, a sensor network architecture must unify not only communication interfaces but also programming interfaces, since network communication and computation functions are tightly intertwined. In that sense, the sensor network architecture refers to a layered stack of distributed computing abstractions. This paper presents an architecture and key considerations in designing and interconnecting local and global sensor networks. Candidate protocols and middleware instantiations are described from the authors' ongoing work that meet the discussed considerations	algorithm;application domain;communications protocol;computation;denial-of-service attack;distributed computing;embedded system;end system;end-to-end principle;general-purpose markup language;internet protocol suite;interoperability;microsoft forefront;middleware;network architecture;network congestion;programming language;real-time cmix;real-time clock;testbed;transfer function	Tarek F. Abdelzaher;Qing Cao;Raghu K. Ganti;Dan Henriksson;Mohammad Maifi Hasan Khan;Jin Heo;Chengdu Huang;Praveen Jayachandran;Hieu Khac Le;Liqian Luo;Yu-En Tsai	2007	10th IEEE International Symposium on Object and Component-Oriented Real-Time Distributed Computing (ISORC'07)	10.1109/ISORC.2007.60	sensor web;embedded system;communications protocol;real-time computing;wireless sensor network;computer science;operating system;distributed computing;key distribution in wireless sensor networks;internet protocol suite;programming language;computer network	Embedded	-36.41802357823552	45.86882096148597	69439
80d6b254bd6d400a0f09d864950acd794b017098	hera: hardware-embedded reactive agents platform		Wireless Sensor Networks is a key technology for gathering outstanding information from different sources. However, it is not easy to integrate devices from different technologies into a single network. Distributed architectures, such as Multi-Agent Systems, can facilitate the integration of heterogeneous sensor networks. In addition, Multi-Agent Systems expand the sensors’ capabilities changing their behavior dynamically and personalizing their reactions. This paper presents the novel Hardware-Embedded Reactive Agents (HERA) platform. HERA allows developing applications where agents are directly embedded in heterogeneous wireless sensor nodes with reduced computational resources.	embedded system;reactive planning	Dante I. Tapia;Ricardo S. Alonso;Óscar García;Juan Manuel Corchado	2011		10.1007/978-3-642-19917-2_30	wireless sensor network;wireless;hera;service-oriented architecture;distributed computing;multi-agent system;computer science	Robotics	-39.20015321011654	45.7216371525854	69532
32185ba2a63ece4fda1b282aec595b6064d08642	x-in-the-loop advanced driving simulation platform for the design,development, testing and validation of adas		This paper presents a X-in-the-loop (where X: Model, Software, Hardware, Driver/Human, etc.) driving simulation platform, developed at Siemens PLM Software, that facilitates the design, development, testing and validation of Advanced Driver Assistance System (ADAS). The paper outlines the essential components of the simulator and demonstrates the usefulness by two autonomous driving functionalities i.e. adaptive cruise control and autonomous intersection crossing. In addition, the paper highlights the key features of the platform.	algorithm;architecture design and assessment system;autonomous car;autonomous robot;co-simulation;driving simulator;dual in-line package;hardware-in-the-loop simulation;model-based testing;radar;real life;scalability;simulation;user interface	Sikandar Moten;Francesco Celiberti;Marco Grottoli;Maia Natalia Pavlovic;Yves Lemmens	2018	2018 IEEE Intelligent Vehicles Symposium (IV)	10.1109/IVS.2018.8500409	advanced driver assistance systems;embedded system;software;computer science;cruise control	Embedded	-37.70905371840414	34.5679792837599	69674
cdaccb20f518fce93dc417fe13af130e1f48813f	an early-reply based framework: reliable concurrency that is verifiable	software performance modelling;tool assisted platform based design flow;application specific multiprocessor systems;microarchitecture components;platform based design;formal specification;performance evaluation;architecture exploration;multiprocessor systems;perforation;jahuel;component based metamodel;multiprocessor embedded systems;embedded system;multiprocessing systems application software hardware computer architecture analytical models formal languages software performance software tools independent component analysis performance analysis;hardware architecture;computer architecture;embedded systems;software architecture;multiprocessor architecture;p ware simulation tool;software architecture computer architecture embedded systems formal specification multiprocessing systems performance evaluation;performance analysis;compilation chain;software hardware analysis;modelling environment;p ware simulation tool modelling environment exploration environment application specific multiprocessor systems tool assisted platform based design flow embedded multiprocessor application formal language platform independent behavior abstract execution model microarchitecture components hardware architecture compilation chain jahuel component based metamodel software performance modelling hardware performance modelling performance analysis;abstract execution model;platform independent behavior;multiprocessing systems;software hardware analysis multiprocessor embedded systems architecture exploration;simulation tool;hardware performance modelling;exploration environment;embedded multiprocessor application;packet forwarding;formal language;meta model;embedded software;performance modelling	Despite its widespread use, concurrent programming is still plagued by reliability problems, such as race conditions and deadlock, not found in sequential programs. We present a concurrency framework to help developers avoid these error conditions, and make it possible to verify their absence through static analysis.	concurrency (computer science);concurrency control;concurrent computing;deadlock;http 404;list of code lyoko episodes;race condition;static program analysis	Stephen W. Cook;Bjarne Stroustrup;Scott M. Pike	2007	10th IEEE High Assurance Systems Engineering Symposium (HASE'07)	10.1109/HASE.2007.54	metamodeling;software architecture;computer architecture;formal language;parallel computing;real-time computing;embedded software;computer science;operating system;software engineering;formal specification;hardware architecture;packet forwarding	Embedded	-36.765637731410386	35.14438824483706	69726
c0cae76afea2b989d45fb990ee506ba37ca9b74d	context-aware dynamic event processing using event pattern templates	rfid;wireless sensor network;complex event processing	A variety of ubiquitous computing devices, such as radio frequency identification (RFID) and wireless sensor network (WSN), are generating huge and significant events that should be rapidly processed for business excellence. In this paper, we describe how complex event processing (CEP) technology can be applied to ubiquitous process management based on context-awareness. To address the issue, we propose a method for context-aware event processing using event processing language (EPL) statement. Specifically, the semantics of a situation drive the transformation of EPL statement templates into executable EPL statements. The proposed method is implemented in the domain of ubiquitous cold chain logistics management. With the proposed method, context-aware event processing can be realized to enhance business performance and excellence in ubiquitous computing environments. key words: Context-awareness, complex event processing, ubiquitous logistics, RFID, wireless sensor network	algorithm;business process;complex event processing;context awareness;eltron programming language;esoteric programming language;executable;file synchronization;institute of electronics, information and communication engineers;logistics;radio frequency;radio-frequency identification;sensor;ubiquitous computing;warez	Pablo Rosales Tejada;Jae-Yoon Jung	2013	IEICE Transactions		radio-frequency identification;embedded system;real-time computing;wireless sensor network;computer science;complex event processing;distributed computing	Mobile	-42.95262152285123	45.14058320546295	69742
056a18f8e804185e8d405f2d69578c8a1f7ce725	scalable context-aware development infrastructure for interactive systems in smart environments		Context-aware systems for smart environments can be very complex and demanding for developers especially in distributed computing and communication environments. We propose a new development infrastructure, that targets this challenge by improving the general system's scalability and traceability. The infrastructure has been developed for and tested in two research labs for smart environments and human computer interaction. First measurements show that the platform has high scalability and low message latency that is perfectly suitable for interactive projects and virtual reality experiments.	context-aware pervasive systems;distributed computing;experiment;human computer;human–computer interaction;scalability;smart environment;traceability;virtual reality	Tobias Eichler;Susanne Draheim;Christos Grecos;Qi Wang;Kai von Luck	2017	2017 IEEE 13th International Conference on Wireless and Mobile Computing, Networking and Communications (WiMob)	10.1109/WiMOB.2017.8115848	scalability;latency (engineering);traceability;distributed computing;virtual reality;smart environment;middleware;computer science	Visualization	-40.067020726080834	45.74086373337967	69918
9a6c8c3d94ea8fd11a5742ffac4e5172c30112c3	the wandering logic of intelligence - or yet another view o nomadic communications	wandering logic;view o nomadic communications	Whatever is flexible and flowing will tend to grow... (Dao De Jing) This paper presents a third generation (UMTS/IMT2000) integrated network architecture among Flexible Intelligent Network Elements (FINEs) based on the multimedia multimode (client, server and agent) IN Service Node concept ([1],[2]), to perform a crafty Unified Media Communications Service (UMCS) across heterogeneous networks. The FINE architecture represents a network of configurable elements allowing user access to a Unified Message Store (UMS) and Universal Communications Channel (UCC) via traditional PSTNIISDN/PLMN equipment such as telephones, pagers and fax machines on the one side and networked computers and mobile terminals equipped with mail readers, web browsers and video codecs to enable both on-line and off­ line interactions. A virtual cluster of FINEs within an integrated personal communications network is dynamically configured in a distributed or centralised manner according to user profile requirements, network size and performance to provide artful messaging and conferencing services in a changing environment. Each FINEC can be deployed in some of the three modes --- independent (server), dependent (client) and autonomous (agent) --­with respect to the user/network configuration, thus allowing a dynamically configurable (per user/ per node/ per service) centralised or distributed service architecture. The FINE itself is organised along with other nodes by a Network Operation Support Environment (NOSE), a service oriented and TMN compliant Operation, Administration & Maintenance Center. Service logic can be transferred, installed and mounted on demand among the FINE Controllers and the terminal equipment to provide optimal QoS.	yet another	Plamen L. Simeonov	1999			embedded system;engineering;distributed computing;computer network	AI	-35.244789612873156	45.96854072741345	69963
c186677ae1bef1bfd8b7c3a9d4a1dee55df8687a	technical note - web service credentials	web service	Web service technology promises advances in the dynamic integration of on-line services. Mechanisms are needed to assist in verifying the quality of these services. The end user of a Web service will quickly detect if the content is handled correctly and if the business process rules are adhered to, but often, many unwarranted assumptions are made concerning the quality of a service. Is the provider of the service reliable? If not, the consequences will primarily impact the user, who will blame the provider for delivering bad services. This paper explains the need for Web service credentials to address this issue and explores several aspects of an approach that facilitates a trustworthy dynamic integration of services.	credential;web service	Arjan de Mes;Erik Rongen	2003	IBM Systems Journal	10.1147/sj.423.0532	service provider;web service;service level requirement;service bureau;service level objective;application service provider;business service provider;differentiated service;computer science;service delivery framework;ws-policy;service design;database;internet privacy;world wide web;computer security;computer network;service system	Crypto	-47.597123318885835	43.39777101094305	70051
b9dd6a6b5984227b6c3ae69e0353a0f725bc95f8	model-driven design and organic computing - contradictory or synergetic approaches to overcome the embedded software crisis	automatic control;biology computing;control systems;model driven architecture model driven design organic computing embedded software crisis;model driven design;organic computing;distributed computing;embedded systems model driven design oragnic computing;data mining;embedded system;computer architecture;embedded systems;software architecture;computational modeling;adaptation model;software architecture embedded systems;embedded computing embedded software embedded system biology computing buildings automatic control distributed computing costs computer architecture control systems;embedded software crisis;oragnic computing;model driven architecture;buildings;embedded computing;embedded software	This panel discusses two different approaches toovercome the embedded software crisis. On one hand, Model-Driven Design is an approach to build software by using ahierarchy of models and automatic transformation betweenthese models. Organic computing is building systems inspiredby nature. A main purpose of this panel is to answer thequestion if these approaches are contradictory or can becombined in a synergetic way.	embedded software;model-driven engineering;model-driven integration;organic computing;software crisis;synergetics (haken);synergy	Uwe Brinkschulte	2009	2009 IEEE International Symposium on Object/Component/Service-Oriented Real-Time Distributed Computing	10.1109/ISORC.2009.21	embedded system;software architecture;real-time computing;embedded software;computer science;automatic control;distributed computing;computational model	Embedded	-44.02049911383635	37.151549970594765	70079
8f107201744863e30dbcef5a00f149bf26e47486	the complex event processing paradigm		As mentioned in the previous chapters, pervasive systems demand for continuous processing of information collected from multiple sources deployed in the environment under analysis. Often, a large portion of such information encodes notifications of events occurred within the pervasive system or in the environment where it operates. In such cases, the goal of the processing step is to detect situations of interest as soon as they occur, by looking at the primitive events that have been observed. On the one hand, this requires the ability of defining the situations of interest (often called composite events) as patterns of primitive events, joined by specific relationships. On the other hand, this also demands the capability of effectively exploiting such definitions to detect composite events at run-time, as soon as they occur. Complex Event Processing (CEP) languages and systems have been proposed by research and industry to satisfy these complementary needs. The CEP paradigm shares some similarities with the Data Streaming approach described in Chapter 4. Nevertheless, several key differences exist. Specifically, Data Stream Management Systems (DSMSs) focus on transforming the incoming streams of information into new streams, e.g., by joining or aggregating data items. Conversely, CEP systems interpret incoming information as notifications of events and focus on detecting relevant patterns among such streaming notifications. This chapter focuses on this specific processing abstraction, describing the key features and issues that characterize it.	algorithm;application domain;complex event processing;interaction;management system;pervasive informatics;programming paradigm;scalability;sensor;ubiquitous computing	Gianpaolo Cugola;Alessandro Margara	2015		10.1007/978-3-319-20062-0_6	scalability;real-time computing;streams;processing delay;abstraction;complex event processing;data analysis;computer science	DB	-40.03122213540796	42.32933401220028	70151
77e444e79ca58d43524465747eba938476fd0b3b	bridging the semantic gap between abstract models of embedded systems	design model;time triggered;formal semantics;modeling language;embedded system;inference rule;engineering and technology;teknik och teknologier;semantic gap;data flow;requirement specification;embedded software	In the development of embedded software, modeling languages used within or across development phases e.g., requirements, specification, design, etc are based on different paradigms and an approach for relating these is needed. In this paper, we present a formal framework for relating specification and design models of embedded systems. We have chosen UML statemachines as specification models and ProCom component language for design models. While the specification is event-driven, the design is based on time triggering and data flow. To relate these abstractions, through the execution trajectories of corresponding models, formal semantics for both kinds of models and a set of inference rules are defined. The approach is applied on an autonomous truck case-study.	autonomous robot;bridging (networking);carlson's theorem;component-based software engineering;conformance testing;control system;dataflow;directed acyclic graph;electronic notes in theoretical computer science;embedded software;embedded system;event-driven programming;gadget (computer science);icse;proceedings of the ieee;proof assistant;real-time clock;real-time computing;real-time transcription;requirement;semantics (computer science);sergio verdú;simulation;stavros fasoulas;unified modeling language	Jagadish Suryadevara;Eun-Young Kang;Cristina Cerschi Seceleanu;Paul Pettersson	2010		10.1007/978-3-642-13238-4_4	data flow diagram;real-time computing;formal methods;embedded software;specification language;computer science;theoretical computer science;formal semantics;formal specification;modeling language;programming language;semantic gap;language of temporal ordering specification;rule of inference	Embedded	-40.48699604285215	32.75991696684252	70182
403194521aaa0637d9f9cebed42f8979a32b9a3f	a pluggable and reconfigurable architecture for a context-aware enabling middleware system	context aware application;resource utilization;context awareness;context aware;mobile device;software engineering;reconfigurable architecture;context management;ubiquitous computing;middleware;architectures;experimental evaluation	Context awareness is a core feature of modern mobile and ubiquitous computing systems. Although it has not reached its full potential yet, one can already observe significant activity in the area of software engineering for supporting the development of context-aware applications. An example of such an activity is the MUSIC project, which proposes a middleware featuring a generic and reusable context management system. This paper describes the pluggable architecture of this system, and explains how it advances the state of the art through its support for context heterogeneity and better resource utilization. The former is achieved with the use of a novel architecture, which enables the separation of low-level, platform-specific context plug-ins from higher-level application-specific ones. The improved resource utilization is achieved through intelligent activation and deactivation of context plug-ins based on the needs of the active applications. The proposed approach has been experimentally evaluated and the results indicate that it significantly improves the resource utilization in context-aware applications, especially when deployed on lightweight	central processing unit;consortium;context awareness;context switch;experiment;high- and low-level;middleware;model-driven engineering;platform-specific model;plug-in (computing);programming paradigm;semantic reasoner;software engineering;ubiquitous computing	Nearchos Paspallis;Romain Rouvoy;Paolo Barone;George Angelos Papadopoulos;Frank Eliassen;Alessandro Mamelli	2008		10.1007/978-3-540-88871-0_40	embedded system;real-time computing;engineering;distributed computing	SE	-41.49498834719079	42.6756200109438	70367
0464771a1557bcbe51df0c62c9431fb3971b3509	an architecture for supporting development and execution of context-aware component applications	application development;context aware application;application designer description context aware component application camido context aware middleware ontology meta model context description task management context collection context application adaptation;context aware;ontology meta model;object oriented programming;context aware middleware;ontologies artificial intelligence;camido;context description;context aware component application;context collection;application designer description;middleware;ontologies artificial intelligence middleware mobile computing object oriented programming;middleware ontologies context awareness containers sensor phenomena and characterization fractals automatic control automatic generation control runtime context modeling;task management;mobile computing;meta model;context application adaptation	Context-awareness is rarely considered in component-based middleware. In this paper, we present CAMidO, a context-aware middleware based on an ontology meta-model. CAMidO, enables designers to create component-based context-aware applications. It provides an ontology meta-model for context description. The described information are used by the middleware to automatically adapt the application to relevant context-changes. Context-awareness is managed by component containers through nonfunctional properties. CAMidO manages all tasks related to context collection and application adaptation according to application designer description. Thus, it relieves application developers from programming these painful tasks		N. B. Behlouli;Chantal Taconet;Guy Bernard	2006	2006 ACS/IEEE International Conference on Pervasive Services	10.1109/PERSER.2006.1652207	metamodeling;middleware;computer science;middleware;data mining;database;object-oriented programming;rapid application development;mobile computing;world wide web	SE	-40.802676365350045	40.873864412947555	70435
c966be08d8c52441d63a2ff8a55e1cc531484ffc	context awareness inference engine for location based applications	context aware application;context awareness;location data;context aware;work environment;mobile object;mobile communication network;monitoring system;context aware service;context management;inference engine;knowledge base	In ubiquitous environments, location-based context awareness service provides additional services based on a user's location. In this paper, we design a context awareness inference engine model for working environment monitoring system of mobile object which is an issue in location-based application. We in the proposed a context awareness inference engine can use sensors, mobile communication network in order to achieve working environment information of mobile object. The proposed framework is consisted of data collector, context manager, knowledge base, inference engine, and context database. And it also has a structure that enables to serve users by embodying context awareness application interface for particular application.	context awareness;inference engine;knowledge base;sensor;telecommunications network	Yoon-Ae Ahn	2009		10.1145/1644993.1645033	knowledge base;computer science;knowledge management;artificial intelligence;spatial contextual awareness;data mining;world wide web;inference engine	Mobile	-40.8157883497871	45.11204547683677	70645
38729a0e26cef2ecdb1952e91ad6d6492b7766cd	using corba and java for pbx management	information resources;software portability;protocols;web based applications;information model;project management;pbx management;performance;abstraction;interface description language;telecommunication computing;corba;java switches telephony graphical user interfaces telecommunication switching project management technology management protocols communication switching user interfaces;portability;telephony;three tier web based application;technology management;ease of use;private telephone exchanges;graphical user interfaces;rapid application development;telecommunication switching;specification languages;telecommunication computing distributed object management java telecommunication network management private telephone exchanges telecommunication switching graphical user interfaces information resources software portability specification languages user interface management systems;distributed object management;interface description language corba pbx management legacy two tier system telephone switch management re engineering three tier web based application portability abstraction idl information model java gui performance scripting rapid application development;re engineering;idl information model;java gui;telephone switch management;user interface management systems;communication switching;legacy two tier system;switches;user interfaces;scripting;operations and management;telecommunication network management;java	Telephone Switches are characteristically long-lived, evolving systems. We describe how a legacy two-tier system for telephone switch management was reengineered as a three-tier web-based application using CORBA and Java. In this solution the design-time advantages of portability and abstraction brought by an IDL information model are combined with the universality and ease of use of a Java GUI. Performance was shown to be largely unaffected by the addition of the extra tier, while CORBA was seen to bring unexpected new advantages in the area of scripting and RAD.	common object request broker architecture;distributed computing;emergence;graphical user interface;information model;java;multitier architecture;network switch;rapid application development;scalability;software portability;telephone exchange;thin client;universality probability;usability;web application	P. Hasselmeyer;M. Andrew	2000		10.1109/NOMS.2000.830395	software portability;project management;real-time computing;computer science;technology management;operating system;database;computer security;computer network	SE	-34.71402486286726	42.42414342858643	70689
e0f71f77040288e08133ee57fdc80b2cf84801ba	design and implementation of a service-oriented architecture for the optimization of industrial applications	manufacturing process service oriented architecture industrial application optimization industrial automation optimal production plan computation automated optimized plan usage development flexibility development reusability maintenance flexibility maintenance reusability opc unified architecture servers constraint satisfaction problem layer ua connections flexible manufacturing systems manufacturing problem;flexible manufacturing systems;software reusability flexible manufacturing systems manufacturing processes production engineering computing production planning service oriented architecture software maintenance;software maintenance;production engineering computing;manufacturing processes;software reusability;production planning;service oriented architecture;computer architecture servers manufacturing production web services performance evaluation maintenance engineering;service oriented architecture soa industrial automation opc unified architecture ua optimization	A novel architecture for the field of industrial automation is described, the goals of which are: 1) computation of optimal production plans; 2) automated usage of the optimized plans; 3) flexibility and reusability at development and maintenance; and 4) seamless transition from current practice to the approach introduced herein. The architecture consists of three main components: 1) a set of OPC unified architecture (UA) servers, which are used to model the information from the device level; 2) a set of services organized into two layers (basic and complex services), which act as a link between the first and the third layer; and 3) a constraint satisfaction problem (CSP) layer for the computation of production plans. Extensive performance tests motivate the choice of the service development framework, and prove the effectiveness of the special adapter software solution for the integration of current devices and the ability of the UA server to manage a high number of UA connections. As a proof-of-concept, the architecture has been tested for a real manufacturing problem composed of four flexible manufacturing systems. The results show that the architecture is able to efficiently control and monitor a real manufacturing process according to an optimized schedule with over 99% of the time spent on the manufacturing.	address space;algorithm;automation;canonical account;computation;constraint satisfaction problem;devices profile for web services;erp;graphical user interface;mathematical optimization;opc unified architecture;open platform communications;open-source software;publish–subscribe pattern;run time (program lifecycle phase);seamless3d;server (computing);service-oriented architecture;service-oriented device architecture;user agent	Alina Gîrbea;Constantin Suciu;Septimiu Nechifor;Francisc Sisak	2014	IEEE Transactions on Industrial Informatics	10.1109/TII.2013.2253112	multilayered architecture;enterprise architecture framework;reference architecture;embedded system;software architecture;space-based architecture;systems engineering;engineering;applications architecture;operating system;service-oriented architecture;service;solution architecture;software architecture description;computer-integrated manufacturing;software maintenance;data architecture;manufacturing engineering	Robotics	-39.095109068902474	40.223402499367985	71046
29d49d658ac03a80dcb272df32522f7fb532325a	short paper: a model based framework for effective web of things development	sockets protocols microcontrollers graphics process control internet programming;microcontrollers;word length 8 bit model based framework web of things development http protocol model based integrated development environment taskscript os less systems low energy consumption 8 bit microcontrollers;ide internet of things web of things reactive systems model based design automatic code generation;transport protocols hypermedia internet of things low power electronics microcontrollers software engineering;software engineering;transport protocols;hypermedia;internet of things;low power electronics	This paper discusses the adoption of a Model Based approach in the Web of Things development as a way to simplify the task. A set of primitives is introduced to handle the http protocol at the model level directly, so that application designers need not know programming and networking details. A Model Based Integrated Development Environment, TaskScript, has been extended with such primitives: first results are reported, demonstrating the feasibility and effectiveness of the approach, particularly with OS-less systems using low cost and low energy consumption 8-bit microcontrollers: real case applications have been effectively developed in matter of hours.	8-bit;hypertext transfer protocol;integrated development environment;microcontroller;operating system;web of things;world wide web	Roberto Manione	2014	2014 IEEE World Forum on Internet of Things (WF-IoT)	10.1109/WF-IoT.2014.6803154	microcontroller;embedded system;real-time computing;web of things;human–computer interaction;telecommunications;computer science;operating system;world wide web;computer security;internet of things;transport layer;low-power electronics;computer network	SE	-35.344211654580015	40.535144405550746	71048
7c9de194c4f60c136f5408761fde91ec0abdd5c8	detecting architectural violations using responsibility and dependency constraints of components			sensor	Shinpei Hayashi;Fumiki Minami;Motoshi Saeki	2018	IEICE Transactions		artificial intelligence;computer vision;computer science;machine learning	SE	-47.601100799851885	36.387425845539305	71265
ac3df8915cfce1f3540978d6091335bfa8fb05fb	a formal aspect-oriented method for modeling and analyzing adaptive resource scheduling in cloud computing	deadline constraint aspect oriented method resource scheduling cloud computing systematic method reflection mechanism petri net enforcement algorithm system reliability;processor scheduling;virtual machining;computational modeling;adaptive scheduling;adaptation models;processor scheduling cloud computing virtual machining computational modeling adaptive scheduling adaptation models;software reliability aspect oriented programming cloud computing petri nets resource allocation scheduling;reflection mechanism cloud computing resource scheduling ctl petri nets;cloud computing	Cloud computing has attracted much interest recently from both industry and academia. However, the scale and highly dynamic nature of cloud application imposes significant new challenges to resource management, and efficient resource scheduling schemes are highly demanded. In this paper, we propose a systematic method to address the reliability, running time, and failure processing of resource scheduling in cloud computing. A reflection mechanism is used to abstract the resource scheduling process as a metaobject. Petri nets are used to construct the base layer model, meta layer model, metaobject protocol, and other components, thus forming the resource scheduling model. The adaptive resource scheduling strategy is converted into CTL formulas, and the properties are analyzed. Meanwhile, an enforcement algorithm is proposed, which can guarantee the correct behavior of cloud computing while meeting the required reliability within deadline constraints. The operational semantics and related theories of Petri nets help prove its effectiveness and correctness. We have also performed a series of simulations to evaluate our approach. Results show that it can help reveal the structural and behavioral characteristics of cloud computing and improve the efficiency of resource management.	algorithm;aspect-oriented software development;cloud computing;correctness (computer science);experiment;metaobject;operational semantics;petri net;scheduling (computing);semantics (computer science);service-level agreement;simulation;software as a service;state space;time complexity	Guisheng Fan;Huiqun Yu;Liqiong Chen	2016	IEEE Transactions on Network and Service Management	10.1109/TNSM.2016.2553157	fair-share scheduling;fixed-priority pre-emptive scheduling;real-time computing;earliest deadline first scheduling;flow shop scheduling;cloud computing;dynamic priority scheduling;computer science;rate-monotonic scheduling;theoretical computer science;operating system;two-level scheduling;distributed computing;scheduling;round-robin scheduling;computational model	HPC	-46.16337320379556	39.949024622315626	71442
fd2f472f8dcf7784d59d4c249b45b19306f52070	context directory: a context-aware service for mobile context-aware computing applications by the example of google android	context aware software development context aware services context aware applications;context aware application;context aware computing;context aware;storage management;context aware software development;proof of concept;context model;computer architecture;software architecture;storage management middleware mobile computing operating systems computers software architecture;context aware applications;context aware service;context context aware services mobile communication context modeling middleware computer architecture;software development;mobile communication;software architecture context directory context aware service mobile context aware computing applications google android context awareness distributed mobile applications disseminated context attribute collection context structure context storage context aware middleware;middleware;mobile computing;context modeling;mobile application;operating systems computers;context;context aware services	To enable context-awareness for many distributed mobile applications, an architecture is needed that supports the collecting of disseminated context attributes. After the structuring and storing of context, the interpretation and adaptation with reference to the current context and changes of context must be applied. These tasks are common to a large set of context-aware applications and can be centralized in a context-aware middleware. This article shows the approach called Context Directory, which helps mobile applications to achieve context-awareness. The software architecture and as a proof of concept four categories of context-aware features are described.	android;centralized computing;component-based software engineering;context awareness;directory (computing);middleware;mobile app;mobile computing;mobile device;prototype;software architecture	Ralph Löwe;Peter Mandl;Michael Weber	2012	2012 IEEE International Conference on Pervasive Computing and Communications Workshops	10.1109/PerComW.2012.6197616	real-time computing;computer science;operating system;database;context model;mobile computing;world wide web	SE	-40.267869344622476	44.40401403204251	71577
4c5faf5495a9783abdcfe971cb45bbbefbb43e75	a passivity approach for model-based compositional design of networked control systems	networked control systems;passivity;model based design	The integration of physical systems through computing and networking has become pervasive, a trend now known as cyber-physical systems (CPS). Functionality in CPS emerges from the interaction of networked computational and physical objects. System design and integration are particularly challenging because fundamentally different physical and computational design concerns intersect. The impact of these interactions is the loss of compositionality which creates tremendous challenges. The key idea in this article is to use passivity for decoupling the control design of networked systems from uncertainties such as time delays and packet loss, thus providing a fundamental simplification strategy that limits the complexity of interactions. The main contribution is the application of the approach to an experimental case study of a networked multi-robot system. We present a networked control architecture that ensures the overall system remains stable in spite of implementation uncertainties such as network delays and data dropouts, focusing on the technical details required for the implementation. We describe a prototype domain-specific modeling language and automated code generation tools for the design of networked control systems on top of passivity that facilitate effective system configuration, deployment, and testing. Finally, we present experimental evaluation results that show decoupling of interlayer interactions.	automatic programming;code generation (compiler);control system;coupling (computer programming);cyber-physical system;domain-specific modeling;emergence;interaction;level of detail;modeling language;network packet;pervasive informatics;prototype;software deployment;system configuration	Xenofon D. Koutsoukos;Nicholas Kottenstette;Joseph F. Hall;Emeka Eyisi;Heath J. LeBlanc;Joseph Porter;Janos Sztipanovits	2012	ACM Trans. Embedded Comput. Syst.	10.1145/2362336.2362342	simulation;model-based design	Embedded	-45.2154799521786	37.48181466176173	71682
8747c5c56a69ff9760606f1c0a43d3b5259a83c3	enhanced formal verification flow for circuits integrating debugging and coverage analysis	avioniksysteme	In this paper we briefly review techniques used in formal hardware verification. An advanced flow emerges from integrating two major methodological improvements: debugging support and coverage analysis. The verification engineer can locate the source of a failure with an automatic debugging support. Components are identified which explain the discrepancy between the property and the circuit behavior. This method is complemented by an approach to analyze functional coverage of the proven Bounded Model Checking(BMC) properties. The approach automatically determines whether the property set is complete or not. In the latter case coverage gaps are returned. Both techniques are integrated in an enhanced verification flow. A running example demonstrates the resulting advantages.	debugging;formal verification	Daniel Große;Görschwin Fey;Rolf Drechsler	2013	ECEASST	10.14279/tuj.eceasst.62.860	real-time computing;computer science;theoretical computer science;runtime verification;intelligent verification;functional verification	EDA	-36.688199139610234	33.14237545522176	71756
7afeea8c50f8fc5cc8788c7260b11fa1d66a2484	model-based diagnostic using model checking	model checking technique;program diagnostics;formal specification;physical system diagnosing;model based diagnosis;temporal logic;model based debugging;software fault tolerance;program verification;set theory;faulty component;program specification model based diagnostic reasoning model checking technique physical system diagnosing software program debugging faulty component subset method structural description automaton description temporal logic;automaton description;temporal logic automata theory diagnostic reasoning formal specification program debugging program diagnostics program verification set theory software fault tolerance;model checking;software program debugging;hardware design model based diagnosis model checking model based debugging;model based diagnostic reasoning;subset method;automata theory;hardware design;program debugging;diagnostic reasoning;program specification;structural description;fault diagnosis fault detection software debugging predictive models physics computing computer science software systems hardware testing concrete	In this paper, we present an approach integrating the two techniques of model-based diagnosis and model checking for diagnosing physical systems and debugging software programs (in particular hardware programs). For diagnosis, the physical system is modeled by a structural description viewing the connections between the different components of the system. Our approach which uses model checking technique, diagnoses this description (model) using the obtained observations from the real design (or simulation of a description program). This diagnosis is based on checking the consistency between these observations and the system description with a set of combinations of subsets of faulty and unfaulty components. For debugging, the program is first converted to a diagnosis model. Then, we use the model checking to check the satisfaction of the design properties, if at least one property is violated, our approach will generate a set of subsets of faulted components which are candidate for debugging this program by looking for the associated statements to these faulted components.	algorithm;automaton;compiler;debugging;model checking;prototype;simulation;state space;temporal logic;vhdl	Mustapha Bourahla	2009	2009 Fourth International Conference on Dependability of Computer Systems	10.1109/DepCoS-RELCOMEX.2009.33	model checking;real-time computing;computer science;theoretical computer science;programming language;abstraction model checking	SE	-47.63033097899885	33.48092042572529	71935
07dd4367b7f035c1d5e142c0a8c68f00c7747537	coordination of software components with bip: application to osgi	bip;concurrency;component coordination;osgi	Coordinating component behaviour and access to resources is among the key difficulties of building large concurrent systems. To address this, developers must be able to manipulate high-level concepts, such as Finite State Machines and separate functional and coordination aspects of the system behaviour. OSGi associates to each bundle a state machine representing the bundle's lifecycle. However, once the bundle has been started, it remains in the state Active - the functional states are not represented. Therefore, this mechanism is not sufficient for coordination of active components.   In this paper, we present a methodology for functional component coordination in OSGi by using BIP coordination mechanisms. BIP allows us to clearly separate the system-wide coordination policies from the component behaviour and the interface that components expose for interaction. By using BIP, we show how the allowed global states and state transitions of the modular system can be taken into account in a non-invasive manner and without any impact on the technology stack within an OSGi container.	advanced configuration and power interface;component-based software engineering;concurrency (computer science);finite-state machine;high- and low-level;linear programming;osgi;solution stack	Simon Bliudze;Anastasia Mavridou;Radoslaw Szymanek;Alina Zolotukhina	2014		10.1145/2593770.2593777	embedded system;real-time computing;engineering;operating system	SE	-38.97666728377245	37.95255996931886	71959
603d65f97fd249f49a60d1f9f21db8c547ee0361	system-platforms-based systemc tlm design of image processing chains for embedded applications	signal image and speech processing;circuits and systems;control structures and microprogramming;image processing;electronic circuits and devices	Intelligent vehicle design is a complex task which requires multidomains modeling and abstraction. Transaction-level modeling (TLM) and component-based software development approaches accelerate the process of an embedded system design and simulation and hence improve the overall productivity. On the other hand, system-level design languages facilitate the fast hardware synthesis at behavioral level of abstraction. In this paper, we introduce an approach for hardware/software codesign of image processing applications targeted towards intelligent vehicle that uses platform-based SystemC TLM and component-based software design approaches along with HW synthesis using SystemC to accelerate system design and verification process. Our experiments show the effectiveness of our methodology.	autosar;abstraction layer;component-based software engineering;design flow (eda);electronic system-level design and verification;embedded system;experiment;high- and low-level;high-level synthesis;image processing;level design;microcontroller;profile (uml);simulation;software design;software development;systemc;systems modeling language;systems design;transaction-level modeling;unified modeling language	Muhammad Omer Cheema;Lionel Lacassagne;Omar Hammami	2007	EURASIP J. Emb. Sys.	10.1155/2007/71043	embedded system;computer vision;computer architecture;real-time computing;image processing;computer science;operating system	EDA	-41.04478859301118	33.59934573438844	72298
a0c0e83611c2ca6df1c6b150f7b45d0678dffcca	designing embedded systems using patterns: a case study	time triggered;embedded system;design and implementation;time triggered architecture;design pattern;co operating scheduling;design patterns;task scheduling;embedded processor;article;microcontroller	If software for embedded processors is based on a time-triggered architecture, using co-operative task scheduling, the resulting system can have very predictable behaviour. Such a system characteristic is highly desirable in many applications, including (but not restricted to) those with safety-related or safety-critical functions. In practice, a time-triggered, co-operatively-scheduled (TTCS) architecture is less widely employed than might be expected, not least because care must be taken during the design and implementation of such systems if the theoretically-predicted behaviour is to be obtained. In this paper, we argue that the use of appropriate ‘design patterns’ can greatly simplify the process of creating TTCS systems. We briefly explain the origins of design patterns. We then illustrate how an appropriate set of patterns can be used to facilitate the development of a non-trivial embedded system.	central processing unit;design pattern;embedded system;scheduling (computing);time-triggered architecture	Michael J. Pont;Mark P. Banner	2004	Journal of Systems and Software	10.1016/S0164-1212(03)00006-2	microcontroller;embedded system;embedded operating system;computer architecture;software design pattern;real-time computing;computer science;operating system;design pattern	Embedded	-39.35508135345323	35.511917588641836	72426
57b42ebff4e88c36cc9c69d3ef6ebb13b47af35f	probabilistic contracts for component-based design	parallel composition;component composition;embedded system;interaction model;component based design;markov chain	We define a probabilistic contract framework for describing and analysing component-based embedded systems, based on the theory of Interactive Markov Chains (IMC). A contract specifies the assumptions a component makes on its context and the guarantees it provides. Probabilistic transitions allow for uncertainty in the component behavior, e.g. to model observed black-box behavior (internal choice) or reliability. An interaction model specifies how components interact. We provide the ingredients for a component-based design flow, including (1) contract satisfaction and refinement, (2) parallel composition of contracts over disjoint, interacting components, and (3) conjunction of contracts describing different requirements over the same component. Compositional design is enabled by congruence of refinement. Note to the reviewers: this report extends the submitted paper with all proofs, given in the appendix. Definition 14 (unambiguous contract) has been slightly modified.	black box;component-based software engineering;embedded system;interaction;markov chain;memory controller;refinement (computing);requirement;zeller's congruence	Dana N. Xu;Gregor Gößler;Alain Girault	2010		10.1007/978-3-642-15643-4_24	markov chain;real-time computing;computer science;component-based software engineering;component;programming language	Logic	-35.178101517238204	33.34122130985598	72584
a65fbc92d8d5ae3f3f45e16e7c58078b203e4e21	control integration through message-passing in a software development environment	message processing;environments;user needs;large scale software production;end user needs message passing tool integration software development environment large scale software production control integration paradigm;software tools integrated software programming environments;scale;software engineering;integration;end user needs;programming environments software tools;software development environment;message passing;production;tool integration;control integration paradigm	Understanding tool integration in a Software Development Environment (SDE) is one of the key issues being addressed in current work on providing automated support for large-scale software production. Work has been taking place at both the conceptual level (“What is integration?”) and the mechanistic level (“How do we provide integration?”). Many people see the answers to these questions as providing the cornerstone of real progress in the area. Until recently, existing integration mechanisms have been very rigid in the support for integration that they provide. Users have been offered a fixed level of integration with little flexibility. However, one approach that has been recently implemented employs a control integration paradigm that appears to be flexible, supportive, and adaptable to a wide range of end-user needs. Implementations of this paradigm are based on the notion of “message passing” as the underlying communication mechanism between SDE services. In this paper we examine the message passing approach to integration in an SDE, look at the general principles of the approach, describe some existing implementations, and discuss the use of such a mechanism as the basis for a more flexible environment that is open to experimentation with different approaches to integration.	c++;directory (computing);electronic design automation;encapsulation (networking);graphical user interface;high-level programming language;integrated development environment;message passing;operating system;pipeline (unix);programming paradigm;simultaneous editing;softbench;software development;system call;tooltalk;unix	Alan W. Brown	1993	Software Engineering Journal	10.1049/sej.1993.0017	scale;message passing;real-time computing;computer science;systems engineering;software engineering;database;development environment;programming language;system integration	SE	-35.803112647805825	39.50899356011876	72811
216732816fec14fb37350ad54674f52ba48c556a	agent-based load balancing for mobile robot applications	agent-based load balancing;mobile robot application;load balance;mobile robot	There is an increasing demand for mobile autonomous robots, e.g. in the field of service applications. For the use of mobile service robots in real environments, complex and reactive sensing-perception-action systems are necessary. Many of these models were already developed and/or are subject of current research (Mertsching, et al., 1997), (Wasson, et al., 1998). On the other hand, questions on how these models can be integrated into the software architectures for mobile robots as well as the management of system resources necessary in mobile systems are not well studied. Especially the latter requires mechanisms to handle the different timeliness and priorities of the normally parallel tasks even in dynamic environments.	load balancing (computing);mobile robot	Ralf Kluthe;Wolfgang Obelöer;Claus Grewe	1998			mobile robot;robot control	Robotics	-36.04660187674576	38.645705933797046	73166
e7e84def2d5ab29a110a1f216ef97311c66424e9	the development of easy interaction room	intelligent robots;service robots;mobile robots;software architecture;design and implementation;software reusability;service robot;system development;ubiquitous computing;home automation easy interaction room development ubiquitous computing intelligent robotic service monolithic robot platform cutting edge technology hardware infrastructure software architecture;ubiquitous computing home automation intelligent robots mobile robots service robots software architecture software reusability;home automation;intelligent robots service robots software architecture computer architecture ubiquitous computing human robot interaction pervasive computing collaboration robotics and automation hardware;ubiquitous computing environment	This paper introduces the system development of the ubiquitous computing environment, called easy interaction room (EIR), in which humans can get intelligent robotic services with easy interaction. The room has been built to research the roles between the ubicomp environment and service robot in it. Also EIR system collaborates on a special home service with the monolithic robot platform. In this development, cutting-edge technologies are employed on the design and implementation of hardware infrastructure for the automated environment. Intelligent Robot Software Architecture, developed by CIR for reusable and extensible architecture, is used to build EIR's software architecture for rapid development. Preliminary correlations between EIR and a service robot have been designed and implemented on the architectures.	robot software;service robot;software architecture;ubiquitous computing	Sangseok Yun;Changho Kim;Jonghoon Kim;Mun-Taek Choi;Munsang Kim	2007	RO-MAN 2007 - The 16th IEEE International Symposium on Robot and Human Interactive Communication	10.1109/ROMAN.2007.4415206	mobile robot;embedded system;home automation;software architecture;simulation;computer science;ubiquitous robot;ubiquitous computing	Robotics	-38.942572056709885	42.91297005135911	73208
82e134873d88f3e3546314167db3cda0d0e2fb40	integrating fault recovery and quality of security in real-time systems	software fault tolerance checkpointing real time systems;security quality;fault tolerant;software fault tolerance;checkpointing;confidentiality services;real world application;security requirements;fault tolerance;real time systems fault tolerance fault tolerant systems information security computer science computer security bridges application software cryptography software systems;next generation;confidentiality services real time systems security quality fault recovery fault tolerance;fault recovery;real time systems	In the past five years, mandatory security requirements and fault tolerance have become critical criteria for most real-time systems. Although many conventional fault-tolerant or security approaches were investigated and applied to real-time systems, most existing schemes only addressed either security demands ignoring the fault-tolerant requirements or vice versa. To bridge this technology gap in real-time systems, in this paper we propose a way of integrating fault recovery and confidentiality services. The novel integration of security and fault recovery makes it possible to implement next-generation real-time systems with high reliability and quality of security. Experimental results from real-world applications show that our approach can significantly improve security over the conventional approaches by up to 661.56% while providing an efficient means of fault tolerance.	confidentiality;fault tolerance;real-time clock;real-time computing;real-time locating system;real-time operating system;real-time transcription;requirement	Kiranmai Bellam;Ziliang Zong;Mohammed I. Alghamdi;Mais Nijim;Xiao Qin	2007	21st International Conference on Advanced Information Networking and Applications Workshops (AINAW'07)	10.1109/AINAW.2007.207	software security assurance;computer security model;fault tolerance;real-time computing;computer science;security testing;computer security;software fault tolerance	Embedded	-47.49280579585159	39.16463742162842	73389
283e0c106c2f4455c93739db82b2104622c2553d	uvm based reusable verification ip for wishbone compliant spi master core		The System on Chip design industry relies heavily on functional verification to ensure that the designs are bug-free. As design engineers are coming up with increasingly dense chips with much functionality, the functional verification field has advanced to provide modern verification techniques. In this paper, we present verification of a wishbone compliant Serial Peripheral Interface (SPI) Master core using a System Verilog based standard verification methodology, the Universal Verification Methodology (UVM). The reason for using UVM factory pattern with parameterized classes is to develop a robust and reusable verification IP. SPI is a full duplex communication protocol used to interface components most likely in embedded systems. We have verified an SPI Master IP core design that is wishbone compliant and compatible with SPI protocol and bus and furnished the results of our verification. We have used QuestaSim for simulation and analysis of waveforms, Integrated Metrics Center, Cadence for coverage analysis. We also propose interesting future directions for this work in developing reliable systems.	communications protocol;duplex (telecommunications);embedded system;factory method pattern;semiconductor intellectual property core;serial peripheral interface bus;simulation;system on a chip;systemverilog;universal verification methodology;verilog;wishbone (computer bus)	Lakhan Shiva Kamireddy;Lakhan Saiteja Kamireddy	2018	CoRR		duplex (telecommunications);parallel computing;verilog;system on a chip;factory method pattern;communications protocol;universal verification methodology;functional verification;computer architecture;wishbone;computer science	EDA	-36.82765058767247	33.86856039564234	73393
83b78f987b11ec396714cdbac1c0600f560230c5	fifth international workshop on dynamic software product lines (dspl 2011)	dspls bind variation point;dynamic software product lines;high-quality software;dynamic software product line;variation point addition;variation point;binds variation point;fifth international workshop;resource constraint;pre-runtime variation point;variation points change;extensive variation	"""In emerging domains such as ubiquitous computing, service robotics, unmanned space and water exploration, and medical and life-support devices, software is becoming increasingly complex with extensive variation in both requirements and resource constraints. Developers face growing pressure to deliver high-quality software with additional functionality, on tight deadlines, and more economically. In addition, modern computing and network environments demand a higher degree of adaptability from their software systems. Computing environments, user requirements, and interface mechanisms between software and hardware devices such as sensors can change dynamically during runtime. Because it's impossible to foresee all the functionality or variability an SPL requires, there is a need for dynamic SPLs that produce software capable of adapting to fluctuations in user needs and evolving resource constraints. DSPLs bind variation points at runtime, initially when software is launched, to adapt to the current environment, as well as during operation to adapt to changes in the environment. Although traditional SPL engineering recognizes that variation points are bound at different stages of development, and possibly also at runtime, it typically binds variation points before delivery of the software. In contrast, DSPL engineers typically aren't concerned with pre-runtime variation points. However, they recognize that in practice mixed approaches might be viable, where some variation points related to the environment's static properties are bound before runtime and others related to the dynamic properties are bound at runtime. In DSPLs, monitoring the current situation and controlling the adaptation are thus central tasks. The user, the application, or generic middleware can perform these tasks manually or automatically. Although dynamic software product lines build on the central ideas of SPLs, there are also differences. For example, the focus on understanding the market and letting the SPL drive variability analysis is less relevant to DSPLs, whose primary goal is to adapt to variations in individual needs and situations rather than market forces. In summary, a DSPL has many, if not all, of the following properties:• dynamic variability configuration and binding at runtime, • changes binding several times during its lifetime, • variation points change during runtime: variation point addition (by extending one variation point), • deals with unexpected changes (in some limited way), • deals with changes by users, such as functional or quality requirements, • context awareness (optional) and situation awareness, • autonomic or self-adaptive properties (optional), • automatic decision making (optional), and• individual environment/context situation instead of a """"market."""" Given these characteristics, DSPLs benefits from research in several related areas. For example, situation monitoring and adaptive decision making are also characteristics of autonomic computing, and the DSPL approach can be seen as one among several to building self-adapting/managing/healing systems. In addition, dynamically reconfigurable architectures provide mechanisms to rebind variation points at runtime, while multiagent systems, which focus on the use of agents and communities of agents, are particularly useful for evolving systems such as DSPLs [1]."""	agent-based model;autonomic computing;context awareness;emergence;heart rate variability;middleware;multi-agent system;reconfigurability;requirement;robotics;run time (program lifecycle phase);sensor;software product line;software system;spl (unix);ubiquitous computing;unmanned spacecraft;user requirements document	Svein O. Hallsteinsen;Michael G. Hinchey;Sooyong Park;Klaus Schmid	2011	2011 15th International Software Product Line Conference	10.1109/SPLC.2011.50	design;real-time computing;computer science;systems engineering;space exploration;operating system;software engineering;middleware;evolution;certification;ubiquitous computing	SE	-43.28510448965301	39.05010884595086	73398
550f4fa7978664b96d92bf7f5ecf7f9f05d3a652	human behaviours simulation in ubiquitous computing environments		Ambient Assisted Living (AAL) systems’ main goal is to augment live quality of elderly people, by using ICT based systems. In this paper, we are concerned with the artificial reproduction of a physical environment (i.e. a house) and an elder (i.e. the attended) living in such environment. An agent based social simulation system is used for such purpose. Such simulator will allow the integration of ubiquitous computing appliances, services and applications in such environment. A realistic reproduction of human behaviour in the simulator helps, in this context, in the validation of silent monitorisation, diagnosis and action based applications. Proofs are given in the paper which demonstrate the level of reality reached by comparing the artificial behaviour with real ones.	atm adaptation layer;ava radio company;agent-based model;agent-based social simulation;automata theory;emoticon;high-level programming language;probabilistic automaton;source data;taxonomy (general);time complexity;ubiquitous computing	Teresa García-Valverde;Francisco Campuzano;Emilio Serrano;Juan A. Botía Blaya	2010			human–computer interaction;ubiquitous computing;context-aware pervasive systems;artificial reproduction;agent-based social simulation;ubiquitous robot;information and communications technology;computer science	AI	-41.937331588320525	44.02830724365499	73561
e0c400f755b9ece661ae2225983b44395b27fe96	ocarina: an environment for aadl models analysis and automatic code generation for high integrity applications	distributed application;automatic code generation;distributed real time embedded;model analysis;modeling language	Developing safety-critical distributed applications is a difficult challenge. A failure may cause important damages as loss of human life or mission’s failure. Such distributed applications must be designed an d built with rigor. Reducing the tedious and error-prone development steps is req uired; we claim that automatic code generation is a natural solution. In order to ase the process of verification and certification, the user can use modeling langua ges to describe application critical aspects. In this paper we introduce the use o f AADL as a modeling language for Distributed Real-time Embedded (DRE) systems . Then we present our tool-suite OCARINA which allows automatic code generation from AADL models. Finally, we present a comparison between O CARINA and traditional approaches.	ada;architecture analysis & design language;automatic programming;code generation (compiler);cognitive dimensions of notations;component-based software engineering;distributed computing;executable;middleware;modeling language;multiple independent levels of security;polyorb;ravenscar profile;real-time clock;real-time computing;scheduling (computing)	Gilles Lasnier;Bechir Zalila;Laurent Pautet;Jérôme Hugues	2009		10.1007/978-3-642-01924-1_17	real-time computing;computer science;engineering;software engineering;modeling language;programming language	Embedded	-43.61569781349642	33.52087097848361	73667
f93d61f261f33ae49261c75cd8e762f1c330a29c	structure-free name management for evolving distributed environments	distributed environment	Name services facilitate sharing in distributed environments by allowing objects to be named unambiguously and maintaining a set of application-defined attributes for each named object. Existing distributed name services, which manage names based on their syntactic structure, may lack the flexibility needed by large, diverse, and evolving computing communities. A new approach, structure-free name management, separates three activities: choosing names, selecting the storage sites for object attributes, and resolving an object’s name to its attributes. Administrative entities apportion the responsibility for managing various names, while the name service’s information needed to locate an object’s attributes can be independently reconfigured to improve performance or meet changing demands. CR	directory service;entity	Douglas B. Terry	1986			syntax;distributed computing;computer science;distributed computing environment	DB	-36.332568020584155	43.225286258711726	73767
c5e57043ad695f0166e08f68e3fefdcf4573495c	aspect-oriented frameworks (poster session): the design of adaptable operating systems	design model;fault tolerant;separation of concern;aspect oriented design;software systems;software engineering;three dimensional;software architecture;operating system;design and implementation;object oriented;aspect oriented programming;levels of abstraction;system design;design pattern;software migration;systems and applications;aspect oriented;software life cycle;software quality;base layer	With software systems such as operating systems, the interaction of their components becomes more complex. This interaction may limit reusability, adaptability, and make it difficult to validate the design and correctness of the system. As a result, re-engineering of these systems might be inevitable to meet future requirements. There is a general feeling that OOP promotes reuse and expandability by its very nature. This is a misconception as none of these issues is enforced. Rather, a software system must be specifically designed for reuse, expandability, and adaptability [4]. Operating systems are dominated in many aspects. Supporting separation of concerns and aspectual decomposition in the design of operating systems provides a number of benefits such as reusability, expandability, adaptability and reconfigurability. However, such support is difficult to accomplish. Aspect-Oriented Programming (AOP) [7] is a paradigm proposal that aims at separating components and aspects from the early stages of the software life cycle, and combines them together at the implementation phase. Besides, Aspect-Oriented Programming promotes the separation of the different aspects of components in the system into their natural form. However, Aspect-Oriented software engineering can be supported well if there is an operating system, which is built based on an aspect-oriented design. Therefore aspects can be created in applications, reused and adapted from the aspects provided by the operating systems. Object-Oriented Operating Systems treat aspects, components, and layers as a two dimensional models, which is not a good design model. Aspects in the operating system cannot be captured in the design and implementation. Two-dimensional models lead to inflexibility, limit possibilities for reuse and adaptability, and make it hard to understand and modify. The poster will show an Aspect-Oriented Framework [1, 8], which simplifies system design by expressing its design at a higher level of abstraction, for supporting the design of adaptable operating systems. A framework is more than a class hierarchy and it is a reusable to produce custom systems and applications [5]. Aspect-Oriented Framework is based on a three-dimensional design that consists of components, aspects, and layers. Components consist of the basic functionality modules of the system. Aspects are the properties in the systems that cut across the components in the operating systems. Some aspects in operating systems such as synchronization, scheduling, fault-tolerance cut across, in horizontal and vertical, the basic functionality of the systems. Layers consist of the components and aspects. By separating aspects and components of the operating systems in every layer, we can provide a better generic design model of the operating systems. The framework uses design patterns [6]. The overall architecture is divided into two frameworks: Base Layer and Application Layer Framework. The poster will show The UML model of frameworks and how to maximize separation of aspects, components, and layers from each other. Our goal is to achieve a better design model and implementation of operating systems, in terms of reusability, adaptability, extensibility, and reconfigurability.	aspect-oriented programming;class hierarchy;correctness (computer science);design pattern;extensibility;fault tolerance;operating system;programming paradigm;reconfigurability;requirement;scheduling (computing);separation of concerns;software engineering;software release life cycle;software system;synchronization (computer science);systems design;unified modeling language	Paniti Netinant;Constantinos A. Constantinides;Tzilla Elrad;Mohamed Fayad	2000		10.1145/367845.367937	embedded operating system;real-time computing;aspect-oriented programming;system of systems;computer science;programming language;systems design	Embedded	-40.81300314421313	35.62185067267926	74072
7661922e35eca904dd70eb854ae6129a49aa2c9f	two heads are better than one: using diversity to make software dependable.				Bev Littlewood	1999			embedded system;real-time computing;operating system	Robotics	-47.30897310659252	35.93774424224007	74311
05b787a06a6ef30a411333f3ff44c622ba0a655d	service group management facilitated by dsl driven policies in embedded middleware	biomedical monitoring;policy engine;software;dsl;programming language;domain specific languages service group management dsl driven policies embedded middleware behaviour injection software development methods programming languages;specification languages embedded systems middleware software engineering;group communication middleware policy engine domain specific language services;group communication;software engineering;embedded systems;medical services;engines;monitoring;specification languages;levels of abstraction;software development;software component;domain specific language;system development;middleware;services;dsl engines middleware biomedical monitoring software medical services monitoring;communications infrastructure management	Middleware by its very nature is fundamental to the functioning of systems as it provides the communication between software components. It is very much an underlying technology and is rarely visible to end users. As systems develop, certain domain semantics, provided by the domain experts, need to be injected into the behaviour of the underlying middleware, but in a controlled manner. The methods used to achieve this are often static in nature, wholly dependent on how they are implemented, deployed and managed. An increasingly popular way to manage this behaviour injection is through the use of policies, a technique used to govern defined rules, triggered by associated events, resulting in specific actions when certain conditions are encountered. Strong efforts have been made throughout the evolution of software development methods and programming languages to solve the lack of dynamicity which can arise through poor practices. Successive language based attempts to attain a higher level of abstraction in the notations used and techniques deployed have resulted in the re-discovery of Domain Specific Languages (DSL). This paper looks at injecting the dynamicity required in the management of service groups through a policy based DSL.	component-based software engineering;digital subscriber line;domain-specific language;middleware (distributed applications);programming language;software development process	Christopher Foley;Gemma Power;Leigh Griffin;Chen Chen;Niall Donnelly;Eamonn de Leastar	2010	The IEEE symposium on Computers and Communications	10.1109/ISCC.2010.5546775	real-time computing;service;digital subscriber line;communication in small groups;computer science;domain-specific language;component-based software engineering;software development;operating system;middleware;programming language;computer security;computer network	Embedded	-44.70908663669269	43.00226732241441	74661
3e3f39717e596fcc4d39f2a554cabbf471639bbf	fault injection into vhdl models: the mefisto tool	analytical models;design process;contracts;spectrum;fault injection methodology;indexing terms;process design;mefisto tool;fault tolerant computing;computational modeling;formal verification;computer testing;fault tolerant systems;specification languages;vhdl;experimental validation;simulation language;predictive models;software tools;genetic mutations;simulation language mefisto tool fault injection methodology fault tolerant systems vhdl;fault injection;software tools specification languages fault tolerant computing computer testing formal verification;fault tolerant systems hardware process design analytical models laboratories computational modeling genetic mutations costs contracts predictive models;hardware	This paper focuses on the integration of the fault injection methodology within the design process of fault-tolerant systems. Due to its wide spectrum of application and hierarchical features, VHDL has been selected as the simulation language to support such an integration. Suitable techniques for injecting faults into VHDL models are identified and depicted. Then, the main features of the MEFISTO environment aimed at supporting these techniques are described. Finally, some preliminary results obtained with MEFISTO are presented and analyzed.	fault injection;fault tolerance;simulation language;vhdl	Eric Jenn;Jean Arlat;Marcus Rimén;Joakim Ohlsson;Johan Karlsson	1994		10.1109/FTCS.1994.315656	reliability engineering;real-time computing;computer science;computer engineering	DB	-46.637329635535515	33.97951630895525	74841
408574a52c5281d9a9f61bfaa3bd5172d0b4aa9a	a java-based framework for the programming of distributed systems for mobile robots		We propose a novel concept for the programming of distributed systems for mobile robots. A software architecture is presented that eases the development of applications for mobile robots. This software architecture is based upon the Roblet-Technology, which is a powerful medium for robots. It introduces the possibility to develop, compile and execute a distributed application on one workstation. The fundamental paradigm of the Roblet-Technology is the strong use of mobile code. Using mobile code an application distributes parts of itself through the network and builds up a distributed application. Since the RobletTechnology uses Java the development is independent of the operation system. With the feature of running programs as a distributed software, the framework allows running algorithms which need great computation power on different machines which provide this power. In this way, it greatly improves programming and testing of applications in service robotics. We provide several examples of complex applications which were developed using our framework. They all have in common that they use the Roblet-Technology to combine several independently developed software components.	algorithm;autonomous robot;client (computing);code mobility;compiler;component-based software engineering;computation;distributed computing;encryption;hardware abstraction;high- and low-level;java;mobile robot;multimodal interaction;operating system;programming paradigm;robotics;service robot;software architecture;usability;workstation	Daniel Westhoff;Hagen Stanek	2008		10.1007/978-3-642-03558-6_6	compiler;component-based software engineering;software architecture;motion planning;computer science;mobile robot;workstation;artificial intelligence;robotics;distributed computing;java	Robotics	-34.29927195189554	38.896758153471296	74849
2969d56ff042605f4b4bd5846b0961e8df8b90af	study and application of fault injection in hla-based train control simulation system	railways;simulation system reliability hla based train control simulation system basic theory software based fault injection distributed simulation architecture inter operated simulation architecture high level architecture fault test program train control model failure process train control system simulation interface fault injection tools distributed instructions train control simulation system simulation;distributed processing;simulation;software fault tolerance;user interfaces digital simulation distributed processing fault diagnosis program testing railways software architecture software fault tolerance;software architecture;automatic train control;program testing;control systems object oriented modeling educational institutions computer architecture analytical models computational modeling software;fault injection;high level architecture;user interfaces;digital simulation;fault diagnosis	Based on basic theory and methods of fault injection, the software-based fault injection was constructed for distributed and inter-operated simulation architecture based on High Level Architecture (HLA). The fault test program of communication in train control simulation system was designed. The fault injection tools were used to control train control model. Every module in train control model should follow fault test program to operate. The failure process of train control system could be shown by simulation interface. There are three steps in fault injection. Firstly, fault test program was loaded into fault injection tools; secondly, fault injection tools distributed instructions of fault test program to every related subsystem; thirdly, every subsystem followed the steps during operation. Analysis results shows that fault injection method could be effectively applied in train control simulation system simulation based on HLA to improve reliability of simulation system.	algorithm;control system;fault injection;functional testing;online and offline;operability;simulation	Chen-xi Gou;Bai-gen Cai;Shangguan Wei;Jian Wang	2011	2011 14th International IEEE Conference on Intelligent Transportation Systems (ITSC)	10.1109/ITSC.2011.6083048	embedded system;real-time computing;fault coverage;engineering;fault model;general protection fault;software fault tolerance;computer engineering	Robotics	-46.693837750974296	34.45436499795357	75063
2edbf6ae830d4644e5e1a74f3a6f05214423c92f	synthesis of correct adaptors for protocol enhancement in component-based systems		Adaptation of software components is an important issue in Component Based Software Engineering (CBSE). Building a system from reusable or Commercial-Off-The-Shelf (COTS) components introduces a set of problems, mainly related to compatibility and communication aspects. On one hand, components may have incompatible interaction behavior. This might require to restrict the system’s behavior to a subset of safe behaviors. On the other hand, it might be necessary to enhance the current communication protocol. This might require to augment the system’s behavior to introduce more sophisticated interactions among components. We address these problems by enhancing our architectural approach which allows for detection and recovery of incompatible interactions by synthesizing a suitable coordinator. Taking into account the specification of the system to be assembled and the specification of the protocol enhancements, our tool (called SYNTHESIS ) automatically derives, in a compositional way, the glue code for the set of components. The synthesized glue code implements a software coordinator which avoids incompatible interactions and provides a protocol-enhanced version of the composed system. By using an assume-guarantee technique, we are able to check, in a compositional way, if the protocol enhancement is consistent with respect to the restrictions applied to assure the specified safe behaviors.	communications protocol;component-based software engineering;computer compatibility;glue code;interaction	Marco Autili;Paola Inverardi;Massimo Tivoli	2004	CoRR		embedded system;real-time computing;engineering;computer security	SE	-40.050639028058725	36.35023461057421	75333
4b240ba61594da45c52976ded4cb5e5d384fb41e	probabilistic validation of computer system survivability	top down;department of defense;formal method;intrusion tolerance;information system	There is a growing need for systems whose survivability in a specified use and/or attack environment can be assured with confidence. Many techniques have been proposed to validate individual components (e.g., formal methods) or a system as a whole (e.g., red teaming). However, no single technique can provide the breadth of evidence needed to validate a system with respect to high-level survivability requirements. To accomplish this, we propose an integrated validation procedure (IVP) that begins with the formulation of a specific survivability requirement R and determines whether a system is valid with respect to R. The IVP employs a topdown approach that methodically breaks the task of validation into manageable tasks, and for each task, applies techniques best suited to its accomplishment. These efforts can be largely independent, and the results, which complement and supplement each other, are integrated to provide a convincing assurance argument. We then illustrate the IVP by applying it to an intrusion-tolerant information system being developed by the U.S. Department of Defense. In addition to validating the system against high-level survivability requirements, we demonstrate the use of model-based validation techniques, as a part of the overall validation procedure, to guide the system’s design by exploring different configurations and evaluating tradeoffs.	classification tree method;data validation;formal methods;high- and low-level;information system;linc;requirement	William H. Sanders	2005		10.1007/11572329_1	reliability engineering;intrusion tolerance;simulation;formal methods;computerized system validation;computer science;engineering;top-down and bottom-up design;database;programming language;computer security;information system	EDA	-47.93212493813187	36.141761100960395	75378
55547706389a3e9a50219f4ef580cf70342ccd8d	verification framework for uml-based design of embedded systems	embedded system	System level design incorporating system modeling and formal specification in combination with formal verification can substantially contribute to the correctness and quality of the embedded systems and consequently help reduce the development costs. Ensuring the correctness of the designed system is, of course, a crucial design criterion especially when complex distributed (realtime) embedded systems are considered. Therefore, this paper aims at presenting a verification framework designated for formal verification and validation of UML-based design of embedded systems. It first introduces an approach of using the AsmL language for acquiring formal models of the UML semantics and consequently presents an on-the-fly model checking technique designed to run the formal verification directly over those semantic models.	embedded system;unified modeling language	Martin Kardos;Yuhong Zhao	2004		10.1007/1-4020-8149-9_3	verification;multicube	EDA	-43.5397053124273	32.36275435288957	75428
040b23069059a1d174cecb32be453002a684aa01	dynamic wrappers: handling the composition issue with jac	dynamic programming;object oriented programming dynamic wrappers jac dynamic adaptation application execution time jac framework java aspect components;wrapping;control systems;prototypes;separation of concern;object oriented programming;runtime;functional programming;application execution time;jac framework;jac;component framework;dynamic programming programming profession wrapping java control systems prototypes runtime;programming profession;object oriented programming java;dynamic adaptation;java aspect components;java;dynamic wrappers	Modern applications, and especially distributed ones: need jexibility and dynamic evolution. These goals can be partially reached with separation of concerns. However, a static approach is not suficient when trying to get dynamic adaptation during the application execution-time. I n this paper, we present the JAG Jramezoork that meets dynamic adaptation by using the notions of dynamic wrappers in order to achieve separation of concerns for non-functional programs, and of wrapping controllers to implement the composition of wrappers (maybe coming from different programmers) at wrap-time and at call-time.	programmer;separation of concerns;wrapping (graphics)	Renaud Pawlak;Laurence Duchien;Gerard Florin;Lionel Seinturier	2001		10.1109/TOOLS.2001.941659	real-time computing;computer science;operating system;programming language	SE	-37.38118934366677	38.810887602399404	75470
4658aa90b49d6488f452ca585c0515c2ac028420	a notation for component-based design of java applications	object oriented;enterprise javabean;component model;component based design;type system	In this paper we present JTN2 (Java Targeted Notation 2) a notation for component-based design of Java applications. JTN2 defines a component model based on the fundamental object-oriented principles: abstraction, encapsulation, modularization and typing. Indeed, JTN2 is an extension of JTN, an object-oriented, formal, visual notation for designing concurrent Java applications. JTN2 component model aims to deal with three issues of Java based component development: component definition, component interconnection and component implementation in Java. JTN2 allows a component to be described, understood and analyzed independently from other components. Pre-designed components are interconnected to form complete systems. JTN2 provides a static type system that checks if two components can be interconnected. Java code can be, then, generated automatically by taking advantage of multiple Java technologies, e.g., JavaBeans, Enterprise JavaBeans and JINI.	component-based software engineering;enterprise javabeans;interconnection;java;type system;jini	Catalin Amza;Gianna Reggio	2002		10.1007/3-540-36520-6_14	java api for xml-based rpc;real-time computing;jsr 94;java concurrency;common component architecture;computer science;operating system;java modeling language;strictfp;real time java;javabeans;programming language;java;generics in java;scala;java annotation	SE	-37.591004671830646	38.6597804521617	75747
450adb3bd580ff90dd83cc94a2a764714b905ffd	adaptable data models for scalable ambient intelligence scenarios	environmental data modeling;multi agent system;wireless sensor networks adaptable data models scalable ambient intelligence scenarios reliable sensory data;ambient intelligence;computer model;temperature sensors;reliability modeling;environmental conditions;indexing terms;sensor network;temperature sensor;data model;wireless sensor network;computational modeling adaptation model data models temperature measurement temperature sensors predictive models humidity;computational modeling;adaptation model;humidity;sensor nodes;artificial intelligence;ubiquitous computing;predictive models;wireless sensor networks artificial intelligence data models digital simulation;prediction model;temperature measurement;hybrid simulation;early detection;wireless sensor networks;everyday life;environmental data modeling ambient intelligence hybrid simulation wireless sensor networks;digital simulation;data models;neural network	In most real-life scenarios for Ambient Intelligence, the need arises for scalable simulations that provide reliable sensory data to be used in the preliminary design and test phases. This works present an approach to modeling data generated by a hybrid simulator for wireless sensor networks, where virtual nodes coexist with real ones. We apply our method to real data available from a public repository and show that we can compute reliable models for the quantities measured at a given reference site, and that such models are portable to different environments, so as to obtain a complete, scalable and reliable testing environment.	ambient intelligence;anisotropic filtering;coexist (image);data model;experiment;predictive modelling;real life;scalability;simulation;software repository	Alessandra De Paola;Giuseppe Lo Re;Fabrizio Milazzo;Marco Ortolani	2011	The International Conference on Information Networking 2011 (ICOIN2011)	10.1109/ICOIN.2011.5723138	real-time computing;simulation;wireless sensor network;computer science;data mining;ubiquitous computing	Robotics	-34.75664731750293	35.278541075575504	75835
9c774558a8223bfb48c9f3bc305fcbcfda319f9d	thematic track: formal languages and methods for designing and verifying complex embedded systems	design process;embedded system;formal method;critical system;system design;power management;formal language	  Nowadays, it is well accepted that the develop- ment of critical systems involves the use of formal methods. One of the major  fields where these methods made a lot of progress are the avionics, aerospace, transport areas, telecom, etc. These systems  are responsible for various functions, such as navigation, guidance, stability, power management, board/ground communications,  passenger entertainment.... Moreover, their complexity is continuously growing.      Due to safety constraints, these systems often have to go through certification. This requires testing, and a design process  based on a set of tight rules. However, due to the increasing complexity of described systems, there is clearly no guarantee  that such tight rules and rigorous testing will lead to error free systems. An alternative approach for helping system designers  is formal methods, i.e. fundamental languages, techniques and tools for design, analysis, validation or transformation of  systems in a provably correct way.      	embedded system;formal language	Yamine Aït Ameur;Frédéric Boniol;Dominique Méry;Virginie Wiels	2010		10.1007/978-3-642-16558-0_7	grammar systems theory;formal language;real-time computing;formal methods;design process;object language;formal verification;computer science;formal specification;programming language;systems design	EDA	-44.61230444967529	35.509037704119	75969
6753ab078a09910d822235c0e9ead0117cac458c	schedulability analysis of on-board satellite software based on model-driven and compositionality techniques	program diagnostics;aerospace computing;scheduling;scheduling aerospace computing aerospace instrumentation artificial satellites computerised instrumentation program diagnostics;artificial satellites;mast analysis tool schedulability analysis on board satellite software model driven technique compositionality technique realtime requirements validation instrument control unit icu epd suite energetic particle detector suite solar orbiter mission european space agency esa nasa national aeronautics and space administration edroom code generation tool;analytical models software timing protocols libraries space vehicles ports computers;computerised instrumentation;aerospace instrumentation	This paper presents the application of a model-driven and compositionality techniques for the real-time requirements validation of the on-board software for the Instrument Control Unit (ICU) of the Energetic Particle Detector (EPD) suite, which will be launched as a payload of the Solar Orbiter mission of the European Space Agency (ESA) and NASA. The main purpose of this approach is to automate the schedulability analysis of the on-board software. The complete solution integrates a component-based and automatic code generation tool, called EDROOM; RapiTime RVS 3.0, a tool that provides support for on-target execution time measurement; and an analysis tool, called MAST, to perform schedulability analysis. A framework called MICOBS is used to apply model-driven and compositionality techniques for the integration of the aforementioned tools, facilitating the transformations between the different models and allowing the automated generation of schedulability analysis reports.	associate-o-matic;automatic programming;code generation (compiler);component-based software engineering;control unit;epd;esa;instrument control;international components for unicode;library (computing);model-driven integration;on-board data handling;real-time transcription;requirement;run time (program lifecycle phase);sam;scheduling (computing);scheduling analysis real-time systems;system analysis;worst-case execution time	Javier Fernández;Pablo Nuño de la Parra;Bogdan Nilas;Ignacio García;Sebastián Sánchez-Prieto;Oscar R. Polo	2013	2013 8th IEEE International Symposium on Industrial Embedded Systems (SIES)	10.1109/SIES.2013.6601490	embedded system;real-time computing;simulation;computer science;operating system;scheduling;satellite	Embedded	-38.39413092600645	34.07158380625267	76230
63618d4062d07acd1347f248e5bfaadc91f8e438	hybrid approach to software interworking problems: managing interactions between legacy and evolving telecommunications software	telecommunications software;transactional technique;real time;rollback hybrid approach software interworking problems legacy systems telecommunications software real time software reliability transactional technique;telecommunication computing;hybrid approach;legacy systems;software reliability;software interworking problems;rollback	Intenvorking problems between software services arise for a number of reasons; they may occur because the services, or their component parts, have evolved to fulfil different roles from the originally intended ones, resulting in conflicting requirements. Alternatively, the services themselves may be undocumented, poorly understood, or required to intenvork with services from third party legacy systems. Intenvorking problems are difficult to predict and detect, as well as to resolve in an acceptable manner. The problems are particularly acute in the telecommunications domain with its supplementary concerns of real-time, distributed control and data, high reliability, rapid evolution, and a deregulated market that is encouraging multiple service providers. Approaches to intenvorking problems may be characterised as being either online or offline, formally or pragmatically/experimentally based. While numerous approaches have been developed, there have been very few attempts to combine formally based and online approaches to produce a technique. The research goal is to develop such a technique because experience with other combinations has led to the belief that they are not sufficient to deal with the intenvorking problems of complex, evolving software systems, as common in telecommunications. This is particularly the case for systems which also have to intenvork with third party and legacy code: a hybrid approach which combines both online and formally based approaches promises to address problems which have proven very difficult to resolve with other techniques. The paper outlines a hybrid approach based on a transactional technique with rollback capability. While the approach described is applied specifically to telecommunications services software, many aspects of the approach are applicable to other software domains which exhibit similar characteristics of realtime, event driven operation, such as control systems.	distributed control system;experiment;interaction;legacy code;legacy system;online and offline;real-time transcription;requirement;rollback (data management);software system;transaction processing;undocumented feature	Muffy Calder;Evan H. Magill;Dave Marples	1999	IEE Proceedings - Software	10.1049/ip-sen:19990613	real-time computing;rollback;telecommunications control software;computer science;operating system;software engineering;distributed computing;computer security;legacy system;software quality	SE	-44.90041322864908	40.4831456604022	76286
e9c1ccbbea6a6019a63e770471e73d980fba7f2b	intelligent system architecture for context-awareness in ubiquitous computing	context aware application;context aware;context information;wireless communication;intelligent system;ubiquitous computing;middleware;physical environment;ubiquitous computing environment	In this paper, we design an intelligent system architecture for dealing with context-aware application services in ubiquitous computing. The intelligent system architecture is composed of middleware, context server, and client. The middleware component of our intelligent system architecture plays an important role in recognizing a moving node with mobility by using a Bluetooth wireless communication technology as well as in executing an appropriate execution module according to the context acquired from a context server. The context server functions as a manager that efficiently stores into the database server context information, such as user's current status, physical environment, and resources of a computing system. To verify the usefulness of our intelligent system architecture, we finally develop a context-aware application system base on it, which provides users with a music playing service in ubiquitous comput-	bluetooth;context awareness;database server;inference engine;moe;middleware;server (computing);systems architecture;ubiquitous computing	Jae-Woo Chang;Seung-Tae Hong	2008		10.1007/978-3-540-69293-5_53	embedded system;real-time computing;computer science;operating system;middleware;world wide web;ubiquitous computing;wireless;intelligent sensor	Mobile	-40.70435571483238	44.92591027400583	76414
b6a894b5cd7533ac4e9c9764e40ec8d796300ecb	a service oriented loosely coupled gui framework in the mobile context	service orientation;gui framework;generic client;service oriented	This document describes the architecture of a generic GUI framework on mobile devices. In a client server system such a framework allows to display a user interface on a multitude of devices without any changes in the GUI description.#R##N##R##N#To achieve this goal an extended version of the model view controller (MVC) pattern is used in the form of a Java applet which communicates with its server via the http protocol.#R##N##R##N#The last section of this document elaborates on the special circumstances of client server applications on mobile devices.	loose coupling	Albrecht Stäbler	2008			computer science;operating system;database;world wide web	Mobile	-35.175867575362645	43.1209628968326	76457
ccb89cc62e1c39237e15585d1efff9456b5c3d50	self-adaptive component-based transaction commit management	transaction management;component based systems;commit protocols;adaptive system;next generation;non functional services;self adaptive systems;semantic relations;peer to peer	Traditionally, when implementing a transaction service, a protocol is chosen and it remains the same during the system execution. Nevertheless, the dynamic nature of nowadays application contexts (e.g., mobile, ad-hoc, peer-to-peer) and behaviour variations (semantic-related aspects) motivates the needs for application adaptation. Next generation of system applications should be adaptive or even better self-adaptive. This paper proposes (1) a component-based architecture of standard 2PC-based protocols and (2) a self-Adaptive Component-based cOmmit Management, named ACOM. Self-adaptation is obtained by behaviour awareness and component-based reconfiguration. This allows ACOM to select the most appropriate protocol according to the context. We show that using ACOM performs better than using only one commit protocol in a variable system and that the reconfiguration cost can be negligible.	agency.com;component-based software engineering;hoc (programming language);peer-to-peer	Patricia Serrano-Alvarado;Romain Rouvoy;Philippe Merle	2005		10.1145/1101516.1101527	three-phase commit protocol;commit;real-time computing;two-phase commit protocol;computer science;x/open xa;database;distributed computing	Mobile	-39.76741672003499	39.88679492185666	76552
7728debb7c3b9b4e243fc0fcb83de323eaae91b7	crest: principled foundations for decentralized systems	decentralization;web service;decentralized system;side effect;web services;mobile code;adaptive system;architectural style	CREST is an architectural style for decentralized, flexible, and secure open and adaptive systems. Adopting the bilateral transfer of computation as the fundamental medium of exchange among peers, CREST reduces content to a side-effect of computational exchange. We discuss the style's constraints, its anticipated benefits, and the implementation mechanisms.	adaptive system;bilateral filter;computation	Michael M. Gorlick;Kyle Strasser;Alegria Baquero;Richard N. Taylor	2011		10.1145/2048147.2048202	web service;real-time computing;simulation;computer science;adaptive system;computer security	AI	-36.54827354441116	44.000426544719986	77260
51624eca9775a83953feca5da3a59d7b8ae31e45	free and open source fault tree analysis tools survey	actuators;statistical analysis;logic gates;tools;open source software;fault trees	This paper gives an in-depth survey about some free and open source tools for Fault Tree Analysis (FTA), which is one of the most used techniques in safety and reliability engineering. We have carried out a comparative study for four different tools. Firstly, OpenFTA is an open source fault tree analysis which is based on XFTA calculation engine. Secondly, OpenAltaRica platform which is a free tool that analyzes the risk of complex systems. Thirdly, ALD Fault Tree Analyzer which is a free web-based tool that analyzes static fault trees. Finally, DFTCalc which is an open source tool that analyzes dynamic fault trees based on Stochastic Model Checking techniques. To compare these tools, three representative examples are used. The first one, modeled by OpenFTA and ALD Fault Tree Analyzer, is an Electro Mechanical Actuator (EMA) used to actuate the ailerons of an aircraft, with a static fault tree containing AND gates representing redundancy mechanism. The second, modeled by DFTCalc, is a remotely controlled lawnmower with a dynamic fault tree. The third, modeled by OpenAltaRica, is an example of fault tree generation from AltaRica code. In addition, the same example of EMA system has also been modeled by Isograph Fault Tree++ in order to compare free and open source tools with some commercial tools.	atomic layer deposition;complex systems;fault tree analysis;model checking;open-source software;reliability engineering;remote control;web application	Anis Baklouti;Nga Nguyen;Jean-Yves Choley;Faïda Mhenni;Abdelfattah Mlika	2017	2017 Annual IEEE International Systems Conference (SysCon)	10.1109/SYSCON.2017.7934794	embedded system;real-time computing;fault coverage;computer science;stuck-at fault;fault model;distributed computing	SE	-46.8348488498616	34.96253692122818	77389
078254ea576b5673c45780c05a35b95456c19b30	a two-stage bootloader to support multi-application deployment and switching in wireless sensor networks	virtual machine;multi core processor;empirical study;52 node sensor network testbed two stage bootloader network multiapplication deployment wireless sensor network switching resource constrained embedded systems dynamic application switching approach telosb platform program memory ram;user interface;resource allocation;development process;bootloader;wireless sensor node;sensor network;embedded system;wireless sensor network;wireless sensor networks switches operating systems application software condition monitoring computer networks embedded computing testing random access memory costs;operating system;sensor networks;application switching;sensor nodes;on the fly;wireless sensor networks;application switching sensor networks bootloader;wireless sensor networks resource allocation;scripting language;dynamic loading	Wireless sensor networks are built from highly resource constrained embedded systems. Supporting multiple applications on the sensor network is a desirable goal, however, these constraints make supporting multiple concurrent applications on each node difficult. Therefore, we propose a dynamic application switching approach where only a single application is active on each sensor node at a time. In this paper we present a dynamic application switching framework that can automatically reprogram the sensor node in response to application requests. We implement our framework on the TelosB platform and evaluate its performance using a 52-node sensor network testbed. The implementation of a two-stage bootloader reduces the memory requirements to only 1KiB of program memory and 8 bytes of RAM on this platform. We evaluate the implementation using two different modes of application switching; asynchronous and synchronous. Extensive performance studies indicate that dynamic application switching using our two-stage bootloader is a useful approach to support multiple applications in wireless sensor networks.	booting;byte;embedded system;interaction;network switch;random-access memory;read-only memory;requirement;sensor node;software deployment;testbed	Alan Marchiori;Qi Han	2009	2009 International Conference on Computational Science and Engineering	10.1109/CSE.2009.50	embedded system;real-time computing;wireless sensor network;sensor node;computer science;operating system;key distribution in wireless sensor networks;mobile wireless sensor network;computer network	Mobile	-37.11368192679032	45.639882691707164	77567
e6d2495850bcfcc18131dd5ac280849e081dcb3f	testing real-time embedded systems with hardware-in-the-loop simulation using high level architecture	high level architecture real time testing embedded systems hardware in the loop;testing hardware embedded systems computational modeling real time systems synchronization computer architecture;real time;user interfaces control engineering computing digital simulation embedded systems formal verification mobile robots open systems path planning program testing sensors;testing;computer architecture;embedded systems;computational modeling;hardware architecture real time embedded system testing hardware in the loop simulation high level architecture hil simulation hla standard heterogeneous architecture interoperability heterogeneous architecture synchronization ptolemy framework respective reference model verification process software interface mobile robot navigation algorithm testing sensor respective reactions models of computation moc;hardware in the loop;synchronization;high level architecture;hardware;real time systems	This work presents a technique for testing real-time embedded systems using Hardware-in-the-Loop (HIL) simulation, exploiting High-Level Architecture (HLA) standard for interoperability and synchronization of heterogeneous architectures. The proposed testing approach uses the Ptolemy framework to verify in real-time models running in hardware against their respective reference models developed in Ptolemy. The approach consisted in the development of new actors in Ptolemy responsible for the integration with HLA and the verification process, and a software interface to be deployed in the hardware under verification. As proof of concept, the proposed approach was applied for the testing of a simple mobile robot navigation algorithm. All data collected by sensors and the respective reactions are transferred in real-time to Ptolemy, which performs the verification against a reference model. Such technique allows different Models of Computation (MoC) to be used as reference models in Ptolemy to verify different hardware architectures synchronously based on HLA.	algorithm;computation;embedded system;hardware-in-the-loop simulation;high-level architecture;interoperability;mobile robot;real-time clock;real-time transcription;reference model;robotic mapping;sensor	Jose Claudio Vieira S. Junior;Alisson V. Brito;Tiago P. Nascimento	2015	2015 Brazilian Symposium on Computing Systems Engineering (SBESC)	10.1109/SBESC.2015.34	reference architecture;embedded system;computer architecture;desktop and mobile architecture for system hardware;real-time computing;computer science;applications architecture;hardware architecture	Embedded	-39.33553188994524	33.56654832318886	77870
62555234cb5ef1dc965a6d2585c554fa5d036537	modeling and optimizing resource scheduling for service composition based on queuing petri nets	analytical models;resource scheduling;service composition;queuing theory;processor scheduling;queueing theory;time factors processor scheduling computational modeling analytical models dynamic scheduling queueing analysis;resource scheduling service composition queuing theory petri nets;computational modeling;time factors;formal verification;scheduling;web services;formal verification service composition queuing petri nets individual web services resource management resource scheduling schemes queuing theory;petri nets;queueing analysis;dynamic scheduling;web services formal verification petri nets queueing theory scheduling	Service composition is an important means for integrating the individual Web services to create new value added systems. However, because highly dynamic nature of service composition poses new challenges to resource management, efficient resource scheduling schemes are highly demanded. In this paper, a hierarchal service scheduling net is proposed to model different components of service composition, queuing theory is used to describe the competition process of available service, thus forming the scheduling model of service composition. On this basis, the evaluation function and resource scheduling strategy of service composition are proposed by considering the preference, the price and response time of available service. The related theories of Petri net are used to formally verify the correctness of proposed method. Both case study and simulation results show that the method can optimize the resource scheduling process of service composition, which has the merits of rich expressivity, while improving the performance.	correctness (computer science);evaluation function;experiment;formal system;mathematical optimization;operational semantics;optimizing compiler;petri net;problem domain;profiling (computer programming);queueing theory;response time (technology);rich internet application;scheduling (computing);service composability principle;simulation;web service	Guisheng Fan;Huiqun Yu;Liqiong Chen;Dongmei Liu	2013	2013 IEEE 37th Annual Computer Software and Applications Conference	10.1109/COMPSAC.2013.87	fair-share scheduling;real-time computing;dynamic priority scheduling;computer science;rate-monotonic scheduling;operating system;two-level scheduling;database;distributed computing;programming language;queueing theory;round-robin scheduling	HPC	-46.20884692763785	40.00464921703904	77892
fab0896a0e81777ea0bc0a17a63bed55aa333e7e	on the quantitative estimation of abstraction level increase in metaprograms		Higher-level programming such as metaprogramming introduces a layer of abstraction above the domain language programs. Metaprogramming allows describing generic components and managing variability in a domain. It is especially useful for developing program generators for domains, where a great deal of commonalties exists. It allows increasing the level of abstraction and hiding details that are unnecessary to the designer. Information abstraction and hiding reduces the amount of “user-visible” information. In this paper, we estimate the increase of abstraction by evaluating the information content at the lower (domain) and higher (meta) layers of abstraction. The estimation method is based on the Kolmogorov complexity and uses a common compression algorithm. The method is evaluated experimentally on families of DSP components.	abstraction layer;algorithm;digital signal processor;experiment;kolmogorov complexity;metaprogramming;self-information;spatial variability	Robertas Damaševičius	2006	Comput. Sci. Inf. Syst.	10.2298/CSIS0601053D	real-time computing;abstraction inversion;computer science;theoretical computer science;programming language;algorithm	AI	-41.685687428947546	33.87571759793145	77925
602bb5a8a4805c1520ff2694ae36e4a2d07d4e10	reusable and architecture-neutral virtual communication interface for embedded systems	design reusability;hardware software co design;communication interfaces;api;virtual community;interface design;embedded system;embedded systems;functional model;optimization;communication technology	In this paper, a functional model of a virtual communication interface (VCI) for embedded systems is presented. It hides the underlying communication technology from the application. The communication bus can then be changed without worrying about its users and without the need to rewrite the application. The VCI is co-designed in hardware/software to improve performance considering architectural issues and the needs of the application. Communication buses widely used in embedded systems are used to test the applicability of this VCI. The experimental results demonstrate that with careful co-design, the VCI is not only reusable but also can remarkably improve the overall performance.	bus (computing);embedded system;function model;rewrite (programming)	Amjad Mohsen;Jochen Brandt	2009	SIGBED Review	10.1145/1851340.1851347	embedded system;information and communications technology;real-time computing;application programming interface;computer science;function model;interface design;operating system	EDA	-38.788888261791634	34.99071910250816	78136
4ac77b6239505b167542596fc0c36ecaf9551b67	implementation of network framework for development and integration of network-based humanoid robot system	network framework;data communication;stability;computer architecture;middleware network based humanoid robot network framework template based service component;humanoid robots;monitoring;middleware;control engineering computing;stability control engineering computing humanoid robots;verification process network based humanoid robot system network framework service components simplification process integration task error handling mechanism network framework stability;template based service component;middleware humanoid robots computer architecture monitoring data communication;network based humanoid robot	In this paper, we describe practical implementation of a framework for development and integration of network-based humanoid robot system. The characteristics of the framework are dynamically to connect, execute and disconnect humanoid robot and service components related to the robot, and to provide simplification process about development of service components and their integration task. In addition, using an error-handling mechanism, the framework is able to recovery the components interrupted by the unexpected error. Also, the stability of the network framework is guaranteed through verification process of developed service components.	humanoid robot;interrupt;microsoft windows;network interface controller;operating system;pentium 4;plug computer;random-access memory;text simplification;universal plug and play	Joo-Hyung Kim;Ho-Dong Lee;Gwi-Tae Park;Jung-Min Park	2012	2012 Third FTRA International Conference on Mobile, Ubiquitous, and Intelligent Computing	10.1109/MUSIC.2012.51	embedded system;real-time computing;simulation;computer science	Robotics	-34.63707666368606	39.52130807919883	78307
a2a96715dc38fef21f8561e9b8490ea8dbebc1d4	a compositional approach for modeling and timing analysis of wireless sensor and actuator networks		Wireless sensor and actuator networks (WSAN) are created through the integration of multiple nodes which acquire data and perform reaction based on them. In a general overview, sensor nodes of WSANs are responsible for data acquisition and sending them to a central node. The central node stores all the received data and performs reactions. Timing verification of WSAN applications to ensure schedulability of tasks is a challenge, and is generally performed by worst-case analysis. This process is error-prone and inherently conservative. On the other hand, using model checking for analyzing WSAN applications results in state space explosion even for middle-sized configurations. The reason is the necessity of considering the interleaving of the large number of sensors in WSANs. In this paper, we show how to build an actor-based model of WSAN applications, starting from sensor node-level and moving towards the full system, and we show how this compositional modeling improves analysability and modifiability. Realtime extension of actor model is appropriate for modeling WSAN applications where we have many concurrent and asynchronous processes, and interdependent realtime deadlines. We demonstrate the approach using a case study of a distributed realtime data acquisition system for high-frequency sensing, where Timed Rebeca is used for modeling. We use model checking to check the intra/inter-sensor node schedulability.	actor model;best, worst and average case;cognitive dimensions of notations;data acquisition;download;forward error correction;interdependence;model checking;scheduling (computing);sensor node;state space;static timing analysis	Marjan Sirjani;Ehsan Khamespanah;Kirill Mechitov;Gul A. Agha	2017	SIGBED Review	10.1145/3166227.3166237	real-time computing;model checking;distributed computing;wireless sensor network;interleaving;asynchronous communication;state space;computer science;data acquisition;static timing analysis;actor model	Embedded	-39.44507995531238	36.976218570132644	78522
3eb263675e3176b6a8deb8750c2e8ae797143054	gridcc: real-time workflow system	workflow pipline;workflow management;instruments;real time;potential difference;grid;research paper;workflow system;work flow;performance aware;workflow;grid enabled instrumentation;quality of service;european union	The Grid is a concept which allows the sharing of resources between distributed communities, allowing each to progress towards potentially different goals. As adoption of the Grid increases so are the activities that people wish to conduct through it. The GRIDCC project is a European Union funded project addressing the issues of integrating instruments into the Grid. This increases the requirement of workflows and Quality of Service upon these workflows as many of these instruments have real-time requirements. In thispaper we present the workflow management service within the GRIDCC project which is tasked with optimising the workflows and ensuring that they meet the pre-defined QoS requirements specified upon them.	quality of service;real-time clock;requirement	A. Stephen McGough;Asif Akram;Li Guo;Marko Krznaric;Luke Dickens;Dave Colling;Janusz Martyniak;Roger Powell;Paul Kyberd;Constantinos Kotsokalis	2007		10.1145/1273360.1273362	workflow;computer science;knowledge management;database;workflow management system;workflow engine;workflow technology	HPC	-46.81358158675352	42.10092509671377	78562
4eaf7f43bf47ec3423594b361ec45c740bae59d6	enhancing the flexibility of algebraic deadlock avoidance policies through petri net structural analysis	automatic control;flexible manufacturing systems;resource allocation;analysis and design;resource management;deadlock avoidance;polynomials;systems engineering and theory;automata;discrete event system;system recovery;production control;finite state automata;polynomials production control resource allocation petri nets finite automata;production control deadlock avoidance petri net structural analysis resource allocation discrete event system finite state automata;finite automata;discrete event systems;petri nets;digital audio players;system recovery resource management digital audio players polynomials automatic control systems engineering and theory discrete event systems automata petri nets flexible manufacturing systems;petri net;structural analysis;structure analysis	Deadlock avoidance in sequential resource allocation systems is a well-defined problem in Discrete Event System literature, as it underlies the operation of many contemporary technological systems. In the past, the problem has been studied by means of a number of formal frameworks, including the finite state automata (FSA) and Petri nets (PN). In this paper, it is shown that a significant class of deadlock avoidance policies (DAP), known as algebraic PK-DAP’s, originally developed in the FSA paradigm, can be analyzed using recent results from PN structural analysis. Furthermore, the approach to DAP analysis and design taken in this paper has led to the effective generalization of the currently available algebraic PK-DAP’s, and to their enrichment with new and more flexible policy implementations.	algebraic equation;automata theory;correctness (computer science);deadlock;finite-state machine;formal language;gene ontology term enrichment;icl distributed array processor;petri net;programming paradigm;public-key cryptography;sequential logic;structural analysis	Jonghun Park;Spyros A. Reveliotis	2000		10.1109/ROBOT.2000.845237	real-time computing;computer science;artificial intelligence;theoretical computer science;distributed computing;structural analysis;finite-state machine;petri net;deadlock prevention algorithms	Embedded	-35.73117691055536	32.94431200205077	78619
1ddb997a454dac0cd9645f74a8bc17a9d1725388	using a formal specification and a model checker to monitor and direct simulation	microprocessors;protocols;model checker;state space methods;formal specification;memory protocols;protocol state transitions;specification;formal specifications;refinement map;abstraction;formal verification;cache coherence protocol;model checking;monitoring;permission;state space;coverage information;coherence;hardware design;coverage;error trace;formal specifications monitoring protocols hardware design methodology permission formal verification state space methods microprocessors coherence;error trace formal specification model checker hardware design protocol state transitions refinement map coverage information protocol level traces alpha 21364 microprocessor cache coherence protocol;alpha 21364 microprocessor;state transition;microprocessor chips;memory protocols formal specification formal verification microprocessor chips;hardware;protocol level traces;design methodology	We describe a technique for verifying that a hardware design correctly implements a protocol-level formal specification. Simulation steps are translated to protocol state transitions using a refinement map and then verified against the specification using a model checker. On the specification state space, the model checker collects coverage information and identifies states violating certain properties. It then generates protocol-level traces to these coverage gaps and error states. This technique was applied to the multiprocessing hardware of the Alpha 21364 microprocessor and the cache coherence protocol. We were able to generate an error trace which exercised a bug in the implementation that had not been discovered before a prototype was built.	brian;cache coherence;formal specification;microprocessor;model checking;multiprocessing;prototype;refinement (computing);simulation;software bug;state space;tracing (software);verification and validation	Serdar Tasiran;Yuan Yu;Brannon Batson	2003		10.1145/775832.775926	model checking;computer architecture;parallel computing;real-time computing;computer science;formal specification;programming language	Embedded	-38.265452003350106	33.12673584905904	78684
c2eb6c44a327f273d8f63658e8ba3aaa32d4fdfe	cyber-physical systems in industrial process control	control theory;cyber physical systems;large scale;interconnected system;process control;process control system	As a large-scale interconnected system of heterogeneous components integrating computation with physical processes, Cyber-Physical Systems (CPS) can greatly improve the efficiency of industrial process control systems. However, the inherent heterogeneity and the close integration of different components pose new challenges, which can only be solved by a new unifying network and control theory. This article investigates such challenges in industrial process control and proposes a CPS architecture for future research. Some open research issues are also suggested.	computation;control system;control theory;cyber-physical system;open research	Yunbo Wang;Mehmet C. Vuran;Steve Goddard	2008	SIGBED Review	10.1145/1366283.1366295	industrial control system;advanced process control;process control;cyber-physical system	Robotics	-45.397856566309926	37.452305058978624	78747
4f0d6d73792ed93b7eff55280191f378b834cfc0	model-based testing of global properties on large-scale distributed systems	software testing;distributed test architecture;distributed hash table;distributed software;defects;distributed computer systems;trustworthy softwares;model checking;large scale distributed system;open source implementation;experiments;model based testing;experimental validations	Context: Large-scale distributed systems are becoming commonplace with the large popularity of peerto-peer and cloud computing. The increasing importance of these systems contrasts with the lack of integrated solutions to build trustworthy software. A key concern of any large-scale distributed system is the validation of global properties, which cannot be evaluated on a single node. Thus, it is necessary to gather data from distributed nodes and to aggregate these data into a global view. This turns out to be very challenging because of the system’s dynamism that imposes very frequent changes in local values that affect global properties. This implies that the global view has to be frequently updated to ensure an accurate validation of global properties. Objective: In this paper, we present a model-based approach to define a dynamic oracle for checking global properties. Our objective is to abstract relevant aspects of such systems into models. These models are updated at runtime, by monitoring the corresponding distributed system. Method: We conduce real-scale experimental validation to evaluate the ability of our approach to check global properties. In this validation, we apply our approach to test two open-source implementations of distributed hash tables. The experiments are deployed on two clusters of 32 nodes. Results: The experiments reveal an important defect on one implementation and show clear performance differences between the two implementations. The defect would not be detected without a global view of	abstraction layer;aggregate data;assertion (software development);cloud computing;connectivity (graph theory);distributed computing;distributed hash table;elasticity (data store);elegant degradation;experience;experiment;floyd–warshall algorithm;global optimization;information retrieval;java;kermeta;liveness;load testing;model transformation;model-based testing;observable;open-source software;peer-to-peer;reliability engineering;routing;run time (program lifecycle phase);scenario testing;software bug;software testing;strongly connected component;system testing;system under test;test case	Gerson Sunyé;Eduardo Cunha de Almeida;Yves Le Traon;Benoit Baudry;Jean-Marc Jézéquel	2014	Information & Software Technology	10.1016/j.infsof.2014.02.002	model checking;distributed algorithm;model-based testing;computer science;chord;theoretical computer science;software engineering;database;distributed computing;software testing;distributed design patterns	SE	-40.87348194540544	37.96741403718065	78810
89d95154dc155409334e38601d2b777f1b2a0292	understanding and extending autosar bsw for custom functionality implementation		AUTOSAR (Automotive Open System Architecture) is a de factor standard for automotive software development. It addresses crucial topics such as software architecture, application interfaces and development methodology, thereby providing a basic infrastructure for software development. However, the current AUTOSAR standard is too complex to learn and has significant dependence upon tool chains. As a result, it is very difficult to implement custom functionality in BSW (Basic Software) without special support from tool vendors. In this paper, we present how custom functionality can be implemented within AUTOSAR BSW obviating the need for tool vendor’s support. We first examine the internal structure and function of AUTOSAR software stack with an emphasis on the interfaces and execution of BSW modules. We then describe how a new BSW functionality can be incorporated into AUTOSAR BSW. Our approach is illustrated through a simple BSW module implementation with EB tresos AutoCore and Infineon TriCore TC1797.	autosar	Taeho Kim;Ji Chan Maeng;Hyunmin Yoon;Minsoo Ryu	2013		10.1007/978-94-007-6738-6_130	embedded system;computer architecture;real-time computing	NLP	-47.188325472972636	37.273783336228995	78821
75b6b8e1f3f4d2c07148a7d87a959f66528a94fa	web services non-functional classification to enhance discovery speed		Recently, the use and deployment of web services has dramatically increased. This is due to the easiness, interoperability, and flexibility that web services offer to the software systems, which other software structures don't support or support poorly. Web services discovery became more important and research conducted in this area became more critical. With the increasing number of published and publically available web services, speed in web service discovery process is becoming an issue which cannot be neglected. This paper proposes a generic non-functional based web services classification algorithm. Classification algorithm depends on information supplied by web service provider at the registration time. Authors have proved mathematically and experimentally the usefulness and efficiency of proposed algorithm.	algorithm;categorization;experiment;interoperability;non-functional requirement;service discovery;software deployment;software system;web services discovery;web service	Mamoun M. Jamous;Safaai Deris	2011	CoRR		web service;web application security;web development;web modeling;web analytics;web mapping;web design;web standards;computer science;ws-policy;web navigation;social semantic web;data mining;ws-addressing;database;services computing;web intelligence;web engineering;ws-i basic profile;world wide web;universal description discovery and integration	Web+IR	-40.53855379926936	45.79564745715174	78946
597afeeda23ddd92dc210a6f2a78c2e62fd9f8e7	towards self-adaptation on real-world hardware: a preliminary lightweight programming framework	programming framework self adaptive systems embedded systems control loop;acoustics;vehicles embedded systems image color analysis hardware programming acoustics;embedded systems;self adjusting systems embedded systems programming;image color analysis;control loop;vehicles;self adaptive systems;programming;lego mind storms ev3 lightweight programming framework environmental changes real world hardware adaptation mechanism real world embedded systems self adaptive embedded systems;hardware;programming framework	Self-adaptive systems can adapt to environmental changes. In spite of many studies of self-adaptive systems, there are few implementations of them on real-world hardware. One of the main reasons for this is that the existing programming frameworks do not pay enough attention to the constraints on real-world hardware. In this study, we focus on an adaptation mechanism for real-world embedded systems and present a preliminary programming framework to implement self-adaptive embedded systems. As a case study we build a self-adaptive system using our framework on LEGO Mind storms EV3 to demonstrate the feasibility of our framework.	adaptive system;embedded system;mind	Hiroki Tsuda;Hiroyuki Nakagawa;Tatsuhiro Tsuchiya	2015	2015 IEEE 9th International Conference on Self-Adaptive and Self-Organizing Systems	10.1109/SASO.2015.33	embedded system;programming;real-time computing;simulation;reactive programming;computer science;control system;software framework;event-driven programming;inductive programming;management	Embedded	-42.302594881808126	38.198845542272124	78998
4b083d714bed69e8589d9a57e2ff51dad163f1ed	engineering high performance service-oriented pipeline applications with medici	software pipelines;general and miscellaneous mathematics computing and information science;component based systems;service orientation;processing middleware;performance;software systems;soa;computer architecture;software architecture;middleware;software pipelining;component based systms;high throughput;high performance	The pipeline software architecture pattern is commonly used in many application domains to structure a software system. A pipeline comprises a sequence of processing steps that progressively transform data to some desired outputs. As pipeline-based systems are required to handle increasingly large volumes of data and provide high throughput services, simple scripting-based technologies that have traditionally been used for constructing pipelines do not scale. In this paper we describe the MeDICI Integration Framework (MIF), which is specifically designed for building flexible, efficient and scalable pipelines that exploit distributed services as elements of the pipeline. We explain the core runtime and development infrastructures that MIF provides, and demonstrate how MIF has been used in two complex applications to improve performance and modifiability.	service-oriented device architecture	Ian Gorton;Adam Wynne;Yan Liu	2010		10.1007/978-3-642-19394-1_10	high-throughput screening;software pipelining;software architecture;parallel computing;real-time computing;performance;computer science;operating system;software engineering;service-oriented architecture;middleware;database;software system	HPC	-37.88591976108329	37.171357416762255	79502
31ae78b827608964f9a96bdf61fc6db95d099c22	reliable software-based control as enabler for flexible production systems		The current evolution of the industrial production systems to cyber physical production systems requires an increased flexibility of the system structure that is nowadays still difficult to find in the industrial systems. The control applications are extremely strict by requiting jitter-free communication of sensor and control values in networked control systems. The software-based control approach presented here enhances the reliability of the control system using a control valuematrix as information source. This approach benefits of predictive control algorithms that rely on model-based strategies.	algorithm;automation;bandwidth (signal processing);cloud computing;co-simulation;coexist (image);control system;control theory;information source;loose coupling;mathematical model;network function virtualization;non-functional requirement;simulation	Santiago Soler Perez Olaya;Stefan Matzler;Martin Wollschlaeger	2017	Automatisierungstechnik	10.1515/auto-2017-0089	control engineering;engineering;computer engineering;software	Robotics	-45.48926383324795	37.48086712225987	79867
7bacbfa30c7b370f4d2ef2538f1c2432602a233f	"""a """"smart bedroom"""" as an active database system"""	aal;home computing;geriatrics;smart bedroom ambient assisted living system smart homes architecture software technologies heterogeneous hardware resource adapters home environment actuators sensors active rules smart environment development care delivery age older people home based healthcare technologies active database system;active database system;healthcare;elektroteknik och elektronik;sensors;electrical engineering electronic engineering information engineering;software architecture active databases assisted living building management systems geriatrics home computing sensors;assisted living;software architecture;databases intelligent sensors actuators monitoring biomedical monitoring computer architecture;building management systems;active databases;dbms;system architecture;system architecture smart environments dbms active databases aal healthcare;smart environments	"""Home-based healthcare technologies aim to enable older people to age in place as well as to support those delivering care. Although a number of smart homes exist, there is no established method to architect these systems. This work proposes the development of a smart environment as an active database system. Active rules in the database, in conjunction with sensors and actuators, monitor and respond to events taking place in the home environment. Resource adapters integrate heterogeneous hardware and software technologies into the system. A """"Smart Bedroom"""" has been developed as a demonstrator. The proposed approach represents a flexible and robust architecture for smart homes and ambient assisted living systems."""	as-interface;active database;authentication;event condition action;interoperation;java ee connector architecture;living systems;machine learning;postgresql;responsiveness;scalability;smart environment;statistical model;systems architecture;usability	Wagner Ourique de Morais;Nicholas Wickström	2013	2013 9th International Conference on Intelligent Environments	10.1109/IE.2013.29	embedded system;simulation;architectural engineering;engineering;smart environment;internet of things	Robotics	-41.53592566448698	44.77728254227855	79901
fe332233601ad049e235718d11bf42203941787a	modeling and analysis of safety in early design	system design;functional analysis	In this paper we present a method of explicit inclusion of safety into a model-based design method for cyberphysical systems. This approach enables an analysis where component-level failures can be mapped to potential system-level hazards. Application of this work presents several significant advances to the fields of safety engineering and design. This paper present a method of representing the safety property of a system by the introduction of the concept called the Further, the function of achieving safety is mapped to the performance functions of the system. We present a process of concurrently developing a system concept from the safety and functional perspective. The end result of this process is a system architecture where components of the system are explicitly mapped to both the functions they perform and the role it plays in ensuring safe system operation. The benefit of this approach is having a system representation that allows for analysis of critical events and offnominal component behavior to identify potential losses in function and safety constraint violations. The approach is demonstrated on a software controlled hardware system. Namely, a generic spacecraft reaction control system. © 2013 The Authors. Published by Elsevier B.V. Selection and/or peer-review under responsibility of Georgia Institute of Technology.	concurrent computing;control system;hazard (computer architecture);safety engineering;systems architecture	David C. Jensen;Irem Y. Tumer	2013		10.1016/j.procs.2013.01.086	software;data mining;reaction control system;reliability engineering;systems design;systems architecture;functional analysis;computer science;safety property;safety engineering	Robotics	-44.62668737344646	34.311891937387884	80069
1c57bd46cd1239753f04e4d8c1b53e99682fa9a9	the fluid computing middleware: bringing application fluidity to the mobile internet	model view controller;data structure fluid computing middleware model view controller design pattern application programming interface data management service mobile internet java mobile computing;optimistic replication;real time;data management;computer applications middleware mobile computing internet programming profession data flow computing fluid flow data structures computer networks collaboration;data replication;object oriented programming;internet;design pattern;java internet mobile computing middleware object oriented programming;middleware;mobile computing;mobile internet;data structure;java	The fluid computing middleware allows application data to flow, as a liquid, between devices. The middleware, based on the model-view-controller design pattern, transforms a collection of devices into a cooperative platform and provides application programmers with appropriate abstractions to use generic data management services, such as data replication and synchronization of arbitrary data structures. Relieved from managing this underlying complexity, programmers can focus on developing new application functionality. In particular, they can program applications that seamlessly transition between devices and connectivity degrees, by relying on the fluid real-time optimistic replication mechanism. By shifting the focus from the network and devices to the data, fluid computing enables new interaction paradigms, where users can access and manipulate their data from any of their devices transparently. Applications, then, become multidevice - a characteristic that can be applied to both single-user and collaboration scenarios.	complexity;data structure;middleware;model–view–controller;multi-user;optimistic replication;programmer;programming paradigm;real-time clock;replication (computing);software design pattern	Daniela Bourges-Waldegg;Yann Duponchel;Marcel Graf;Michael Moser	2005	The 2005 Symposium on Applications and the Internet	10.1109/SAINT.2005.63	real-time computing;the internet;data structure;data management;computer science;operating system;middleware;database;distributed computing;design pattern;programming language;object-oriented programming;model–view–controller;java;mobile computing;world wide web;replication;computer network	Embedded	-34.53060770325034	44.45474631743057	80104
34cd29052c208b7deff61644041d3497ad38f107	a distributed architecture for internet robot	internet robot kinematics intelligent robots robot sensing systems computer architecture ip networks distributed computing intelligent sensors computer networks robot control;intelligent robots;distributed networks;distributed computing;mobile robots;ad hoc networks intelligent robots telerobotics internet local area networks mobile robots control engineering computing;internet;networked robot system internet robot distributed network architecture intelligent robot lan based robot system distributed perception network resources generic distributed robotic framework hybrid robotic architecture autonomous robot distributed network structure distributed computing infrastructure ad hoc connection mechanism pnp connection mechanisms distributed computation distributed information;telerobotics;ad hoc networks;control engineering computing;autonomous robot;local area networks;distributed architecture;distributed robotics	This paper describes a novel distributed networked architecture for an intelligent robot. It is proposed to address two challenges for an Internet/LAN based robot system: (1) how to utilize the networked resources of perception and computation, and (2) how to realize a dynamic structured and updateable robotic system. In this architecture, a generic distributed robotic framework evolved from hybrid robotic architecture is proposed, to integrate an autonomous robot into a distributed network structure. A distributed computing infrastructure and the spontaneous and PnP connection mechanisms are realized, which implement the scheme of distributed computation and information for the networked robot system.	autonomous robot;code;cognitive robotics;computation;distributed computing;distributed object;internet;java;legacy plug and play;sensor;spontaneous order	Xueqiao Hou;Jianbo Su	2004	IEEE International Conference on Robotics and Automation, 2004. Proceedings. ICRA '04. 2004	10.1109/ROBOT.2004.1308772	local area network;telerobotics;control engineering;wireless ad hoc network;mobile robot;distributed algorithm;the internet;simulation;computer science;artificial intelligence;distributed computing;distributed system security architecture;ubiquitous robot;personal robot	Robotics	-38.035271456950355	43.53282954220789	80245
031b36b53b1030fc07d6ae57fba000907ecec374	time-outing internet services	response time internet services web services time outs dependability uncertainty cloud computing performance benchmarks error recovery fault tolerance intrusion tolerance availability;error recovery;availability;uncertainty;web and internet services;network security;performance benchmarks;response time;internet;fault tolerance;dependability;web services;intrusion tolerance;internet services;software reliability;time outs;cloud computing	Uncertainty and response time instability can affect invoked Web services' usability, performance, trustworthiness, and dependability. To resolve uncertainty, researchers have applied a three-pronged approach. First, they remove uncertainty through advances in data collection, response time measurement, and benchmarking. Second, they employ a mathematical foundation for modeling uncertainty. Finally, they improve fault-tolerance techniques by making well-considered choices of time-outs and trade-offs between cost, availability, trustworthiness, and performance.	computer performance;dependability;fault tolerance;instability;response time (technology);trust (emotion);usability;web service	Anatoliy Gorbenko;Alexander Romanovsky	2013	IEEE Security & Privacy	10.1109/MSP.2013.43	web service;availability;intrusion tolerance;fault tolerance;real-time computing;the internet;uncertainty;cloud computing;computer science;network security;dependability;response time;computer security;software quality	Metrics	-47.95210716298078	40.558351048802606	80351
0289348d7f7de620d3fc5cdf0a1c6b16da286f24	a mdd methodology for specification of embedded systems and automatic generation of fast configurable and executable performance models	performance;design;languages;standardization	This paper presents the COMPLEX UML/MARTE modeling methodology and its related framework for automatic generation of executable performance models. The modeling methodology supports Model-Driven Development (MDD), required by industrial flows, and a novel set of modeling features specifically suitable for Design Space Exploration (DSE), a crucial design activity. The COMPLEX framework has other advantages for DSE. The COMPLEX tooling enables the automatic generation of an executable and configurable model for fast performance analysis without requiring engineering effort. The COMPLEX tooling automates the production of an easily portable text-based representation of the UML/MARTE model. This representation is read by the underlying simulation infrastructure, which automatically builds a fast performance model supporting the evaluation of different configurations of the system. An important aspect of this performance analysis framework is that it supports a system-level text-based front-end, which is produced from the COMPLEX UML/MARTE model, and which avoids the development of SW implementations, HW refinements, or the implementation of HW/SW interfaces. Moreover, neither code regeneration, nor recompilation is required for any DSE iterations, and thus, the time taken in the exploration is mostly due to model simulation.	design space exploration;embedded system;executable;high- and low-level;iteration;model-driven engineering;model-driven integration;modeling and analysis of real time and embedded systems;profiling (computer programming);simulation;text-based (computing);unified modeling language	Fernando Herrera;Héctor Posadas;Pablo Peñil;Eugenio Villar;Francisco Ferrero;Raúl Valencia	2012		10.1145/2380445.2380527	embedded system;computer architecture;real-time computing;computer science	HPC	-42.30757744397938	33.92836676465193	80364
051c283190e0563ca24cb9e2d38d1ee9349c0ec1	automated prototyping tool-kit (apt)	psdl;automated prototyping;software tool;components;real time;formal methods;reuse;formal method;control system;hard real time system;apt;command and control;community structure;reusable component;architecture;flight control;domain specificity;embedded software;real time systems;evolution;time constraint	Automated prototyping tool-kit (APT) is an integrated set of software tools that generate source programs directly from real-time requirements. The APT system uses a fifth-generation prototyping language to model the communication structure, timing constraints, I/O control, and data buffering that comprise the requirements for an embedded software system. The language supports the specification of hard real-time systems with reusable components from domain specific component libraries. APT has been used successfully as a research tool in prototyping large war-fighter control systems (e.g. the command-and-control station, cruise missile flight control system, patriot missile defense systems) and demonstrated its capability to support the development of large complex embedded software.		Nader Nada;Man-tak Shing;Valdis Berzins;Luqi	2002	Inf. Sci.	10.1016/S0020-0255(01)00174-8	embedded system;command and control;requirements analysis;real-time computing;simulation;formal methods;embedded software;computer science;architecture;evolution;reuse;community structure	HCI	-38.88266806198213	33.238843270277776	80438
4edcc518f722558c9446580da222715e33378565	decision-making framework for user-based inter-cloud service migration	inter cloud vm migration;qos;cloud service management;mcdm;cloud computing;service migration	Cloud computing has rapidly become the most effective computing paradigm for today’s increasingly technology-dependent society. The emerging concepts of federated clouds with support for interoperability between different cloud providers and open standards in cloud middleware have opened up new challenges in cloud service management. One of the emerging research areas in cloud computing is the possibility of live virtual machine migration between different clouds. This is of importance when the quality of a cloud service currently used by a user degrades or a new cloud service is developed which is better in terms of quality, performance and cost than the current service being used. In such scenarios, the user needs to make a decision as to whether to continue with the currently used service or migrate to the newly available service. In our previous work, we presented a decision-making approach that assists a cloud service user in selecting a cloud service provider based on the QoS of its services. In this paper, we extend our previous work in the pre-interaction time phase and discuss the decision-making process involved in the migration from one cloud service to another cloud service through inter-cloud virtual machine migration. 2015 Elsevier B.V. All rights reserved.	cloud computing;elegant degradation;federated identity;interoperability;middleware;preference ranking organization method for enrichment evaluation;programming paradigm;quality of service;throughput;virtual machine;z/vm	Zia ur Rehman;Omar Khadeer Hussain;Elizabeth Chang;Tharam S. Dillon	2015	Electronic Commerce Research and Applications	10.1016/j.elerap.2015.08.002	cloud computing security;service level requirement;service catalog;simulation;quality of service;cloud computing;differentiated service;computer science;service delivery framework;cloud testing;data as a service;multiple-criteria decision analysis;world wide web;computer security	HPC	-47.98933124089039	43.55593863550334	80789
e86b5286c4e3584d81b4a6d92b6821607d671eac	a mechanism for real-time decision making and system maintenance for resource constrained robotic systems through refresh	refresh;fault detection and location;system maintenance;fault mitigation	Robot operating environments and the status of robots are complex and varying, so it is practically impossible for a robotics designer to anticipate all system configurations to successfully complete a task prior to deployment. Therefore, a mechanism for dynamic decision making and configuration synthesis that copes with system fault and uncertainty is necessary. This paper implements such a mechanism within a self-adaptive framework (ReFrESH). The goal of this presented mechanism is to provide diagnosability and maintainability to manage the system performance during task execution in the presence of unexpected uncertainties. Specifically, the functionality of the proposed mechanism include: (1) detection of system performance degradation; (2) diagnosis and locate of the fault module; (3) synthesis of feasible task configurations; (4) selection of the optimal one. We illustrate the feasibility of the proposed mechanism through a visual servoing task.	real-time transcription;robot	Yanzhe Cui;Richard M. Voyles;Joshua T. Lane;Akshay Krishnamoorthy;Mohammad H. Mahoor	2015	Auton. Robots	10.1007/s10514-015-9472-x	real-time computing;simulation	Robotics	-43.497946164475174	38.28317208306215	80880
2f25016af715775d2d28ae41b7a1a79a0fe9756c	development of a smart sensor system using opc ua		In this paper, a smart sensor system using the IEC 62541 standard, which represents the international standard of OPC UA is designed and developed. OPC-UA is defined as a communication standard for smart grids and smart factories, and it extends the scope of its usage by collaborating with many other standards. Currently, most of the factories in Korea have CNCs without communication functions and are mainly used to send and receive the processed files using FTP. Therefore, a smart sensor is required to secure the data required for the configuration of the smart factory. The smart sensor manufactured in this paper can be installed independently and easily applied to the smart factory management system because the OPC-UA communication middle-ware is sitting atop of it. Later, if necessary, the manufactured smart sensor system can be used to control specific equipment.	edge computing;electrical engineering;intelligent control;opc unified architecture;open platform communications;sampling (signal processing);sensor;smart board;smart transducer;user agent;warez	SeongJoon Lee;ChunKyung Kim;JaeDuck Lee	2017		10.1145/3151848.3156475	computer network;computer science;smart grid;management system;file transfer protocol;factory;international standard	Robotics	-35.14563698166548	39.046151810750544	81183
83ed6c131c7ba2d1a6716b5baa60883cb6b696d4	ovid: a software-defined distributed systems framework to support consistency and change		We present Ovid, a framework for building large-scale distributed systems that have to support strong consistency and at the same time need to be able to evolve quickly as a result of changes in their functionality or the assumptions they made for their initial deployment. In practice, organic growth often makes distributed systems increasingly more complex and unmanageable. To counter this, Ovid supports transformations, automated refinements that allow distributed systems to be developed from simple components. Examples of transformations include replication, batching, sharding, and encryption. Refinement mappings prove that transformed systems implement the specification. The result is a software-defined distributed system, in which a logically centralized controller specifies the components, their interactions, and their transformations. Such systems can be updated on-the-fly, changing assumptions or providing new guarantees while keeping the original implementation of the application logic unchanged.	agent-based model;business logic;centralized computing;correctness (computer science);distributed computing;encryption;interaction;prototype;python;refinement (computing);replication (computing);shard (database architecture);software deployment;strong consistency	Deniz Altinbüken;Robbert van Renesse	2016	IEEE Data Eng. Bull.		data mining;database;software;computer science	OS	-40.4031886489216	38.6164661092982	81253
63a82d5a186b42efeee918789960c284b6c482bc	social awareness in pervasive communities for collaborative work		Future pervasive environments will take into consideration physical and digital social relations. Nowadays it is important use to collective intelligence, where the interpretation of context information can be harnessed as input for context-aware applications, especially for group collaboration. The use of collective intelligence represents new possibilities but also new challenges in terms of collective information for adaptability and personalization in intelligent environments. This paper presents a collaborative context-aware framework focusing on social matching capabilities for session formation in collaborative activities.	collective intelligence;intelligent environment;personalization;pervasive informatics	Christopher Lima;Mário Antunes;Diogo Gomes;Rui L. Aguiar	2013		10.3233/978-1-61499-286-8-110	ubiquitous computing;business;environmental resource management;social consciousness;knowledge management	HCI	-42.11421921186462	45.624309494746974	81441
64ab510d8b84510454c60533d2092d08185a2aa7	an approach on service component selection and analysis of the resulting system reliability	software;system reliability;reliability;availability;hierarchical automata;service component selection;soa;automata software reliability availability logic gates software service oriented architecture;automata;software architecture;logic gates;reliability service oriented architecture service component selection dependability hierarchical automata;hierarchical automata service component selection system reliability service oriented architecture soa;dependability;automata theory;quality criteria;software reliability automata theory software architecture;service oriented architecture;software reliability	Components can be assembled based on the Service-Oriented Architecture (SOA), which allows enterprises to specify their services in a finer granularity, thus the services can be expressed in a deeper and more comprehensive manner. This paper makes use of the formal description of the service component, the Hierarchical Automata, studies the importance factors of each component and roughly categorizes them into different rankings, which reflect different component quality criteria (i.e. availability, reliability and dependability within the scope of this discussion, refer to Section 3.2), through mapping functions, and thus the appropriate components can be selected based on their importance factors and quality parameters, and then proposes an algorithm to calculate the resulting system reliability, and finally studies a case to demonstrate the selection of components and the resulting reliability.	algorithm;automaton;dependability;service-oriented architecture;service-oriented device architecture	Lin Xi;Qinglei Zhou;Linlin Xie	2010	2010 10th IEEE International Conference on Computer and Information Technology	10.1109/CIT.2010.225	real-time computing;computer science;service-oriented architecture;database	Robotics	-47.02984881378898	38.92440794718877	81508
0992cf5d62270be5c0dd4a800eab903b73d7ec64	a multi-level approach to the dependability analysis of networked systems based on the can protocol	traffic engineering computing automotive electronics vehicle dynamics road safety controller area networks protocols;automotive electronics;protocols;structural model;dependence analysis;can bus;controller area networks;automotive;vehicle dynamics multilevel approach dependability analysis networked systems can protocol safety critical applications digital components mechanical components automotive fields complex tasks functional models;level of detail;levels of abstraction;functional model;traffic engineering computing;road safety;networked systems;fault injection;vehicle dynamics;protocols automotive engineering computer network reliability computer networks vehicle dynamics application software permission fault diagnosis information analysis testing	Safety-critical applications are now common where both digital and mechanical components are deployed, as in the automotive fields. The analysis of the dependability of such systems is a particularly complex task that mandates modeling capabilities in both the discrete and in the continuous domains. To tackle this problem a multi-level approach is presented here, which is based on abstract functional models to capture the behavior of the whole system, and on detailed structural models to cope with the details of system components. In this paper we describe how the interaction between the two levels of abstraction is managed to provide accurate analysis of the dependability of the whole system. In particular, the proposed technique is shown to be able to identify faults affecting the CAN network whose effects are most likely to be critical for vehicle's dynamic. Exploiting the information about the effects of these faults, they can then be further analyzed at the higher level of details.	abstract data type;dependability;experiment;fault injection;principle of abstraction	Fulvio Corno;Julio Pérez Acle;Matteo Sonza Reorda;Massimo Violante	2004	Proceedings. SBCCI 2004. 17th Symposium on Integrated Circuits and Systems Design (IEEE Cat. No.04TH8784)	10.1145/1016568.1016593	embedded system;communications protocol;electronic engineering;real-time computing;vehicle dynamics;simulation;can bus;computer science;engineering;function model;operating system;level of detail;dependence analysis	Embedded	-46.07695849293549	33.825689568888826	81602
4e40039e2216979d394d30d0a9cc3832faa515e6	managing things and services with semantics: a survey	protocols;semantics protocols industries monitoring interoperability zigbee logic gates;semantics;industries;000 computer science knowledge systems;510 mathematics;logic gates;monitoring;zigbee;interoperability	This paper presents a survey on the usage, opportunities and pitfalls of semantic technologies in the Internet of Things. The survey was conducted in the context of a semantic enterprise integration platform. In total we surveyed sixty-one individuals from industry and academia on their views and current usage of IoT technologies in general, and semantic technologies in particular. Our semantic enterprise integration platform aims for interoperability at a service level, as well as at a protocol level. Therefore, also questions regarding the use of application layer protocols, network layer protocols and management protocols were integrated into the survey. The survey suggests that there is still a lot of heterogeneity in IoT technologies, but first indications of the use of standardized protocols exist. Semantic technologies are being recognized as of potential use, mainly in the management of things and services. Nonetheless, the participants still see many obstacles which hinder the widespread use of semantic technologies: Firstly, a lack of training as traditional embedded programmers are not well aware of semantic technologies. Secondly, a lack of standardization in ontologies, which would enable interoperability and thirdly, a lack of good tooling support.	embedded system;enterprise integration;integration platform;internet of things;interoperability;ontology (information science);programmer	Matthias Thoma;Torsten Braun;Carsten Magerkurth;Alexandru-Florian Antonescu	2014	2014 IEEE Network Operations and Management Symposium (NOMS)	10.1109/NOMS.2014.6838366	semantic interoperability;communications protocol;interoperability;semantic integration;logic gate;telecommunications;computer science;knowledge management;data mining;database;semantics;computer security	Mobile	-43.301142398017774	46.326461890240296	81632
d2df657eda21c46814721dd7117ac44cb152dca6	user constraints for reliable user-defined smart home scenarios	reliability;smart home;formal methods;graphical user interface;user defined scenarios;safety	Defining control scenarios in a smart home is a difficult task for end users. In particular, one concern is that user-defined scenarios could lead to unsafe or undesired state of the system. To help them explore scenario specifications, we propose in this paper a system that enables specification of constraints restricting the control commands that can be used inside user-defined scenarios. The system is based on timed automata model checking abstracted by event condition action rules. A prototype was implemented, including a user interface to interact with the user. The usability of the system and interface was evaluated in a user study which results are reported here.	as-interface;automata theory;cobham's thesis;complexity;environment variable;event condition action;formal methods;formal specification;formal verification;graphical user interface;home automation;intelligent environment;liveness;logic programming;model checking;prototype;requirement;sensor;state space;statistical model;timed automaton;usability testing	Thibaut Le Guilly;Michael Nielsen;Thomas Pedersen;Arne Skou;Jesper Kjeldskov;Mikael B. Skov	2016	Journal of Reliable Intelligent Environments	10.1007/s40860-016-0020-z	user interface design;embedded system;user;real-time computing;simulation;formal methods;computer science;reliability;graphical user interface;programming language;user interface;statistics	HCI	-44.31826391531959	35.44178030538598	81718
770c3b9707a5fa94540556e6c63875bb54f1a287	a template system for modeling and verifying agent behaviors		The spread of Cyber-Physical Systems (CPSs) leads developers to embed various agents in a large system. It is a complicated and difficult task to analyze and design such systems from comprehensive specifications such as an architecture document because many behaviors of many components including agents must be dealt with. In such a system, the appropriateness of interactions between components should be ensured. However, no method to efficiently define and verify behaviors in such interactions from such specifications taking into consideration the characteristics of CPSs has been proposed. To improve this situation, this paper preliminarily proposes a stepwise method to define and verify behaviors in interactions between CPS components. More specifically, a template system to stepwise define behaviors from an abstract level to a concrete level is presented based on an existing architecture modeling method. Furthermore, a model transformation tool for verifying such behavior definitions by using the model checking tool NuSMV is introduced.		Shinpei Ogata;Yoshitaka Aoki;Hiroyuki Nakagawa;Kazuki Kobayashi	2018		10.1007/978-3-030-03098-8_44	systems engineering;architecture;model checking;cyber-physical system;model transformation;distributed computing;architectural model;computer science	AI	-42.3775819443479	32.88275648046482	81732
b0bff691246ac2c99d94fa85c759e3d86c4c7e2c	extending swarm communication to unify choreography and long-lived processes		The usual way of doing message passing is to have relatively intelligent processes, objects or actors sending and receiving dumb messages. Swarm communication presents the inverted approach of thinking to messages as relatively smart beings, visiting relatively non intelligent places, to produce better code and a new path for integrating complex applications. Swarm communication can be used as software architecture for an Enterprise Service Bus. This paper extends the swarm communication to support long-lived processes, providing an alternative approach to the standard techniques for executable Business Process Management. The ubiquity of connected devices is a fertile ground for new approaches to application development and systems integration based on complex business processes.	business process;distributed computing;distributed transaction;enterprise service bus;executable;futures studies;kerrison predictor;message passing;requirement;run time (program lifecycle phase);scalability;software architecture;software system;swarm;system integration;waits	Lenuta Alboaie;Sinica Alboaie;Tudor Barbu	2014			message passing;swarm behaviour;simulation;system integration;business process;software architecture;business process management;executable;distributed computing;computer science;enterprise service bus	SE	-38.67197772000744	41.09006632651129	81799
96ba39f06b649313322e2c960d6417cf3941f24a	adaptive distributed embedded and real-time java systems based on rtsj	software;service oriented component models adaptive distributed embedded java systems adaptive distributed real time java systems rtsj based profiles programming technology distributed safety critical systems dynamic software modification bug fixing;air traffic control;components;memory management;service orientation;real time;distributed processing;resource manager;resource management;service oriented architecture adaptive systems distributed processing embedded systems java object oriented programming program debugging safety critical software;object oriented programming;software engineering;software engineering real time java adaptive systems components;embedded systems;servers;adaptive systems;real time systems java software memory management resource management servers;safety critical software;adaptive system;safety critical system;component model;real time java;program debugging;dynamic characteristic;service oriented architecture;java;real time systems	Java is a programming technology which has been extended in order to provide the timeliness required by real-time systems (e.g., RTSJ). There are two RTSJ-based profiles: DRTSJ supporting distributed real-time Java systems and SCJS supporting the development of programs that must be certified. However neither of them considers dynamics characteristics allowing the system to be adapted to the changing environment. Distributed safety-critical systems that must provide continuous service (e.g., air-traffic control systems or enterprise and financial applications) require dynamic updates. Dynamic software modification is a useful capability because the application is able to update itself to fix bugs and add new features without requiring a stop and a restart. In this paper, we overview Java solutions considering real-time requirements in service-oriented component models allowing dynamics updates (e.g., OSGi).	control system;osgi;real time java;real-time clock;real-time computing;real-time transcription;real-time web;requirement;service-oriented software engineering;software bug	M. Teresa Higuera-Toledano	2012	2012 IEEE 15th International Symposium on Object/Component/Service-Oriented Real-Time Distributed Computing Workshops	10.1109/ISORCW.2012.37	embedded system;real-time computing;computer science;resource management;adaptive system;operating system;air traffic control;service-oriented architecture;component object model;distributed computing;real time java;programming language;object-oriented programming;java;server;memory management	Embedded	-38.61722775519106	39.621121512703056	82004
7ee0f2b64bad75150ca8921c46e3158f8c861537	soppa - service oriented p2p framework for digital libraries	service orientation;digital library;p2p	P2P and SOA paradigms provide new opportunities for the development of new digital libraries and the redesign of existing ones. This paper describes the work being conducted to create a framework for the creation of digital libraries, which relies on a P2P network and service-enabled peers to achieve high modularity, reusability and performance in dynamic environments. While this framework supports data and metadata storage and management, this paper focuses on its service oriented approach.		Marco Fernandes;Pedro Almeida;Joaquim Arnaldo Martins;Joaquim Sousa Pinto	2008			digital library;computer science;peer-to-peer;database;world wide web	Web+IR	-36.617856713440396	43.667427206927904	82154
ef5f9fe07c25ca20253bd78b7cbc87b2026bf3e4	formal verification for embedded systems design based on mde	automatic generation;embedded system;formal verification;embedded system design;model driven engineering;temporal properties;timed automata;sequence diagram	This work presents a Model Driven Engineering (MDE) approach for the automatic generation of a network of timed automata from the functional specification of an embedded application described using UML class and sequence diagrams. By means of transformations on the UML model of the embedded system, a MOF-based representation for the network of timed automata is automatically obtained, which can be used as input to formal verification tools, as the Uppaal model checker, in order to validate desired functional and temporal properties of the embedded system specification. Since the network of timed automata is automatically generated, the methodology can be very useful for the designer, making easier the debugging and formal validation of the system specification. The paper describes the defined transformations between models, which generate the network of timed automata as well as the textual input to the Uppaal model checker, and illustrates the use of the methodology with a case study to show the effectiveness of the approach.	algorithm;automata theory;dataflow;debugging;embedded system;formal verification;functional specification;meta-object facility;metamodeling;model checking;model-driven engineering;sequence diagram;systems design;timed automaton;uppaal;unified modeling language	Francisco Assis M. do Nascimento;Marcio F. da S. Oliveira;Flávio Rech Wagner	2009		10.1007/978-3-642-04284-3_15	embedded system;real-time computing;formal verification;computer science;programming language	Embedded	-40.981259178748076	32.59374187080505	82341
65733ec590d363ef58bc46949a44d0543069f6cb	a toolkit to design adaptable user interfaces in ubiquitous computing environments	media oriented applications;dynamic change;visual c;physical user interfaces;mobile device;application software;building block;user interface;media rendering service;home appliances;generic interface functionality;web presence manager distributed platform;digital cameras;adaptive components;computer architecture;software architecture;graphical user interfaces;user interfaces ubiquitous computing application software computer architecture rendering computer graphics home appliances software tools cellular phones digital cameras computer interfaces;dynamically changing context;software architecture software tools ubiquitous computing graphical user interfaces;software component models;media rendering service mobile devices media oriented applications software component models adaptive components reusable building block dynamically changing context generic interface functionality media services control physical user interfaces visual c web presence manager distributed platform;software component;ubiquitous computing;software tools;media services control;adaptive user interface;rendering computer graphics;computer interfaces;reusable building block;user interfaces;mobile devices;cellular phones;ubiquitous computing environment	We describe an architecture to support the rapid development of software applications for mobile devices that can discover and adapt to resources in the environment of the user. To narrow the scope of our research, we focus on media-oriented applications involving the rendering, capture and control of pictures, audio or video. Inspired by the success of software component models, we introduce the concept of adaptive components. An adaptive component is a reusable building block that can discover and adapt to a dynamically changing context to deliver a generic interface functionality. Examples of such functionalities include the capture or playback of various types of media and the control of media services via physical user interfaces or graphical ones. We detail an early implementation of our architecture using Visual C#, UPnP and the Web presence manager distributed platform. We present how we used this implementation to create a simple media rendering service.	complex adaptive system;component-based software engineering;graphical user interface;image;mobile device;ubiquitous computing;universal plug and play;web presence	Philippe Debaty	2004	IEEE Annual Conference on Pervasive Computing and Communications Workshops, 2004. Proceedings of the Second	10.1109/PERCOMW.2004.1276926	embedded system;human–computer interaction;computer science;operating system;mobile device;multimedia;user interface;ubiquitous computing	Visualization	-37.06579536564812	41.51957620410375	82361
037569aed527a609a0c743dcc3773a675a858ffc	position summary: supporting disconnected operation in doors	distributed system;groupware;disconnected operation;asynchronous collaboration;data type portable computers disconnected operation support doors distributed object store asynchronous collaboration servers object replication epidemic propagation model clients shared data modification log based system;client server systems;data type;distributed objects;portable computers;file servers collaboration portable computers distributed computing computer architecture application software concurrent computing concurrency control mobile communication network servers;distributed object management;data access;groupware portable computers client server systems distributed object management;structured documents	The increasing popularity of portable computers opens the possibility of collaboration among multiple distributed and disconnected users. In such environments, collaboration is often achieved through the concurrent modification of shared data. DOORS is a distributed object store to support asynchronous collaboration in distributed systems that may contain disconnected computers. In this summary we focus on the mechanisms to support disconnected operation. The DOORS architecture is composed by servers that replicate objects using an epidemic propagation model. Clients cache key objects to support disconnected operation. Users run applications to read and modify the shared data (independently from other users) – a read any/write any model of data access is used. Modifications are propagated from clients to servers and among servers as sequences of operations – the system is log-based. Objects are structured according to an object framework that decomposes object operation in several components (figure 1). Each component manages a different aspect of object execution. Each object represents a datatype (e.g. a structured document) and it is composed by a set of sub-objects. Each sub-object represents a subpart of the data-type (e.g. sections). A new object is created composing the set of subobjects that store the type-specific data with the adequate implementations of the other components. The following main characteristics are the base to support disconnected operation in DOORS. Multiple concurrency control/reconciliation strategies: To support the different requirements posed by multiple data-types we rely on the flexibility provided by the DOORS object framework. The concurrency control component allows the use of different log-based reconciliation strategies. The capsule component allows the definition of different data configurations – e.g. the tentative and committed versions of an object can be easily maintained duplicating the adequate components under the control of the capsule. Integrated awareness support: The reconciliation among concurrent streams of activity is often performed when users are no longer connected to the system. In DOORS, awareness information may be generated and processed during the reconciliation phase – this approach makes it possible, for example, to provide shared feedback about data evolution and/or to explore off-system communication infrastructures, such as the use of SMS messages.	cpu cache;concurrency (computer science);concurrency control;optimistic replication;rational doors	Nuno M. Preguiça;José Legatheaux Martins;Sergio N. Duarte;Henrique João L. Domingos	2001		10.1109/HOTOS.2001.990095	data access;real-time computing;data type;computer science;operating system;database;distributed computing;data transfer object;distributed object;portable object	DB	-33.96454030179498	41.44904454930222	82666
75ceef2599803f30920ae45df86a2c099117e0b9	building pattern charts and fault trees for reliability, availability and maintainability analysis	fault tree		chart;fault tree analysis	Cornel Resteanu;Florin G. Filip;Teodor-Sorin Stanescu;Adrian Mihailescu	1998			reliability engineering;real-time computing;systems engineering	Logic	-46.925556712817745	32.48126774715299	82724
8a8f8a25862f1df94f00a228dabbc82e0f4f5276	a strategy to verify chassis controller software-dynamics, hardware, and automation	automatic control;automated testing;automotive engineering;software testing;instruments;regression testing;laboratory equipment;instrumentation;automobiles;hardware computational modeling automatic testing automatic control computer simulation automotive engineering computer interfaces instruments automation software testing;simulator requirements;real time;automatic testing;program verification;simulation software;computational modeling;statistical analysis;hardware in the loop;simulator requirements chassis controller software verification real time hardware in the loop tool set automotive chassis controller testing high speed computers specialized hardware interfaces instrumentation laboratory equipment simulation software script files test suites regression testing;chassis controller software verification;automotive chassis controller testing;statistical analysis automatic testing automobiles program verification transport control real time systems;high speed computers;script files;transport control;computer interfaces;real time hardware in the loop tool set;test suites;simulation model;computer simulation;high speed;specialized hardware interfaces;hardware;real time systems;automation	A real-time hardware-in-the-loop tool set is presented to test automotive chassis controllers. The use of highspeed computers, specialized hardware interfaces, and instrumentation, as well as simulation models and automation software, provide a realistic and repeatable laboratory environment to supplement in-vehicle testing. In this paper, the dynamics for a variety of chassis models are presented to support the verification of integrated controller hardware and software. To implement these mathematical descriptions the computer hardware, laboratory equipment, and simulation software are discussed. The automated testing features of the simulator permit the creation of script files and test suites for regression testing and reuse on similar programs. A number of issues such as simulator requirements, hardware interfaces, and the need for metrics are explored in order to facilitate the development and justification of a simulation capability.	chassis;computer hardware;electrical connector;hardware-in-the-loop simulation;integrated circuit;real-time transcription;regression testing;requirement;simulation software;test automation	John R. Wagner;John F. Keane	1997	IEEE Trans. Systems, Man, and Cybernetics, Part A	10.1109/3468.594914	computer simulation;hardware compatibility list;embedded system;regression testing;simulation;simulation software;computer science;automation;simulation modeling;automatic control;hardware architecture;software testing;computational model;instrumentation	Embedded	-37.84544072989992	34.316801522052096	82760
c0896abdd82e971f11b864db12409f51c7903794	smart: an application reconfiguration framework	masterthesis;virtual appliance;automatic application configuration	SmART (Smart Application Reconfiguration Tool) is a framework for the automatic configuration of systems and applications. The tool implements an application configuration workflow that resorts to the similarities between configuration files (i.e., patterns such as parameters, comments and blocks) to allow a syntax independent manipulation and transformation of system and application configuration files. Without compromising its generality, SmART targets virtualized IT infrastructures, configuring virtual appliances and its applications. SmART reduces the time required to (re)configure a set of applications by automating time-consuming steps of the process, independently of the nature of the application to be configured. Industrial experimentation and utilization of SmART show that the framework is able to correctly transform a large amount of configuration files into a generic syntax and back to their original syntax. They also show that the elapsed time in that process is adequate to what would be expected of an interactive tool. SmART is currently being integrated into the VIRTU bundle, whose trial version is available for download from the project’s web page.	binary file;compiler;download;extensibility;grammar induction;international symposium on fundamentals of computation theory;parsing;prototype;smart;text-based (computing);usability;virtual appliance;web page	Hervé Paulino;João André Martins;João Lourenço;Nuno Duro	2010		10.1007/978-3-642-15654-0_5	embedded system;telecommunications;engineering;operating system	SE	-34.03668805252113	39.99227966584253	82845
67c8ca3dc3e65a045be5ac6bb8a0a10195823d15	modeling and quantitative safety analysis of chinese train control system of systems	chinese train control system;quantitative safety analysis;probabilistic risk analysis;prism;automatic train control;safety analysis;mathematical models;probabilistic model checking;markov processes;markov decision process;train control system	In order to perform the quantitative safety analysis of Chinese Train Control System level 3, Markov Decision Process(MDP) is employed as the foundation of system behavior modelling. The non-deterministic behaviors and stochastic behaviors in physical behavior model, normal behavior model and fault behavior models are all expressed in MDPs. The quantitative analysis results produced by probabilistic model checker PRISM can be used to judge and compare the prototype designs and evaluate the probabilistic risk of hazards. The conclusions show that comprehensive behavior model and PRISM can automatically consider all the paths of the dynamic system behaviors in System of Systems, which makes the behavior model more accurate and complete. The methodology manifests that it is applicable for the safety analysis of CTCS3 and other train control systems.	behavior model;control system;dynamical system;markov chain;markov decision process;model checking;prism (surveillance program);prototype;statistical model;system of systems	Guo Zhou;Huibing Zhao	2015	2015 IEEE 18th International Conference on Intelligent Transportation Systems	10.1109/ITSC.2015.71	control engineering;simulation;engineering;operations management	Robotics	-45.56823397328144	35.029291539614675	82999
3734bd20527b3f7a6fae0fefa137fa91f643eb7b	leon3 vip: a virtual platform with fault injection capabilities	software;virtual platform fault injection capability hardware software design simulation techniques leon3 32bit sparc cpu systemc transaction path xml dynamic binary instrumentation c binary tlm2 0;hardware software codesign;circuit faults;hardware software design;dynamic binary instrumentation;software prototyping;circuit faults xml hardware software computational modeling time domain analysis time varying systems;tlm2 0;time varying systems;xml faultset;debug transport interface leon3 fault injection xml faultset binary instrumentation;simulation techniques;time domain analysis;computational modeling;formal verification;simulation technique;c binary;xml;systemc transaction path;xml fault diagnosis formal verification hardware software codesign software prototyping;leon3;binary instrumentation;virtual platform;software design;fault injection;debug transport interface;fault diagnosis;32bit sparc cpu;transaction level;hardware;fault injection capability	In addition to functional simulation for validation of hardware/software designs, there are additional robustness requirements that need advanced simulation techniques and tools to analyze the system behavior in the presence of faults. In this paper, we present the design of a fault injection framework for LEON3, a 32bit SPARC CPU based system used by the European Space Agency, described at Transaction Level using System C. First of all an extension of a previous XML formalization of basic binary faults, like memory and CPU registers corruption, is done in order to support TLM2.0transaction’s parameters corruptions. Next a novel Dynamic Binary Instrumentation (DBI) technique for C++ binaries is used to insert fault injection wrappers in SystemC transaction path. For binary faults in model components the use ofTLM2.0 “transport_dbg” is proposed. This way each component with fault injection capabilities exposes a standard interface to allow internal component inspection and modification.	32-bit;binary file;c++;central processing unit;fault injection;leon;logic simulation;perl dbi;requirement;sparc;systemc;virtual machine;xml	Antonio Dasilva;Sebastián Sánchez	2010	2010 13th Euromicro Conference on Digital System Design: Architectures, Methods and Tools	10.1109/DSD.2010.34	embedded system;computer architecture;real-time computing;xml;formal verification;computer science;software design;operating system;programming language;computational model	EDA	-38.00211734189266	34.04965031923614	83010
a89f2be5e535cdf7384b95547e693bffabf3fbb3	a demo on using visualization to aid run-time verification of dynamic service systems	interactive quality visualization;software testing;quality attributes;service system;visualization tool;software behaviour;service oriented architecture quality of service software systems software testing software quality runtime environment system testing data visualization computer architecture software tools;dynamic service oriented system;iqvis tool;service orientation;software verification;v v technique;runtime environment;verifying and validating;software systems;program verification;qos;computer architecture;software architecture;visualization;iqvis tool run time verification dynamic service oriented system service oriented architecture dynamic architecture smart environment software behaviour verifying and validating visualization tool v v technique software verification dynamic software system quality of service interactive quality visualization;software architecture program verification program visualisation;dynamic software system;monitoring;data visualization;adaptive system;self adaptive systems visualization quality attribute qos run time verification;system testing;software tools;self adaptive systems;quality of service;service oriented architecture;security;program visualisation;software quality;run time verification;smart environment;dynamic architecture;quality attribute	Future software systems will be dynamic service oriented systems. Service-Oriented Architecture (SOA) provides an extensible and dynamic architecture to be used, for example, in smart environments. In such an environment, software has to adapt its behaviour dynamically. Thus, there is a need for Verifying and Validating (V & V) the adaptations at run-time. This paper contributes to that by introducing a novel visualization tool to be used with traditional V & V techniques to aid the software analysts in the verification process of dynamic software systems. When Quality of Service (QoS) of dynamic software systems varies due to the changing environment the Interactive Quality Visualization (IQVis) tool detects these changes and provides analysts an easier way of understanding the changed behaviour of the system.	quality of service;run time (program lifecycle phase);service-oriented architecture;service-oriented device architecture;smart environment;software system;verification and validation	Jarkko Kuusijärvi	2010	2010 Third International Conference on Software Testing, Verification, and Validation Workshops	10.1109/ICSTW.2010.40	software visualization;verification and validation;real-time computing;quality of service;software verification;computer science;information security;adaptive system;software engineering;software construction;data visualization;software system;computer engineering	SE	-44.15182046261219	33.725799792802036	83552
cf7e01adfec02fec2209f6696d24049d8db38f76	fault tree and formal methods in system safety analysis	fault tree;construction process;formal specification;data integrity;fault trees safety us department of transportation logic gates system analysis and design specification languages formal verification resource management information technology;data integrity formal specification fault trees specification languages program verification;formal model;integrable system;specification language formal methods system safety analysis fault tree analysis deductive safety analysis system design formal semantics correctness checking consistency checking formal fault tree construction model fault tree correctness system safety properties cafeobj formal modeling formal specification formal verification integrated system analysis;spectrum;formal semantics;program verification;safety properties;specification language;formal method;safety analysis;specification languages;system design;system safety;fault tree analysis;fault trees	Fault tree analysis is a traditional deductive safety analysis technique that is applied during the system design stage. However, traditional fault trees often suffer from a lack of formal semantics to check the correctness or consistency of the descriptions. To overcome this limitation, we first propose a formal fault tree construction model in which the correctness of the fault tree is proved by the construction process per se, while at the same time subtler and more precise system safety properties are discovered. Then, based on analyzing the results of our formal fault tree model, we demonstrate how CafeOBJ, a wide spectrum specification language based on multiple logical foundations, can be used to formally model, specify, and verify a system as well as its important safety properties. Thus, we propose an integrated system analysis platform that enables engineers to find, analyze, and solve problems more efficiently and effectively.	correctness (computer science);deductive database;fault tree analysis;formal methods;semantics (computer science);specification language;system analysis;system safety;systems design	Jianwen Xiang;Kokichi Futatsugi;Yanxiang He	2004	The Fourth International Conference onComputer and Information Technology, 2004. CIT '04.	10.1109/CIT.2004.1357343	formal methods;fault tree analysis;computer science;stuck-at fault;fault model;database;programming language	Embedded	-46.169534286196395	32.36308142524444	83622
807fa8ce0654308175583f6e6ff1757662c271c4	checking inconsistency of rule sets in active real-time databases	database system;active database;real time;real time databases;eca rules;program verification;constraint solving active databases real time databases eca rules consistency checking;database systems timing event detection data engineering systems engineering and theory real time systems laboratories computer science fires temperature;event condition action rules active real time databases rule sets timing constraints;consistency checking;event condition action;constraint solving;active databases;real time systems active databases program verification;real time systems;time constraint	Using active rules in database systems provides a kind of abstraction and flexibility. But it may also be difficult to use the rules properly, especially when they involve timing constraints. In this paper, we define a type of inconsistency between event-condition-action (ECA) rules, and propose an approach for checking the inconsistency automatically.	database;event condition action;real-time transcription;transponder timing	Jian Zhang	2008	2008 11th IEEE High Assurance Systems Engineering Symposium	10.1109/HASE.2008.58	real-time computing;computer science;data mining;database	DB	-34.390785573209186	34.86615018523438	83637
20a66e956b868cfb67894edb1988e4488f31f154	a practical framework of dynamic monitors in service-oriented computing	middleware;software architecture;relational data;public domain software;service oriented computing	To dynamically monitor services and diagnosing causes of potential problems, we need to acquire essential information about atomic services. A challenge is how we tap the service middleware and acquire low-level runtime data about atomic services. In this paper, we present a design of dynamic monitor which gathers quality-related data of running services deployed on Enterprise Service Bus. We show the architecture of dynamic monitor, and present an implementation of the monitor on open source platform.	algorithm;code;data flow diagram;design pattern;enterprise service bus;high- and low-level;middleware;open-source software;quality of service;requirement;service-oriented device architecture	Du Wan Cheun;Jeong Seop Bae;Won Young Jeon;Hao Yuan;Soo Dong Kim	2007	IEEE International Conference on e-Business Engineering (ICEBE'07)	10.1109/ICEBE.2007.106	software architecture;real-time computing;relational database;computer science;operating system;software engineering;service-oriented architecture;middleware;database;services computing;public domain software	Visualization	-39.309449681273584	41.522292903144915	83713
2699d44739749eb3b5f8ed85c29a4e9f227c5972	software reference architecture for smart environments: perception		With the increase of intelligent devices, ubiquitous computing is spreading to all scopes of people life. Smart home (or industrial) environments include automation and control devices to save energy, perform tasks, assist and give comfort in order to satisfy specific preferences.#R##N##R##N#This paper focuses on the proposal for Software Reference Architecture for the development of smart applications and their deployment in smart environments. The motivation for this Reference Architecture and its benefits are also explained. The proposal considers three main processes in the software architecture of these applications: perception, reasoning and acting.#R##N##R##N#This paper centres attention on the definition of the Perception process and provides an example for its implementation and subsequent validation of the proposal.#R##N##R##N#The software presented implements the Perception process of a smart environment for a standard office, by retrieving data from the real world and storing it for further reasoning and acting processes. The objectives of this solution include the provision of comfort for the users and the saving of energy in lighting. Through this verification, it is also shown that developments under this proposal produce major benefits within the software life cycle.	control system;prototype;reference architecture;smart environment;software architecture;user (computing);user interface	Alejandro Fernández-Montes;J. A. Ortega;J. I. Sánchez-Venzalá;Luis González Abril	2014	Computer Standards & Interfaces	10.1016/j.csi.2014.02.004	reference architecture;embedded system;simulation;operating system;software engineering;database;multimedia;computer security	HPC	-41.014986147933	44.095612586431194	83744
4a3d687e64e04c516704bdda5359668e109373b9	performability modeling of mobile software systems	object oriented programming mobile computing unified modeling language software development management;performance evaluation;heterogeneous computing;software systems application software performance analysis mobile agents software performance performance evaluation degradation computer science mobile computing stochastic processes;software systems;object oriented programming;stochastic activity network mobile software system heterogeneous computing environment mobile component software life cycle design phases analysis techniques model based analysis uml based notation inferred performability model;phase analysis;unified modeling language;performance model;stochastic activity networks;software life cycle;mobile computing;software development management	An increasing number of applications operate in heterogeneous computing environments, often with mobile components. Methodologies that help developers assess the ability of such applications to meet their performance requirements throughout the software life-cycle are needed. In particular, early in the design phases, analysis techniques are critical for ensuring the future system's behavior, evaluating and comparing design alternatives. A performability evaluation is the most appropriate means to assess the expected system's ability to perform, including the effects of component failures and repairs. This paper focuses on model-based analysis of performability of mobile software systems. We propose a general methodology that starts from design artifacts expressed in a UML-based notation. Inferred performability models are based on the stochastic activity networks notation. The viability of the proposed approach is demonstrated through its application in a case study.	algorithm;code on demand;component-based software engineering;heterogeneous computing;queueing theory;reliability engineering;remote evaluation;requirement;software architecture;software development process;software framework;software release life cycle;software reliability testing;software system;state space;stochastic process;throughput;unified modeling language	Paola Bracchi;Bojan Cukic;Vittorio Cortellessa	2004	15th International Symposium on Software Reliability Engineering	10.1109/ISSRE.2004.27	reliability engineering;unified modeling language;verification and validation;computing;real-time computing;software sizing;computer science;systems engineering;package development process;software design;social software engineering;software framework;component-based software engineering;software development;software design description;operating system;software engineering;software construction;systems development life cycle;object-oriented programming;resource-oriented architecture;mobile computing;software deployment;goal-driven software development process;software development process;use case points;symmetric multiprocessor system;software metric;software system	SE	-47.47020308986966	34.49874886967198	83856
9479405b6ae1b3c0562bbd8b14d756b8d720ed79	towards a ttcn-3 test system for runtime testing of adaptable and distributed systems		Today, adaptable and distributed component based systems need to be checked and validated in order to ensure their correctness and trustworthiness when dynamic changes occur. Traditional testing techniques can not be used since they are applied during the development phase. Therefore, runtime testing is emerging as a novel solution for the validation of highly dynamic systems at runtime. In this paper, we illustrate how a platform independent test system based on the TTCN-3 standard can be used to execute runtime tests. The proposed test system is called TT4RT: TTCN-3 test system for Runtime Testing. A case study in the telemedicine field is used as an illustration to show the relevance of the proposed test system.	correctness (computer science);distributed computing;dynamical system;graphical user interface;interference (communication);mathematical optimization;osgi;prototype;relevance;run time (program lifecycle phase);ttcn-3;test case;test data;test management;trust (emotion)	Mariam Lahami;Fairouz Fakhfakh;Moez Krichen;Mohamed Jmaiel	2012		10.1007/978-3-642-34691-0_7	reliability engineering;embedded system;real-time computing;white-box testing;computer science;runtime verification;system under test;test management approach	SE	-41.732104995024145	36.144414980426475	84344
22b80d60e31ad4440ef795cb0b1a060dee77804e	modeling and simulation semantics for building large-scale multi-domain embedded systems.		This paper discusses a set of semantic constraints that have to be applied for multi-domain modeling of complex, embedded systems. In particular, using the Hybrid Bond Graph (HBG) modeling language, we analyze issues that deal with consistent causality assignments across model reconfigurations using hybrid switching junctions, and the complementarity of the electrical and mechanical domains by imposing additional constraints in the modeling environment. A case study of a Reverse Osmosis system developed at NASA JSC illustrates the effectiveness of our approach.	causality;complementarity theory;complex systems;computer science;electrical engineering;email;embedded system;half-life 2: episode two;hybrid system;isis;modeling language;programming paradigm;simulation	Joshua D. Carl;Zsolt Lattman;Gautam Biswas	2013		10.7148/2013-0093	theoretical computer science;distributed computing;programming language	Embedded	-41.87800308234348	32.466255408262576	84387
0d287de90a0d0242cd1c3ec7b13c910bd3f2e87d	a model-based approach for the specification of a virtual power plant operating in open context	formal specification;fuzzy logic;operating systems (computers);power engineering computing;power plants;cpss;spes german research project;spes development method;cyber physical systems;formal specification;fuzzy logic;model-based approach;modeling theory;operating system;software systems;virtual power plant specification	Nowadays, it's widely accepted that the paradigm of closed context systems has altered. As software systems in combination with physical systems, termed Cyber Physical Systems (CPSs) evolve to more and more complex structures to meet the continuously increasing complexity of requirements, they are faced with a variety of challenges. Those systems have to operate in an open context, meaning that the system boundary between the system and the environment changes over time. Furthermore, the operating system has to adapt its behavior to the observed environmental changes. Hence, there is a high need for the establishment of a seamless modeling framework which fosters the modeling of systems operating in open context. In this paper: 1) we explore how a modeling theory based on fuzzy logic allows for a formal specification of such systems 2) we embed the modeling theory to the SPES development method established within the German research project SPES by showing the compositionality of our approach 3) we illustrate on a show case how the approach can be applied exemplary for modeling the behavior of a Virtual Power Plant (VPP).	formal specification;fuzzy logic;operating system;programming paradigm;requirement;seamless3d;secure multi-party computation;software system	Vasileios Koutsoumpas	2015	2015 IEEE/ACM 1st International Workshop on Software Engineering for Smart Cyber-Physical Systems		real-time computing;simulation;systems modeling;computer science;systems engineering;context model	SE	-40.99423410812199	37.54766369026649	84406
8eb95789c60a8515e96b4cca6000efbdc29ae3d2	modelling and adapting to context	context aware application;context aware;rule based system;rule based;software architecture;system design;adaptive system;location awareness	One of the hardest points in context-aware applications is deciding what reactions a system has to a certain context. In this paper, we introduce an architecture used in two context-aware museum guides. We discuss how the context is modelled and we briefly present a rule-based mechanism to trigger system actions. A rule-based system offers the flexibility required to be context-sensitive in the broadest sense since many context features can be considered and evaluated at the same time. This architecture is very flexible and easily supports a fast prototyping approach.	context-sensitive grammar;logic programming;rule-based system;software prototyping	Daniela Petrelli;Elena Not;Massimo Zancanaro;Carlo Strapparava;Oliviero Stock	2001	Personal and Ubiquitous Computing	10.1007/s007790170023	rule-based system;software architecture;real-time computing;simulation;computer science;artificial intelligence;data mining;context model;systems design	HCI	-40.95495244883417	42.26876128454456	84587
57e457de5c08a3c55082531d612c808018e06c12	software agents as cloud computing services	agent based;software agent;proof of concept;virtual environment;agency theory;cloud computing	The community devoted to the agency theory needs to create practical solutions capable of representing users in the virtual societies which are emerging as a result of Internet. Cloud Computing has precisely succeeded as a model able to bring software solutions to users in a practical and transparent manner. To foster the adoption of agent-based solutions by the users, this paper describes a model where software agents figure as a new Cloud Computing service which would represent clients in virtual environments. We discuss the challenges that entail the proposal, the technologies necessary for its implementation and finally we develop a proof of concept to confirm its viability.	cloud computing;software agent	Ignacio Lopez-Rodriguez;Mario Hernández-Tejera	2011		10.1007/978-3-642-19875-5_35	cloud computing;computer science;cloud testing;distributed computing;utility computing;world wide web;computer security	HPC	-45.60509657338648	45.284792002269064	84808
976f37680988b72f758237664573403e5e20fdf8	enabling model-driven schedulability analysis in the development of distributed component-based real-time applications	distributed application;analytical models;component interface;model driven schedulability analysis;omg standards real time component based schedulability;real time;scheduling object oriented programming real time systems;real time component based distributed application;real time analysis model model driven schedulability analysis temporal behaviour model software component real time component based distributed application component based distributed application specification real time data component interface composable analysis model;object oriented programming;real time data;schedulability analysis;data mining;real time analysis model;temporal behaviour model;component based distributed application specification;application software job shop scheduling assembly software engineering concrete timing packaging processor scheduling distributed computing information management;scheduling;real time scheduling;schedulability;unified modeling language;composable analysis model;software component;model development;omg standards;context modeling;real time application;hard real time;concrete;real time systems;component based;timing	This work presents a strategy to include temporal behaviour models in deliverable software components in order to develop hard real-time component-based distributed applications, keeping the opacity and composability features that are inherent to the components paradigm. The Deployment and Configuration of Component-based Distributed Applications Specification of the OMG has been extended to include and manage the information that is required to design, analyse, and configure component-based applications with hard real-time requirements. The real-time data added to a component interface enable the application designers to validate scheduling and design decisions without any knowledge of the component internals. Besides, real-time reusable and composable analysis models, developed according to a concrete modelling methodology, are added to each implementation of the component interface. In the context of a concrete application, they are processed by tools to generate the complete real-time analysis model of the application, which is used to evaluate the configuration parameters that guarantee its schedulability. The OMG's MARTE profile provides the conceptual and semantic framework to formulate the real-time behaviour models used in this work.	behavioral modeling;component-based software engineering;composability;distributed computing;model-driven architecture;modeling and analysis of real time and embedded systems;programming paradigm;real-time clock;real-time computing;real-time data;real-time locating system;real-time transcription;requirement;sms language;scheduling (computing);scheduling analysis real-time systems;software deployment	Patricia López Martínez;José M. Drake;Julio L. Medina Pasaje	2009	2009 35th Euromicro Conference on Software Engineering and Advanced Applications	10.1109/SEAA.2009.28	unified modeling language;embedded system;real-time data;real-time computing;concrete;computer science;component-based software engineering;operating system;context model;programming language;object-oriented programming;scheduling	Embedded	-39.50032489637788	38.26071667918223	85195
46cd48065306be52dbdde47cff53df4849b404c4	introduction of the hybrid inference tool (hit)	belief networks;method engineering;bayesian network;bayesian technique;probability;probability application program interfaces bayes methods belief networks fuzzy logic inference mechanisms;api;hybrid network;bayes methods;high level fusion modeling;fuzzy logic bayesian methods possibility theory buildings uncertainty large scale systems engines packaging testing sections;fusion 2;inference mechanisms;application program interface;application programming interface hybrid inference tool belief network high level fusion modeling probabilistic component possibilistic component bayesian technique ambiguous data component fuzzy logic;situational awareness;fuzzy logic;application program interfaces;probabilistic component;situation awareness;hybrid inference;ambiguous data component;api hybrid inference fusion 2 situational awareness air engagement bayesian networks fuzzy logic;air engagement;belief network;hybrid inference tool;application programming interface;possibilistic component;bayesian networks	The construction of belief networks is a widely used methodology for high level fusion modeling. While some of the components of a belief network deal with ambiguous (probabilistic) data, others may deal with vague (possibilistic) data. Given the need to represent both probabilistic and possibilistic components in a single belief network, a framework and toolset for building Hybrid networks, utilizing Bayesian techniques to represent ambiguous data components and Fuzzy logic for vague components, is highly desired. To address this shortfall, we introduce the hybrid inference tool (HIT) to aid in the construction, compilation and performing of inference on Hybrid networks. The design of HIT includes an application programming interface (API) to support the incorporation of different transformation methods, engines and modeling packages for each component type. The applications utilized for the development, testing and validation of HIT are Norsys' Netica API (Bayesian networks) and the NRC CIIT's Fuzzy J API.	algorithm;application programming interface;bayesian network;buffalo airstation;compiler;computation;elegant degradation;fuzzy logic;high-level programming language;software propagation;vagueness	K. David Lee;Andrew Gelfand;Eric Wiesenfeld;Brian Stepnitz	2007	2007 10th International Conference on Information Fusion	10.1109/ICIF.2007.4408116	computer science;artificial intelligence;machine learning;data mining	Robotics	-46.49866012090763	33.1809887831602	85312
a57c4dae4733a0edecdc15924c8fcbe20c5bf6f0	a call model for multimedia multiuser communication platform	groupware;multimedia communication application software computer applications communication system control protocols electronic mail distance learning centralized control context aware services context modeling;distance education;multimedia;multimedia multiuser communication;groupware multimedia communication;computer supported cooperative work;multimedia multiuser communication multimedia multiuser communication platform computer supported cooperative working desktop multimedia conferencing distance education communication platform call model;multiuser communication platform;desktop multimedia conferencing;multimedia communication;call model;communication platform;computer supported cooperative working;communication service	Most experiments in building multimedia communications systems to date have adopted application architectures which are intended for communication-specific applications such as teleconferencing, and support only particular kinds of communication channels and mechanisms. This paper describes an application architecture which gives developers of diverse applications, from word processor and spreadsheet programs to large distributed multi-user systems, a means to enable users to control real-time communications directly in the context of their work. It also provides unifonn application-level control of distributed multimedia resources. It is designed for eventual use in a distributed object system and provides a programming interface based on intuitive operations on a telephone call which model basic communication tasks such as placing and forwarding a call. Analogies are drawn between properties of a call system and those of a window system. The architecture and its implementation allow numerous communication services to be controlled together and can control any service with a suitable switching interface. In addition to supporting switching for traditional communications media, it is possible, for example, to control sets of connections between clients and servers in a distributed computing environment. A particularly powerful example is provided by the addition of switching control for connections between X Windows clients and servers, giving rise to shared rnultitMdia workspaces which provide a seamless integration between personal work contexts and communication contexts.	application programming interface;applications architecture;component-based software engineering;distributed computing environment;distributed object;experiment;graphical user interface;graphics hardware;graphics software;microsoft windows;multi-user;personal computer;real-time web;seamless3d;spreadsheet;workspace;x window system	Seungchul Park;Yanghee Choi	1995		10.1109/ICNP.1995.524846	distance education;real-time computing;simulation;computer science;computer-supported cooperative work;multimedia;computer network	Networks	-36.87661183482645	41.45178208247179	85648
7f3202e6987af5fface7bfd2135e6dbe1a4b15ef	mobilespaces: a framework for building adaptive distributed applications using a hierarchical mobile agent system	distributed application;dynamic change;control systems;software agents distributed programming adaptive systems;application software;mobile agents;hierarchical mobile agent system;extensible mobile agent system;portable mobile agent system;power method;personal digital assistants;software agents;assembly;mobile agents application software large scale systems programming personal digital assistants buildings assembly mobile computing control systems robustness;large scale;mobile agent system;adaptive systems;distributed programming;robustness;agent hierarchy;mobile agent;mobile computing;mobilespaces;portable mobile agent system hierarchical mobile agent system adaptive distributed application building mobilespaces agent hierarchy inter agent migration large scale mobile application extensible mobile agent system;programming;mobile application;large scale mobile application;buildings;large scale systems;inter agent migration;adaptive distributed application building	This paper presents a new framework for constructing mobile agents. The framework introduces the notion of agent hierarchy and inter-agent migration and thus allows a group of mobile agents to be dynamically assembled into a single mobile agent. It provides a powerful method to construct a distributed application, in particular a large-scale mobile application. To demonstrate how to exploit our framework, we construct an extensible and portable mobile agent system based on the framework. The system is implemented as a collection of mobile agents and thus can dynamically change and evolve its functions by migrating agents that offer the functions. Also, mobile agent-based applications running on the system can naturally inherit the extensibility and adaptability of the system.	agent-based model;application programming interface;authentication;distributed computing;extensibility;java development kit (jdk);java version history;mobile agent;mobile app;multi-agent system	Ichiro Satoh	2000		10.1109/ICDCS.2000.840918	embedded system;programming;application software;real-time computing;power iteration;computer science;software agent;operating system;mobile agent;assembly;distributed computing;mobile computing;robustness	AI	-35.6929994489694	42.718147369946834	85727
215b74ea273782e759aaec29a9ede01cd5692b42	composition and compositionality in a component model for autonomous robots	spectrum;control architecture;constraint programming;sensors and actuators;component model;constraint system;motor behavior;autonomous robot;time constraint	Component models for autonomous robots control architectures are much more constrained than traditional ones: obeying strict timing constraints, coping with a large spectrum of rapidly changing hardware (e.g. sensors and actuators), etc. Beyond introducing new concepts into components themselves, composition in such models must go much farther than the standard connection through method signature interfaces. Viewing components as full-fledged sensori-motor behaviors, our model follows the concept of rich interfaces introduced by Henzinger et al. to attach to each component all the necessary syntactical and behavioral information to make them externally composable. This paper presents two kinds of composition, parallel and by modes, their semantics, their compositionality properties and the impact of these on the composition model. A prototype implementation in Java is backed by a constructive semantics defined as a constraint system solved in this prototype with the ECLIPSe constraint programming system.		Olena Rogovchenko;Jacques Malenfant	2010		10.1007/978-3-642-14046-4_3	spectrum;constraint programming;real-time computing;simulation;computer science;artificial intelligence;machine learning;component object model	Robotics	-36.19153545313707	38.12385429872795	86116
61b7f23253a30b57fdc54b9c6dfab6b9ad532813	enabling proactivity in context-aware middleware systems by means of a planning framework based on htn planning	htn planning;proactive computing;mobile and ubiquitous systems;context aware computing and systems	Today’s context-aware systems tend to be reactive or ‘pull’ based the user requests or queries for some information and the system responds with the requested information. However, none of the systems anticipate the user’s intent and behavior, or take into account his current events and activities to pro-actively ‘push’ relevant information to the user. On the other hand, Proactive context-aware systems can predict and anticipate user intent and behavior, and act proactively on the users’ behalf without explicit requests from them. Two fundamental capabilities of such systems are: prediction and autonomy. In this paper, we address the second capability required by a context-aware system to act proactively i.e. acting autonomously without an explicit user request. To address it, we present a new paradigm for enabling proactivity in context-aware middleware systems by means of a Planning Framework based on HTN planning. We present the design of a Planning Framework within the infrastructure of our intelligent context-aware middleware called Rover II. We also implement this framework and evaluate its utility with several use cases. We also highlight the benefits of using such a framework in dynamic ubiquitous systems.	automated planning and scheduling;autonomy;context-aware pervasive systems;hierarchical task network;middleware;proactive parallel suite;programming paradigm;rover (the prisoner)	Preeti Bhargava;Ashok K. Agrawala	2015	EAI Endorsed Trans. Context-aware Syst. & Appl.	10.4108/eai.22-7-2015.2260304	real-time computing;simulation;computer science;knowledge management;computer security	Robotics	-41.718481850560956	42.17163284274929	86191
741cdd32145962bc66e995e2b3b3b96283b8f673	webmanager: transforming a network management application into a component-based framework		This paper describes a network management tool. Visits to organizations of all sizes reveal that more than 95% of them are empty-handed as far as network management tools are concerned and pursue ad hoc management techniques. We argue that this sad state of affairs is due to the lack of cheap, easy to use tools. Although we don't solve the problem completely by providing such a tool, we show how a black-box component-oriented framework can be the basis for constructing it. We report on results of actual use of the tool to manage a small network and show that the postulated requirements (flexibility, scalability, ease of use and portability) are met.	black box;hoc (programming language);requirement;scalability;software portability;usability	Jacques Philippe Sauvé;Antônio A. T. R. Coutinho;Rodrigo R. Almeida;Ayla D. D. de Souza;Alexandre Duarte	2001			scalability;computer science;usability;state of affairs;software portability;network management;distributed computing;network management application	OS	-36.11763396691494	44.20830443355652	86766
4d393888d299b9875b45fc99f9253e483b1d3744	qos control by balancing continuous mm streams	monitoring;hybrid systems;system control;continuous functions;end-to-end qos.;streams;distributed system;differential equation;end to end;state machine;operating system;hybrid system	Loosely coupled systems, i.e. distributed systems that have to execute a common task obviously need some type of end-to-end control. End-to-end control will be achieved by sensoring relevant system variables and by controlling the feeding input components. Whereas sensoring is a continuous activity, controlling in most cas- es is a discrete one. Discrete controlling signals will be issued when certain invariant conditions of the system get violated. Models of which obey the components of a continuously operating system, a continuously sen- soring component and a discretely decision-taking component. In order to achieve an adequate view it is en- visaged to combine modelling concepts that represent the continuous system behaviour with those for discrete decision-taking and for steering the stream sources. Decision-taking and controlling is represented by so-called hybrid systems. The system behaviour itself is modelled by continuous streams. Hybrid systems are a combi- nation of state machines together with continuously evolving variables. The continuous stream model is based on differential equations.	quality of service	Jan de Meer	1997			streams;quality of service;differential equation;finite-state machine;hybrid system;real-time computing;computer science	DB	-39.41028162302342	36.562296684270095	86768
dfbb37cc7095283ef94279d997992972538f7f1f	sat based enforcement of domotic effects in smart environments		The emergence of economically viable and efficient sensor technology provided impetus to the development of smart devices (or appliances). Modern smart environments are equipped with a multitude of smart devices and sensors, aimed at delivering intelligent services to the users of smart environments. The presence of these diverse smart devices has raised a major problem of managing environments. A rising solution to the problem is the modeling of user goals and intentions, and then interacting with the environments using user defined goals. ‘Domotic Effects’ is a user goal modeling framework, which provides Ambient Intelligence (AmI) designers and integrators with an abstract layer that enables the definition of generic goals in a smart environment, in a declarative way, which can be used to design and develop intelligent applications. The high-level nature of domotic effects also allows the residents to program their personal space as they see fit: they can define different achievement criteria for a particular generic goal, e.g., by defining a combination of devices having some particular states, by using domain-specific custom operators. This paper describes an approach for the automatic enforcement of domotic effects in case of the Boolean application domain, suitable for intelligent monitoring and control in domotic environments. Effect enforcement is the ability to determine device configurations that can achieve a set of generic goals (domotic effects). The paper also Fulvio Corno Politecnico di Torino, Dipartimento di Automatica ed Informatica, Corso Duca degli Abruzzi 24, 10129 Torino, Italy E-mail: fulvio.corno@polito.it Faisal Razzak Politecnico di Torino, Dipartimento di Automatica ed Informatica, Corso Duca degli Abruzzi 24, 10129 Torino, Italy E-mail: raja.faisal@gmail.com presents an architecture to implement the enforcement of Boolean domotic effects, and results obtained from carried out experiments prove the feasibility of the proposed approach and highlight the responsiveness of the implemented effect enforcement architecture.	ambient intelligence;application domain;boolean expression;emergence;experiment;goal modeling;high- and low-level;high-level programming language;home automation;interaction;responsiveness;sensor;smart device;smart environment	Fulvio Corno;Faisal Razzak	2014	J. Ambient Intelligence and Humanized Computing	10.1007/s12652-013-0183-x	embedded system;real-time computing;simulation;computer security	HCI	-41.81937643933501	42.812208948007445	86863
4fad161342ffdf6209bba28e7a25488d7873c842	agent mobility and reification of computational state: an experiment in migration	virtual machine;multi agent system	This paper describes an experiment with mobility in multi-agent systems. The setting is a virtual machine that supports reification of the computational state of a running process. The objective is to investigate how this feature facilitates telescripting and to speculate on how languages like Java should evolve to include the resulting notion of strong migration	computation;electron mobility;java;multi-agent system;reification (knowledge representation);virtual machine	Werner Van Belle;Theo D'Hondt	2000		10.1007/3-540-47772-1_15	simulation;computer science;virtual machine;artificial intelligence;multi-agent system;distributed computing	AI	-36.80375478940757	38.99998763915501	86876
ade66c7c2b69409ae995a8e47f2fe3a5a25ec615	adaptubiflow: selection and adaptation in workflows for ubiquitous computing	context middleware quality of service availability semantics context modeling ubiquitous computing;fault tolerant;semantic workflows ubiquitous computing platform integration context provision middleware service selection adaptation;service selection;semantic workflows;failure analysis;adaptation;fault tolerance;workflow management software failure analysis fault tolerance quality of service ubiquitous computing;workflow management software;context provision middleware;ubiquitous computing;middleware;quality of service;quality of context;platform integration;quality of context adaptubiflow workflow adaptation workflow selection ubiquitous computing opencopi element automatic reconfiguration fault tolerant system qos qoc	Ubiquitous environments still suffer from low availability given that any device may fail and it is hard to replace a failed element. In this paper we present AdaptUbiFlow (Adaptive Ubiquitous Workflow), an OpenCOPI´s element that aims to increase the availability of an ubiquitous system. When a device fails, AdaptUbiFlow supports the automatic reconfiguration of the system replacing the failed device (or service) by an equivalent one, this makes the system fault-tolerant without the need of any manual intervention. The replacing of a device/service is chosen taking into account not only the QoS and QoC (Quality of Context) provided but also the application's execution flow to ensure that the best adaptation option will be chosen. AdaptUbiFlow evaluation showed encouraging results.	experiment;fault tolerance;overhead (computing);quality of service;service composability principle;ubiquitous computing	Frederico Lopes;Thiago Pereira;Everton Cavalcante;Thaís Vasconcelos Batista;Flávia Coimbra Delicato;Paulo F. Pires;Paulo José Azevedo Vianna Ferreira	2011	2011 IFIP 9th International Conference on Embedded and Ubiquitous Computing	10.1109/EUC.2011.12	fault tolerance;real-time computing;computer science;database;world wide web;ubiquitous computing	HCI	-43.242216409075	41.86301163237752	86951
846c12487101edda7e40eb7391dfcdec55406b1b	a method for partitioning bpel processes for decentralized execution		Service orchestrations are a common means to compose individual services to either higher-level services or potentially complex composite applications. The Web Service Business Process Execution Language (WS-BPEL) is an example for a language that allows for defining automatically executable orchestrations of Web services. As of today, BPEL process are typically executed in a centralized manner; the process model is deployed on a single workflow management system which, during process instance execution, interprets the process definition and interacts with the orchestrated Web services on behalf of the user. In previous work, we have presented an approach which enables decentralized execution of BPEL processes based on a decentralized process model and supporting runtime infrastructure. In this paper we describe a method for automatic splitting of a process among the partners participating in its execution, referred to as process partitioning.	algorithm;business process execution language;centralized computing;composite application;executable;high- and low-level;orchestration (computing);process modeling;run-time infrastructure (simulation);web service;world wide web	Daniel Wutke;Daniel Martin;Frank Leymann	2009			workflow management system;web service;programming language;business process execution language;executable;distributed computing;computer science	Web+IR	-40.18635563692203	38.38240765620655	87012
b4a36c96d55d622b9a1921ce6aeca0e3300a435f	the on-board control procedures subsystem for the herschel and planck satellites	databases;libraries;space vehicles aerospace control aerospace engineering;dawn;software;command language;aerospace engineering;herschel satellites;planck satellites;vmc;onboard control procedures subsystem;data management;script like programs;bridges;specification language;goce satellite;onboard command language;aerospace control;venus express;satellites software databases bridges space vehicles aerospace electronics libraries;satellites;aerospace electronics;spacecraft onboard control procedures subsystem herschel satellites planck satellites central data management unit application sw script like programs onboard command language rosetta osiris venus express vmc dawn fc goce satellite;central data management unit;rosetta;on board control procedures obcp herschel planck;osiris;spacecraft;fc;space vehicles;application sw	The on-board control procedures (OBCP) subsystem of Herschel and Planck satellites' central data management unit (CDMU) application SW (ASW) provides means to control the spacecraft through small script-like programs written in a specific language called on-board command language (OCL). The implementation for Herschel and Planck satellites is an adaptation from previous experiences on instruments like Rosetta/OSIRIS, Venus Express/VMC and Dawn/FC, but it had also been adapted successfully for the GOCE satellite already. The purpose of having on-board control procedures is to allow the ground operators to be able to prepare and up-link complex operations sequences (more complex than simple sequences of mission time-line telecommands) to be executed on-board during the mission operational phase. This is possible because the OBCPs run in a quite separate subsystem, so the creation of a new procedure does not require modification, uplink and re-validation of the whole on-board software. The OBCP subsystem allows these control procedures to be developed, tested on ground, and executed on the spacecraft.	command language;herschel graph;on-board data handling;telecommunications link;variational monte carlo	Massimo Ferraguto;Tim Wittrock;Mark Barrenscheen;Matti Paakko;Ville Sipinen	2008	2008 32nd Annual IEEE International Computer Software and Applications Conference	10.1109/COMPSAC.2008.218	simulation;specification language;data management;aerospace engineering;computer science;engineering;spacecraft;dawn;satellite	Robotics	-35.81333000681526	34.73375510074202	87141
812c4c1b33b604df129aee14dbdb309a1df63122	prototype of a verified program code execution system		This paper describes technical implementation of a verified program code execution system. The functional purpose of the system is to investigate arbitrary executable files of an operating system in the absence of source codes in order to control program code execution within specified functional requirements. The prerequisites for development of such a system are outlined and a user’s operating procedure with two typical usage scenarios is described. General description of the architecture of the system and software used for its implementation, including the mechanism of interaction among system elements, is presented. A model example of implementing the system is considered. A flexible set of functional constraints based on a temporal attribute of process action is described. In conclusions, a brief comparison with the closest analogs is conducted.	code;executable;functional requirement;malware;operating system;prototype	A. V. Kozachok;E. V. Kochetkov	2018	Programming and Computer Software	10.1134/S0361768818030039	computer science;theoretical computer science;architecture;computer architecture;software;functional requirement;source code;executable	SE	-41.00491849102887	34.780809702055926	87156
6e46187b585b7d1acb43f5d69edff52acd68b0ae	an intelligent access control for web services based on service oriented architecture platform	reusable access control;intelligent access control;web application component;web service software;security rules;expert systems;information security;application software;authorisation;access rights;distributed computing;software systems;inference mechanisms;web service;intelligent control;independent software component;internet;software reusability;intelligent control access control web services service oriented architecture application software information security software systems distributed computing software reusability expert systems;web services;soa platform;software component;internet authorisation expert systems inference mechanisms;access rights intelligent access control web service software soa platform service oriented architecture web application component web software system security information service distributed computing reusable access control independent software component expert system security rules inference engine;access control;inference engine;information service;service oriented architecture;web software system security;expert system	With the rapid development of Web applications and services, there have been security threats appearing on the Web based software systems. Web services are a new approach in providing efficient information and services using distributed computing. It is an important step towards service-oriented architecture (SOA). This paper describes the design of a reusable access control layer for Web services software. The layer is designed as an independent software component which is separated from the application components of Web applications and services. It applies expert system type of rules using an inference engine to determine security rules and access rights	access control;authorization;buffer overflow;clips;component-based software engineering;distributed computing;expert system;first-order logic;inference engine;service-oriented architecture;service-oriented device architecture;software bug;software system;web application;web service;world wide web	Weider D. Yu	2006	The Fourth IEEE Workshop on Software Technologies for Future Embedded and Ubiquitous Systems, and the Second International Workshop on Collaborative Computing, Integration, and Assurance (SEUS-WCCIA'06)	10.1109/SEUS-WCCIA.2006.13	web service;web application security;middleware;web development;web application;web modeling;data web;web mapping;web-based simulation;web design;web standards;computer science;ws-policy;service-oriented architecture;ws-addressing;database;services computing;web intelligence;ws-i basic profile;web 2.0;law;world wide web;expert system;mashup	SE	-43.75851834497336	41.94311735199173	87172
563a48a4def83959a0821380a0146d3b66e3cd60	formally modeling and analyzing the reliability of cloud applications	reliability;computation tree logic ctl;petri nets;modeling;cloud computing	Cloud computing has become an important, useful paradigm for building applications with cloud services. However, cloud services exist in heterogeneous environments on the Internet. It is challenging to guarantee the reliability of cloud applications. Although there are e®orts studying cloud and grid service reliability, very few have considered the modeling and analysis of the reliability of cloud applications. To address this emerging, important problem, we propose the ̄rst systematic approach that considers both cloud application elements and their running environment so as to faithfully model the dynamics of cloud computing. First, we present a formal description language to model the di®erent components of a cloud application, and use it to analyze the static and dynamic factors a®ecting the reliability of cloud applications. Second, we propose reliability assurance strategies to ensure that cloud applications dynamically meet their required reliability. Third, Computation Tree Logic (CTL) is used to convert the reliability assurance strategy into the CTL formulas. We present operational semantics and related theories of Petri nets for establishing the correctness of our proposedmethod. Finally, a series of simulations are performed to evaluate the e±ciency of our proposed approach.	cloud computing;computation tree logic;correctness (computer science);distributed computing environment;experiment;formal system;game theory;integrated development environment;internet;nl-complete;numerical aperture;operational semantics;petri net;programming paradigm;reliability engineering;requirement;runtime system;scalability;simulation;software as a service;state space	Guisheng Fan;Huiqun Yu;Liqiong Chen	2016	International Journal of Software Engineering and Knowledge Engineering	10.1142/S0218194016500121	reliability engineering;real-time computing;systems modeling;cloud computing;computer science;theoretical computer science;cloud testing;reliability;petri net	SE	-46.22212182973204	39.97015574680916	87504
b4e5f9f0837918f64a0bc9152d2344a5b7afe9a3	a template for rapid prototyping of operating systems	software prototyping;software prototyping operating systems computers;rapid prototyping;operating system;prototypes operating systems computer science prom security access control;minix system rapid prototyping operating systems executable template specification specification process proof obligations sub specifications;operating systems computers	"""Rapid prototyping of many classes of systems can be facilitated by starting from an executable template specification appropriate to that class. A system template serves several useful purposes. It organizes ones thinking about the particular system to be specified, and speeds the specification process by pre-specifying structures and operations common to all systems in a class. If executable, it can be developed into a system prototype. Though beyond the scope of this paper, it can organize proofs of properties of the specification and its implementations by making it possible to isolate the relevant proof obligations. The authors templates have an additional property: they classify sub-specifications according to """"kinds"""" that needs to be completed differently. The authors illustrate rapid prototyping from a template for operating systems, specifically showing how to obtain a rapid prototype of the MINIX system. This approach may also be useful for other classes of systems, such as architectures. >"""	operating system;rapid prototyping	Myla Archer;Deborah A. Frincke;Karl N. Levitt	1990		10.1109/IWRSP.1990.144044	embedded system;embedded operating system;real-time computing;computer science;operating system;software engineering;computer engineering	OS	-40.145977508690855	35.14712329919287	87604
6dbc23358d700fbf226dbd7a391037653321309f	a distributed object platform infrastructure for multimedia applications	communication system;performance evaluation;computer model;real time;distributed multimedia;corba;multimedia application;soft real time;qa75 electronic computers computer science;distributed objects;operating system;distributed object system;distributed object computing;middleware;quality of service	Although distributed object computing has developed rapidly over the past decade, and is now becoming commercially important, there remain key application areas inadequately supported by current standards and implementations. This paper describes research aimed at support for one of these areas: distributed soft real-time/ multimedia applications. The approach is to provide a low level platform which offers generic middleware services useful for the implementation of a range of multimedia capable distributed object systems. The design of the platform is influenced on the one hand by the real-time/ multimedia-oriented computational model of the RM-ODP and on the other hand by recent research results in the efficient engineering of communications systems and operating systems. The platform provides support for quality of service (QoS) and application specific protocols as required by multimedia capable distributed object systems. A novel scheme for flexible QoS specification and management is described. A performance evaluation of the platform is given and a sample application program is presented to illustrate the platform’s API.	application programming interface;computation;computational model;distributed object;middleware;operating system;performance evaluation;quality of service;rm-odp	Geoff Coulson;Michael Clarke	1998	Computer Communications	10.1016/S0140-3664(98)00147-9	embedded system;distributed algorithm;middleware;real-time computing;quality of service;computer science;object request broker;operating system;common object request broker architecture;middleware;distributed computing;distributed object;distributed design patterns;communications system	Embedded	-33.712647846513335	44.760902132504505	87729
63ebcf6ad4232bbe92bad370fab16348ee1bb99b	a programming framework for quality-aware ubiquitous multimedia applications	application development;audio content analysis;qos guarantee;multimedia application;design and implementation;speaker change detection;consistency checking;speaker segmentation;ubiquitous computing;speaker tracking;quality of service;mobile video	"""Ubiquitous computing promises a computing environment that seamlessly and pervasively delivers applications to the user, despite changes of resources, devices, and locations. However, few ubiquitous multimedia applications (UMAs) exist up-to-date. One of the main reasons lies in the fact that it is difficult and error-prone to build a UMA which is mobile and deployable in different ubiquitous environments, and still provides acceptable application-specific Quality-of-Service (QoS) guarantees. In this paper, we present the design and implementation of a novel programming framework, called 'QCompiler"""" to address the challenges. The framework includes (1) a high-level application specification for the application developer to easily write a UMA with specific quality, mobility, and ubiquity supports, (2) a meta-data compilation, which provides automated consistency checks, translations, and substitutions, to relieve the application developer from dealing with complex programming related to quality, mobility, and ubiquity, (3) a binding, which prepares a quality-aware specification to be executable, in a specific deployment environment, and (4)a run-time meta-data execution, utilizing the meta-data compilation's results, to manage and control a quality-aware multimedia application. As a case study, we apply the programming framework to build a mobile Video-on-Demand (VoD) application. The experimental results show tradeoffs between easiness and flexibility to develop and deploy UMA, and overheads during UMA instantiation and adaptation."""	cognitive dimensions of notations;compiler;deployment environment;executable;high- and low-level;quality of service;software deployment;ubiquitous computing;uniform memory access;universal instantiation;user-managed access	Duangdao Wichadakul;Xiaohui Gu;Klara Nahrstedt	2002		10.1145/641007.641131	real-time computing;quality of service;computer science;operating system;database;rapid application development;world wide web;ubiquitous computing	SE	-40.115714505901984	45.66669034708112	87740
a7ada1bdaf9bec65338a4775e7328ead2b876863	timeline: an operating system abstraction for time-aware applications	time synchronization;distributed real time systems;choreographed scheduling	Having a shared and accurate sense of time is critical to distributed Cyber-Physical Systems (CPS) and the Internet of Things (IoT). Thanks to decades of research in clock technologies and synchronization protocols, it is now possible to measure and synchronize time across distributed systems with unprecedented accuracy. However, applications have not benefited to the same extent due to limitations of the system services that help manage time, and hardware-OS and OS-application interfaces through which timing information flows to the application. Due to the importance of time awareness in a broad range of emerging applications, running on commodity platforms and operating systems, it is imperative to rethink how time is handled across the system stack. We advocate the adoption of a holistic notion of Quality of Time (QoT) that captures metrics such as resolution, accuracy, and stability. Building on this notion we propose an architecture in which the local perception of time is a controllable operating system primitive with observable uncertainty, and where time synchronization balances applications' timing demands with system resources such as energy and bandwidth. Our architecture features an expressive application programming interface that is centered around the abstraction of a timeline – a virtual temporal coordinate frame that is defined by an application to provide its components with a shared sense of time, with a desired accuracy and resolution. The timeline abstraction enables developers to easily write applications whose activities are choreographed across time and space. Leveraging open source hardware and software components, we have implemented an initial Linux realization of the proposed timeline-driven QoT stack on a standard embedded computing platform. Results from its evaluation are also presented.	application programming interface;component-based software engineering;cyber-physical system;distributed computing;embedded system;holism;imperative programming;internet of things;linux;observable;open-source hardware;open-source software;operating system;timeline	Fatima M. Anwar;Sandeep D'Souza;Andrew Colquhoun Symington;Adwait Dongare;Ragunathan Rajkumar;Anthony Rowe;Mani B. Srivastava	2016	2016 IEEE Real-Time Systems Symposium (RTSS)	10.1109/RTSS.2016.027	embedded system;real-time computing;simulation;computer science;operating system;distributed computing;programming language	Embedded	-37.99934625083619	45.46569489521924	88046
8689a720873c22e30c7dc130de5af8510f6f63f2	fault analysis in analog circuits through language manipulation and abstraction		Each year automotive systems are becoming smarter thanks to their enhancement with sensing, actuation and computation features. The recent advancements in the field of autonomous driving have increased even more the complexity of the electronic components used to provide such services. ISO 26262 represents the natural response to the growing concerns in terms of the functional safety of electrical safety-related systems in this area. However, if the functional safety analysis of digital devices is quite a stable methodology, the same analysis for analog components is still in its infancy. This paper aims to explore the problem of fault analysis in analog circuits and how it can be integrated into the design processes with minimum effort. The methodology is based on analog language manipulation, analog fault instrumentation and automatic abstraction. An efficient and comprehensive flow for performing such an activity is proposed and applied to complex case studies.	analogue electronics;autonomous car;computation;electronic component;sensor	Enrico Fraccaroli;Francesco Stefanni;Franco Fummi;Mark Zwolinski	2017	2017 Forum on Specification and Design Languages (FDL)	10.1109/FDL.2017.8303890	computer science;fault injection;computer engineering;analogue electronics;computation;electronic component;functional safety;abstraction;instrumentation	EDA	-44.61409198930042	36.47253273315522	88152
89ac9d77cea8cf5b7fd6eac9556a762a3174ae13	robustness evaluation of the rainbow framework for self-adaptation	autonomic systems;robustness testing;self adaptive systems;rainbow	Self-adaptive (or autonomic) systems incorporate complex software components that act as controllers of a target system by executing actions through effectors, based on information monitored by probes. Despite the growing importance and criticality of controllers in many application domains, a central concern about them is the difficulty in assessing their robustness when architecting self-adaptive systems. In previous work, we proposed an approach for evaluating the robustness of controllers in self-adaptive systems. In this practical experience report, we describe a comprehensive evaluation of the robustness of a particular controller, in our case Rainbow, in the context of two case studies: a benchmark case study that reproduces the typical infrastructure for a news website, and an industrial middleware for monitoring populated networks of devices. The aim of this work is to assess to what extent the use of a different target system has an impact on the robustness of the controller, which has to be customized in different ways, and may need to resort to the activation of different features, depending on the particular target system. Our analysis concludes that the customization of Rainbow (the controller) has little impact on its robustness because of the way the controller was designed and built, and this modularization of non-functional requirements is indeed encouraging when architecting self-adaptive systems.	adaptive system;autonomic computing;benchmark (computing);component-based software engineering;criticality matrix;functional requirement;middleware;non-functional requirement;population;robustness (computer science)	Javier Cámara;Rogério de Lemos;Nuno Laranjeiro;Rafael Ventura;Marco Vieira	2014		10.1145/2554850.2554935	robustness testing;real-time computing;simulation;operating system;database;computer security;robustness	SE	-43.33278394365006	40.17571559471699	88339
4814ae966c2e1c8ae022f581162da96727fa7309	aware ware: an adaptation middleware for heterogeneous environments	distributed application;component based distributed application application level adaptation middleware heterogeneous environment dissimilar network computing device end user application awareware dynamic component reconfiguration architecture environment measurement tool adaptation decision module reconfiguration mechanism;measurement tool;wireless networks;programming environments;collaborative work;dissimilar network;adaptive middleware;application software;reconfigurable architectures;programming environments object oriented programming middleware distributed object management reconfigurable architectures software tools;environmental conditions;heterogeneous environment;logicial personalizado;distributed computing;dynamic component reconfiguration architecture;object oriented programming;computer networks;intergiciel;prototipo;reconfiguration mechanism;environment measurement tool;awareware;aplicacion distribuida;heterogeneidad;portable computers;distributed object management;computer displays;adaptation decision module;bandwidth;middleware;software tools;middleware computer networks application software distributed computing computer displays portable computers collaborative software collaborative work wireless networks bandwidth;computing device;application level adaptation middleware;application repartie;component based distributed application;prototype;architecture reconfigurable;network computing;heterogeneity;heterogeneite;collaborative software;end user application	"""A heterogeneous environment consists of a number of dissimilar networks, computing devices, end users, applications, and environmental conditions. Traditional distributed applications are generally not aware of the heterogeneities of the environment. In this paper we present """"AwareWare"""", which is a middleware that facilitates applications to be more adaptive in such a heterogeneous environment. AwareWare addresses five types of heterogeneities and advocates dynamic component reconfiguration as a unified approach for both architectural and application level adaptation. AwareWare includes environment measurement tools, an adaptation decision module that is separated from other constructions of the application, and reconfiguration mechanisms for component based distributed applications. Prototype examples are presented that demonstrate the potential use of the middleware."""	distributed computing;middleware;prototype;warez	Qiang Wang;Liang Cheng	2004	2004 IEEE International Conference on Communications (IEEE Cat. No.04CH37577)	10.1109/ICC.2004.1312743	embedded system;middleware;application software;real-time computing;computer science;heterogeneity;operating system;wireless network;middleware;distributed computing;prototype;object-oriented programming;bandwidth;collaborative software	HPC	-34.30548014481588	45.14771102394901	89003
2833207397b3bf2bf320df2be696b45055f0d146	development of a flight control system for an ultralight airplane	avionics;aircraft control;aerospace control airplanes operating systems hardware real time systems aerospace electronics costs software systems software design embedded software;software systems;real time operating system;embedded systems;aerospace computing;operating system;linux;control engineering computing;real time embedded platform flight control system ultralight airplane low cost avionic system ultralight airplanes nonreal time operating system embedded linux;linux aerospace computing aircraft control avionics control engineering computing embedded systems;flight control;non real time	This paper presents development of the hardware and software for the low cost avionic system of ultralight airplanes. There are shown three levels of a hardware and software system design. As far as the software is concerned, we focused on changeover from non real-time operating system (embedded Linux) to the real-time embedded platform (QNX). We discussed the problems that led to operating system change. Various advantages and disadvantages of both operating systems are presented in this contribution. Concerning the hardware we concentrated on the development of the avionic control, monitoring and display modules that are a components of the dash board. The paper has been focusing on safety and reliability in the ultralight aviation and what can be improved or extended by the real-time operating system.	can bus;control system;distributed control system;embedded system;linux on embedded systems;qnx;real-time clock;real-time operating system;software development process;software system;systems design	Vilém Srovnal;Jirí Kotzian	2008	2008 International Multiconference on Computer Science and Information Technology	10.1109/IMCSIT.2008.4747325	avionics;embedded system;embedded operating system;real-time computing;simulation;computer science;operating system;linux kernel;software system;avionics software	Embedded	-34.38752910136226	37.36777020377986	89193
c1c1e181b4b95aaf27ce068a7a340758e85f45bb	mico: an open source corba implementation	formal specification;middleware public domain software distributed object management formal specification;programming language;heterogeneous environment;distributed programs;corba;65;mico internal architecture open source corba software common object request broker architecture distributed program object standard middleware architecture programming language corba specification;public domain software;distributed objects;distributed object management;mico open source corba;middleware;source code;java open source software guidelines skeleton libraries computer languages software tools feedback middleware auditory system;common object request broker architecture;mico;open source software;open source	T he Common Object Request Broker Architecture is a specification for creating, distributing, and managing distributed program objects across a network. Both the International Organization for Standardization and X/Open have sanctioned CORBA as the standard middleware architecture for distributed objects. CORBA was specifically designed to support heterogeneous environments, different vendors’ products, and several popular programming languages. Numerous implementations of the CORBA specification exist today, both in the commercial and the open source domain. MICO (www.mico.org) is one such implementation; I and several other developers are its cofounders. In this column, I’ll discuss MICO’s internal architecture and then offer a few guidelines to help you choose the right CORBA implementation for your purposes.	common object request broker architecture;distributed object;middleware;open-source software;programming language;x/open	Arno Puder;Kay Römer	2000	IEEE Software	10.1109/MS.2004.22	computer science;operating system;common object request broker architecture;database;distributed object;programming language	SE	-33.939717350819635	42.26240700332892	89209
55de1e171e95c5064d5731536e8aa491b32e0bc2	automatic simulation to predict software architecture reliability	predictive models software architecture analytical models software systems computer architecture performance analysis reliability automata engines telecommunication control;programming environments;formal specification;specification languages software architecture reliability prediction software simulation software development lifecycle software designs toolset workflow to sdl direct simulation performance w2s methodology communicating extended finite state machine bellcore telecommunication control system experiments;model generation;telecommunication control;simulation;software performance evaluation;software systems;communicating extended fsm cefsm;software architecture;finite state machines;control system;telecommunication control software reliability virtual machines programming environments specification languages formal specification software performance evaluation finite state machines;reliabilityprediction;virtual machines;extended finite state machine;specification languages;work flow;system design;software reliability	One of the goals of software architecture research is to analyze the reliability of a software system early in the development lifecycle. This allows the system designers to predict reliability and evaluate alternative designs. This paper presents a methodology and accompanying toolset, Workflow-to-SDL-Direct-Simulation (W2S), for generating a simulator from a semi-formal architecture description. This simulator allows the analysis of the system S reliability based on the simulated behavior and performance. There are three steps in the W2S methodology: ( I ) translation of the description to a Communicating Extended Finite State Machine (CEFSM) model; ( 2 ) generation of a simulator from the CEFSM model and a model of the system environment; and (3) execution of the simulator on top of an underlying CEFSM engine. The W2S methodology was applied to a Bellcore telecommunication control system, using a set of tools that we developed. Several sets of experiments were carried out. The result shows that the information generated by the simulator can be used to predict the reliability of a system solely based on its architectural description. This prediction allows designers to select more reliable architectures.	computer performance;control system;environment variable;experiment;extended finite-state machine;object process methodology;semiconductor industry;simulation;software architecture;software system	J. Jenny Li;Josephine Micallef;Joseph Robert Horgan	1997		10.1109/ISSRE.1997.630862	reliability engineering;extended finite-state machine;workflow;software architecture;real-time computing;computer architecture simulator;computer science;systems engineering;engineering;virtual machine;control system;operating system;software engineering;formal specification;software architecture description;finite-state machine;programming language;software quality;software system;systems design	Robotics	-43.78594423695469	33.597537381652465	89299
d8a8941e35e337e40c4b31271f13a87181a52a04	towards a dynamic cloud-enabled service eco-system	virtual resources dynamic cloud enabled service ecosystem cloud computing ict service oriented architecture scalable high value services internal management logic virtual distributed execution environment;virtual reality cloud computing service oriented architecture;composition;virtual distributed execution environment;virtual reality;business roles cloud computing soa virtual distributed execution environment discovery composition;discovery;soa;computational modeling;dynamic scheduling cloud computing quality of service computational modeling service oriented architecture;business roles;quality of service;service oriented architecture;dynamic scheduling;cloud computing	Cloud computing re-defined what, in ICT, can be delivered “as a service”. The new types of services increase the potential of some Service-Oriented Architecture concepts, e.g. dynamic discovery and composition of services. We envision a dynamic cloud-enabled service ecosystem in which different business actors cooperate in delivering scalable high-value services to the end user. The different providers should be able to discover, request, use and discard services during runtime based on some internal management logic. We define and use a reference model to explain this dynamicity, characterized by the introduction of the concept of Virtual Distributed Execution Environment (VDEE) between the virtual resources and the applications. Based on a study of the state of the art on cloud and SOA technologies, we identify functions of existing platforms that could be integrated to implement the proposed reference model. We also identify some challenges that still need to be addressed. Finally we anticipate the business-related evolution towards the dynamic cloud.	application programming interface;autonomic computing;cloud computing;component-based software engineering;ecosystem;experiment;itil;interoperability;ontology (information science);reference model;requirement;scalability;service-level agreement;service-oriented architecture;trust (emotion)	Humberto Nicolás Castejón Martínez;Anastasius Gavras;Joao Miguel Goncalves;Corrado Moiso;Astrid Undheim;Josip Zoric	2011	2011 15th International Conference on Intelligence in Next Generation Networks	10.1109/ICIN.2011.6081086	real-time computing;cloud computing;computer science;cloud testing;distributed computing;utility computing;services computing;data as a service;world wide web	HPC	-46.34374140519724	43.894077240516324	89304
4f872bdae8086b6b490b5304f6b5894f1ef3afac	taming uncertainty in self-adaptive software	uncertainty;risk aversion;software systems;satisfiability;self adaptation;software architecture;software component;possibility theory;quality of service	Self-adaptation endows a software system with the ability to satisfy certain objectives by automatically modifying its behavior. While many promising approaches for the construction of self-adaptive software systems have been developed, the majority of them ignore the uncertainty underlying the adaptation decisions. This has been one of the key obstacles to wide-spread adoption of self-adaption techniques in risk-averse real-world settings. In this paper, we describe an approach, called POssIbilistic SElf-aDaptation (POISED), for tackling the challenge posed by uncertainty in making adaptation decisions. POISED builds on possibility theory to assess both the positive and negative consequences of uncertainty. It makes adaptation decisions that result in the best range of potential behavior. We demonstrate POISED's application to the problem of improving a software system's quality of service via runtime reconfiguration of its customizable software components. We have extensively evaluated POISED using a prototype of a robotic software system.	component-based software engineering;possibility theory;prototype;quality of service;risk aversion;robot;software system	Naeem Esfahani;Ehsan Kouroshfar;Sam Malek	2011		10.1145/2025113.2025147	possibility theory;software architecture;quality of service;risk aversion;uncertainty;software sizing;computer science;systems engineering;engineering;artificial intelligence;software design;software framework;component-based software engineering;software development;software design description;software engineering;software deployment;software quality control;software metric;software system;satisfiability	SE	-44.10736584228517	38.405590830662305	89318
8bca5f4e2c316897382225adcc8e59041b4bf12e	providing lightweight and adaptable service technology for information and communication (plastic) in the mobile ehealth case study	plastics;adaptive coding;data set;java;quality of service;unified modeling language;mobile computing;qos;service model	In this paper we briefly describe a case study, i.e. the Mobile eHealth (MeH), developed in the context of the IST PLASTIC project aimed at supporting self-adapting and context-aware services. The goal of the case study is to show how to model a service-based application and to demonstrate that model-based solutions are suitable to generate Quality of Service (QoS) models and adaptable code from service models.	context-aware network;quality of service	Marco Autili;Luca Berardinelli;Davide Di Ruscio;Catia Trubiani	2012	2012 4th International Workshop on Principles of Engineering Service-Oriented Systems (PESOS)		mobile qos;simulation;computer science;multimedia;world wide web	SE	-39.81425248612283	43.31094044227629	89559
dbba31ed18b8a15d80e11a4cba6eb518c74dcf17	perspectives of system informatics	information systems;artificial intelligence;computer architecture;object oriented programming;hybrid systems;software engineering;neural nets	Distributed algorithms have numerous mission-critical applications in embedded avionic and automotive systems, cloud computing, computer networks, hardware design, and the internet of things. Although distributed algorithms exhibit complex interactions with their computing environment and are difficult to understand for human engineers, computer science has developed only very limited tool support to catch logical errors in distributed algorithms at design time. In the last two decades we have witnessed a revolutionary progress in software model checking due to the development of powerful techniques such as abstract model checking, SMT solving, and partial order reduction. Still, model checking of fault-tolerant distributed algorithms poses multiple research challenges, most notably parameterized verification: verifying an algorithm for all system sizes and different combinations of faults. In this paper, we survey our recent results in this area which extend and combine abstraction, partial orders, and bounded model checking. Our results demonstrate that model checking has acquired sufficient critical mass to build the theory and the practical tools for the formal verification of large classes of distributed algorithms.	cloud computing;computer science;distributed algorithm;embedded system;fault tolerance;formal verification;informatics;interaction;internet of things;mission critical;model checking;partial order reduction;verification and validation	Manuel Mazzara;Andrei Voronkov;Gerhard Goos;Juris Hartmanis;Jan van Leeuwen;Helmut Veith	2015		10.1007/978-3-319-41579-6	health administration informatics;engineering informatics;informatics;translational research informatics;materials informatics	Logic	-45.37828894455642	36.277828784771145	89593
2e5c0be9b76e0382beccbcce38b6d9737b7bc23c	wcf: a case study involving a distributed client/server game	client server	WCF provides a basis for SOA – service-oriented architecture. This paradigm differs from traditional OOP in which tight encapsulation of data is encouraged and supported by classes. With SOA utilizes loosely coupled services. Each service defines a contract to the entities that consume it. It is generally difficult to implement a single interface across many platforms and languages because of the nature of distributed systems. It is essential to implement the interfaces in a generic manner.	.net framework;book;callback (computer programming);client (computing);computer science;distributed computing;entity;graphical user interface;loose coupling;norm (social);programming paradigm;server (computing);service-oriented architecture;service-oriented device architecture;software design pattern;software development;the journal of object technology;windows communication foundation	Richard Wiener	2009	Journal of Object Technology	10.5381/jot.2009.8.2.c6	client;reverse proxy;computer science;operating system;appleshare;distributed computing;server-side;fat client;world wide web;windows server;application server;client–server model;game client;remote evaluation	PL	-35.70330018069821	41.73243303466409	89707
151b4fefe5d7364aab8b9432beb7155978788ab1	economic model-driven cloud service composition	service composition;cloud service;economic model	This article considers cloud service composition from a decision analysis perspective. Traditional QoS-aware composition techniques usually consider the qualities available at the time of the composition because compositions are usually immediately consumed. This is fundamentally different in the cloud environment where the cloud service composition typically lasts for a relatively long period of time. The two most important drivers when composing cloud service are the long-term nature of the composition and the economic motivation for outsourcing tasks to the cloud. We propose an economic model, which we represent as a Bayesian network, to select and compose cloud services. We then leverage influence diagrams to model the cloud service composition. We further extend the traditional influence diagram problem to a hybrid one and adopt an extended Shenoy-Shafer architecture to solve such hybrid influence diagrams that include deterministic chance nodes. In addition, analytical and simulation results are presented to show the performance of the proposed composition approach.	bayesian network;cloud computing;decision analysis;influence diagram;model-driven integration;outsourcing;quality of service;service composability principle;simulation	Zhen Ye;Athman Bouguettaya;Xiaofang Zhou	2014	ACM Trans. Internet Techn.	10.1145/2651420	simulation;cloud computing;computer science;economic model;database;world wide web	Metrics	-48.18665906267625	42.63003128479587	89778
7b31984335655a1d51a9266ad5ef7774c6b903b7	cloud patterns for mobile collaborative applications		Deploying collaborative applications (e.g., group editors) over mobile devices is problematic because these devices will always be resource-poor and with unstable connectivity and constrained energy. To overcome these limitations, one straightforward solution is to leverage mobile collaboration via the cloud. This emerged model relies on virtualisation for efficient and flexible use of hardware assets and software services over a network without requiring user intervention. However, designing collaborative applications with flexibility and reusability has become a hot topic in mobile cloud computing as no mature models have been proposed yet. In this paper, we describe cloud patterns (i.e., extension of classic design patterns) focusing on the description of mobile real time data sharing through the cloud. Our design model consists of two levels: the first one provides self-protocol to create clones of mobile devices, manage usersu0027 groups and recover failed clones in the cloud. As for the second level, it...		Nadir Guetmi;Abdessamad Imine	2017	IJIIDS	10.1504/IJIIDS.2017.10007786	data mining;virtualization;computer science;distributed computing;cloud computing;mobile cloud computing;software design pattern;reusability;mobile device;mobile collaboration;mobile computing	HCI	-43.75919352080639	44.503540337574705	89984
514e63819f97e94b3135131eba71f1a91f36975b	sentire: a framework for building middleware for sensor and actuator networks	logical relation;sensor systems;sensor phenomena and characterization;actuators middleware sensor fusion;application software;sanet middleware;pervasive computing;resource management;actuators;middleware actuators application software pervasive computing intelligent sensors sensor phenomena and characterization resource management sensor systems conferences computer science;plug in infrastructure sentire sensor and actuator networks sanet middleware;plug in infrastructure;sentire;sensors and actuators;middleware;computer science;sensor fusion;sensor and actuator networks;intelligent sensors;conferences	Sentire represents a framework for building extensible middleware for sensor and actuator networks (SANET). The fundamental principle behind Sentire is the partitioning of SANET middleware into logically related components in order to allow developers of different aspects of the middleware to share a common plug-in infrastructure where their developed artifacts can interact. In this paper, an extended introduction of Sentire is presented, followed by a practical illustration of how this framework can be used to build SANET middleware.	middleware;plug-in (computing)	Joel W. Branch;John S. Davis;Daby M. Sow;Chatschik Bisdikian	2005	Third IEEE International Conference on Pervasive Computing and Communications Workshops	10.1109/PERCOMW.2005.74	embedded system;application software;real-time computing;computer science;resource management;operating system;middleware;distributed computing;sensor fusion;ubiquitous computing;intelligent sensor;actuator	Robotics	-39.32551922433742	43.99988151978943	90243
14582e4914a497987dde2ed703f23dbec7419fa3	extraction of system functions from 1-d simulation component libraries	product lifecycle management;systems engineering;functional modeling;physical modeling;behavioral modeling;simulation languages	This paper presents a bottom-up approach for the extraction of system functions from simulation component libraries; this step is desirable and necessary for the integration of system-level 1D simulation tools with product lifecycle management systems (PLM). The presented approach performs a port, structural (e.g., equational/algorithmic), parameter, and internal variable analysis to extract functionality from simulation components. The implementation of our algorithm in a research prototype has been validated on more than 4,000 components of the Amesim library with the successful extraction of more than 60,000 system functions. Our results show that the extraction of functions is a practical and viable foundation for associating requirements to system-level simulation models, and for harmonizing concept designs to detailed designs.	algorithm;bottom-up parsing;computer-aided design;high- and low-level;iterative method;lms imagine.lab amesim;library (computing);modeling language;prototype;requirement;system-level simulation;systems engineering;top-down and bottom-up design	Arquimedes Canedo;Jan H. Richter	2014		10.1145/2666202.2666215	reliability engineering;simulation;systems engineering;engineering	EDA	-42.20374476623884	33.938957804788636	90325
4a2703cce9d32c89e380554d76549e4e6965fb95	supporting heterogeneous architecture descriptions in an extensible toolset	grammar description;empirical study;extensible toolset;behavioral analysis;software maintenance;architecture description language;heterogeneous architecture descriptions;complex software systems;code generation;software systems;faulty codes;interface definition languages;architecture description languages;computer architecture fractals decoding software systems graphical user interfaces architecture description languages dsl domain specific languages java software architecture;software architecture;code generation heterogeneous architecture descriptions extensible toolset architecture description languages complex software systems adl interchange formats architecture based software systems grammar description interface definition languages domain specific languages behavioral analysis;adl interchange formats;design pattern;domain specific language;architecture based software systems;interchange format;interface definition language;design patterns;software tools;behavior analysis;software tools software architecture;domain specific languages	Many architecture description languages (ADLs) have been proposed to model, analyze, configure, and deploy complex software systems. To face this diversity, extensible ADLs (or ADL interchange formats) have been proposed. These ADLs provide linguistic support for integrating various architectural aspects within the same description. Nevertheless, they do not support extensibility at the tool level, i.e. they do not provide an extensible toolset for processing ADL descriptions. In this paper, we present an extensible toolset for easing the development of architecture-based software systems. This toolset is not bound to a specific ADL, but rather uses a grammar description mechanism to accept various input languages, e.g. ADLs, Interface Definition Languages (IDLs), Domain Specific Languages (DSLs). Moreover, it can easily be extended to implement many different features, such as behavioral analysis, code generation, deployment, etc. Its extensibility is obtained by designing its core functionalities using fine-grained components that implement flexible design patterns. Experiments are presented to illustrate both the functionalities implemented by the toolset and the way it can be extended.	architecture description language;code generation (compiler);design pattern;domain-specific language;extensibility;software deployment;software system	Matthieu Leclercq;Ali Erdem Özcan;Vivien Quéma;Jean-Bernard Stefani	2007	29th International Conference on Software Engineering (ICSE'07)	10.1109/ICSE.2007.82	architecture description language;computer architecture;computer science;domain-specific language;theoretical computer science;operating system;software engineering;programming language	SE	-40.731652771955964	34.85426715743639	90488
15e3d79d9241adf7954d8a4f1c47ec1a8add6360	model driven security: unification of authorization models for fine-grain access control	domain model;component technology;quality of service security of data authorisation middleware object oriented programming distributed object management;authorisation;plug and play;authorization access control security contracts business communication middleware collaborative software quality of service iec standards iso standards;object oriented programming;quality of service model driven security authorization models fine grain access control unified component meta model framework uniframe security contracts security aware middleware component integration toolkits components providers functional contracts security constraints access control model protected resources access control points component technologies access control requirements platform independent model pim domain models standard transformation platform specific models psm distributed system software;access control models;distributed object management;platform specific model;middleware;platform independent model;access control;quality of service;security of data;meta model	The research vision of the Unified Component Meta Model Framework (UniFrame) is to develop an infrastructure for components that enables a plug and play component environment where the security contracts are a part of the component description and the security aware middleware is generated by the component integration toolkits. That is, the components providers will define security contracts in addition to the functional contracts. These security contracts will be used to analyze the ability of a service to meet the security constraints when used in a composition of components. A difficulty in progressing the security related aspects of this infrastructure is the lack of a unified access control model that can be leveraged to identify protected resources and access control points at the model level. Existing component technologies utilize various mechanisms for specifying security constraints. This paper will explore issues related to expressing access control requirements of components and the resources they manage. It proposes a platform independent model (PIM) for the access control that can be leveraged to parameterize domain models. It also outlines the analysis necessary to progress a standard transformation from this PIM to three existing Platform Specific Models (PSMs).	access control;authorization;han unification;list of toolkits;metamodeling;middleware;model-driven security;platform-independent model;plug and play;requirement	Carol C. Burt;Barrett R. Bryant;Rajeev R. Raje;Andrew M. Olson;Mikhail Auguston	2003		10.1109/EDOC.2003.1233846	software security assurance;computer security model;metamodeling;cloud computing security;security through obscurity;quality of service;computer science;systems engineering;access control;operating system;software engineering;domain model;middleware;database;security service;authorization;object-oriented programming;security testing;world wide web;computer security	Security	-46.07836600868227	42.85677543881185	90718
a58299a19739fcf3c9ad72069cd457465f789fc8	towards a pervasive infrastructure for chemical-inspired self-organising services	software agent;pervasive computing;tuple space;mobile computer;service architecture;interaction pattern;semantic matching	Stimulated by the increasing availability of new mobile computing devices and the corresponding demand of open, long-lasting, and self-organising service applications, recent works proposed the adoption of a nature-inspired approach of chemistry for implementing service architectures [33]. One work in this direction is the chemical tuple-space model [30], by which the existence of data, devices and software agents (in one word, services of the pervasive computing application) gets reified into proper tuples managed by the infrastructure. System behaviour is accordingly expressed by chemical-like reactions that semantically match those tuples and accordingly enact the desired interaction patterns (composition, aggregation, competition, contextualisation, diffusion and	mobile computing;pervasive informatics;self-organization;service-oriented architecture;software agent;tuple space;ubiquitous computing	Mirko Viroli;Matteo Casadei;Elena Nardini;Andrea Omicini	2009		10.1007/978-3-642-14412-7_8	context-aware pervasive systems;computer science;tuple space;software agent;service-oriented architecture;database;distributed computing;mobile computing;world wide web;ubiquitous computing	HCI	-41.57769367730235	44.73088730559178	90730
2297848507957097a957e5b9c7ba2d96a7eca501	the home needs an operating system (and an app store)	application development;technological innovation;home network;operating system;home networks;operating systems	We argue that heterogeneity is hindering technological innovation in the home---homes differ in terms of their devices and how those devices are connected and used. To abstract these differences, we propose to develop a home-wide operating system. A HomeOS can simplify application development and let users easily add functionality by installing new devices or applications. The development of such an OS is an inherently inter-disciplinary exercise. Not only must the abstractions meet the usual goals of being efficient and easy to program, but the underlying primitives must also match how users want to manage and secure their home. We describe the preliminary design of HomeOS and our experience with developing applications for it.	app store;homeos;operating system	Colin Dixon;Ratul Mahajan;Sharad Agarwal;A. J. Bernheim Brush;Bongshin Lee;Stefan Saroiu;Paramvir Bahl	2010		10.1145/1868447.1868465	embedded system;simulation;computer science;operating system;rapid application development;computer security;computer network	OS	-35.96129824727413	44.39097146399933	90920
a2d85615bffadb8870fe51ccee0f03fbbdcc3a5c	aflexible framework for wireless-based intelligent sensor with reconfigurability , dynamic adding ,and web interface	intelligent sensor;microcontrollers;sensor reconfiguration;wireless sensor;sensor node;fault tolerant;wireless sensor networks fault tolerance internet wireless lan;snmp microcontrollers wireless sensors wireless lan i2c smbus device sensor node sensor network;wireless sensors;remote internet enabler;web interface;wireless communication channel;sensor network;temperature sensor;wireless based intelligent sensor;wireless communication;flexible wireless sensor platform;common managed objects base;snmp;internet;sensor network management;common device driver;system integration;i2c smbus;fault tolerance;common controller hardware;sensor nodes;wireless lan;intelligent sensors temperature sensors sensor phenomena and characterization communication system control control systems wireless sensor networks internet fault tolerance stability sensor systems;device;common control program;communication channels;development time;i2c smbus wireless based intelligent sensor web interface flexible wireless sensor platform remote internet enabler sensor reconfiguration fault tolerance common controller hardware common control program common device driver common managed objects base sensor network management wireless communication channel wireless lan microcontroller;device driver;wireless sensor networks;microcontroller	In this paper, we propose the use of standard, verifiable, common approach platform called the flexible wireless sensor platform (FWSP) architecture which had following features remote Internet enabler, reconfiguration by parameter which improve precision, dynamic addition of sensor nodes, and fault tolerance which increase the reliability, stability. The goals of the FWSP architecture are to establish: common controller-hardware (system on module), a common control program, common device drivers, a common managed objects base, and a common appearance to higher-level sensor network management. The proposed platform architecture offers flexibility, easy customization ,and seamless system integration. An experiment has been established based on wireless communication channel, using wireless LAN (IEEE802.11) as primary communication channel on our prototype sensor node, I2C/Smbus device such as temperature sensors, and desire sensor information can be viewed, and Sensor parameter can be adjusted to meet demanding. Measurements about the development time, sensor reconfiguration and confirm the proposed framework feasibility and effectiveness	amplifier;analog-to-digital converter;channel (communications);commo;device driver;fault tolerance;formal verification;input/output;prototype;reconfigurability;seamless3d;sensor node;sensor web;system management bus;system integration;system on module	Hung-Chieh Yu;Shu-Ming Tseng	2006	Seventh ACIS International Conference on Software Engineering, Artificial Intelligence, Networking, and Parallel/Distributed Computing (SNPD'06)	10.1109/SNPD-SAWN.2006.16	microcontroller;sensor web;embedded system;fault tolerance;real-time computing;wireless sensor network;sensor node;computer science;key distribution in wireless sensor networks;mobile wireless sensor network;computer network;visual sensor network	Mobile	-38.8668877321096	46.17797969914147	91237
c4faaee73266d1b5460002127c10eab5ea954fcf	10th international workshop on dynamic software product lines (dspl'17): adaptive systems through runtime variability		Dynamic Software Product Lines (DSPLs) is still an incipient paradigm to support runtime reconfiguration of systems that need to change their behavior under varying circumstances. As many modern systems demand reconfiguration after post-deployment time, this 10th edition of the DSPL workshops attempts to bring new insight and approaches for such needs.	heart rate variability;programming paradigm;software deployment;software product line	Jesper Andersson;Rafael Capilla;Luciano Baresi;Holger Eichelberger	2017		10.1145/3106195.3106200	control reconfiguration;adaptive system;systems engineering;software;computer science	Arch	-43.20182664686267	39.32124997069073	91635
ca3e5a7dfeda0ebb755966d72ca90fd62e0b58b3	qos specification in ambient intelligence systems	pervasive computer systems qos specification ambient intelligence systems human centric ami systems quality of service ami requirements;ami requirements;communication system;formal specification;memory management;pervasive computer systems;service provider;ambient intelligence;pervasive computing;resource management;qos specification;runtime;ambient intelligence quality of service pervasive computing runtime bandwidth memory management energy management environmental management resource management power system management;ambient intelligence systems;power system management;ubiquitous computing formal specification quality of service;bandwidth;ubiquitous computing;quality of service;environmental management;energy management;human centric ami systems	Quality of Service (QoS) is a central characteristic of human-centric Ambient Intelligence (Ami) systems, since it has a strong relation to the degree of satisfaction with the services provided to users. Hence, Ami applications must be able to describe their QoS needs as well as capabilities so that the corresponding infrastructures can match the latter to the preferences of users. Current QoS specification techniques are concentrated on special domains like communication systems and do not address special aspects of the Ami field like high dynamics. In this paper we, elaborate the special Ami requirements posed to QoS specifications and describe an initial approach towards a solution.	ambient intelligence;quality of service;requirement	Daniel Schneider;Michalis Anastasopoulos;Joachim Bayer;Martin Becker;Christian Webel	2007	IEEE International Conference on Pervasive Services	10.1109/PERSER.2007.4283930	service provider;real-time computing;mobile qos;quality of service;ambient intelligence;computer science;formal specification;computer security;ubiquitous computing;bandwidth;communications system;computer network;memory management;energy management	Robotics	-41.28048834096602	43.705130952262415	91645
75827f5ed132d801ff068dddca50d36ee598de2e	partes: performance analysis of real-time embedded systems	system modeling;mobius modeling environment;model parameter space;system modeler design of experiment mobius modeling environment model parameter space;design of experiments;modelling design of experiments discrete event simulation discrete event systems;complex system;parameter space;discrete event systems;system modeler;predictive models computational modeling design optimization discrete event systems performance analysis data security numerical models lead design for experiments response surface methodology;discrete event simulation;design of experiment	The development of performance models from real-time system source code can be a time consuming process. It can be difficult to capture actual system timing values to be used in these models. The tool PARTES is introduced. PARTES facilitates the extraction of CSPL (C-based stochastic Petri net language) models from an ANSTC program which has been annotated by the user. These models are then subjected to sensitivity analysis via the SPNP (stochastic Petri net package). The results from analysis can be used to directly identify any potentially problematic timing areas in the original source code.	embedded system;profiling (computer programming);real-time clock;real-time computing;real-time transcription;stochastic petri net	Benjamin Gorry;Andrew Ireland;Peter King	2007	Fourth International Conference on the Quantitative Evaluation of Systems (QEST 2007)	10.1109/QEST.2007.17	econometrics;complex systems;simulation;computer science;machine learning;mathematics;design of experiments;statistics	Embedded	-41.67401688934916	34.41714215073078	92108
16980def2814fd6d94cfadaa6d3a33b27e4c4d6e	lightweight application-level task migration for mobile cloud computing	instruments;mobile device;performance evaluation;conference_paper;resource allocation;mobile agents;application level;mobile devices lightweight application level task migration mobile cloud computing mobile application resource utilization computation migration mobile nodes cloud nodes highly portable approach transparent migration approach code instrumentation runtime overhead mobile agents migration points migration status java byte code transformation technique asynchronous migration technique user code twin method hierarchy overhead minimization state restoration code middleware cloud resources;system recovery;code instrumentation;mobile communication;mobile handsets;resource allocation cloud computing java middleware mobile agents mobile computing;computation migration;middleware;stack on demand computation migration migration technqiue;migration technqiue;mobile node;mobile handsets instruments java mobile communication performance evaluation cloud computing system recovery;stack on demand;mobile agent;mobile computing;mobile application;cloud computing;java	Mobile cloud computing allows mobile applications to use the enormous resources in the clouds. In order to seamlessly utilize the resources, it is common to migrate computation among mobile nodes and cloud nodes. Therefore, a highly portable and transparent migration approach is needed. In terms of portability, application-level migration with code instrumentation is the most portable approach. However, in the existing literature, this approach imposes significant runtime overhead, even when no migration takes place. Most of these works are for mobile agents, and migrations are to be invoked by the programs. Migration points are also restricted to certain locations where migration status is being polled. In this paper, we propose a Java byte code transformation technique for realizing task migration without imposing significant overhead on normal execution. Asynchronous migration technique is used to allow migrations to take place virtually anywhere in the user codes, and the proposed Twin Method Hierarchy minimizes the overhead resulting from state-restoration codes in normal execution. We have implemented our approach in our middleware. The results show that our approach can allow lightweight computation migration at application level, achieve considerable speedups and utilize the cloud resources from mobile devices.	byte;circuit restoration;code;computation;java bytecode;middleware;mobile agent;mobile app;mobile cloud computing;mobile device;overhead (computing);polling (computer science);software portability	Ricky K. K. Ma;Cho-Li Wang	2012	2012 IEEE 26th International Conference on Advanced Information Networking and Applications	10.1109/AINA.2012.124	embedded system;instrumentation;real-time computing;mobile telephony;cloud computing;resource allocation;computer science;operating system;middleware;application layer;mobile agent;mobile device;database;distributed computing;java;mobile computing;computer security;computer network	HPC	-37.2242741406579	46.26521196689007	92389
2ef546a40a7319a7474baacabe9c34645ed03da5	formal verification of medical cps: a laser incision case study		The use of robots in operating rooms improves safety and decreases patient recovery time and surgeon fatigue, but it introduces new potential hazards that can lead to severe injury or even the loss of human life. Thus, safety has been perceived as a crucial system property since the early days by the industry, the medical community, and the regulatory agents. In this article, we discuss the application of the mathematically rigorous technique known as Formal Verification to analyze the safety properties of a laser incision case study, and we assess its safe and predictable operation. Like all formal methods approaches, our analysis has three distinct components: a method to create a model of the system, a language to specify the properties, and a strategy to prove rigorously that the behavior of the model fulfills the desired properties. The model of the system takes the form of a hybrid automaton consisting of a discrete control part that operates in a continuous environment. The safety constraints are formalized as reachability properties of the hybrid automaton model, while the verification strategy exploits the capabilities of the tool Ariadne to address the verification problem and answer the related questions ranging from safety to efficiency and effectiveness.	approximation error;automata theory;binary prefix;computational complexity theory;cyber-physical system;design flow (eda);differential inclusion;discretization;formal methods;formal verification;guard (computer science);hybrid automaton;initial condition;interval arithmetic;level of detail;nondeterministic algorithm;nonlinear system;numerical analysis;programming paradigm;prototype;reachability;robot;round-off error;scalability;time complexity	Andre A. Geraldes;Luca Geretti;Davide Bresolin;Riccardo Muradore;Paolo Fiorini;Leonardo S. Mattos;Tiziano Villa	2018	TCPS	10.1145/3140237	hybrid system;computer engineering;real-time computing;engineering;formal verification;laser	Logic	-45.081090439183804	36.02537420573173	92403
bc9e347c90e9a9dc0da18dd0ba57312b3b450dc1	dynamic reconfiguration through a generic connector		In component-based programming, it is often desirable that applications can be modeled as sets of services executed by components selected at runtime. In order to support this requirement, we present the Generic Connector, a mechanism that searches for components that provide the services required in the application connguration program, activates each service and returns the results to the client. The Generic Connector explores Lua's and LuaOrb's intrinsic characteristics. Lua is a dynamically typed, interpreted language and LuaOrb is a binding between CORBA and Lua that provides dynamic access to CORBA objects. The Generic Connector allows the connguration of applications as sets of services without previous knowledge about the components that will actually provide them. As components are selected on-they , the Generic Connector turns out to be a powerful mechanism for dynamic reconnguration.	common object request broker architecture;component-based software engineering;interpreted language;lua;name binding;run time (program lifecycle phase);type system	Thaís Vasconcelos Batista;Christina von Flach G. Chavez;Noemi de La Rocque Rodriguez	2000			control reconfiguration;parallel computing;computer science;distributed computing;cable gland	PL	-37.43634946026591	39.11348777307009	92476
726b1c26df0572fecc63814bbf7c279ddc314cad	a novel multi-agent framework for the design of home automation	automatic control;appliance control home automation space agents governor agent network interfaces upnp scp bridge power line communication scp control protocol data gathering information analysis control home devices multiagent systems;control home devices;protocols;multi agent system;scp control protocol;data gathering;governor agent;upnp scp bridge;bridges;space agents;network interfaces;multi agent systems;power line communication;power line communications;multi agent systems home automation;power system management;appliance control;home automation communication system control network interfaces bridges power line communications automatic control protocols power system management information analysis multiagent systems;communication system control;network interface;information analysis;simulation environment;multiagent systems;home automation	A novel hierarchical multi-agent framework for the design of home automation is proposed in this paper. The proposed framework consists of several space agents and a governor agent. The governor agent, situated in the home gateway with network interfaces, can communicate with space agents through UPnP-SCP Bridge. Each space agent was linked through power line communication used SCP control protocol. Located in the top level with global view, the role of the governor agent is to manage and coordinate each space agent to reach the designated goal. The space agent is responsible for data gathering, information analysis, and control home devices within its coverage. The function of the multi-agent system can help users control appliances by learning and analyzing their behaviors. A simulation environment was provided in this study to verify the feasibility of the proposed approach	home automation;multi-agent system;power-line communication;simulation;situated;universal plug and play	Wen-Hui Chen;Wen-Shang Tseng	2007	Fourth International Conference on Information Technology (ITNG'07)	10.1109/ITNG.2007.13	embedded system;real-time computing;simulation;computer science;artificial intelligence;network interface;multi-agent system;computer security;computer network	Robotics	-40.51473303203064	44.997782347312494	92504
8c08c62aa7951abc25be344954a756b93f5ab0b4	a declarative control language for dependable xml message queues	formal specification;queueing theory;web service;transactional xml data store declarative control language dependable xml message queues dependable web service engines distributed network xml message processing business process;internet;web design;business data processing;xml web services engines procurement packaging protocols telecommunication network reliability hardware standards development middleware;declarative languages;xml;message passing;transaction processing;message passing internet xml transaction processing queueing theory formal specification business data processing web design;business process	We present a novel approach for the implementation of efficient and dependable Web service engines (WSEs). A WSE instance represents a single node in a distributed network of participants that communicate using XML messages. We introduce a fully declarative language custom-tailored to XML message processing that allows to specify business processes in a concise manner. To support the efficient and reliable evaluation of our language, we show how to augment a native, transactional XML data store with efficient and reliable XML message queues.	business process execution language;business process;data store;declarative programming;dependability;high- and low-level;logic programming;mathematical optimization;message queue;parallel computing;requirement;rule-based system;systems design;web services enhancements;web service;xml	Alexander Böhm;Carl-Christian Kanne;Guido Moerkotte	2006	First International Conference on Availability, Reliability and Security (ARES'06)	10.1109/ARES.2006.4	xml validation;xml encryption;xml;xml schema;streaming xml;xml protocol;computer science;document structure description;ws-policy;xml framework;soap;xml database;xml schema;database;distributed computing;xml signature;ebxml;world wide web;xml schema editor;cxml;efficient xml interchange	DB	-36.702053837453704	40.12070720931312	92538
4bf620f0284aee0993f59b9aa6729c1ffbb02e3a	ginconf: a configuration and execution interface for wireless sensor network in industrial context	web service;wireless sensor network;high performance	Wireless sensor networks (WSNs) are deployed to sense, monitor and act on the environment. Some applications of these networks, especially in industrial sense and react scenarios, require high performance and guaranties. Our work is focused on building a system that allows configuring/reconfiguring alarms, actions or closed-loop techniques in the context of GINSENG project – wireless sensor networks with performance control guarantees. We propose an approach for interaction with real-world devices through a web services interface, allowing users to configure and apply various operations, including complex closed-loop techniques that monitor and act over any actuator in the WSN. To allow the interaction between a client application and the motes we implemented an API to access services of the motes.	application programming interface;client (computing);web service	José Cecílio;Marly G. F. Costa;Pedro Martins;Pedro Nuno San-Bento Furtado	2010		10.1007/978-3-642-17520-6_23	sensor web;embedded system;service set;wi-fi;wireless wan;wireless sensor network;heterogeneous network;wireless site survey;wireless network;distributed computing;wireless lan controller;key distribution in wireless sensor networks;municipal wireless network;wi-fi array;fixed wireless;mobile wireless sensor network;computer network;visual sensor network	Mobile	-38.9804392467222	46.22483261873967	92615
38b4ec6946e8b570c10c2521b31aa190e8718f25	towards a new meta-model of io lnteroperability		An IoT platform is a fusion of physical resources such as connectors, wireless networks, smart phones and computer technologies viz; protocols, web service technologies, etc. the heterogeneity of used technologies generates a high cost at interoperability level. This paper presents a generic meta-model of IoT interoperability based on different organizational concepts such as service, compilation, activity and architectures. This model called M2IOTI, defines a very simple description of the IoT interoperability. M2IOTI is a meta-model of IoT interoperability by which one can build a model of IoT interoperability with different forms of organizations. We show that this meta-model allows for connected objects heterogeneity in semantic technologies, activities, services and architectures, in order to offer a high level atIoT interoperability. We also introduce the concept PSM which uses the same conceptual model to describe each interoperability model already existed. Such as conceptual, behavioral, semantic and dynamic models. We have also proposed a PIM model that regroups all the common concepts between the PSMs interoperability models.		Rachida Ait Abdelouahid;Abdelaziz Marzak;Nawal Sael	2018	2018 IEEE 5th International Congress on Information Science and Technology (CiSt)	10.1109/CIST.2018.8596441	conceptual model;xml;wireless network;semantic technology;metamodeling;unified modeling language;web service;interoperability;systems engineering;computer science	Visualization	-42.445307377737784	44.73074201116591	92718
11678bf2fa28550d8b2ba81b55d728960b583542	a study of context-based adaptive service model in home environments	context awareness;context based adaptive service model cbasm;ubiquitous application service	This paper suggests an adaptive service model designed under context-based home environment. This model is based for ubiquitous home environment that consists of numerous sensors, devices, measuring equipments and common interfaces provided for interoperability. Furthermore, this model provides the context information requested under applied services. In order to deal with these service’s requirements, this paper suggests a software structure based on distributed object group framework for context-based adaptive service. This context information is modeled under ontology categorized as distinguishable characters of home environment. Finally, we show the structure of system with application service based on it.	categorization;distributed object;information model;interoperability;performance evaluation;protégé;requirement;sensor;ubiquitous computing	Su-Chong Joo;Chang-Won Jeong;K. H. Kim	2013	Telecommunication Systems	10.1007/s11235-011-9550-0	simulation;differentiated service;knowledge management;context model;world wide web	Mobile	-40.965267042417324	44.50195530554309	92764
b2e5df555ea02d834139fa6b859bfa4636bb1c66	an agent-based framework for inhabitants' untraceability in ubiquitous environments	agent based simulation;agent based;agent based ubiquitous applications;mobile agents;information processing;smart spaces;simulation tool for evaluation;mobile agent;simulation tool;human activity;untraceability;smart environment;ubiquitous computing environment	Seamless information processing is gradually being integrated into daily human activities by creating a ubiquitous computing environment. Such information processing requires continuous access to the profiles of users so that the environment can act based on users' preferences. In this paper, we present a design of an experimental study of an agent-based approach to control resource consumption in a ubiquitous environment. A key idea is to explore whether it is feasible to use a mechanism that may help preserve inhabitants' privacy while at the same time provide a smart environment which resolves conflicts based on the preferences of the inhabitants. Experiments will be based on Bosthan, an agent-based simulator for smart spaces that is currently under development. Bosthan can simulate smart environments to investigate and evaluate different ubiquitous applications.	agent-based model;cryptosystem;experiment;information processing;open shading language;privacy;simulation;smart tv;smart environment;ubiquitous computing	Sherin M. Moussa;Mohamed Hashem;Gul A. Agha	2009		10.1145/1821748.1821822	simulation;human–computer interaction;information processing;computer science;knowledge management;mobile agent;smart environment;ubiquitous robot	HCI	-41.125342947281176	45.06473237944987	93043
be912a97406d9915ed411ae48b9c879c2de8e128	reconstruction of software component architectures and behaviour models using static and dynamic analysis		Model-Based Performance Prediction (MBPP, [BDIS04a]) is a software engineering discipline which systematically deals with the evaluation of software performance. MBPP’s central idea is to predict the performance of a software system based on performance models. MBPP can be applied at design-time to avoid bottlenecks when designing a software architecture but also for existing software systems. For existing software systems, one is interested in scalability analysis and resource sizing without actually buying expensive hardware and setting up the execution environment for each possible execution scenario. Additionally, when extending an existing software system by a new component, software performance models allow to estimate the impact of the extension and help avoiding the introduction of bottlenecks. Consider the example of a legacy accounting application: When extending such an application by a new reporting component, it should be estimated how the overall performance (e.g. response time) of the system is affected. Applying MBPP requires the presence of up-to-date software performance models. To reason on software architectures, these models must capture the architecture itself as well as the behaviour of each architecture component. Unfortunately, current reverse engineering techniques often aim at the static software architecture and understanding of software systems [CZvD09]. No approach reverse engineers software performance models at an architectural level which are required to enable software performance engineering. Thus, currently performance models must be created manually when aiming at the support of design decisions for software architectures. The contribution of this thesis is a new integrated reverse engineering approach for the reconstruction of parameterised software component architectures and software component behaviour models which can serve as software performance models due to the execution semantics of the target model. This approach allows reverse engineering behaviour models for each component’s service from code using static, dynamic, and statistical analysis techniques. For performance prediction, the Palladio Component Model Approach [BKR09] is used. The new reverse engineering approach reconstructs static architecture information (components, interfaces, and connectors) as well as a performance behaviour model capturing control and data flow for each provided service of a component. The reverse engineered models are semantically rich so they can serve for performance simulation approaches without requiring manual complements. Since these models are highly parameterised (avoiding constants) they not only help understanding the	behavioral modeling;bottleneck (software);code refactoring;component-based software engineering;dataflow;legacy system;performance engineering;performance prediction;program comprehension;programming language;response time (technology);reverse engineering;scalability;simulation;software architecture;software performance testing;software system	Klaus Krogmann	2010			real-time computing;simulation;theoretical computer science	SE	-43.81495159260931	34.39428622170564	93423
44185e12b60f063866177697990167de158bd449	towards the definition of a framework for service development in the agrofood domain - a conceptual model	settore inf 01 informatica;settore ing inf 05 sistemi di elaborazione delle informazioni	This paper describes the work done in the project MoseForAgrofood (Ms4A) whose goal is to take advantage of mobile technologies to develop augmented Web services for the agrofood domain. The use of personal devices, such as smart phones and tablets, brings in specific issues such as the need to consider quality of protection, quality of services, quality of data at any stage of the service life cycle. In this paper we propose a conceptual model that aims to support the service development and provisioning addressing the above issues by managing suitable non-functional properties.	augmented web;provisioning;quality of service;requirement;smartphone;tablet computer;web service	Donato Barbagallo;Cinzia Cappiello;Alberto Coen-Porisini;Pietro Colombo;Marco Comerio;Flavio De Paoli;Chiara Francalanci;Alessandra Rizzardi	2012			computer science;algorithm	HCI	-42.25523706307611	44.75599316036875	93437
c4f24c84bd2f08233be6aa52cfc3485b31b5bca6	combining horizontal and vertical composition of services	software;vertical service composition;service composition;composition;information hiding;provisioning;cloud;semantics;soa;black box service community middleware information hiding vertical service composition quality of service enterprise service soa;data encapsulation;black box;engines;service community;enterprise service;web services;middleware;service oriented architecture data encapsulation middleware quality of service;enterprise service bus;concrete engines web services hardware semantics software;quality of service;service oriented architecture;cloud soa composition provisioning enterprise service bus;communication service;concrete;hardware	Service composition is a well-established field of research in the service community. Services are commonly regarded as black boxes with well-defined interfaces that can be recursively aggregated into new services. The black-box nature of services does not only include the service implementation but also implies the use of middleware and hardware to run the services. Thus, service composition techniques are typically limited to choosing between a set of available services. In this paper, we keep the black-box nature and the principle of information hiding of services, but in addition we break up services vertically. By introducing vertical service composition, we allow services to be provisioned on demand using the middleware and runtime environment that specifically meets user-required quality of services. Therefore, a service is setup individually for services requestors instead of providing them with a pre-determined list of available services to choose from. We introduce the concept of vertical service composition and present an extension to an enterprise service bus that implements the concept of vertical service composition by combining concepts from provisioning with those of (dynamic) service binding.	black box;enterprise integration;enterprise service bus;interaction;middleware;provisioning;recursion;runtime system;service composability principle;virtual collective consciousness	Ralph Retter;Christoph Fehling;Dimka Karastoyanova;Frank Leymann;Daniel Schleicher	2010	2010 IEEE International Conference on Service-Oriented Computing and Applications (SOCA)	10.1007/s11761-011-0095-6	service level requirement;service level objective;mobile qos;service product management;differentiated service;computer science;service delivery framework;service-oriented architecture;database;semantics;service discovery;services computing;data as a service;law;world wide web;computer network	HPC	-46.33531391415999	44.10677149057583	93740
40a23733e81b224fbfdd60e8e977f7f18b14e65b	addressing assurance for self-adaptive systems in the face of uncertainty	biology uncertainty self adaptive cyber physical systems physical environment cyber environment threats overt attacks model based development automated assurance technique self adaptation software engineering technique control theory machine learning;uncertainty software engineering conferences computer science software face computational modeling;uncertain systems adaptive systems cyber physical systems learning artificial intelligence security of data	This presentation will overview several research projects that investigate novel ways to model, analyze, and mitigate uncertainty for self-adaptive cyber-physical systems, with a particular focus on assurance. First, uncertainty about the physical environment can lead to suboptimal, and sometimes catastrophic, results as the system tries to adapt to unanticipated or poorly-understood environmental conditions. Second, uncertainty in the cyber environment can lead to unexpected and adverse effects, including not only performance impacts (load, traffic, etc.) but also potential threats or overt attacks. Finally, uncertainty can exist with the components themselves and how they interact upon reconfiguration, including unexpected and unwanted feature interactions. Each of these sources of uncertainty can potentially be identified at different stages, respectively design time and run time, but their mitigation might be done at the same or at a different stage. Based on the related literature and our investigations, we argue that the following three overarching techniques are essential and warrant further research to provide enabling technologies to address uncertainty during both stages: model-based development, automated assurance techniques, and self-adaptation. Furthermore, we posit that in order to go beyond incremental improvements to current software engineering techniques, we need to infuse these three areas with successful techniques and inspirations from other disciplines, such as control theory, machine learning, and biology.	adaptive system;control theory;cyber-physical system;interaction;machine learning;model-driven engineering;run time (program lifecycle phase);software engineering	Betty H. C. Cheng	2016	2016 IEEE International Conference on Autonomic Computing (ICAC)	10.1109/ICAC.2016.53	simulation;computer science;artificial intelligence;database;distributed computing;computer security	SE	-43.70504231403667	38.32827432089343	93879
2c6f27ec531b05539af8834d356ca76a30b71c97	increasing systems resilience through the implementation of a proactive technology refreshment program	program;technology;resilience;system;refreshment	Systems resilience has become a growing need and concern over the last decade. Systems are designed to meet requirements and maintain operational characteristics over long operational lives, frequently plagued with uncertainties regarding operational environments and profiles. Meeting requirements along is no longer sufficient. Resilience is the capability that systems have to mitigate the severity and the likelihood of failures or losses; that is, it is the system's capability for adapting to changing needs and conditions by responding appropriately to them. Systems have to exhibit such resilient capability but it is difficult to ensure it, in the face of so many uncertainties in the evolution of the needs, in the intended operational life and system utilization profile. Nevertheless, technology refreshment programs offer a valuable help to attain the so desired level of resilience. Through the continuous assessment of the evolution of the need or opportunity that triggered the design of the system, the monitoring of the performance of the system and the screening of new technologies and capabilities becoming available, technology refreshment programs allow for the performance of resilience-growth programs. This paper presents a detailed technology refreshment methodology and illustrates how through its application a resilience-growth program can be implemented and conducted during the entire operational life of a system.		Alberto Sols	2014		10.1016/j.procs.2014.03.004	simulation;artificial intelligence;system;psychological resilience;technology	EDA	-44.45218275287362	38.19105594455713	93940
de4f16b11f2aa21aed9874ebf038629f339b25e4	a flexible protocol composition for multi-party coordination protocols in multi-agent systems	flexible protocol composition;protocols multiagent systems monitoring pervasive computing packaging specification languages informatics authentication frequency;protocols;multi agent system;metadata;multi agent systems;protocols meta data multi agent systems;metadata flexible protocol composition multi party coordination protocols multi agent systems;protocol composition;meta data;multi party coordination protocols;metadata multi agent system protocol composition	Multi-agent systems need protocols to coordinate among agents implemented by different owners. However, specifying coordination protocols for many participating agents is a complex task. A protocol composition approach, which can reduce the complexity of specifying such a coordination protocol, must specify how to compose coordination protocols in a composition configuration. Current protocol compositions cannot sufficiently reduce the complexity because composing a protocol several times requires the specification of too many configurations. We propose a protocol composition approach that can specify composition configurations in an abstract way. We assign metadata to the messages in a coordination protocol and use the metadata to specify the configuration. An abstract configuration using metadata can be applied to various protocol compositions and can reduce the number of specifications required for configuration composition.	communications protocol;multi-agent system;protocol stack;web service	Ryuichi Takahashi;Kenji Tei;Fuyuki Ishikawa;Yoshiaki Fukazawa;Shinichi Honiden	2008	2008 Sixth Annual IEEE International Conference on Pervasive Computing and Communications (PerCom)	10.1109/PERCOM.2008.94	general inter-orb protocol;universal composability;two-phase commit protocol;computer science;multi-agent system;database;distributed computing;metadata;world wide web	Robotics	-35.52365926489248	44.85831512934374	93988
93430330eee8a958b0461296fb265e30f4f34312	reactive information processing	software;internet of things;software unified modeling language internet of things xml adaptation models information processing;information processing;unified modeling language;xml;reactive internet software reactive information processing internet computing big data internet of things iot plug play middleware mapreduce the reactive manifesto software applications componentization node js websockets state chart xml w3 standard;xml big data internet internet of things;adaptation models	People agree that there are two major concerns in Internet computing: Big Data and the Internet of Things (IoT). On purpose, expected evolutions and progresses in technology and science are ruled by the development of suited paradigms (e.g., plug & play middleware for the IoT or MapReduce for Big Data) to face up this “ever encountered” nature of Internet computing. To that extent, information processing (from raw data to meaningful - i.e., semantically rich-information) encompasses the necessity of building a considerable pool of Internet software in a truly different way. Such a paradigm shift is exposed in “The Reactive Manifesto” (www.reactivemanifesto.org). From an architectural perspective, this manifesto promotes software applications' componentization along with the idea of reactiveness: event-driven/message-driven, elasticity, responsiveness and resilience. In short, applications' components have emerging (reactive) features through their ability to seamlessly cooperate with events/messages. Nowadays, successes like Node.js or WebSockets strongly confirm the benefit of reactiveness. Beyond, this keynote tries to demystify and illustrate “reactiveness” through the State Chart XML W3 standard. The keynote discusses methods to design reactive Internet software from models to concrete implementation supports.	big data;elasticity (data store);event-driven architecture;information processing;internet of things;mapreduce;middleware;node.js;plug and play;programming paradigm;responsiveness;websocket;xml	Franck Barbier	2016	2016 IEEE Tenth International Conference on Research Challenges in Information Science (RCIS)	10.1109/RCIS.2016.7549276	unified modeling language;the internet;xml;web of things;information processing;computer science;artificial intelligence;operating system;software engineering;data mining;database;world wide web;internet of things	SE	-44.90443171834454	45.35310563498868	94013
a15d90ac97353464b30aa9ea01f28c1058b9758d	an approach to adaptive distributed execution monitoring for workflows in service-based systems	virtual machines distributed processing software architecture software quality utility programs;virtual machine;workflows control;virtual machine based;distributed processing;workflows monitoring;computing services;qos;dynamic environment;software architecture;virtual machines;and automated generation service based systems workflow adaptive execution monitoring virtual machine based architecture;workflows monitoring adaptive distributed execution monitoring service based systems service oriented architecture computing services qos temporary unavailability services quality degradation virtual machine based architecture workflows control;adaptive execution monitoring;utility programs;workflow;temporary unavailability;adaptive distributed execution monitoring;service oriented architecture;service based systems;architecture;automated generation;monitoring and control;software quality;condition monitoring computerized monitoring service oriented architecture computer architecture virtual machine monitors distributed computing automatic control quality of service control systems computer interfaces;and automated generation;services quality degradation;virtual machine based architecture	Systems based on service-oriented architecture are called service-based systems (SBS), and comprise of computing services offered by various organizations. Users of SBS often require these services to be composed into complex workflows to perform their high-level tasks. The users usually have certain expectations on the overall QoS of their workflows. Due to the highly dynamic environments of SBS, in which temporary unavailability or quality- degradation of services may occur frequently and unexpectedly, monitoring the execution of workflows in SBS is necessary, and should be done in distributed and proactive manner. In this paper, a virtual machine-based architecture for the execution, monitoring and control of workflows in SBS is presented. Based on this architecture, an approach to automated generation of workflow monitors for adaptive distributed execution monitoring of workflows in SBS is discussed.	elegant degradation;experiment;high- and low-level;overhead (computing);prototype;quality of service;service-oriented architecture;service-oriented device architecture;simulation;smart battery system;unavailability;virtual machine	Stephen S. Yau;Dazhi Huang;Luping Zhu	2007	31st Annual International Computer Software and Applications Conference (COMPSAC 2007)	10.1109/COMPSAC.2007.57	real-time computing;computer science;virtual machine;operating system;software engineering;database;distributed computing	DB	-39.19585464978513	40.197500491675186	94439
2fd5760c090ec170bee9ff6069c0f96a8d4ebfec	a concept for a medical device plug-and-play architecture based on web services	information model;plug and play;testing;web service;medical devices;software safety;rfid;event notification;medical device;devices profile for web services;service discovery	Medical device interoperability is still an issue. Standards exist only for specific areas like HL7 and DICOM, or have not been widely adopted like ISO/IEEE 11073 except for the domain information model at the semantic level. An approach that covers interoperability below the semantics is proposed. It is based on Web services which are widely accepted outside the medical device application domain. In particular the architecture is build on the upcoming Device Profile for Web Services (DPWS). It is a collection of existing Web services specifications for service discovery, interface description, event notification, and security. It is designed for resource-constrained devices and thus seems to be suitable as a basis for medical device plug-and-play.	application domain;dicom;devices profile for web services;event (computing);health level 7;information model;interoperability;plug and play;service discovery;web service	Stephan Pöhlsen;Stefan Schlichting;Markus Strähle;Frank Franz;Christian Werner	2009	SIGBED Review	10.1145/1859823.1859829	radio-frequency identification;web service;web application security;web development;web modeling;web standards;information model;computer science;operating system;ws-policy;ws-addressing;database;software testing;service discovery;services computing;ws-i basic profile;web 2.0;world wide web;computer security;devices profile for web services;universal description discovery and integration	Web+IR	-42.55037163050261	45.29976793958715	94460
3f439cf2c2329b0214a876bd2f1be764b777564b	a test model for hardware and software systems	software testing;software systems;hardware testing;systems validation and verification;hardware design verification;safety critical systems		software system	József Sziray	2004	JACIII	10.20965/jaciii.2004.p0523	non-regression testing;hardware compatibility list;computer architecture;verification and validation;regression testing;verification;formal methods;system integration testing;software verification;software reliability testing;software development;software construction;design for testing;hardware architecture;software testing;high-level verification;life-critical system;systems development life cycle;software deployment;intelligent verification;software fault tolerance;software system	Arch	-47.930311698055	32.99799231403904	94631
04db02acfb3b8270c181149b5baf273267bf569e	evolution of adaptive population control in multi-agent systems	self adaptive agent based systems adaptive population control multiagent systems dynamic population management artificial immune systems digital evolution self replicating computer programs digital organisms self adaptive replication behaviors attack fluctuations self organizing agent based systems;organisms;genomics;computer program;attack fluctuations;artificial immune system;multi agent system;multi agent systems artificial immune systems;adaptive population control;self adaptive replication behaviors;environmental conditions;digital evolution;self adaptive agent based systems;biology;dynamic population management;multi agent system digital evolution cooperative behavior natural selection population regulation;evolution biology;cooperative behavior;multi agent systems;self organizing agent based systems;natural selection;population control;agent based system;immune system;digital organisms;self organization;programmable control adaptive control control systems multiagent systems artificial immune systems degradation quality of service environmental management genetic mutations organisms;quality of service;artificial immune systems;self replicating computer programs;population regulation;multiagent systems;bioinformatics	Dynamic population management is an important aspect of multi-agent systems. In artificial immune systems, for example, a shortage of agents can lead to undetected threats, while an overabundance of agents can degrade quality of service and if unchecked, even create new vulnerabilities. Unfortunately, designing an effective strategy for population management is complicated by the myriad of possible circumstances and environmental conditions the agents may face after deployment. In this paper, we present the results of a study in applying digital evolution to the population management problem. In digital evolution, populations of self-replicating computer programs evolve in a user-defined computational environment, where they are subject to mutations and natural selection. Our results demonstrate that populations of digital organisms are capable of evolving self-adaptive replication behaviors that respond to attack fluctuations, as well as clever strategies for cooperating to mitigate attacks. This study provides evidence that digital evolution may be a useful tool in the design of self-organizing and self-adaptive agent-based systems.	agent-based model;artificial immune system;autonomous robot;avida;computer program;denial-of-service attack;digital organism;distributed computing;evolution;intrusion detection system;multi-agent system;organizing (structure);population;quality of service;self-organization;self-replication;software deployment;threat (computer);world-system	Benjamin E. Beckmann;Philip K. McKinley	2008	2008 Second IEEE International Conference on Self-Adaptive and Self-Organizing Systems	10.1109/SASO.2008.56	simulation;computer science;artificial intelligence;multi-agent system;artificial immune system	AI	-44.027717322931	39.09399297248357	94874
81c6953ff3227dbaa646840b2549b00f29f1fdb9	process state machines for behavioral modeling of embedded systems	hw sw co design;design model;embedded systems and soc design;hdl;multi threading;multithreaded c uml profile;hardware software codesign;design engineering;systemc code process state machines embedded system behavioral modeling soc system on chip model driven hw sw co design methodology systemc uml profile multithreaded c uml profile register transfer level hdl uml state machine formalism concurrency aspects;behavior modeling;state machine;systemc embedded systems and soc design model driven engineering uml statemachines;system on a chip;embedded system;concurrency aspects;systemc uml profile;embedded systems;finite state machines;c language;uml state machine formalism;uml profile;system on chip;levels of abstraction;uml statemachines;unified modeling language;concurrency control;model driven engineering;performance analysis;unified modeling language c language concurrency control embedded systems finite state machines hardware software codesign multi threading system on chip;model driven hw sw co design methodology;process state machines;soc;productivity;register transfer level;embedded system unified modeling language system on a chip model driven engineering proposals productivity timing design engineering real time systems performance analysis;proposals;systemc code;systemc;real time systems;embedded system behavioral modeling;timing	In the embedded systems and SoC (system-on-chip) area, we defined a model-driven HW-SW co-design methodology based on the UML 2, a SystemC UML profile for the HW side, and a multi-threaded C UML profile for the SW side, which allows modeling of the system at higher levels of abstraction (from a functional executable level to register transfer level) - far beyond the capabilities of existing HDLs. In this paper, we present the SystemC Process State Machines, an extension of the UML state machine formalism, that we defined as part of the SystemC UML profile to model the reactive behavior and concurrency aspects of SoC components, abstracting the SystemC design primitives available for this scope and guaranteeing straightforward translation to SystemC code.	behavioral modeling;concurrency (computer science);electronic design automation;embedded system;executable;finite-state machine;model-driven integration;principle of abstraction;process state;register-transfer level;requirement;semantics (computer science);shattered world;system on a chip;systemc;thread (computing);uml state machine;unified modeling language	Sara Bocchio;Elvinia Riccobene;Alberto Rosti;Patrizia Scandurra	2007	2007 International Symposium on Industrial Embedded Systems	10.1109/SIES.2007.4297345	system on a chip;embedded system;computer architecture;transaction-level modeling;parallel computing;real-time computing;uml state machine;uml tool;computer science;applications of uml;finite-state machine	Embedded	-39.75418681683226	33.02307549613705	94934
d75cedf49daf3145b08de83fe38b75f46ddfe980	formal specification of wireless and pervasive healthcare applications	formal specification;formal method;wireless and pervasive healthcare applications;methodologies and tools;point of view	Wireless and pervasive healthcare applications typically present critical requirements from the point of view of functional correctness, reliability, availability, security, and safety. In contrast to the case of classic safety critical applications, the behavior of wireless and pervasive applications is affected by the movements and location of users and resources.  This article presents a methodology to formally express requirements in safety critical wireless and pervasive healthcare applications in order to achieve a higher degree of dependability. In particular, it will be shown how it is possible to formalize and constrict mobility characteristics by combining, and in some cases extending, several formal methods. The article also describes a rigorous specification process. Finally, it concludes with a case study of a real safety critical pervasive healthcare application that is going to be deployed in a city hospital.	correctness (computer science);dependability;formal methods;formal specification;pervasive informatics;requirement	Antonio Coronato;Giuseppe De Pietro	2010	ACM Trans. Embedded Comput. Syst.	10.1145/1814539.1814551	formal methods;computer science;formal specification;programming language;computer security	Embedded	-44.35170343490256	35.905535745177446	95260
f4e3566db64e620f6e182d2d0f83bedd10f4a0e0	towards runtime adaptation in a soa environment.	service oriented architecture	Service Oriented Architecture (SOA) promotes the utilization of available services to develop completely new applications in a context which has not been foreseen as these services were implemented. Unfortunately the interfaces respectively the behaviour of a service often do not fit exactly to the new domain. Slight changes would be necessary to reuse them in the new environment. This paper presents an approach to integrate dynamic AOP into a SOA platform to adapt existing services at runtime to new requirements. Services can then be reused without the need of stopping and redeployment.	requirement;run time (program lifecycle phase);service-oriented architecture	Florian Irmert;Marcus Meyerhöfer;Markus Weiten	2007			computer science;service-oriented architecture;oasis soa reference model	SE	-42.11999302193731	40.42728297593084	95469
76926b711f46ba3ef54b52ed8d9824b0b0aa1e76	a framework to evaluate autonomic behaviours for intelligent truck parking		This paper presents a multi-agent platform to evaluate different strategies to manage the negotiated management of parking spaces in road rest areas. The system dynamically adapts itself to the preferences and needs of the drivers of goods about parking requests. The system is shown to be robust to incidents regarding the closure of road rest areas and allows a conversational interaction of new parking requests through an Android based mobile application.	autonomic computing	José F. García;Vicente R. Tomás López;Luís A. García;Juan J. Martínez	2016		10.1007/978-3-319-39324-7_26	android (operating system);simulation;truck;business	Robotics	-41.86701477321789	42.030124251717154	95486
6af1fb26c08a41d62b3799b43839ac9bf2859d3f	on the use of cep in safety-critical systems		Safety-critical systems have to continuously manage risks, in order to handle hazardous situations and still be able to fulfil their purpose. While being composed by a variety of software, as well as hardware components, it is necessary for each part of these systems, alone and as a whole, to exhibit a required set of characteristics, necessary to ensure the correct system functioning. Complex Event Processing (CEP) systems have been used in a diversity of applications and, while they focus on fast data gathering and processing as well as in providing intelligence to their users, there is incomplete information about how they are adequate to integrate safety-critical systems. In this paper we investigate if the mainstream off-the-shelf CEP systems are suitable for safety-critical applications. We describe the use of complex event processing engines in safety-critical systems and how some authors enhance those to better correspond to the critical system requirements. We demonstrate that, although dependability is well handled in most CEP systems, the same cannot be assumed about security and safety attributes.	authentication;complex event processing;computer security;critical system;dependability;encryption;list of system quality attributes;protection mechanism;requirement;system requirements;system safety	Veronika Abramova;Jorge Bernardino;Bruno Cabral	2017		10.5220/0006308401020109	reliability engineering;life-critical system;engineering	OS	-47.241046122055934	38.31817834841257	95570
c9c9293e8dd06ec2360539f0bc39f401357f5e7a	an industrial application of model checking to a vessel control system	vehicle control;control systems;correctness properties;protocols;distributed vessel control system;formal specification;testing;software engineering;protocols control systems delay safety synchronization testing;conference contribution paper in published proceedings;spin;finite state machines;control system;formal verification;new zealand abstracted finite state model model checking exhaustive state space search correctness properties software design distributed vessel control system;model checking;synchronization;industrial control;safety;exhaustive state space search;industrial application;control engineering computing;search problems;software design;new zealand;abstracted finite state model;ttcan;software engineering control engineering computing finite state machines formal specification formal verification industrial control search problems	Model checking allows an abstracted finite state model of a system to be developed and a set of mathematically defined correctness properties, based on the design specifications, to be defined. The model checker performs an exhaustive state space search of the model, checking the correctness properties hold at each step. This paper describes how model checking has been applied to find and correct problems in the software design of a distributed vessel control system currently under development at a control systems specialist in New Zealand.	backup;can bus;control system;correctness (computer science);intermittent fault;model checking;simulation;software design;software project management;state space search;test automation;verification and validation	Daniel Keating;Allan McInnes;Michael P. Hayes	2011	2011 Sixth IEEE International Symposium on Electronic Design, Test and Application	10.1109/DELTA.2011.24	control engineering;model checking;communications protocol;synchronization;real-time computing;formal verification;computer science;control system;software design;theoretical computer science;operating system;formal specification;software testing;spin;abstraction model checking;algorithm	Embedded	-44.916545541983695	32.88228749557166	95729
202fc4065157f3c0f0b75cafcdd5dc2594bcd177	modeling the environment in software-intensive systems	software intensive system development;inf;chemical processes;formal specification;software component software intensive system development formal model orderly safe traffic system environment modeling;formal model;application software;software systems;traffic control;object oriented programming;software engineering;distributed modelling;embedded system;software systems traffic control software engineering control system synthesis application software chemical processes embedded system;control system synthesis;software component;model based development;model merging;environment modeling;orderly safe traffic system;object oriented programming formal specification	"""In this paper we argue that the modeling activity in the development of software-intensive systems should formalize as much as possible of the environment in which the application being developed operates. We also show that a rich formal model of the environment helps developers clearly state requirements that might typically be considered intrinsically informal (or non-formalizable in general). To illustrate this point, we show how a requirement for """"orderly safe traffic"""" in a traffic system can be modeled, and we briefly discuss the benefits thereof."""	mathematical model;requirement	Carlo A. Furia;Matteo Rossi;Dino Mandrioli	2007	International Workshop on Modeling in Software Engineering (MISE'07: ICSE Workshop 2007)	10.1109/MISE.2007.11	embedded system;application software;real-time computing;computer science;systems engineering;component-based software engineering;operating system;software engineering;formal specification;chemical process;programming language;object-oriented programming;model-based design;software system	SE	-44.64338596842048	33.124812107055284	95842
beb4d5684ac17dcbb9d2cdaca547e969465df8e0	towards dependable service-orientated computing systems	service oriented computing	Service-orienting computing systems refer to computing and information systems that are developed in service-oriented architecture, service-oriented computing paradigm, and service-oriented development lifecycle. The development of service-oriented computing systems is completing the first decade in its lifespan. Service-oriented computing systems started with the concept of Service-Oriented Architecture (SOA). As distributed architecture, SOA considers a software system consisting of a collection of loosely coupled services that communicate with each other through standard interfaces and protocols. These services are platform-independent. They can be published in public or private directories or repositories for software developers to reuse and to compose their applications. As software architecture, SOA is a conceptual model that concerns the organization and interfacing among the software components (services). It does not concern the development of operational software. The definitions of the Simple Object Access Protocol (SOAP) in 2000, the Web Services Description Language (WSDL) in 2001, and the Universal Description Discovery and Integration (UDDI) in 2002 established the foundation of Web Services (WS) and WS-based architecture, which gave SOA a live instance and paved it road to the success. The next step of the development is the formation of Service-Oriented Computing (SOC) paradigm. SOC paradigm is based on the SOA conceptual model. However, it goes a step further to include not only the concepts and principles, but also the methods, algorithms, coding, and evaluation considerations, which are a large part of the software development process. As shown in Fig. 1, layers of technologies have been developed for supporting SOC system development, includes	algorithm;capability maturity model;component-based software engineering;computer programming;dependability;distributed computing;experiment;information system;loose coupling;programming paradigm;soap;service-oriented architecture;service-oriented device architecture;software architecture;software developer;software development process;software repository;software system;web services description language;web services discovery;web service;world wide web	Yinong Chen;Wei-Tek Tsai	2009	Simulation Modelling Practice and Theory	10.1016/j.simpat.2009.06.009	context-aware pervasive systems;computer science;service-oriented architecture;end-user computing;distributed computing;utility computing;grid computing;autonomic computing	SE	-38.63258061617455	42.335951612843026	95867
65b29ebc83e1ec3173841cf1aa1f95499b7bd6f5	spreadsheet as a multi-platform mobile application		The idea we want to advocate is the rapid prototyping of mobile multi-platform applications in the form of vanilla spreadsheets based on spreadsheet formulas, data validation and conditional formatting for tasks like entering and validating data, computing results and generating reports.  Spreadsheet software systems, available on all major desktop and mobile platforms, provide runtime environment for such spreadsheet applications without the need for any plugins. Apart from playing the rôle of a virtual machine, the environment provides also the user interface. Therefore such a spreadsheet becomes instantly a multi-platform application, working both on-line and off-line.  We report on our case study of creating a mobile tool for archaeologists working in the field: a specialized spreadsheet for managing stratigraphic information. The resulting application passed satisfactorily a test of six weeks of regular excavations. Techniques used in the development can be considered as the first good practices for developing spreadsheet mobile applications.	data validation;desktop computer;mobile app;online and offline;plug-in (computing);rapid prototyping;runtime system;software system;spreadsheet;user interface;virtual machine	Jerzy Sikora;Jacek Sroka;Jerzy Tyszkiewicz	2015	2015 2nd ACM International Conference on Mobile Software Engineering and Systems		embedded system;simulation;human–computer interaction;computer science	SE	-34.612162405924124	40.02455315888945	96261
01f9c174d38ba0154b701dcae3ac076a8b341846	the use of runtime configuration capabilities for networked embedded systems	runtime configuration capabilities;life cycle;embedded systems;embedded system;real time os;design automation	Reconfiguration is a very helpful feature that can improve the design life cycle of an embedded system and its quality. Reconfiguration means that software AND hardware parts may be updated in the field. The update of system hardware implies the use of FPGAs in a shipped system. Normally, the update is done server controlled, which means that the active role comes from an external instance. We present a new automatic reconfiguration approach that stores all system configuration data in XML format. The system itself searches for the related components a component broker, and sets up during start up. A case study shows that especially when dealing with permanently connected devices, we achieve promising results while spending a reasonable price. Concept of a RCC Embedded System1 The system consists of three basic parts: the hardware pool, the system management software (firmware) and code describing the user application. The system architecture provides a set of hardware facilities, like microprocessors, DSPs and FPGAs. These hardware parts are connected by a bus or another communication interface. A network interface connects the system to the internet. The basic idea of our concept is the strict separation of design and implementation of an application. Application designers can focus to a global view of the application and their functional aspects. The application designer defines functional units and describes the interaction between these parts. The implementation is the job of code writers. There can be a set of different pieces of software (plug-ins) implementing the functionality of a special component. The choice for a special plug-in (mapping process) depends on statical and dynamical constraints, like microprocessor architecture or current system load. We use XML to describe the functional structure and behavior of the application. The goal of our design study is a system, which analyzes the XML specification and locates all required plug-ins autonomously. This requires extensive use of directory and naming services etc. Fortunately, there are a variety of technologies offering these services. We decided to use the Enterprise Java Beans2 (EJB) technology. If a client wants to execute some kind of application, the XML specification has to be analyzed first. The next step is the mapping process. The system has to find and access the code, which implements the functional components. These pieces of code will be loaded onto the target. The methods of Enterprise Java Beans implement this mapping functionality. The output are objects containing executable code, which can run on a microprocessor or will be used to configure a FPGA.	bus (computing);digital signal processor;directory (computing);embedded system;enterprise javabeans;executable;field-programmable gate array;firmware;internet;java platform, enterprise edition;load (computing);microprocessor;network interface controller;plug-in (computing);server (computing);system configuration;systems architecture;systems management;xml	Carsten Nitsch;Udo Kebschull	2002			embedded system;biological life cycle;real-time computing;computer science;operating system;distributed computing;programming language	OS	-34.0618169196937	39.98442860150742	96313
870e79e52ca026f520eba43c5185ee05a47f7ef8	linked services for enabling interoperability in the sensing enterprise	000 computer science knowledge systems;410 linguistics;510 mathematics	In future, the so called “sensing enterprise”, as part of the Future Internet, will play a crucial role in the success or the failure of an enterprise. We present our vision of an enterprise interacting with the physical world based on a retail scenario. One of the main challenges is the interoperability not only between the enterprise IT systems themselves, but also between these systems and the sensing devices. We will argue that semantically enriched service descriptions, the so called linked services will ease interoperability between two or more enterprises IT systems, and between enterprise systems and the physical environment.	business process;embedded system;enterprise system;future internet;high- and low-level;integration platform;interaction;interoperability;linked data;real-time locating system	Matthias Thoma;Alexandru-Florian Antonescu;Theano Mintsi;Torsten Braun	2013		10.1007/978-3-642-36796-0_12	enterprise architecture framework;functional software architecture;enterprise system;enterprise application integration;enterprise systems engineering;enterprise software;computer science;systems engineering;knowledge management;architecture domain;integrated enterprise modeling;enterprise architecture management;enterprise architecture;enterprise integration;world wide web;enterprise information system;enterprise life cycle	OS	-43.24007177798141	45.53786174502653	96784
0e86c93a02cd60b2169163737a69507b06743d41	reflective layer activation in contextl	dynamic layer activation;context oriented programming;layer combination;active layer;software composition	Expressing layer dependencies in Context-oriented Programming is cumbersome because until now no facility has been introduced to control the activation and deactivation of layers. This paper presents a novel reflective interface that provides such control without compromising efficiency. This allows expressing complex application-defined dependencies between layers where the activation or deactivation of a layer requires the activation or deactivation of another one. The activation or deactivation of specific layers can also be prohibited based on application-defined conditions.		Pascal Costanza;Robert Hirschfeld	2007		10.1145/1244002.1244279	real-time computing;computer science;function composition;programming language	HCI	-38.74840861073069	37.88204038071378	96843
9a626fc12a6c172d9782dc1781ada8d10e638f26	dynamic architectures for soa-based applications	architecture classification;architecture classification scheme;major computer company;existing service;dynamic architectures;software architecture study;soa-based applications;soa-based application;new software requirement;traditional software architecture;new direction;wellknown soa-based application	The architecture of SOA-based applications is different from traditional software architecture where the architecture is mainly static. The architecture of an SOA-based application is dynamic, i.e., the application may be composed at runtime using existing services. Thus SOA has provided a new direction for software architecture study, where the architecture is determined at runtime and the architecture can be dynamically changed at runtime to meet the new software requirements. This paper proposes an architecture classification scheme for SOA-based applications. Using this classification, several wellknown SOA-based applications are reviewed including the architectures proposed and adopted by major computer companies and standard organizations. The architecture classification provides a unified way to evaluate a variety of architectures for SOA-based applications.		Wei-Tek Tsai;Raymond A. Paul;Chun Fan;Xiao Wei	2007	Transactions of the SDPS		dataflow architecture;multilayered architecture;enterprise architecture framework;reference architecture;embedded system;software architecture;space-based architecture;real-time computing;database-centric architecture;computer science;architecture domain;applications architecture;cellular architecture;service-oriented modeling;software engineering;solution architecture;software architecture description;view model;data architecture;systems architecture;oasis soa reference model	Visualization	-46.87788467689154	37.76233326976963	96919
56b65c9cc5486b74731cccede184c36a23cdcb09	an investigation into the use of the tuple space paradigm in mobile computing environments	tuple space;mobile computer;qa75 electronic computers computer science;qa75 electronic computers computer science computer software	.................................................................................................... i Dedication .............................................................................................. iii Acknowledgements................................................................................ iv Declaration............................................................................................. vi	declaration (computer programming);mobile computing;programming paradigm;tuple space	Stephen Paul Wade	1999			computing;human–computer interaction;computer science;theoretical computer science;mobile agent;computer engineering	DB	-36.672932263267555	40.63780631920674	96947
1e77b38179f7e315ae0f12fdad779eb7e36d462a	metaft-a reflective approach to implement replication techniques in corba	distributed system;electrical capacitance tomography;protocols;electronic mail;heart;fault tolerant;heterogeneous systems;application code;meta object protocol;heterogeneous environments;object request broker metaft reflective approach replication techniques corba heterogeneous systems meta object approach orbs group communication heterogeneous environments omg fault tolerance coordination protocols application code quality of service corba platforms distributed systems fault tolerance computational reflection object management group;lungs;heterogeneous environment;distributed computing;computational reflection;software fault tolerance;corba platforms;coordination protocols;corba;group communication;computer architecture;omg;fault tolerant systems;support group;replication techniques;metaft;reflective approach;fault tolerance;distributed object management;object management group;software fault tolerance quality of service distributed object management;orbs;quality of service;distributed systems;electrical capacitance tomography protocols reflection lungs electronic mail fault tolerant systems distributed computing computer architecture fault tolerance heart;object request broker;reflection;meta object approach	A model was introduced in [Fraga97] for integrating replication techniques in heterogeneous systems. The model adopts a reflective structure based on the meta-object approach [10]. Also, this model is founded in ORBs that support group communication in heterogeneous environments. The OMG still does not have specifications for fault tolerance. The MetaFT model has a great flexibility allowing, for instance, to modify the coordination protocols according to the fault tolerance level desired, without any implications for the application code. The advantage is that it allows to use different meta-object protocol to assist different quality of service (QoS) parameters to fault tolerance. This paper explicit our experiences in developing replication techniques following the model using two different CORBA platforms and presents some performance	code;common object request broker architecture;es evm;fault tolerance;metaobject;quality of service;reflection (computer programming);replication (computing)	Lau Cheuk Lung;Joni da Silva Fraga;Carlos Maziero	1999		10.1109/SCCC.1999.810150	embedded system;real-time computing;computer science;distributed computing	DB	-37.584115403148246	39.95625317235411	97147
11d1cf030188451a288d26a1c4869f6b1e9c2a2b	an adaptive middleware design to support the dynamic interpretation of domain-specific models	adaptable middleware;models at runtime;domain independence;domain specific classifier	ContextAs the use of Domain-Specific Modeling Languages (DSMLs) continues to gain popularity, we have developed new ways to execute DSML models. The most popular approach is to execute code resulting from a model-to-code transformation. An alternative approach is to directly execute these models using a semantic-rich execution engine - Domain-Specific Virtual Machine (DSVM). The DSVM includes a middleware layer responsible for the delivery of services in a given domain. ObjectiveWe will investigate an approach that performs the dynamic combination of constructs in the middleware layer of DSVMs to support the delivery of domain-specific services. This middleware should provide: (a) a model of execution (MoE) that dynamically integrates decoupled domain-specific knowledge (DSK) for service delivery, (b) runtime adaptability based on context and available resources, and (c) the same level of operational assurance as any DSVM middleware. MethodOur approach will involve (1) defining a framework that supports the dynamic combination of MoE and DSK and (2) demonstrating the applicability of our framework in the DSVM middleware for user-centric communication. We will measure the overhead of our approach and provide a cost-benefit analysis factoring in its runtime adaptability using appropriate experimentation. ResultsOur experiments show that combining the DSK and MoE for a DSVM middleware allow us to realize efficient specialization while maintaining the required operability. We also show that the overhead introduced by adaptation is not necessarily deleterious to overall performance in a domain as it may result in more efficient operation selection. ConclusionThe approach defined for the DSVM middleware allows for greater flexibility in service delivery while reducing the complexity of application development for the user. These benefits are achieved at the expense of increased execution times, however this increase may be negligible depending on the domain.	domain-specific language;middleware	Karl A. Morris;Mark Allison;Fábio M. Costa;Jinpeng Wei;Peter J. Clarke	2015	Information & Software Technology	10.1016/j.infsof.2015.02.003	embedded system;real-time computing;computer science;middleware;database;distributed computing	SE	-42.07040487094208	42.34670702357364	97192
00fb1fe0cc49ed7e14012247043576c120d0e503	framework for estimating energy consumption in embedded systems	software;manuals;mobile robot;mobile robots;cyber physical systems;embedded system;wireless communication;mobile robots computer power supplies embedded systems;embedded systems;monitoring;energy consumption;energy aware;energy model energy aware battery autonomy;process control;servomotors;energy model;software servomotors sonar manuals process control monitoring wireless communication;mobile robotics energy consumption estimation embedded computer system cyber physical systems electromechanical devices battery autonomy power failure embedded software operating modes;battery autonomy;computer power supplies;embedded computing;sonar	Cyber-Physical Systems (CPS) are characterizedby an intensive interaction between its electro-mechanicaldevices and the embedded computer system. In most of thesesystems the battery autonomy is crucial, since power failurescan render the system inoperable. Therefore CPS designersmust take good-care regarding its energy consumption. Thispaper presents a framework to monitor the energy consump-tion in CPS in order to estimate its autonomy. The developedapproach is based on the characterization of the embeddedsoftware operating modes, which represent the operationalstates of the system. To illustrate the proposed framework we carried out a case-study applied to mobile robotics.	cp system;computer;cyber-physical system;embedded system;mobile robot;operability;robotics	Elisabete Nakoneczny Moraes;Leandro Buss Becker	2011	2011 Brazilian Symposium on Computing System Engineering	10.1109/SBESC.2011.13	control engineering;embedded system;real-time computing;engineering;cyber-physical system	Embedded	-42.63541728584398	37.887349075919126	97231
39cbc7adaaa57ddcf948bd1c0a8c51b8e8b7a4a9	a novel framework for virtual organization creation on cloud		Nowadays, virtual organizations (VOs) need to utilize new technologies in order to respond rapidly to collaboration opportunities. Cloud computing is a new paradigm that could leverage VO efficiency and flexibility whilst it could decrease VO expenditures and response time. Also, VO breeding environment (VBE) is an approach to create efficient VOs. Thus, combination of VBE and cloud computing may facilitate VOs creation and reactions to upcoming opportunities. This paper has proposed a framework to create VO on cloud environment, including three phases: creating and managing VBE on cloud, moving VBE on cloud and finally creating VO on cloud. The proposed framework may be considered as a solution to cope with VO requirements.		Mona Zamanian;Mehran Mohsenzadeh;Ramin Nassiri	2014		10.1007/978-3-662-44745-1_43	systems engineering;knowledge management;virtual organization;cloud computing;computer science	Visualization	-46.26965096660493	44.795314656682	97240
1fa06dada5c0d4c43ffe286c3ada00c3bf55cb89	configurable executable task models supporting the transition from design time to runtime	task modeling;temporal relations;runtime support;executable task model	Model-based design of user interfaces mostly starts with task and domain modeling. The resulting models are an important input to subsequent development steps. Thus, a thorough evaluation of these specifications is of great importance, e.g. to avoid the implementation of bad or even error prone solutions. Executable task models are in use for several years to evaluate the design time specifications. They are also used at runtime by now as part of the final application. In this paper we propose an executable task model that is configured using the design time model. Kernel concept of this work is a task state machine describing a generic task life cycle assigned to each task. Developers may extend it at design time to describe application dependent behavior. The extensions are automatically transferred to the runtime system. A further focus of the paper is on the specification of temporal relations and their extensibility in terms of model description and execution.	executable	Birgit Bomsdorf;Stefan Grau;Martin Hudasch;Jan-Torsten Milde	2011		10.1007/978-3-642-21602-2_18	real-time computing;computer science;operating system;task analysis;distributed computing;programming language	HCI	-43.12454224411584	34.025856674454374	97377
351ed251d6fa9077e01ddfa68d8f35f743f2a6be	semantic interactions in the internet of things	iot;semantic web technology;internet of things;semantic interactions;smart spaces;smart objects	The long-term vision of the Internet of Things (IoT) is to extend the reach of the Internet to any object we can imagine. This new level of connectivity and the presence of smart objects in our environments will make possible systems and applications requiring new kind of interactions. In this paper we present our proposal of semantic interactions for addressing interaction problems in the IoT. We describe some possible scenarios of the IoT where users interact with smart objects in smart spaces. We explain how semantic web technologies can be used for creating richer interactions and also present the evaluation of our proposal by applying the concepts of this work in a system prototype.	interaction;internet of things;prototype;real-time transcription;semantic web;semantic web service;sentience;smart tv;smart objects;smart system;web page;web search engine;wheels	Paul E. Estrada-Martinez;J. Antonio García-Macías	2013	IJAHUC	10.1504/IJAHUC.2013.055464	web of things;human–computer interaction;computer science;knowledge management;internet privacy;world wide web;internet of things	HCI	-41.39400338009122	45.98331177335825	97684
57744d336e9154443e073b6cbaeeb2c64eff42c8	reconfiguration strategies for critical adaptive distributed embedded systems		This paper describes the architecture and mechanisms proposed in the context of the DFT4FTT project for implementing Adaptive Distributed Embedded Systems (ADESs), that is, distributed systems with real-time, dependability and adaptivity requirements. The focus is on the reconfiguration strategies that allow, not only to change the system behaviour, but to improve its tolerance to permanent hardware faults.		Alberto Ballesteros;Julian Proenza;Manuel Barranco;Luis Fernando de Almeida	2018	2018 48th Annual IEEE/IFIP International Conference on Dependable Systems and Networks Workshops (DSN-W)	10.1109/DSN-W.2018.00028	task analysis;architecture;resource management;embedded system;real-time computing;fault tolerance;control reconfiguration;computer science;distributed computing;dependability	Embedded	-34.546082026202676	37.818956655310664	97846
cb3b531328f3b1bd29fbd850fad135badfcf4e77	schedulability and safety analysis in the graphical communicating shared resources	resource allocations;resource contentions;graphical specification;state space methods;formal specification;information science;mobile robot;processor scheduling;resource allocation;scheduling disciplines;calculus of communicating systems;specification;functional requirements;graphical communicating shared resources;operational semantics;delay effects;formal languages;telecommunication computing;safety properties schedulability safety analysis graphical communicating shared resources formal language specification real time systems resource requirements temporal requirements functional requirements resource contentions resource inherent constraints resource allocations scheduling disciplines operational semantics formal analysis mobile robotic application;runtime;safety properties;resource inherent constraints;safety analysis;algebra;specification languages;safety real time systems telecommunication computing information science runtime algebra processor scheduling formal languages information analysis delay effects;scheduling;schedulability;temporal requirements;resource requirements;safety;analysis;state space methods real time systems formal specification specification languages resource allocation scheduling calculus of communicating systems;formal analysis;information analysis;mobile robotic application;formal language;real time systems	Graphical Communicating Shared Resources is a formal language for the speciication and analysis of real-time systems, including their functional, temporal and resource requirements. GCSR supports the explicit representation of system resources and priorities to arbitrate resource contentions. These features allow a designer to examine resource inherent constraints and to experiment with various resource allocations and scheduling disciplines in order to produce a more dependable speciication. In addition, GCSR has a precise operational semantics and notions of equivalence that allow the execution and formal analysis of a speciication. In this paper, we show how to model a scheduling discipline and verify schedulability and safety properties within GCSR. We illustrate our method through a mobile robotic application.	formal language;graphical user interface;operational semantics;real-time clock;real-time computing;requirement;robot;scheduling (computing);turing completeness	Hanêne Ben-Abdallah;Young-Si Kim;Insup Lee	1996		10.1109/WORDS.1996.506258	real-time computing;computer science;theoretical computer science;distributed computing	Embedded	-37.417320868544955	32.321106337884586	98108
4a064d04fc95f5b253659536d6d10147b71510f9	the implementation of xpdl workflow verification service based on saas	databases;software;mapping algorithm;routing;web and internet services;logic;verification algorithm;xpdl process definition;runtime;inspection;process sub model;laboratories costs inspection runtime logic databases web and internet services simultaneous localization and mapping error correction workflow management software;formal verification;system recovery;internet;error correction;simultaneous localization and mapping;web services;process control;xml;workflow management software;software algorithms;mapping algorithm saas xpdl verification algorithm extended petri net;verification algorithms;software as a service;petri net;xpdl process definition xpdl workflow verification service software as a service verification algorithms process sub model extended petri net;xpdl;algorithm design and analysis;xml formal verification web services workflow management software;xpdl workflow verification service;extended petri net;saas	The process sub-model is the core of workflow model, verifying process sub-model before deployment can reduce the cost of shutdown, inspection and repair at run-time. This paper proposes verification algorithms, which focus on structural errors of process sub-model, and those algorithms will use the characteristics of the extended Petri net discussed in this paper. Simultaneously, this paper explains how to design a XPDL Validator based on SaaS and it emphasis on mapping XPDL process definition to extended Petri net.	algorithm;control flow;petri net;process modeling;shutdown (computing);software as a service;software deployment;validator;verification and validation;xpdl	Ding Xiao;Qianqian Zhang	2010	2010 International Conference on Service Sciences	10.1109/ICSS.2010.26	xpdl;computer science;systems engineering;workflow management coalition;database;distributed computing	EDA	-45.352600672223396	32.73727604428692	98320
2de5629a036d647d5ae8dd69143aff9153e8dbf0	a visual approach to validating system level designs	formal specification;simulation;sequence charts;systemc based checker engine visual approach system level designs validation simulation based methodology visual specification live sequence charts;formal method;high level synthesis;formal specification high level synthesis system on chip;system on chip;system level design;validation methodology;live sequence chart;system level design analytical models permission engines design engineering visualization automatic programming formal verification lead	This paper proposes a simulation-based methodology for validation of a system under design in an early phase of development. The key element of this approach is the visual specification, as Live Sequence Charts (LSCs), of the properties to be checked. The LSCs are automatically translated into the input format for the SystemC-based checker engine, which indicates during simulation, if the property is fulfilled or produces a counter-example, if the property is violated. The entire process from the visual property specification to the checking is largely automated, which makes our approach accessible even for users which have not been trained in formal methods.	chart;formal methods;simulation;systemc	Jürgen Ruf;Thomas Kropf;Jochen Klose	2002		10.1145/581199.581240	real-time computing;formal methods;computer science;systems engineering;formal specification;engineering drawing	SE	-41.071451324651974	32.75931453099626	98542
a03ce4a12241a7033ac7f532c1b3554c153dd349	an efficiency-centric design methodology for mobile application architectures	model view controller;mobile application architecture;design principles mobile application architecture design guidelines model view controller;mobile communication computer architecture guidelines servers complexity theory mobile handsets synchronization;mobile handsets;design guidelines;mvc architecture efficiency centric design methodology mobile application architectures software architecture heavy weight functionality model view controller architecture;design principles	Software architecture is known as an effective solution to realize extra-functional and quality requirements. It becomes even more important in developing efficient mobile applications since the resource limitation drawback of mobile devices can be remedied with architecture design. A general guideline is to place heavy-weight functionality on server sides, however more specific and detailed guidelines for developing mobile applications architectures and for evaluating the architecture are yet to come. In this paper, we present a design methodology for mobile applications architectures. We first present different patterns of Model-View-Controller (MVC) architecture for mobile applications. And, we define design criteria for mobile applications architectures, from which design guidelines are derived. With a set of experiments, the proposed methodology is evaluated.	architectural pattern;computer;experiment;mobile app;mobile device;model–view–controller;requirement;server (computing);software architecture	Hyun Jung La;Ho Joong Lee;Soo Dong Kim	2011	2011 IEEE 7th International Conference on Wireless and Mobile Computing, Networking and Communications (WiMob)	10.1109/WiMOB.2011.6085388	enterprise architecture framework;reference architecture;embedded system;software architecture;space-based architecture;website architecture;desktop and mobile architecture for system hardware;real-time computing;database-centric architecture;computer science;applications architecture;cellular architecture;design elements and principles;solution architecture;software architecture description;model–view–controller;mobile computing;data architecture	Mobile	-42.95868122474963	43.148696947380536	98664
50ebb4fb321cd607d91072b9d43729fc8450237e	role-based security for configurable distributed control systems	hypermedia markup languages;fault tolerant;distributed control system;distributed control security computer architecture permission distributed computing fault tolerance xml timing fault tolerant systems computer science;distributed computing;software fault tolerance;corba;hypermedia markup languages distributed object management software fault tolerance safety critical software application program interfaces;aspect description;safety critical software;application program interfaces;distributed object management;xml;distributed tele laboratory application role based security configurable distributed control systems common object request broker architecture corba object based distributed computing architecture reliable fault tolerant secure software corbasec specification coarse grained mechanisms access rights fault tolerance security extension data abstraction data encapsulation internal behavior resource usage fault tolerance mechanisms interface definition language idl functional interface nonfunctional properties security settings role based security aspect oriented programming description language extended markup language xml orbacus corba implementation secure corba service;security;common object request broker architecture;component configuration	The Common Object Request Broker Architecture (CORBA) is the most successful representative of an object-based distributed computing architecture. Alth ough CORBA simplifies the implementation of complex, dis tributed systems significantly, the support of techniqu es for reliable, fault-tolerant, and secure software is ve ry limited in the state-of-the-art CORBA. Extensions, such as the CORBAsec specification provide only a limited choic e of coarse-grained mechanisms to specify access rights for components. Any fault-tolerance or security extension for CORBA components needs to trade off data abstraction and encapsulation against implementation specific knowledge about a component’s internal behavior, resource usage, in teraction and access patterns. These non-functional aspe ct of a component are crucial for the predictable behavior of security and fault-tolerance mechanisms. However, in co trast to CORBA’s interface definition language (IDL ), which describes a component’s functional interface, th re is no general means to describe a component’s nonfunctional properties, such as security settings or faulttolerance. Within this paper we present our approach towards role-based security for CORBA. Following the idea o f aspect-oriented programming, we have developed a desc ription language for security settings. The descriptio n language uses the eXtended Markup Language (XML) as an underlying representation and allows specification f access rights independently from an object’s implemen tation. A role-editor tool allows for configuration of a c omponent’s security settings without affecting the comp nent’s source code. Security settings are enforced by our enhanced version of the ORBacus CORBA implementation. We discuss the necessary description and configurat ion steps for a secure CORBA service. We demonstrate ho w our previously developed distributed tele-laborator y application can be configured for secure access. One may notice that, although this configuration step require d the development of a number of role descriptions, no modi fications to the tele-laboratory’s source code were nec essary.	abstraction (software engineering);aspect-oriented programming;common object request broker architecture;component-based software engineering;computer architecture;distributed computing;distributed control system;fault tolerance;interface description language;java;limbo;markup language;object-based language;quality of service;role-based access control;television;transport layer security;xml	Michael Hauf;Janek Schwarz;Andreas Polze	2001		10.1109/WORDS.2001.945121	software security assurance;computer security model;interface description language;real-time computing;common component architecture;computer science;common object request broker architecture;database;distributed computing	Security	-37.77609494687008	39.2744012626145	98773
6acae593ca411c2789040b1429669c0050eec1df	a tool supported methodology to passively test asynchronous systems with multiple users		Abstract Context: Testing usually involves the interaction of the tester with the system under test. However, there are many situations in which this interaction is not feasible and so one requires a passive approach in which the system is analysed to look for failures or unexpected behaviours. The entities of a complex system usually communicate in an asynchronous manner and this complicates the testing tasks since the observed order of events need not be the same as the order in which the events were produced. In previous work, we presented a formal passive testing theory for a single user and system communicating through an asynchronous channel. We were able to check that a trace generated by the system satisfies a given property. Objective: This papers extends our work, for detecting potential intrusions and unexpected behaviours, to the case where many users simultaneously communicate with a central server. We evaluate the practical value of the theoretical framework with a non-trivial system. Method: We developed a novel complete theoretical framework to analyse asynchronous systems with multiple users. All the algorithms are fully implemented. Experiments were performed over the Nextcloud platform to show the applicability of our framework. The experiments include an attack so that actual vulnerabilities could be revealed. Results: The application of our methodology, supported by a tool fully implementing it, was able to reveal a vulnerability in the WebDAV protocol running on Nextcloud. Conclusion: The extension of our previous work is not only useful from a theoretical point of view but also increases the applicability of the original work. We are now able to analyse systems where the interaction with different users can lead to unexpected behaviours. We have been able to find a vulnerability in a real system, showing the usefulness of our work.	asynchronous system;multi-user	Mercedes G. Merayo;Robert Mark Hierons;Manuel Núñez	2018	Information & Software Technology	10.1016/j.infsof.2018.07.013	data mining;real-time computing;system under test;complex system;computer science;test theory;webdav;asynchronous communication;vulnerability;communication channel	EDA	-41.72183458043541	35.65815597592372	98806
42afc8d91da0ce4f8639e35f7fb3803c2bdf2eb5	a middleware for discovering proximity-based service-oriented industrial internet of things	context weight schemes proximity based service oriented industrial internet of things discovery spatial information real time resource discovery data retrieval technology mobile devices real time content mash up services resource management continuous resource discovery handheld mobile devices utility cloud services task offloading process context awareness service oriented workflow based mobile cloud middleware framework task allocation cost performance index scheme workflow configuration decision making fuzzy set;performance evaluation;service oriented architecture cloud computing fuzzy set theory internet of things middleware mobile computing;mobile communication cloud computing servers mobile handsets performance evaluation real time systems;internet of things;servers;workflow system;mobile cloud;mobile communication;mobile handsets;service discovery;service oriented architecture;cloud computing;real time systems;workflow system service discovery service oriented architecture mobile cloud internet of things	In the near future, Industrial Internet of Things can provide various useful spatial information in urban areas. Based on real time resource discovery and data retrieval technologies, mobile devices can continuously interact with surrounding things and provide real time content mash up services to their users. One challenge involved in such a scenario falls in the resource management. Continuous resource discovery and content mash up processes can be resource intensive for common handheld mobile devices. In order to reduce the resource usage, certain tasks of mobile application can be offloaded to Utility Cloud services. However, the task offloading process needs to be context-aware. In certain cases, performing tasks in mobile devices is more cost-efficient. This paper proposes a service-oriented workflow based mobile Cloud middleware framework for balancing the task allocation between the mobile terminal and utility Cloud service. The proposed cost-performance index scheme assists workflow configuration decision-making based on fuzzy set and weight of context schemes. The prototype has been implemented in real mobile devices and the evaluation has shown that the workflow system can automatically configure the task allocation based on resource availabilities.	autonomous robot;cost efficiency;data retrieval;fuzzy set;handheld game console;interaction;internet of things;mash-1;middleware;mobile app;mobile device;mobile phone;prototype;quality of service;run time (program lifecycle phase);service composability principle;service-oriented device architecture;service-oriented middleware	Chii Chang;Satish Narayana Srirama;Jakob Mass	2015	2015 IEEE International Conference on Services Computing	10.1109/SCC.2015.27	real-time computing;mobile search;mobile web;mobile database;computer science;mobile technology;distributed computing;mobile computing;world wide web;workflow management system	Robotics	-40.90753574435887	44.56669466286664	98956
da8d1202a12df5ba38667990754e0829641c27c7	a decentralized data replication approach for the reconfigurable robotic information and control systems		This paper continues our previous studies on the reconfigurable robotic information and control system dependability. We consider the approach to the configuration forming optimization problem solving. This approach presupposes the criteria number reducing by the additional software functions implementation. These functions include tasks context data replication to the computational units, where those tasks can be launched after the reconfiguration procedure. Within the current paper some generic approaches to the context data storage element interaction are presented. The first approach is centralized and based on the principles of Viewstamped replication protocol, the second one is fully decentralized. Both of the approaches are discussed and estimated in terms of the communication environment workload, the conclusion is made, as well as some outlines of the future work.		Eduard Menik;Anna Klimenko	2018		10.1007/978-3-319-99582-3_14	workload;real-time computing;control reconfiguration;replication (computing);software;computer science;control system;dependability;computer data storage;optimization problem	Robotics	-36.8150796236978	37.38435876515177	98958
e9a4706f5f79d56976b8cfee4611446c576aad1f	continuity aspects of embedded reconfigurable computing	reconfigurable computing;dynamic reconfiguration;indexing terms;embedded system;formal method;software development	In embedded systems, dynamically reconfigurable computing can be partially modified at runtime without stopping the operation of the whole system. In this paper, we consider a reorganization mechanism for dynamically reconfigurable computing in embedded systems to guarantee that invariants of the design are respected. This reorganization is considered as a visual transformation of the logical configuration by the formulated rules. The invariant is recognized under the restructuring of the configuration using reconfiguration rules.	complexity;embedded system;formal methods;graph rewriting;invariant (computer science);reconfigurability;reconfigurable computing;run time (program lifecycle phase);scott continuity	Phan C. Vinh;Jonathan P. Bowen	2005	Innovations in Systems and Software Engineering	10.1007/s11334-005-0003-3	embedded system;parallel computing;real-time computing;formal methods;index term;reconfigurable computing;computer science;software development;distributed computing	EDA	-34.038407459790896	33.70063773458861	98997
5d9b908919746b6e48bf68939dc762bc5f11cf13	a model of domain-polymorph component for heterogeneous system design	components;heterogeneous systems;software engineering;embedded system;signal processing;polymorphism;heterogeneous design;heterogeneous embedded systems;actors;model of computation;domain specificity	Heterogeneous systems mix different technical domains such as signal processing, analog and digital electronics, software, telecommunication protocols, etc. Heterogeneous systems are composed of subsystems that are designed using different models of computation (MoC). These MoCs are the laws that govern the interactions of the components of a subsystem. The design of heterogeneous systems includes the design of each part of the system according to its specific MoC, and the connection of the parts in order to build the model representing the system. Indeed, this model allows the MoCs that govern different parts of system to coexist and interact. To be able to use a component which is specified according to a given MoC, under other, different MoCs, we can use either a hierarchical or a non hierarchical approach, or we can build domain specific components (DSC). However, these solutions present several disadvantages. This paper presents a new model of component, called domain polymorph component (DPC). Such a component is atomic and is able to execute its core behavior, specified under a given MoC, under different host MoCs. This approach is not a competitor to the approaches above but is complementary.	analog signal;aspect-oriented software development;benchmark (computing);coexist (image);complement (complexity);deferred procedure call;digital electronics;domain-specific language;interaction;model of computation;ptolemy ii;signal processing;systems design	Mohamed Feredj;Frédéric Boulanger;Aimé Mokhoo Mbobi	2009	Journal of Systems and Software	10.1016/j.jss.2008.05.031	model of computation;embedded system;polymorphism;real-time computing;simulation;computer science;engineering;operating system;signal processing;programming language	SE	-40.02428215061385	34.89069446810537	99059
505d451e2ce13cfdd2f29b947ad1e92c25976bbe	supporting mobile multimedia applications through adaptive middleware	mobile multimedia;adaptive middleware;qos adaptation;computer model;mobile computing client server systems multimedia communication distributed object management open systems quality of service computer networks;client server systems;computer networks;programming model;qa75 electronic computers computer science;reflective middleware;multimedia communication;reflective middleware mobile multimedia applications adaptive middleware middleware platforms open approach quality of service adaptation qos extended corba computational model explicit open bindings architectural framework;distributed object management;open system;middleware;quality of service;middleware streaming media computational modeling open systems multimedia systems encoding protocols quality of service multimedia computing distributed computing;mobile computing;open systems	The traditional approach to developing middleware platforms is to adopt a ‘black box’ philosophy whereby the platform offers a fixed programming model to applications together with fixed per-platform implementations. In this paper we describe research which is exploring an open approach to the implementation of middleware platforms. Our motivation is to accommodate the demanding requirements for quality of service adaptation as imposed by mobile multimedia applications. We use an extended CORBA computational model featuring the concept of explicit open bindings. This provides an architectural framework for openness and quality of service adaptation. The paper concludes by considering the more general application of an open systems philosophy; in particular, we introduce the concept of reflective middleware.	common object request broker architecture;computational model;enterprise architecture framework;middleware;openness;programming model;quality of service;requirement;systems philosophy	Geoff Coulson;Gordon S. Blair;Nigel Davies;Philippe Robin;Tom Fitzpatrick	1999	IEEE Journal on Selected Areas in Communications	10.1109/49.790487	middleware;real-time computing;computer science;operating system;middleware;distributed computing;open system;mobile computing;computer network	Embedded	-36.92654438790858	42.05663445310823	99142
133add0bf42a8605877ce8bf144fd90b3a185f73	integrated system fault diagnostics utilising digraph and fault tree-based approaches	arbol defecto;fault tree;system reliability;fiabilite systeme;digraph;digraphs;integrable system;real time;fuel;systems engineering;digrafo;aeronef;systeme integre;sistema integrado;aeronave;engineering system;rectification;faulty diagnostics;fiabilidad sistema;analyse arbre defaut;combustible;diagnostic panne;arbre defaut;sequential test;system design;fault diagnostic;temps reel;airplane;rupture;diagnostico pana;defaillance;avion;ingenierie systeme;tiempo real;failures;rectificacion;integrated system;article;fallo;ruptura;fault diagnostics;fault tree analysis;aircraft;fault diagnosis;fault trees;digraphe	With the growing intolerance to failures within systems, the issue of fault diagnosis has become ever prevalent. Information concerning these possible failures can help to minimise the disruption to the functionality of the system by allowing quick rectification. Traditional approaches to fault diagnosis within engineering systems have focused on sequential testing procedures and real-time mechanisms. Both methods have been predominantly limited to single fault causes. Latest approaches also consider the issue of multiple faults in reflection to the characteristics of modern day systems designed for high reliability. In addition, a diagnostic capability is required in real time and for changeable system functionality. This paper focuses on two approaches which have been developed to cater for the demands of diagnosis within current engineering systems, namely application of the fault tree analysis technique and the method of digraphs. Both use a comparative approach to consider differences between actual system behaviour and that expected. The procedural guidelines are discussed for each method, with an experimental aircraft fuel system used to test and demonstrate the features of the techniques. The effectiveness of the approaches is compared and their future potential highlighted.		Lisa M. Bartlett;E. E. Hurdle;E. M. Kelly	2009	Rel. Eng. & Sys. Safety	10.1016/j.ress.2008.12.005	reliability engineering;simulation;fault tree analysis;engineering;forensic engineering	Robotics	-34.969306623494624	36.37501450298076	99228
8352fc4ffef616463601ed869f1c3e802a907187	a component- and push-based architectural style for ajax applications	application development;distributed system;ajax;rich internet application;web engineering;user interface;software engineering;client server;event notification;interaction model;web architectural style;user interaction;single page interface;architectural style	A new breed of web application, dubbed Ajax, is emerging in response to a limited degree of interactivity in large-grain stateless Web interactions. At the heart of this new approach lies a single page interaction model that facilitates rich interactivity. Also push-based solutions from the distributed systems are being adopted on the web for Ajax applications. The field is, however, characterized by the lack of a coherent and precisely described set of architectural concepts. As a consequence, it is rather difficult to understand, assess, and compare the existing approaches. We have studied and experimented with several Ajax frameworks trying to understand their architectural properties. In this paper, we summarize four of these frameworks and examine their properties and introduce the Spiar architectural style which captures the essence of Ajax applications. We describe the guiding software engineering principles and the constraints chosen to induce the desired properties. The style emphasizes user interface component development, intermediary delta-communication between client/server components, and push-based event notification of state changes through the components, to improve a number of properties such as user interactivity, user-perceived latency, data coherence, and ease of development. In addition, we use the concepts and principles to discuss various open issues in Ajax frameworks and application development.	ajax (programming);client–server model;coherence (physics);distributed computing;event (computing);interaction;interactivity;server (computing);software engineering;stateless protocol;user interface;web application;widget (gui)	Ali Mesbah;Arie van Deursen	2008	Journal of Systems and Software	10.1016/j.jss.2008.04.005	ajax;web application;rich internet application;computer science;operating system;software engineering;database;representational state transfer;web engineering;user interface;rapid application development;world wide web;client–server model	SE	-38.4883206907407	38.88485112993642	99275
0d9895ea630b2f69d645d6e9b95312d3c2f7ce78	the timed abstract state machine language: abstract state machines for real-time system engineering	abstract state machine;real time;embedded systems;abstract state machine language;inbaddad systemteknik;real time systems	In this paper, we present the Timed Abstract State Machine (TASM) language, which is a language for the specification of embedded real-time systems. The TASM language is an extension of Abstract State Machines (ASM), that includes facilities for specifying non-functional behavior namely time and resource consumption. In the engineering of real-time systems, the correctness of the system is defined in terms of three aspects function, time, and resource consumption. The goal of the TASM language and its associated toolset is to provide a basis for specification-based real-time system engineering where these three key aspects can be specified and analyzed. We begin the presentation of the language with a historical survey on the use of ASM in specifying real-time systems. The core difference between the TASM language and ASM is that steps are durative instead of being instantaneous. This paradigm captures the realistic behavior of real-time systems where actions are never instantaneous. The concurrency semantics of TASM is synchronous with respect to durative steps. We present the syntax and semantics of the language and illustrate the concepts using the production cell case study.	abstract state machines;cell (microprocessor);concurrency (computer science);concurrency semantics;correctness (computer science);embedded system;floor and ceiling functions;model checking;programming paradigm;real-time clock;real-time computing;real-time operating system;real-time transcription;run time (program lifecycle phase);surround sound;systems engineering;test case;uppaal;verification and validation	Martin Ouimet;Kristina Lundqvist	2008	J. UCS	10.3217/jucs-014-12-2007	real-time computing;specification language;computer science;artificial intelligence;operating system;software engineering;programming language;algorithm;abstract state machines	Embedded	-39.53251453771661	32.54699372253695	99314
07c256a96a57474e0a27cd7d70bad359fb95021e	bialancingv computation and communication costs: the case for hybrid execution in sensor networks	virtual machine;dynamic compilation;sensor network;embedded system;wireless sensor network;code specialization;embedded systems;distribution costs;communication cost;middleware;just in time;jit compiler;wireless sensor networks	Virtual machines (VM) are promising as system software in sensor networks. A major impediment to their widespread acceptance is their performance overhead. Compiling VM bytecode to native code addresses this, but increases footprint and code distribution costs. Thus, there is an important tradeoff between cost of computing and cost of communication due to code distribution. In this paper, we describe a remote Just-In-Time (JIT) compilation service that is effective in combining interpretation with native execution to arrive at an efficient hybrid execution configuration. The principles apply to any middleware used to develop applications in sensor networks.	compiler;computation;just-in-time compilation;machine code;middleware;overhead (computing);virtual machine	Joel Koshy;Ingwar Wirjawan;Raju Pandey;Yann Ramin	2006	2006 3rd Annual IEEE Communications Society on Sensor and Ad Hoc Communications and Networks	10.1016/j.adhoc.2007.11.006	embedded system;parallel computing;real-time computing;wireless sensor network;computer science;operating system;just-in-time compilation;distributed computing;key distribution in wireless sensor networks;computer network	Mobile	-37.24379161256643	46.045110370179565	99519
af49d677aadfa1f49d40c2c33ddf5d743c1c00f8	a systematic robot fault-tolerance approach	robot sensing systems;reliability engineering;robot fault tolerance;dependancy structure systematic approach robot fault tolerance uml profile;fault tolerant;application software;systematic approach;fault tolerant systems fault tolerance fault diagnosis humans robot sensing systems computer applications application software computer science reliability engineering manufacturing;computer applications;fault tolerance dependability;uml profile;fault tolerant systems;fault tolerance;robots;dependability;unified modeling language;manufacturing;dependence structure;control engineering computing;humans;computer science;dependancy structure;context;fault diagnosis;unified modeling language control engineering computing fault tolerance robots	As the field of robot service expands, reliability has become one of the highest priorities in robot development. Fault-tolerance is an important characteristic for robots to increase their reliability levels. However, the literature on fault-tolerance in robotics has focused mainly on developing a single fault-tolerance technique that is focused on improving reliability for a limited set of context and situations. To meet the demands for reliable robots, a set of appropriate fault-tolerance techniques should be used in the given context and situation. In this paper, we present a systematic approach to facilitate the selection of appropriate robot fault-tolerance techniques on the basis of the context in the robot domain. We have applied the approach to build a fault-tolerance architecture for a robot platform.	byzantine fault tolerance;robot;robotics	Bingu Shim;Beomho Baek;Sooyong Park	2009	2009 33rd Annual IEEE International Computer Software and Applications Conference	10.1109/COMPSAC.2009.90	reliability engineering;robot learning;fault tolerance;real-time computing;computer science;engineering;mobile robot navigation;personal robot;computer engineering	Robotics	-43.781551570697005	37.47746941146317	99872
65a6336d69851047fcd735141e46ae9388cf8665	abstractions of interaction mechanisms	distributed application;software engineering middleware;patterns abstraction interaction mechanisms;interaction;conformance requirements interaction mechanisms abstractions communication middleware;abstraction;satisfiability;data mining;software engineering;communication middleware;interaction mechanisms abstractions;synchronization;middleware process design asynchronous communication distributed computing mechanical factors abstracts concrete web services;business;conformance requirements;mechanisms;middleware;patterns;interaction design;context;concrete;design methodology	The design of distributed applications is a complex undertaking, especially if the designers are forced to immediately deal with the detailed behaviour of the underlying middleware. It would be better if the designers could first focus on the essentials of the applications using suitable abstractions of interaction mechanisms that are provided by communication middleware. In this paper we present a method for abstracting a structure of interactions into a more abstract interaction. We apply this method to obtain the abstractions of common interaction mechanisms. The abstractions of interaction mechanisms are defined using the same interaction design concept as used to define other interactions. The abstractions can thus be manipulated in the same way as any other interactions. The correctness of an abstraction with respect to the interaction mechanism it represents is assessed by checking whether a set of conformance requirements are satisfied.	conformance testing;correctness (computer science);distributed computing;exception handling;interaction design;middleware;quality of service;refinement (computing);requirement	Teduh Dirgahayu;Marten van Sinderen;Dick A. C. Quartel	2009	2009 IEEE International Enterprise Distributed Object Computing Conference	10.1109/EDOC.2009.21	synchronization;interaction;real-time computing;concrete;design methods;computer science;theoretical computer science;operating system;software engineering;interaction design;middleware;data mining;database;distributed computing;abstraction;pattern;programming language;satisfiability	HPC	-38.63142688754922	38.80340420362578	100156
265724e6a495218fdb3e64a021d516f47848e9bc	interruptible context-dependent executions: a fresh look at programming context-aware applications	interruptible context dependent executions;prompt adaptations;reactive dispatching;context aware applications	Context-aware applications provide end-users with enhanced experiences by continuously sensing their environment and adapting their behaviour to match the current context of use. However, developing true context-aware applications remains notoriously difficult due to the unpredictable nature of context changes. A context change may occur at any moment during a procedure execution, which may require an ongoing execution to be promptly interrupted in order to prevent the procedure from running in a wrong context. Currently, developers have to manually constrain a procedure execution to a particular context and take care of saving and restoring the execution state between context changes. Such manual approaches are error-prone and may lead to incorrect application behaviour.  This paper presents a novel programming language model called interruptible context-dependent executions, where a procedure execution is always constrained to happen only under a specified context. In this model, a procedure execution can be seamlessly interrupted or resumed depending on the context. Additionally, the procedure execution state is automatically preserved between interruptions. We present the Flute language that supports interruptible context-dependent executions.	care-of address;cognitive dimensions of notations;context-sensitive language;interrupt;language model;programming language	Engineer Bainomugisha;Jorge Vallejos;Coen De Roover;Andoni Lombide Carreton;Wolfgang De Meuter	2012		10.1145/2384592.2384600	real-time computing;simulation;computer science;distributed computing	SE	-41.105412324444806	38.513437789353546	100272
8f8637cb697a96ad468d7048a167676689b18a05	specifying and verifying plc systems with tla+ : a case study	formal specification;plc;model checking;tla	We report on a method for formally specifying and verifying programmable logic controllers (PLCs) in the specification language TLA^+. The specification framework is generic. It separates the description of the environment from that of the controller itself and its structure is consistent with the scan cycle mechanism used by PLCs. Specifications can be parameterized with the number of replicated components. In our experience, the structuring mechanisms of TLA^+ help to obtain clear, well-organized, and configurable specifications, finite instances of which are verified by the TLA^+ model checker TLC. We have validated our approach on a concrete case study, a controller for fire fighting equipment in a ship dock, and report on the results obtained for this case study.	formal specification;tla+;verification and validation	Hehua Zhang;Stephan Merz;Ming Gu	2010	Computers & Mathematics with Applications	10.1016/j.camwa.2010.05.017	model checking;real-time computing;computer science;programmable logic controller;formal specification;algorithm	SE	-44.19431512032619	32.49056740311735	100417
f46a7af0a595625bb695d46558b9f2bbc0bb98da	platform-as-a-service for human-based applications: ontology-driven approach		The number of crowd computing applications is rapidly growing; however, they currently lack unification and interoperability as each platform usually has its own model of tasks, resources and computation process. We aim at the development of a unifying ontology-driven platform that would support deployment of various human-based applications. Key features of the proposed human-computer cloud platform are ontologies and digital contracts. Ontological mechanisms (ability to precisely define semantics and use inference to find related terms) are employed to find and allocate human resources required by software applications. Whereas digital contracts are leveraged to achieve predictability required by cloud users (application developers). The paper describes major principles behind the platform.	cloud computing;computation;crowd computing;information processing;interoperability;ontology (information science);platform as a service;smart contract;software deployment;software developer;unification (computer science)	Alexander V. Smirnov;Andrew Ponomarev;Tatiana Levashova;Nikolay Shilov	2017	2017 IEEE 7th International Symposium on Cloud and Service Computing (SC2)	10.1109/SC2.2017.31	task analysis;resource management;software deployment;systems engineering;ontology (information science);software;interoperability;cloud computing;inference;computer science	Arch	-44.70789791451067	44.37741702210479	100473
f6c26ae8f3b3b47c7dde6a0ea4585dab44ad8cd4	resource scavenging in object-oriented, real-time, fault-tolerant control systems	control application;object oriented language;software fault tolerance resource allocation computerised control object oriented programming object oriented languages c language real time systems;programming language;computerised control;resource allocation;real time;resource manager;resource management;software fault tolerance;object oriented programming;fault tolerant control;system infrastructure;real time fault tolerant control systems;object oriented systems;transient resource shortfall;c language;fault tolerant system;object oriented;real time systems fault tolerant systems control systems fault tolerance resource management technology management software systems force control application software timing;resource scavenging;object oriented language resource scavenging object oriented systems real time fault tolerant control systems resource management transient resource shortfall system infrastructure c;c;object oriented languages;real time systems	This paper presents a variety of resource management techniques for real-time, fault-tolerant control systems. These techniques are based on resource scavenging, a concept that is introduced in this paper. Resource scavenging techniques attempt to meet transient resource shortfalls in one part of the system by reassigning resources from other parts of the system. The techniques presented take advantage of properties of real-time, fault-tolerant systems in general and some specific properties of control applications. At the same time, the techniques are constrained by control related requirements of the applications. The specific properties of a control application and its requirements are communicated to the system infrastructure entirely in terms of control concepts. Such a system infrastructure is also described in the paper. Finally, the paper proposes an extension to the programming language C++ that will simplify the development of applications that take advantage of resource scavenging techniques.	control system;fault tolerance;real-time cmix;real-time computing	Prabha Gopinath;Vicraj Thomas;Mukul Agrawal	1994		10.1109/WORDS.1994.518686	real-time computing;computer science;systems engineering;distributed computing	Embedded	-35.36458464435077	38.23434662215407	100614
09adb4b70fb4988829fcb6d20e2db94feef02eb9	madeus: a formal deployment model		Distributed software architecture is composed of multiple interacting modules, or components. Deploying such software consists in installing them on a given infrastructure and leading them to a functional state. However, since each module has its own life cycle and might have various dependencies with other modules, deploying such software is a very tedious task, particularly on massively distributed and heterogeneous infrastructures. To address this problem, many solutions have been designed to automate the deployment process. In this paper, we introduce Madeus, a component-based deployment model for complex distributed software. Madeus accurately describes the life cycle of each component by a Petri net structure, and is able to finely express the dependencies between components. The overall dependency graph it produces is then used to reduce deployment time by parallelizing deployment actions. While this increases the precision and performance of the model, it also increases its complexity. For this reason, the operational semantics needs to be clearly defined to prove results such as the termination of a deployment. In this paper, we formally describe the operational semantics of Madeus, and show how it can be used in a use- case: the deployment of a real and large distributed software (i.e., OpenStack).	complexity;component-based software engineering;distributed computing;heterogeneous system architecture;high- and low-level;interaction;model checking;operational semantics;parallel computing;petri net;reachability;software architecture;software deployment	Maverick Chardet;Hélène Coullon;Dimitri Pertin;Christian Pérez	2018	2018 International Conference on High Performance Computing & Simulation (HPCS)	10.1109/HPCS.2018.00118	software deployment;dependency graph;cloud computing;petri net;architecture;operational semantics;software architecture;software;distributed computing;computer science	SE	-40.21214216320364	38.12006618663522	100699
821e61e970aba41b03781ae21055e9d372e63ea1	monitoring bpel-based web service composition using aop	formal specification;run time monitoring;information science;prototypes;logic;aop;ws policy;system monitoring;metg property specification;msc;object oriented programming;web service;data mining;runtime;web service composition;ws policy web services monitoring aop msc;travel reservation service;computerized monitoring;message sequence chart;engines;monitoring;bpel based web service composition monitoring policy;specification languages;aspect oriented programming;travel reservation service bpel based web service composition monitoring policy aop technology aspect oriented programming run time monitoring web service requirements conformance bpel execution engine emsc extended message sequence chart metg property specification;business;web services formal specification object oriented programming reservation computer systems specification languages system monitoring travel industry;unified modeling language;web services;web services runtime computerized monitoring engines logic switches information science sun computer science prototypes;sun;emsc;aop technology;computer science;reservation computer systems;bpel execution engine;switches;extended message sequence chart;algorithm design and analysis;web service requirements conformance;travel industry	With the loose coupling and dynamic attributes of Web Service, the implementation behavior may be different from original requirement, so it’s essential to implement the run-time monitoring. Monitoring analyzes the conformance of a Web Service to the requirements. This paper gives a novel monitoring prototype framework. It introduces WS-Policy to express the user’s monitoring requirement on the Services. Then, AOP (Aspect Oriented Programming) technology is used to extend the BPEL execution engine in order to capture run-time information of the service. Finally, monitoring information is analyzed against the EMSC (Extended Message Sequence Charts) and METG property specification of that service, reaching the predefined goal of monitoring. To evaluate our approach, we have executed a travel reservation service sample under the monitoring framework. Case study demonstrates the feasibility.	aspect-oriented programming;business process execution language;conformance testing;loose coupling;message sequence chart;prototype;requirement;ws-policy;web service	Mingjie Sun;Bixin Li;Pengcheng Zhang	2009	2009 Eighth IEEE/ACIS International Conference on Computer and Information Science	10.1109/ICIS.2009.70	service level requirement;real-time computing;computer science;service delivery framework;database;world wide web	SE	-40.01787152471044	39.942688951682975	100800
375633c0e8c9a06a6c2462bfc113347a2657a199	a model for representing mobile distributed sensing-based services		The barriers to offering mobile distributed services continue to be prohibitive for most: not only must these services be implemented, but they would also inevitably compete for resources on people's devices. This is in part because of the lack of precise understanding, specification, and analysis of such services. This paper presents MobDisS (Mobile Distributed Services), a model for representing mobile distributed services, allowing them to be carefully studied. Services can be built by composing simpler services. MobDisS is built on the Actor model, which is a well-established model for formalizing concurrent computations in open and distributed systems. The paper presents the syntax and operational semantics of MobDisS, and illustrates its use in specifying services.	actor model;computation;distributed computing;mathematical model;operational semantics	Ahmed Abdel Moamen;Nadeem Jamali	2018	2018 IEEE International Conference on Services Computing (SCC)	10.1109/SCC.2018.00049	computation;operational semantics;syntax;actor model;distributed computing;computer science	SE	-37.89999182823784	35.85584713861555	100812
b9ee1ac73d51a52ede3322c11099ff69ac509acc	ecosystem of naming systems: discussions on a framework to induce smart space naming systems development	application development;intelligent actuators;application software;ecosystems application software intelligent sensors intelligent actuators laboratories object detection pervasive computing event detection ubiquitous computing computer applications;pervasive computing;event detection;computer applications;internet;client resolver model;system evolution;ecosystems;client resolver model naming system ecosystem smart space naming system development smart space application;smart space naming system development;smart spaces;ubiquitous computing home automation internet;system development;ubiquitous computing;smart space application;naming system ecosystem;intelligent sensors;object detection;home automation	In this paper, we discuss the ecosystem of naming systems for smart spaces. Since we think resolution of detected object names should be a common trigger of smart space applications, we focus on naming systems. We aim at a naming system framework to enable the following. First, each application developer of smart spaces can design and implement new applications freely. Minimal limitations should be imposed on developers. Second, users can interact with applications opaquely. We propose combination of the following two approaches to induce naming systems evolution for smart space applications. The first approach is integration of independent naming systems for simple client resolvers. The second approach is a client resolver model to handle independent naming systems concurrently. We also describe some case studies concerning smart space application scenarios.	ecosystem;named entity;overhead (computing);smart tv;software development process	Yusuke Doi;Shirou Wakayama;Masahiro Ishiyama;Satoshi Ozaki;Tomohiro Ishihara;Yojiro Uo	2006	First International Conference on Availability, Reliability and Security (ARES'06)	10.1109/ARES.2006.57	embedded system;simulation;computer science;distributed computing	SE	-39.1200334191541	42.431347265856154	100825
7dd746b172c42939ea63d40630a1cd30b0543fae	an adaptive scheduling approach in real-time corba	scheduling distributed object management real time systems client server systems open systems distributed programming;model combination;adaptive programming;real time;client server systems;firm guarantee adaptive scheduling approach real time corba middleware infrastructure open standardization distributed object programming abstractions real time constraints programming models real time applications adaptive programming model distributed real time applications corba concepts time polymorphic invocation technique;programming model;scheduling;polymorphism;distributed programming;distributed object management;middleware;open systems;real time application;adaptive scheduling electrical capacitance tomography protocols time factors middleware costs internet tcpip reactive power computer architecture;open standard;real time corba;real time systems	CORBA is an emerging middleware infrastructure with open standardization that is receiving a good acceptance since it makes easier to program distributed objects. CORBA is being extended through the specification of interfaces and necessary abstractions to support applications with real-time constraints. These new abstractions will enable a variety of programming modelsions will enable a variety of programming models for real-time applications. This paper presents an adaptive programming model for distributed real-time applications using CORBA concepts. The model combines the time polymorphic invocation technique with the (m,k)-firm guarantee.	common object request broker architecture;distributed object;middleware;programming model;real-time transcription;real-time web;scheduling (computing)	Carlos Montez;Joni da Silva Fraga;Jean-Marie Farines;Rômulo Silva de Oliveira	1999		10.1109/ISORC.1999.776396	polymorphism;real-time computing;open standard;computer science;operating system;middleware;distributed computing;programming paradigm;open system;scheduling	Embedded	-36.47197710497909	42.06012367312468	100828
fd7f646797fbf36933fa98012fec5a8b2f2fdb02	designing adaptive mobile applications	application software home appliances computer architecture software systems mobile computing mobile communication systems engineering and theory software standards standards development power system management;information sources;mobile document management adaptive mobile applications 3 tier architectures mobile users software systems multiple appliances multiple information sources;software systems;mobile computer;parallel architectures mobile computing;parallel architectures;architectural pattern;reusable component;mobile computing;mobile application;mobile user;document management	Standard 3-tier-architectures do not provide a suficient basis for the development of services for mobile users. The spec@ characteristics of these types of applications require different approaches to application design. In view of this situation, development of specialized application architectures for the area of mobile computing will continue to be necessary. Our approach is to support the development of this kind of software systems by providing a specialized layered design for the middle tier of mobile applications as well as reusable components and services along with design and architecture patterns. This paper presents a design solution for the problem of handling multiple appliances and multiple information sources on the side of the stationary application. We illustrate our conclusions by an example from the application field of mobile document management.	architectural pattern;mobile app;mobile computing;multitier architecture;software system;stationary process	Sandra Haseloff	2001		10.1109/EMPDP.2001.905035	embedded system;intelligent network;real-time computing;mobile search;mobile web;computer science;mobile technology;mobile agent;distributed computing;mobile business development;mobile station;mobile computing	HCI	-38.68277855555611	42.49421830679508	100935
9eaa7f49a0461f564c5949c0fd83a998788e3110	demonstration of model-driven performance prediction of distributed real-time embedded systems of systems	architectural design;modelling system of systems;distributed environment performance analysis	Investigating the performance of system of systems raises significant challenges due to their distributed and interconnected nature. To determine the suitability of different architectural alternatives, the proposed performance prediction process captures and analyses system metrics. Metric visualisation provides feedback to system experts who can pose performance questions and decide on the optimal architectural design. To support this process, this paper presents a model driven engineering and system execution modelling tool set. This provides early insight into architectural characteristics and assists in the design and development of Distributed Real-time and Embedded systems of systems.	embedded system;model-driven engineering;model-driven integration;performance prediction;real-time computing;real-time transcription;software metric;system of systems	Marianne Rieckmann;Daniel Fraser;Vanea Chiprianov;Claudia Szabo;Katrina E. Falkner	2014		10.1145/2642803.2642837	real-time computing;simulation;system of systems;systems engineering;engineering	Embedded	-43.919264985769246	34.400933754334936	101005
9e7cced0ae1cb8c37b0a100e5aebef5018258d01	refinement of uml/marte models for the design of networked embedded systems	building automation;application specification;design space;embedded application;communication requirements extraction;standard uml;specification front-end;circuit cad;uml;marte;networked embedded system;networked embedded systems;marte model;embedded systems;marte element;analytical exploration;network design;front end;computer model;documentation;unified modeling language;computational modeling;network synthesis;wireless communication;embedded system	Network design in distributed embedded applications is a novel challenging task which requires 1) the extraction of communication requirements from application specification and 2) the choice of channels and protocols connecting physical nodes. These issues are faced in the paper by adopting UML/MARTE as specification front-end and repository of refined versions of the model obtained by both simulation and analytical exploration of the design space. The emphasis is on using standard UML/MARTE elements for the description of networked embedded systems to allow re-use, tool interoperability and documentation generation. The approach is explained on a case study related to building automation.	documentation generator;embedded system;interoperability;modeling and analysis of real time and embedded systems;requirement;simulation;unified modeling language	Emad Samuel Malki Ebeid;Franco Fummi;Davide Quaglia;Francesco Stefanni	2012	2012 Design, Automation & Test in Europe Conference & Exhibition (DATE)		computer simulation;unified modeling language;embedded system;real-time computing;documentation;computer science;systems engineering;operating system;applications of uml;east-adl	EDA	-41.12488077076352	35.039931615073684	101067
d33ce8919c4555f40a00bad78a8ac54c30e238ca	a context middleware framework for managing context in mobile ad hoc network environment	reliability;context aware;manet;dempster shafer rule;inference mechanisms;context middleware;mobile computing ad hoc networks inference mechanisms middleware;mobile ad hoc networks;situation reasoning;middleware environmental management mobile ad hoc networks context modeling context aware services context awareness disaster management uncertainty conference management technology management;dempster shafer rule context middleware mobile ad hoc network context aware systems context spaces;cognition;mobile communication;manet context aware situation reasoning middleware;dempster shafer;context spaces;ad hoc networks;mobile ad hoc network;middleware;context aware systems;mobile computing;context modeling;context	The emergence of context-aware systems has highlighted the requirement to reduce complexity in developing the systems by establishing a context middleware. The middleware aims to provide support for managing context independently from applications and enhance generality and reusability of context sources for multiple applications. In this paper we propose a novel framework for managing context in Mobile Ad Hoc Network Environment (MANET). We model contexts and situations based on the concept of situation space in Context Spaces theory and integrate the model with Dempster-Shafer rule of combination for situation reasoning. Furthermore, we incorporate reliability of information in the fusion mechanism based on discount rule to adopt uncertainty factor that may exist due to limited and uncertain evidence in the host’s environment. Finally, the implementation and experimentation issues of the prototype are also discussed.	context-aware pervasive systems;emergence;hoc (programming language);middleware;prototype;spaces	Waskitho Wibisono;Sea Ling;Arkady B. Zaslavsky	2009	2009 Tenth International Conference on Mobile Data Management: Systems, Services and Middleware	10.1109/MDM.2009.44	mobile ad hoc network;computer science;operating system;data mining;database;distributed computing;context model;mobile computing	SE	-38.07955087268033	36.150641524606435	101171
72c235af784d5d22dbe318543622d1818c543439	on detecting feature interactions in the programmable service environment of internet telephony	call processing language;internet telephony;vocal;feature interaction;xml;experimental evaluation;feature interactions;voip;semantic warnings;open source	This paper presents a new method to tackle the feature interaction problem in Internet telephony with the CPL (Call Processing Language) programmable service environment. To cope with the problems of the programmable service, we first propose a notion of semantic warnings, which are guidelines for non-experts to assure semantic correctness of individual CPL scripts. Then, we define feature interactions as semantic warnings over multiple CPL scripts. On the basis of this definition, we propose a method for detecting feature interactions. We conduct an experimental evaluation with an open-source VoIP system. The results show that the proposed method identifies a semantic redundancy in a ready-made feature and five interactions among pairwise combinations of the features. We also discuss the applicability and limitations from the viewpoint of implementation. 2004 Elsevier B.V. All rights reserved.	cpl;correctness (computer science);feature interaction problem;open-source software;sensor	Masahide Nakamura;Pattara Leelaprute;Ken-ichi Matsumoto;Tohru Kikuno	2004	Computer Networks	10.1016/j.comnet.2004.03.003	xml;telecommunications;computer science;operating system;data mining;voice over ip;database;world wide web;computer security;computer network	SE	-48.267945962742644	39.24793332548582	101251
91d263949e02d69c64844f75c5ed7824ea12fa62	a semantic and adaptive middleware architecture for pervasive computing systems	adaptive middleware;architecture description language;higher-order typed π calculus;smart caa space;pervasive computing	With the increasing demands for adaptive middleware of dynamic systems in pervasive computing environments, the need for dynamic software architecture and programming infrastructure to achieve dynamic adaptation is widely recognized. In this paper, we firstly present a semantic and adaptive middleware architecture called ScudWare that supports for dynamic and heterogeneous environments. ScudWare middleware is based on adaptive communication environments, which consists of adaptive components, and semantic virtual agents. Specially, a ScudADL framework and the specification semantics, based on higher-order typed π calculus theory, are proposed, which describes ScudWare component structure characters, and dynamic behavior adaptation. In the ScudADL, the computing resources consumption is concerned. And the component inner and outer adaptive behaviors are separated from component functional behaviors in an explicit way. Finally, we introduce an application of ScudWare architecture, which is a computer aided assessment system in a smart CAA space, and give a case study to show its adaptation.	dns certification authority authorization;dynamical system;middleware;software architecture;tao;ubiquitous computing	Qing Wu;Weihua Hu;Wen Ding	2009	JSW		architecture description language;real-time computing;computer science;theoretical computer science;operating system;database;distributed computing;ubiquitous computing	PL	-40.411620277127774	37.667781229012924	101262
5a4f2eb7b48243fa65c36ff375005288db7055b7	multimodal architecture to strengthen the interaction of the robot in ambient intelligence environments	context aware computing;pervasive computing;software architecture;multimodality;intelligent agent;petri nets	"""With the development of applications called """"intelligent"""", one of the challenges of research on multimodality in ambient intelligence environments is the elaboration of architectural solutions that respond and adapt to different types of constraints in the human robotic interaction.  These architectures must continually adapt to changes due to external disturbances or user actions. They are therefore subject to restrictions in use (in real time) when the robot interacts with the user and the environment.  The main objective of this paper is to propose a model of adaptive software architecture, which allows the robot to use several modalities and make the fusion of the data to increase its interaction with the environment while considering the context. We also introduce fuzzy logic in the processing of data from input modalities. This multimodal software architecture that considers the context is modeled by colored, timed and stochastic Petri nets (CTSPN) simulated in CPNTools."""	ambient intelligence;fuzzy logic;multimodal interaction;real-time computing;robot;software architecture;stochastic petri net	Nadia Touileb Djaid;Nadia Saadia;Amar Ramdane-Cherif	2012		10.1145/2370216.2370409	embedded system;software architecture;real-time computing;simulation;human–computer interaction;computer science;artificial intelligence;operating system;machine learning;computer security;petri net;ubiquitous computing;intelligent agent	Robotics	-40.94022050848178	42.56592772771648	101364
9646a5d5cfe70e9c2928a7efcb68807e9509c823	indigo: an infrastructure for optimization of distributed algorithms	distributed algorithms;indigo;optimisation;analysis distributed algorithms optimization message complexity;generic algorithm;computer science indigo an infrastructure for optimization of distributed algorithms kansas state university gurdip singh kolesnikov;topology based optimization indigo distributed algorithms generic algorithms;distributed computing;optimisation distributed algorithms;generic algorithms;design knowledge;topology based optimization;valeriy;dissertation;middleware;optimization;analysis;distributed systems;distributed algorithm;message complexity;intermediate representation	The developers of distributed algorithms are faced with two opposing forces. One is to design generic algorithms that are reusable in a large number of applications. Efficiency considerations, on the other hand, force the algorithms to be customized to specific operational contexts. This problem is often attacked by simply re-implementing all or large portions of an algorithm. This paper proposes InDiGO, an infrastructure which allows design of generic but customizable algorithms and provides tools to customize such algorithms for specific applications. InDiGO provides the following capabilities: (a) Tools to generate intermediate representations of an application which can be leveraged for analysis, (b) Mechanisms to allow developers to design customizable algorithms by exposing design knowledge in terms of configurable options, and (c) An optimization engine to analyze an application to derive the information necessary optimize the algorithms. We perform three types of optimizations: static, dynamic and physical topology-based optimization. We present experimental results to demonstrate the advantages of our infrastructure.	distributed algorithm;emoticon;mathematical optimization	Valeriy Kolesnikov;Gurdip Singh	2008	2008 International Symposium on Parallel and Distributed Computing	10.1109/ISPDC.2008.43	distributed algorithm;parallel computing;indigo;genetic algorithm;computer science;theoretical computer science;middleware;analysis;distributed computing;intermediate language	Arch	-35.81253565887608	45.50744478545918	101509
62dd208c9a3236a779cc2ec4bc3bf8acaa8d9a6f	automated verification of quantum protocols by equivalence checking		Technologies based on Quantum Information Processing (QIP) are emerging rapidly in our life, from cryptography and communication to fast computation. The grand challenge in QIP is not only harnessing and controlling natural processes but is also about how we deploy QIP to solve our problems. This is where conceptual errors in designing QIP protocols may arise. This is because the correctness of QIP protocols relies on theoretical proofs on the paper, while sophisticated QIP implementations demand systematic and automated verification. Classical Information Processing (CIP) also shares the same problem, and that is why a range of techniques and tools, called formal verification have been developed to verify large and interactive systems such as systems on chip, communication and cryptography protocols, against design errors. Formal verification deals with mathematical models of systems and abstracts their requirements by specifying them in formal languages, and systematically checks that whether those requirements are satisfied in the system’s model. The goal of our novel, ongoing research is to develop formal verification techniques and tools for analysis of QIP protocols.	computation;correctness (computer science);cryptography;formal equivalence checking;formal language;formal verification;grand challenges;information processing;mathematical model;quantum information science;requirement;system on a chip;turing completeness	Ebrahim Ardeshir-Larijani;Simon J. Gay;Rajagopal Nagarajan	2013	CoRR		discrete mathematics;theoretical computer science;mathematics;algorithm	Logic	-35.829225398368564	33.04323346278224	101523
73f8661ee8d20fe697e04d6d220cea25ebe9a139	state space approach to security quantification	security of data state space methods discrete event systems markov processes decision theory optimal control;state space methods;discrete event dynamic system;software systems;null;safety properties;semi markov process;optimal control;minimal cost safe security policy security quantification state space model software system security semi markov process model abstract software system probability meantime to security failure mttsf discrete event dynamic system model security dynamics discrete event control theory maximally robust controllable sub language state transition markov decision problem optimal controllable language;state space;decision theory;discrete event systems;markov decision problem;controlled language;state space methods security software systems control systems taxonomy safety controllability robust control costs optimal control;markov processes;state space model;security policy;security of data;discrete event;state transition	In this paper, we describe three different state space models for analyzing the security of a software system. In the first part of this paper, we utilize a semi-Markov process (SMP) to model the transitions between the security states of an abstract software system. The SMP model can be solved to obtain the probability of reaching security failed states along with the meantime to security failure (MTTSF). In the second part of the paper, we use a discrete event dynamic system model of security dynamics. We show how to derive events and transitions from existing security taxonomies. We then apply theory of discrete event control to define safety properties of the computer system in terms of the basic concepts of controllability used in discrete event control for two special sublanguages K/sub s/ and K/sub v/. These languages correspond to maximally robust controllable sub-languages. In the third approach, we show that by associating cost with the state transitions, the security quantification problem can be casted as Markov decision problem (MDP). This MOP can be solved to obtain an optimal controllable language K/sub s//spl sube/K/sub v/ the gives the minimal cost safe security policy.	computer;confidentiality;decision problem;dynamical system;markov chain;sube card;semiconductor industry;software system;state space;state-space representation	Christopher Griffin;Bharat B. Madan;Kishor S. Trivedi	2005	29th Annual International Computer Software and Applications Conference (COMPSAC'05)	10.1109/COMPSAC.2005.145	real-time computing;simulation;optimal control;decision theory;discrete event dynamic system;computer science;state space;security policy;state-space representation;theoretical computer science;markov process;computer security;statistics;software system	SE	-45.5354875153193	35.548265086041695	101527
76cd78be6d0ea232a630e4db6f8969519a94d264	bionets: self evolving services in opportunistic networking environments	demonstrator;evolutionary services;hardware in the loop;bionets;opportunistic networking	This paper presents the BIONETS opportunistic service evolution platform. The proposed platform allows pervasive services to evolve over time by exploiting opportunistic communications among mobile nodes on the one hand, and evolutionary computation techniques on the other. We present the main components of the platform, describing their functionalities and technical implementation. Finally, we present the hardware–in–the–loop approach we have followed to evaluate it, where a simulation platform, in charge or reproducing a large number of mobile nodes communicating wirelessly, is integrated with a real software prototype.	evolutionary computation;prototype;simulation;software prototyping;xojo	Iacopo Carreras;Louay Bassbouss;David Linner;Heiko Pfeffer;Vilmos Simon;Endre Varga;Daniel Schreckling;Jyrki Huusko;Helena Rivas	2009		10.1007/978-3-642-12808-0_8	real-time computing;simulation;telecommunications;operating system;computer security;hardware-in-the-loop simulation	Mobile	-38.97736641495921	45.7254906070699	101829
6a092544c4a1150cd31f30ba784b430d1b185940	model driven extra-functional properties for web services	functional properties;distributed computing;web service;software engineering;mechanical factors;web services object oriented modeling proposals unified modeling language java xml mechanical factors software engineering computer science distributed computing;unified modeling language;web services;platform specific model;xml;platform independent model;distributed computing environment;computer science;proposals;object oriented modeling;java	Web Services provide our systems with a platform independent and loosely coupled distributed computing environment. However, on adding extra-functional properties to web services, the loosely coupled environment is not always maintained due to dependences established between the main functionality service modules and the ones from added properties, thus decreasing the application's modularity and flexibility. In order to decouple extra-functional properties from services at modeling and implementation stage, we propose to use a model driven approach, in which the Platform Independent Model (PIM) has been designed by using UML. Then, ATL transformation rules have been applied to transform the PIM into the Platform Specific Model (PSM), which has been split into three specific models, an object, an aspect and a policy based models. Finally Java, AspectJ and Ws-Policy code is generated from the specific models.	aspectj;distributed computing environment;java;loose coupling;platform-independent model;platform-specific model;unified modeling language;ws-policy;web service	Guadalupe Ortiz;Juan Hernández Núñez	2006	2006 IEEE Services Computing Workshops	10.1109/SCW.2006.32	computer science;database;distributed computing;world wide web	SE	-37.856714195252195	39.54558796592507	101842
39306dbbc512804758d04ca9b5ee308730cad436	using uml for modeling complex real-time systems	systeme temps reel;architecture systeme;real time;sistema informatico;software systems;computer system;sistema complejo;object oriented programming;modeling language;model complexity;software architecture;systeme complexe;complex system;unified modeling language;arquitectura sistema;real time system;systeme informatique;sistema tiempo real;system architecture;programmation orientee objet;real time systems	The embedded real-time software systems encountered in applications such as telecommunications, aerospace, and defense typically tend to be large and extremely complex. It is crucial in such systems that the software is designed with a sound architecture. A good architecture not only simplifies construction of the initial system, but even more importantly, readily accommodates changes forced by a steady stream of new requirements. In this paper, we describe a set of constructs that facilitate the design of software architectures in this domain. The constructs, derived from field-proven concepts originally defined in the ROOM modeling language, are specified using the Unified Modeling Language (UML) standard. In particular, we show how these architectural constructs can be derived from more general UML modeling concepts by using the powerful extensibility mechanisms of UML.	embedded system;extensibility;floor and ceiling functions;metamodeling;real-time clock;real-time operating system;real-time transcription;requirement;software architecture;software system;uml tool;unified modeling language;whole earth 'lectronic link	Bran Selic	1998		10.1007/BFb0057795	unified modeling language;embedded system;software architecture;model-driven architecture;complex systems;simulation;real-time operating system;systems modeling language;uml tool;computer science;artificial intelligence;applications of uml;class diagram;modeling language;object-oriented programming;node;object constraint language;systems architecture;software system	Embedded	-45.199522859558456	33.85833463377208	101980
b22c35c4ee4360b789751ba3e38bc571fe6e910c	a pluggable framework for tracking and managing faults in service-oriented systems	change management;fault tracking;service orientation;hb economic theory;qa75 electronic computers computer science;service oriented systems;fault management;fault recovery	Practical fault management in service-oriented systems requires dynamic monitoring of services for SLA violations, failures and undesirable changes in the system runtime environment. It should also include effective fault recovery strategies, and be transparent and lightweight to enhance trust and to minimise the load on the consumer and providers. This paper describes a technology-independent fault management approach that uses a pluggable brokerage model to track and resolve service changes and faults. A case study is used to illustrate the efficacy of the approach.	service-oriented architecture;service-oriented device architecture	Daniel Robinson;Gerald Kotonya	2009		10.1007/978-3-642-10383-4_46	real-time computing;computer science;fault management;change management;distributed computing;management;software fault tolerance	Robotics	-46.646717491792764	41.13347634606854	102018
343d5e491ad79fdace212119962a6fba78ee379d	hardware and software dependability evaluation: system dependability.				William C. Carter	1989			dependability	SE	-47.26653262811042	35.71440874214381	102629
04fe420f41435d70bcdd2c5d4752c69b308c74e7	integration of scheduling analysis into uml based development processes through model transformation	unified modeling language;embedded systems;processor scheduling;uml;embedded system;model based development;model transformation;nonfunctional requirement;parallel robot controller;scheduling analysis	The complexity of embedded systems and their safety requirements have risen significantly in recent years. Models and the model based development approach help to keep overview and control of the development. Nevertheless, a support for the analysis of non-functional requirements, e.g. the scheduling, based on development models and consequently the integration of these analysis technologies into a development process exists only sporadically. The problem is that the analysis tools use different metamodels than the development tools. Therefore, a remodeling of the system in the format of the analysis tool or a model transformation is necessary to be able to perform an analysis. Here, we introduce a scheduling analysis view as a part of the development model, which is a MARTE annotated UML model to describe a system from the scheduling behavior point of view. In addition, we present a transformation from this annotated UML model to the scheduling analysis tool SymTA/S and a treatment of the analysis results to integrate scheduling analysis into a development process. With our approach it is not necessary to remodel the system in an analysis tool to profit from the analysis and its results. Additionally, we illustrate our approach in a case study on a parallel robot controller.	cyclic redundancy check;embedded system;functional requirement;metamodeling;model transformation;modeling and analysis of real time and embedded systems;non-functional requirement;parallel manipulator;programming tool;scheduling (computing);unified modeling language	Matthias Hagner;Ursula Goltz	2010	Proceedings of the International Multiconference on Computer Science and Information Technology		unified modeling language;real-time computing;simulation;computer science;operating system;applications of uml;database;programming language;model-based design	Embedded	-41.282668396379094	33.03763446034217	102794
0794df1f175c9a85fdf3f1bfa4bb61dbc2fad8dd	building mde cloud services with distil	conferenceobject	Model-Driven Engineering (MDE) techniques, like transformations, queries, and code generators, were devised for local, single-CPU architectures. However, the increasing complexity of the systems to be built and their high demands in terms of computation, memory and storage, requires more scalable and flexible MDE techniques, likely using services and the cloud. Nonetheless, the cost of developing MDE solutions on the cloud is high without proper automation mechanisms. In order to alleviate this situation, we present DISTIL, a domain-specific language to describe MDE services, which is able to generate (NoSQL-based) respositories for the artefacts of interest, and skeletons for (single or composite) services, ready to be deployed in Heroku. We illustrate the approach through the construction of a repository and a set of cloud-based services for bentō reusable transformation components.	central processing unit;cloud computing;computation;domain-specific language;exception handling;image scaling;java;model-driven engineering;model-driven integration;nosql;sql;scalability	Carlos Carrascal Manzanares;Jesús Sánchez Cuadrado;Juan de Lara	2015			systems engineering;cloud computing;computer science	DB	-45.14410017672412	41.284507107667004	102808
c1d85b672824713a59c0a3bce2d2e57685998d5f	rapid development and flexible deployment of adaptive wireless sensor network applications	application development;wireless sensor network deployment;biomedical monitoring;3 59 kb;3 59 kb wireless sensor network development wireless sensor network deployment adaptive wireless sensor network application agilla middleware network flexibility mobile agent autonomous agent network sharing high level language linda like tuple space interagent communication mica2 mote microsensors;empirical study;high level languages;interagent communication;application software;mobile agents;tuple space;agent communication;adaptive wireless sensor network application;wireless sensor network;linda like tuple space;mica2 mote;wireless sensor networks microsensors middleware mobile agents;wireless sensor network development;autonomous agent;adaptive systems;programming profession;mobile communication;middleware;agilla;adaptive systems wireless sensor networks application software mobile agents fires middleware biomedical monitoring programming profession high level languages mobile communication;network sharing;mobile agent;network programming;fires;high level language;microsensors;wireless sensor networks;network flexibility	Wireless sensor networks (WSNs) are difficult to program and usually run statically-installed software limiting its flexibility. To address this, we developed Agilla, a new middleware that increases network flexibility while simplifying application development. An Agilla network is deployed with no pre-installed application. Instead, users inject mobile agents that spread across nodes performing application-specific tasks. Each agent is autonomous, allowing multiple applications to share a network. Programming is simplified by allowing programmers to create agents using a high-level language. Linda-like tuple spaces are used for inter-agent communication and context discovery. This preserves each agent's autonomy while providing a rich infrastructure for building complex applications, and marks the first time mobile agents and tuple spaces are used in a unified framework for WSNs. Our efforts resulted in an implementation for MICA2 motes and the development of several applications. The implementation consumes a mere 41.6KB of code and 3.59KB of data memory. An agent can migrate 5 hops in less than 1.1 seconds with 92% reliability. In this paper, we present Agilla and provide a detailed evaluation of its implementation, an empirical study of its overhead, and a case study demonstrating its use	autonomous robot;autonomy;high- and low-level;high-level programming language;kilobyte;linda (coordination language);middleware;mobile agent;overhead (computing);pre-installed software;programmer;tuple space;unified framework	Chien-Liang Fok;Gruia-Catalin Roman;Chenyang Lu	2005	25th IEEE International Conference on Distributed Computing Systems (ICDCS'05)	10.1109/ICDCS.2005.63	embedded system;real-time computing;wireless sensor network;computer science;adaptive system;operating system;distributed computing;programming language;high-level programming language;computer security;computer network	Mobile	-37.53284222847185	45.720060268564595	102874
662dc2fd2acbf820952dc336c991e6215faa72be	distributed simulation of repast models over hla/actors	hla actor repast;repast tileworld model;repast models;java computational modeling distributed computing multiagent systems communication system control time factors predictive models runtime real time systems application software;aspectj;mirrors;software engineering process;ieee standards;multi agent system;ieee standard hla middleware;modelling and distributed simulation;simulation;hla actors;tileworld;hla rti;data mining;runtime;time management;software engineering;multi agent systems;computational modeling;engines;tileworld multi agent systems repast modelling and distributed simulation actors hla rti java text annotations aspectj;aspect oriented programming;distributed programming;reconfigurable multi agent systems;repast;location transparent naming;text annotations;middleware;actors;java text annotations;distributed simulation;context;repast tileworld model distributed simulation repast models hla actors hla actor repast reconfigurable multi agent systems location transparent naming control centric framework ieee standard hla middleware software engineering process java text annotations aspect oriented programming;software engineering aspect oriented programming distributed programming ieee standards java middleware multi agent systems simulation;control centric framework;java	This paper reports about a research project-HLA ACTOR REPAST- aimed to distributing RePast modelsthus potentially corresponding to the computational demandsof large and reconfigurable multi-agent systems (MASs). Novelin HLA ACTOR REPAST is an exploitation of a lean actorinfrastructure implemented in Java. Actors bring to RePastagents such features as migration, location-transparent naming,efficient communications, and a control-centric framework.Actors can be orchestrated by an in-the-large custom controlstructure which can ensure the necessary message causalityconstraints. Distribution and time management concerns dependon the IEEE standard HLA middleware. The paper first discussesdetails of the software engineering process underlyingHLA ACTOR REPAST. The mapping techniques, based on Javatext annotations and aspect oriented programming, minimize“code intrusions” in the original model. Then the paper describessome experiments and performance results of applyingHLA ACTOR REPAST to a distributed version of a RePastTileworld model.	actor model;aspect-oriented programming;aspectj;experiment;graphic art software;java;message passing;middleware;multi-agent system;repast (modeling toolkit);simulation;software development process;software engineering	Franco Cicirelli;Angelo Furfaro;Andrea Giordano;Libero Nigro	2009	2009 13th IEEE/ACM International Symposium on Distributed Simulation and Real Time Applications	10.1109/DS-RT.2009.14	real-time computing;computer science;distributed computing;programming language	SE	-35.07578144288735	41.28517329716202	102920
f523b5305759420a0c9e25c2a6e02e021b1741e5	balanced mvc architecture for developing service-based mobile applications	model view controller;mobile device;computer architecture mobile communication servers mobile handsets business object oriented modeling design methodology;computer model;form factor;server side architecture;function optimization;computer architecture;large scale;software architecture;servers;servie based;client side architecture;balanced mvc architecture;service based mobile applications;mvc architecture;business;mobile communication;mobile handsets;software architecture mobile computing;weight function;servie based mobile application mvc architecture;mobile computing;server side architecture service based mobile applications balanced mvc architecture android device model view controller architecture client side architecture;android device;model view controller architecture;mobile application;object oriented modeling;design methodology	A mobile device such as Android device is emerging as a convenient client computing device with mobility and context-sensing capability. However, the computing power and hardware resource of the devices are limited due to the small form-factor. Consequently, large-scaled applications could not be deployed on these devices. To remedy the limitations, it is desirable to deploy some heavy-weight functionality on the server side, and to let the client application invoke the functionality, resulting in Service-based Mobile Applications. In this paper, we propose a unique, ideal and practical architecture for service-based mobile applications, called balanced Model-View-Controller (MVC) architecture. The architecture is devised by adopting three architectural principles; being thin-client, being layered with MVC, and being balanced between client side and server side. There are a number of technical benefits by adopting this architecture. We first present the computing model of service-based mobile applications, and propose the balanced MVC architecture. Then, we define methods to partition the functionality optimally between client and provider sides, and to design other technical decisions about the architecture. We also present a case study of applying the proposed methods to design the architecture.	android;business logic;client (computing);client-side;computer architecture;coupling (computer programming);data access;display resolution;form factor (design);mobile app;mobile device;model–view–controller;server (computing);server-side;small form factor;thin client	Hyun Jung La;Soo Dong Kim	2010	2010 IEEE 7th International Conference on E-Business Engineering	10.1109/ICEBE.2010.70	enterprise architecture framework;reference architecture;embedded system;space-based architecture;real-time computing;computer science;applications architecture;cellular architecture;operating system;solution architecture;model–view–controller;mobile computing	Mobile	-42.977643129486076	43.1899195859342	102922
24387b3d1064727cbbf535921b108d40da4c8e96	mcl: a mobigate coordination language for highly adaptive and reconfigurable mobile middleware	dynamic reconfiguration;adaptive middleware;coordination language;coordination languages;middleware;mobile computing	Abstract#R##N##R##N#The use of middleware is one important approach in facilitating adaptation across wireless and mobile environments, where augmented service entities are composed and deployed to shield mobile clients from the effects of dynamic network characteristics. The MobiGate Coordination Language (MCL) system provides a language-based approach to the building of mobile applications running in an adaptive middleware, MobiGATE. The concept of the separation of concerns forms the underlying and unifying principle in the provision of the adaptive composition of services. Specifically, a coordination language, MCL, is designed to provide rich constructs supporting the definition of compositions, with constrained type validation and checking. In particular, MCL is formalized by means of the design of a semantic model based on the Z language, which can be used to analyze architectural descriptions and detect possible composition errors such as feedback loops and open circuit problems. Copyright © 2006 John Wiley & Sons, Ltd.	macintosh common lisp;middleware	Yongjie Zheng;Alvin T. S. Chan;Grace Ngai	2006	Softw., Pract. Exper.	10.1002/spe.757	real-time computing;computer science;operating system;middleware;database;distributed computing;programming language;mobile computing	NLP	-39.65200017895083	41.27792405531231	103019
42f87f13c4f0d5e5284312264395f0869c36e1f2	the extensible dynamic presentation manager for content adaptation	content management;libraries;channel access;user modelling;extensible presentation language;human computer interaction;context information;innovative tools;user modelling human computer interaction internet;employee welfare;application software;multi channel access;software systems;conference management;user preferences;working conditions;delivery context content adaptation multimodal application multi channel access;user preferences extensible dynamic presentation manager content adaptation human computer interaction web application innovative tools extensible presentation language profiler system;adaptation model;internet;engines;web application;guidelines;image color analysis;delivery context;user experience;xml;competitive intelligence;content adaptation;profiler system;software tools;adaptation model java engines data models image color analysis libraries xml;multimodal application;extensible dynamic presentation manager;transcoding;data models;java	Human computer interaction studies deals with systems and tools that are able to improve user experience during interaction with computer. For this purpose, modern Web application are expected to supply multimodal and multi-channel access, adaptivity and transcoding features. We present in this work the Extensible Dynamic Presentation Manager (XDPM) which is a set of innovative tools that support the Extensible Presentation Language (XPL) in the adaptation of contents to different working contexts. The adaptation is performed according to the delivery context information which have been formalized by means of a profiler system. A profile holds information about the specific access device, the user preferences and the device working conditions.	content adaptation;human computer;human–computer interaction;multimodal interaction;presentation manager;user (computing);user experience;web application;xpl	Roberto Raccuglia;Antonella Santangelo;Antonio Gentile;Giuseppe Vella;Nunzio Ingraffia	2008	2008 International Conference on Complex, Intelligent and Software Intensive Systems	10.1109/CISIS.2008.116	computer science;database;multimedia;world wide web	Robotics	-37.699415905654924	42.18345362095345	103214
0d4763285be2630d36a55b29c9ceb2ae08d63097	sla-based management of human-based services in business processes for socio-technical systems		Research and industry are focused on Collective Adaptive Systems (CAS) to keep up with the social changes in the way we work, conduct business and organize our societies. With advances in human computing, we can strengthen these systems with a crucial type of resources, namely people. However, while other resources in CAS are managed by Service Level Agreements (SLAs) in an automated way, human-based services are not. Considering the fact that not much work has been reported on SLAs in settings where human computation is an integral part of a process, this paper investigates SLAs for social computing, including non-functional parameters for human-based services, as well as privacy constraints. We investigate and evaluate SLA changes at runtime, which in turn influence elastic runtime social-collective adaptations, in processes designed to allow for elastic management of social collectives.	adaptive system;algorithm;business process;elasticity (data store);experiment;floor and ceiling functions;human-based computation;prototype;run time (program lifecycle phase);service-level agreement;single compilation unit;social computing;sociotechnical system	Mirela Riveni;Tien-Dung Nguyen;Schahram Dustdar	2017		10.1007/978-3-319-74030-0_27	process management;adaptive system;business process;sociotechnical system;human computation;social computing;social change;computer science;service level	HCI	-45.512288887003336	44.153598852114065	103242
74ea398bc703eb5fad57bf8baf7c8bca002195ce	design and implementation of user context aware recommendation engine for mobile using bayesian network, fuzzy logic and rule base	context aware computing;mobile communication systems;pervasive computing;personalization;socialization;fuzzy logic;bayesian;context aware mobile;ubiquitous computing;user context;rule base	Context-aware computing refers to a general class of mobile systems that can sense their physical environment, and adapt their behavior accordingly. Such systems are a component of a ubiquitous computing. Context aware computing makes systems aware of situations of interest, enhances services to users, automates systems and reduces obtrusiveness and customizes and personalizes applications. Mobile phones and PDAs are converging into mobile lifestyle devices that offer a wide range of applications to end users. Many of these applications will have the ability to adapt themselves to the user’s situation, commonly referred to as context awareness. Context-aware services have been introduced into mobile devices, such as cellular phones. Context aware service recommendation engine for mobile is designed to automatically adopt its behavior to changing environment. To achieve this, an important issue to be addressed is how to effectively select services for adaptation according to the user’s current context. In this paper, we propose an intelligent service recommendation model. We formulate the service adaptation process by using artificial intelligence techniques like Bayesian Network, fuzzy logic and rule based reasoning .Bayesian Network to classify the incoming call (high priority call, low priority call and unknown calls), fuzzy linguistic variables and membership degrees to define the context situations, the rules for adopting the policies of implementing a service, fitness degree computation and service recommendation. In addition to this we have proposed maximum to minimum priority based context attributes matching algorithm for rule selection based on fitness degree of rules. The context aware mobile is tested for library and class room scenario to exemplify the proposed service recommendation engine and demonstrate its effectiveness General Terms Context Aware Computing, Ubiquitous Computing, Service Recommendation Engine.	algorithm;artificial intelligence;bayesian network;computation;context awareness;context-aware network;exemplification;fuzzy logic;mobile device;mobile phone;personal digital assistant;recommender system;rule-based system;ubiquitous computing	G. S. Thyagaraju;Umakant P. Kulkarni	2012	Int. J. Pervasive Computing and Communications	10.1108/17427371211245364	fuzzy logic;human–computer interaction;socialization;bayesian probability;computer science;theoretical computer science;machine learning;data mining;personalization;ubiquitous computing;intelligent control	AI	-41.19341567963813	44.353922185224775	103288
f0dd97fa9a0877c11a1c5e4181a473352c43674b	mobile code enabled web services	client side programmers;computer languages;formal specification;programming language;software prototyping;x;prototypes;client server systems;web service;xml based intermediate language;web services containers programming profession xml access protocols simple object access protocol computer science computer languages software prototyping prototypes;internet;intermediate language;code specification;programming profession;distributed programming;web services;mobile code;write once deploy anywhere web service;xml;access protocols;on the fly;service developer;code specification mobile code web services distributed service programming languages client side programmers service developer xml based intermediate language x write once deploy anywhere web service client server systems;computer science;formal specification internet distributed programming xml;simple object access protocol;programming languages;containers;distributed service	A primary benefit of Web services is that they provide a uniform implementation-independent mechanism for accessing distributed services. Building and deploying such services do not benefit from the same advantages, however. Different Web services containers are implemented in different programming languages, with different constraints and requirements placed on the programmer. Moreover, client side programmers must use the Web service interface specified by the service developer. Therefore, the kinds of applications and uses for a Web service are unnecessarily restrictive, constrained by the granularity of access defined by the interface and by the characteristics of the service functions. This paper describes an approach that addresses both of these drawbacks by enabling Web service containers with the ability to accept new mobile code on the fly, and to run it within the containers, providing direct local access to the containers' other services. The code can be specified in a small simple language (a subset of C), and translated and passed to the container in a common XML-based intermediate language called X#. This approach effectively removes the dependence on any single implementation environment. Our prototype implementation for two different containers demonstrates the feasibility of the approach, which represents a first step toward write-once deploy-anywhere Web services.	client-side;code mobility;on the fly;programmer;programming language;prototype;requirement;web service;world wide web;write once, run anywhere;xml	Michael J. Lewis	2005	IEEE International Conference on Web Services (ICWS'05)	10.1109/ICWS.2005.80	web service;web development;web modeling;business process execution language;web standards;computer science;operating system;ws-policy;service-oriented architecture;ws-addressing;database;services computing;programming language;ws-i basic profile;world wide web;universal description discovery and integration	SE	-34.85259563789792	41.744171794395704	103699
c4d29160c761ba6e919b2af87b96fbcc0e0e4ebe	multilevel self-organization in smart environment - service-oriented approach		Self-organization of distributed devices of a smart environment requires development of self-organisation mechanisms. However, uncontrolled self-organization can often lead to wrong results. The presented approach utilizes the “top-to-bottom” configuration principle to solve this problem. The device heterogeneity problem is addressed via proposed service-based architecture, enabling replacement of the organisation of the smart environment with that of distributed service network. Application of the approach is illustrated via a museum smart environment case study.	academy;internet;mathematical model;mind;recommender system;reference model;self-organization;service-oriented architecture;service-oriented device architecture;smart environment;system analysis;uncontrolled format string	Alexander V. Smirnov;Nikolay Shilov;Alexey Kashevnik	2013		10.5220/0004544202900297	self-organization;knowledge management;computer science;smart environment	SE	-44.781454138386486	45.54221281357301	103946
6c35da59540b64d4111e62534f4a2c134ea2b95a	a model-based testing for aadl model of embedded software	analytical models;markov chain model;software;aadl model;formal specification;electromagnetic compatibility;software architecture embedded systems formal specification formal verification markov processes program testing;testing;architecture analyze and design language aadl;embedded system;software architecture under testing;software development methodology;computer architecture;embedded systems;software architecture;formal verification;program testing;error model model based testing markov chain architecture analyze and design language aadl;software development;unified modeling language;architecture analyze and design language;model based testing;avionic embedded system;error model;markov processes;software testing embedded software automatic testing system testing computer architecture unified modeling language software quality programming software architecture power system modeling;software quality;markov chain model based testing aadl model embedded software architecture analyze and design language software development avionic embedded system software quality software architecture under testing;embedded software;markov chain	As Architecture Analyze and Design Language (AADL) becomes a popular software development methodology for Avionic embedded system, it is one of hot issues to ensure the quality of software which is based on models. This article studies on model-based testing (MBT) focusing on software architecture under testing which constructed with AADL, and an algorithm is proposed to carry out model-based testing on AADL model with Markov chain. An example is given at the end of the article to demonstrate the algorithm.	algorithm;architecture analysis & design language;embedded software;embedded system;markov chain;model-based testing;software architecture;software development process	Yunwei Dong;Geng Wang;Hong-bing Zhao	2009	2009 Ninth International Conference on Quality Software	10.1109/QSIC.2009.33	markov chain;computer architecture;real-time computing;architecture analysis & design language;computer science;software reliability testing;software engineering;software construction;software architecture description;software testing;programming language	SE	-47.71004902942581	32.847686742109836	103950
1fa2435beb4e95d989fa837e7530fda3842eae88	embedcloud - design and implementation method of distributed embedded systems		This paper presents a novel design and implementation methodology of the distributed embedded systems, called EmbedCloud. It defines structured implementation model for each module in the system. EmbedCloud forms the basis for the automatic code generation algorithm of the distributed embedded systems which accelerates and simplifies synthesis process of such systems. The EmbedCloud utilizes CloudBus protocol demonstrated in previous publica- tions, which provides a process synchronization and control mechanism for a num- ber of processing units distributed in a network. The CloudBus protocol allows to significant savings in the amount of transmitted data between end modules in the distributed embedded system, especially when compared with the other protocols used in the industry. To verify and evaluate the performance of the EmbedCloud, a concurrent process was described using Petri nets. Hardware tests and synthesis verification of the distributed embedded system was performed on the testing plat- form built with AVR, ATmega series microcontrollers. The tests confirmed the correctness of the developed source code and EmbedCloud method. Further- more, resource requirements and reaction time analysis were performed.	embedded system	Kazimierz Krzywicki;Marian Adamski;Grzegorz Andrzejewski	2015		10.1007/978-3-319-16766-4_17	embedded system;distributed algorithm;real-time computing;computer science;operating system;distributed computing	EDA	-34.79696228363336	33.32730938601878	104306
48c68ac06b85ec1b9123b2a1cc9e82397cf6b2ba	risk-based adaptive group testing of semantic web services	web services ontologies artificial intelligence program testing risk management semantic web system monitoring;semantic web service;analytical models;software;dynamic change;protocols;service composition;complexity theory;ruling out service;open platform;selective testing technique;risk management;service configuration;system monitoring;ontology based quantitative risk assessment;testing;web service;runtime;ontologies artificial intelligence;quantitative risk assessment;program testing;monitoring;test case;comprehensive testing;risk based adaptive group testing;web services;testing semantic web web services protocols costs context aware services ontologies risk management runtime monitoring;runtime monitoring;risk based testing web services group testing;user requirements;semantic web;ontologies;risk based testing;runtime monitoring mechanism;context;group testing;service composition risk based adaptive group testing semantic web service comprehensive testing open platform selective testing technique test case ontology based quantitative risk assessment ruling out service runtime monitoring mechanism service configuration;context aware services	Comprehensive testing is necessary to ensure the quality of complex web services that are loosely coupled, dynamic bound and integrated through standard protocols. Testing of such web services can be however very expensive due to the diversified user requirements and the large numbers of service combinations delivered by the open platform. Group testing was introduced in our previous research as a selective testing technique to reduce test cost and improve test efficiencies. It applies test cases efficiently so that the largest percent of problematic web service is detected as early as possible. The paper proposes a risk-based approach to group test selection. With this approach, test cases are categorized and scheduled with respect to the risks of their target service features. The approach is based on the assumption that for a service-based system, the tolerance to a feature’s failure is an inverse ratio to its risk. The risky features should be tested earlier and with more tests. We specially address the problem in the context of semantic Web Services and report a first attempt for an ontology-based quantitative risk assessment. The paper also discusses risk-based group testing process and strategies for ranking and ruling-out services of the test groups, at each risk level. Runtime monitoring mechanism is incorporated to detect the dynamic changes in service configuration and composition so that the risks can be continuously adjusted online.	categorization;loose coupling;open platform;requirement;risk assessment;semantic web service;test case;user requirements document	Xiaoying Bai;Ron S. Kenett	2009	2009 33rd Annual IEEE International Computer Software and Applications Conference	10.1109/COMPSAC.2009.180	test strategy;web service;white-box testing;risk management;computer science;software engineering;data mining;database;risk-based testing;law;world wide web;test management approach	SE	-47.61338660119398	40.478287738047854	104379
89760a4ebfcab4afe2f05d373d20c037309814ce	high-level design and architecture of an http-based infrastructure for web applications	object oriented;design pattern;mobile code;high level language;scripting language;communication service	xoComm is a communication infrastructure for web applications based on the HTTP protocol. It provides an HTTP server and client access. Furthermore it is the basic communication service for the ActiWeb web object and mobile code system. The HTTP server component of xoComm is used to implement ActiWeb places. The places use the HTTP client access to provide the communication means for their agents. We present the design and architecture of xoComm on several crucial excerpts of the design. These are closely related to their implementation in the object-oriented scripting language XOTcl. We discuss how a dynamic and reflective environment, high-level language constructs, and concepts like design patterns influence the design and architecture.	code mobility;design pattern;extensibility;high- and low-level;high-level programming language;hypertext transfer protocol;level design;requirement;scripting language;server (computing);web application;xotcl	Gustaf Neumann;Uwe Zdun	2000	World Wide Web	10.1023/A:1019269327021	web service;computer science;dynamic web page;database;distributed computing;scripting language;design pattern;common gateway interface;programming language;object-oriented programming;world wide web;high-level programming language;web server	Web+IR	-35.787339858948634	41.80817169159046	104426
1c4700ae256fad12600a6c58c4b50773047e8293	evaluating a development framework for engineering internet of things applications		Application development in the Internet of Things (IoT) is challenging because it involves dealing with a wide range of related issues such as lack of separation of concerns in multiple layers and lack of high-level abstractions to address both the large scale and heterogeneity. Moreover, stakeholders involved in the application development have to address issues spanning to multiple life-cycles. Therefore, a critical challenge is to enable IoT application development with minimal effort from various stakeholders involved in the development process. Several approaches to tacking this challenge have been proposed in the fields of wireless sensor networks and ubiquitous and pervasive computing, regarded as precursors to the modern day of IoT. However, although existing approaches provide a wide range of features, stakeholders have specific application development requirements and choosing an appropriate approach requires thorough evaluations on different aspects. To date, this aspect has been investigated to a limited extend. In view of this, this paper provides an extensive set of evaluations based on our previous work on IoT application development framework. Specifically, we evaluate our approach in terms of (1) development effort: the effort required to create a new application, (2) reusability: the extend to which software artifacts can be reused during application development, (3) expressiveness: the characteristics of IoT applications that can be modeled using our approach, (4) memory metrics: the amount of memory and storage a device needs to consume in order to run an application under our framework, and (5) comparison of our approach with state of the art in IoT application development on various dimensions, which does not only provide a comprehensive view of state of the art, but also guides developers in selecting an approach given application requirements in hand. We believe that the above different aspects provide the research community with insight into evaluating, selecting, and developing useful IoT frameworks and applications. [Copyright notice will appear here once ’preprint’ option is removed.]	appear here;application framework;file spanning;high- and low-level;internet of things;requirement;separation of concerns;software development;ubiquitous computing	Pankesh Patel;Tie Luo;Umesh Bellur	2015	CoRR		simulation;systems engineering;engineering;data mining	SE	-45.976529803433145	39.28587767931751	104620
8b750e1923106ab7cbdb74700ba750f2c8cc0887	handling influence among multiple applications in a smart space	smart space context aware computing influence handling;context aware computing;genetic algorithms color sociology statistics conferences context aware services context;influence handling;genetic algorithm smart space ubiquitous pervasive computing sensors actuators context aware applications user experience colored weighted directed acyclic graph cwdag influence graph;ubiquitous computing actuators directed graphs genetic algorithms sensors;smart space	As a typical ubiquitous/pervasive computing environment, a smart space usually consists of many sensors/actuators for interacting with the physical environment together with many context-aware applications providing users with kinds of services. However, as context-aware applications deployed in a smart space share the same physical environment, they may have influences on one another. These influences, if not carefully handled, might lead to performance degradation of running applications and further affect user experience. To guarantee the user experience, mechanisms for handling such influences are needed. In this paper, we model context-aware applications in a smart space together with their pair wise influences by a special colored weighted directed acyclic graph (CWDAG)-Influence Graph, and propose an efficient genetic algorithm for finding a fairly good plan for configuring applications running in the same smart space based on the influence graph. Exhausted simulations are carried out to show the effectiveness and efficiency of the proposed algorithm.	directed acyclic graph;elegant degradation;genetic algorithm;interaction;least fixed point;sensor;simulation;ubiquitous computing;user experience	Ma Jun;XianPing Tao;Chun Cao;Jian Lu	2014	2014 IEEE 11th Intl Conf on Ubiquitous Intelligence and Computing and 2014 IEEE 11th Intl Conf on Autonomic and Trusted Computing and 2014 IEEE 14th Intl Conf on Scalable Computing and Communications and Its Associated Workshops	10.1109/UIC-ATC-ScalCom.2014.90	embedded system;simulation;computer science;theoretical computer science;distributed computing;smart environment	Visualization	-41.14068032331954	44.2757113239836	104809
7562057a79ea0ce47f0a66f27e543a8681cf077e	selecting fault tolerant styles for third-party components with model checking support	fault tolerant style;high availability;fault tolerant;satisfiability;software implemented fault tolerance;software architecture;model checking;fault tolerance	To build highly available or reliable applications out of unreliable third-party components, some software-implemented fault-tolerant mechanisms are introduced to gracefully deal with failures in the components. In this paper, we address an important issue in the approach: how to select the most suitable fault-tolerant mechanisms for a given application in a specific context. To alleviate the difficulty in the selection, these mechanisms are abstracted as Fault-tolerant styles (FTSs) at first, which helps to achieve required high availability or reliability correctly because the complex interactions among functional parts of software and fault-tolerant mechanism are explicitly modeled. Then the required fault-tolerant capabilities are specified as fault-tolerant properties, and the satisfactions of the required properties for candidate FTSs are verified by model checking. Specifically, we take application-specific constraints into consideration during verification. The satisfied properties and constraints are evidences for the selection. A case study shows the effectiveness of the approach.	applications architecture;black box;correctness (computer science);fault tolerance;fault-tolerant computer system;financial times;fleet telematics system;graceful exit;graphical user interface;high availability;interaction;model checking;principle of abstraction;spin model checker	Junguo Li;Xiangping Chen;Gang Huang;Hong Mei;Franck Chauvel	2009		10.1007/978-3-642-02414-6_5	reliability engineering;fault tolerance;real-time computing;computer science;software engineering;distributed computing;software fault tolerance	SE	-46.721272349181156	33.90328162269572	104885
502eb29c9ba93de1056ccecc72955151e2aeeb9f	modeling delegation in requirements-driven trust framework	service composition;pediatrics;authorisation;holistic requirement based trust framework;trust model;service distribution;trust propagation;data mining;runtime;strontium;global dynamic interoperation;servers;access control policy;trust propagation global dynamic interoperation service workflow service sharing holistic requirement based trust framework access control policy mapping interoperation domain service distribution service delegation hierarchical elementary net system;service sharing;web services;hierarchical elementary net system;access control policy mapping;difference set;access control;interoperation domain;quality of service;web services authorisation;service workflow;service delegation;trust negotiation;service workflow service composition service delegation trust model trust propagation;access control costs information technology statistics collaborative work web services runtime permission	Exponentially growing of global dynamic interoperation in service workflow requires promising mechanisms and processes to establish trust relationship among entities involved. The information and service sharing on each domain has different set of policies and requirements. In order to provide in place mechanisms to allow previously unknown entities to cooperate or participate in a workflow, the holistic Requirement-Based Trust Framework that facilitates interacting domains through access control policy mapping between interoperating domains has been proposed. However, trust negotiation and establishment processes including policies and roles integration are very costly and sophisticated, especially when more than two domains are involved in the interoperation. In this paper, we propose the model to depict the trust propagation for service distribution and service delegation based on Hierarchical Elementary Net System (HENS) called HENS+ applied to the Requirements-Driven Trust Framework in which the cost incurred during interoperation in many cases is reduced compared to the original framework.	access control;entity;holism;interaction;interoperation;requirement;software propagation;tree structure	Wattana Viriyasitavat	2009	2009 Congress on Services - I	10.1109/SERVICES-I.2009.88	knowledge management;database;business;computer security	AI	-47.44881775263204	45.27863751500329	105027
c78d8cac0e1f97519056bc71809acfd07ad5c3a7	strategies for the service market place	service provider;service orientation;ervice oriented infrastructure;business;guaranteed service;service level agreement;point of view;service oriented architecture;grid computing;services marketing	We describe a number of strategies for a future service oriented market place. We describe the SLA’s role within the service framework, and how it enables customers to make value judgements regarding the quality of a service. We also discuss the complexity of too much choice from both the customer and provider points of view, and advocate a “discrete offer” approach. We discuss the “cost of negotiation” and argue that it must be carefully balanced with the cost, value and risk of the offering being negotiated for. We add to the negotiation analysis with presentation and discussion of some results showing a simulated Grid market place and show that it is possible for service providers to deny themselves work through attempting to offer a high quality guaranteed service.	display resolution;interdependence;online transaction processing;service-level agreement;service-oriented architecture;signature;simulation;whole earth 'lectronic link	Paul McKee;Steve Taylor;Mike Surridge;Richard Lowe;Carmelo Ragusa	2007		10.1007/978-3-540-74430-6_5	service provider;service level requirement;service bureau;service level objective;mobile qos;service;service product management;application service provider;business service provider;differentiated service;computer science;knowledge management;service delivery framework;marketing;value-added network;service-oriented architecture;service design;service guarantee;service desk;data as a service;customer service assurance;law;grid computing;service system	ECom	-47.30311225557679	43.82008877981393	105096
baf50a9aa282f55475728de2c2fd0e535f7baa0b	java-based distributed measurement systems	distributed measurement systems;collision mitigation;java aware browsers;software measurement;measurement systems;measurement system;client server systems;testing;web tools;object oriented programming;indexing terms;java web server testing software measurement internet collision mitigation object oriented programming network servers remote monitoring object oriented modeling;computer architecture;network interfaces;java based distributed measurement systems;network servers;gpib;internet java tools web tools distributed measurement systems object oriented programming client server communications remote configuration remote monitoring measurement system industrial measurement requirements;client server;computerised monitoring internet measurement systems object oriented programming client server systems;educational measurement requirements;internet;object oriented;actors java based distributed measurement systems web tools object oriented programming client server communications remote configuration remote monitoring industrial measurement requirements educational measurement requirements internet wide applets java aware browsers gpib;actors;remote monitoring;web server;computerised instrumentation;client server communications;internet wide applets;java tools;computerised monitoring;industrial measurement requirements;open systems;network interfaces measurement systems java object oriented programming internet computerised instrumentation client server systems open systems;java web server testing collision mitigation software measurement computer architecture internet object oriented programming remote monitoring object oriented modeling;object oriented modeling;remote configuration;java	This paper focuses on the development of distributed measurement systems using Java and web tools. An approach is proposed which is based on object-oriented programming and client/server communications and which allows remote configuration and monitoring of a measurement system. The approach proves useful both for educational and industrial measurement requirements.	client–server model;java;requirement;server (computing);system of measurement	Domenico Grimaldi;Libero Nigro;Francesco Pupo	1998	IEEE Trans. Instrumentation and Measurement	10.1109/19.728799	jsr 94;computer science;operating system;system of measurement;database;real time java;object-oriented programming;java;world wide web	Embedded	-34.378946377654316	45.8066011939711	105271
b7dde5df95d88e1f99ac71d3d45ffc307c9db913	real time self adaptable web services to the context: case study and performance evaluation		Web services are a solution for the integration of distributed information systems, autonomous and in real time, heterogeneous and auto adaptable to the context. This impact can resolve many problems in different system based on SOA and Web services. In this paper, we are interested in defining an approach to provide the different needs of a selfadaptability of Web services to context based on workflow and present its performance through an evaluation study, define the real time goal in our approach and showing the feasibility of this approach in an e-healthcare study.	autonomous robot;information system;metamodeling;performance evaluation;real-time computing;service-oriented architecture;web service	Faîçal Felhi;Jalel Akaichi	2015	IJWA		real-time computing;computer science;multimedia;world wide web	DB	-41.95848070347528	40.75165252586138	105345
54e22005c9711a41f486b14256ba3e13b04ad413	a dynamic, real-time testbed for resource management technology	distributed application;dynamic change;new technology;resource constraint;process capability;agent based;intelligent robots;resource allocation;paper technology;real time;resource manager;resource management;distributed computing;mobile robots;test bed;autonomous mobile robot;resource management real time systems space technology distributed computing system testing intelligent sensors mobile robots paper technology nasa intelligent robots;adaptive resource management;agent based system;space missions;system testing;space technology;nasa;command and control systems;intelligent sensors;real time systems;time constraint	This paper describesa test-bedfor technology that unifies agentbasedcomputing and adaptive resource managementfor dynamic real-time systems.We describe a unified framework that combinesa hybrid agent based architecturewith explicit resourceadapting mechanisms.	agent-based model;real-time clock;real-time computing;real-time transcription;testbed;unified framework	David M. Chelberg;Lonnie R. Welch;Cynthia R. Marling;Carl Bruggeman;Douglas Lawrence;David W. Matolak;Robert L. Williams;Jae Y. Lew;Arvind Lakshmikumar;Matthew Gillen;Qiang Zhou;Barbara Pfarr	2001	Proceedings 15th International Parallel and Distributed Processing Symposium. IPDPS 2001	10.1109/IPDPS.2001.925044	mobile robot;real-time computing;simulation;process capability;resource allocation;computer science;resource management;space exploration;distributed computing;space technology;system testing;human resource management system;intelligent sensor;testbed	Embedded	-36.01348031518761	38.62816974008071	105418
a0c24c22d05c0ece0e5432912da2bcd12a1ff01d	a novel method to speed-up the evaluation of cyber-physical systems (iso 26262)	measurement;iso standards;cyber physical system battery management system design decision making tool aided method hardware verification safety critical system automotive electronic system iso 26262;cyber physical systems;hardware safety unified modeling language iso standards measurement cyber physical systems;safety;unified modeling language;safety critical software automotive electronics battery management systems cyber physical systems decision making iso standards;hardware	The development of electric/electronic systems of today's vehicles is becoming more and more complex. New challenges are arising through highly distributed systems, so-called cyber-physical systems, which interact with and have an impact on the physical world. Methods and tools are thus essential to support the development process, especially when systems are safety-critical and demand reliability. In this paper, we present a novel method to decrease the design effort and speed up the verification of hardware. Our approach helps to avoid building safety-critical systems from scratch using industry standards like IP-XACT and UML/MARTE. Furthermore, our tool-aided method supports designers in making design-decisions for hardware very early in the development process. To demonstrate its efficiency, our methodology is applied to an industrial use-case of a battery management system. The results show that using our approach, it is possible to decrease development time and effort in the development of safety-critical systems.	battery management system;co-simulation;cyber-physical system;distributed computing;eclipse;fault injection;ip-xact;matlab;modeling and analysis of real time and embedded systems;reliability engineering;simulation;super harvard architecture single-chip computer;unified modeling language;vhdl	Ralph Weissnegger;Markus Pistauer;Christian Kreiner;Kay Römer;Christian Steger	2015	2015 12th International Workshop on Intelligent Solutions in Embedded Systems (WISES)		unified modeling language;embedded system;simulation;system of systems;systems modeling language;computer science;operating system;systems development life cycle;cyber-physical system;measurement	EDA	-45.95646132864942	37.85406235728925	105542
3dea8b546db854f5a5f13f017833da6186215328	a scalable service-oriented architecture for multimedia analysis, synthesis and consumption	business process execution language;multimedia;service oriented architectures;soa;audio resynthesis;mash up;visual grid orchestrator;web services;video content analysis;workflow;bpel;distributed analysis;soas;service oriented architecture;vigo	Although Service-Oriented Architectures (SOAs) were not designed for multimedia processing, they speed up the development of distributed multimedia applications by allowing the composition or reconfiguration of existing services. For example, the Business Process Execution Language for Web Services (BPEL) is a powerful tool to orchestrate, model and execute workflows. However, due to its process-oriented approach, it is not directly applicable to data-intensive applications, such as those from the multimedia domain. In this paper, a comprehensive service-oriented infrastructure for multimedia applications is presented that (a) overcomes some drawbacks of BPEL for data-intensive applications and (b) provides tools that further ease the development and use of web services for a broad scope of multimedia applications covering video content analysis, audio analysis and synthesis and multimedia consumption. The proposed service-oriented infrastructure can be easily integrated into existing business processes by using BPEL. A dynamic allocation of cloud computing resources ensures the scalability of a multimedia application. To allow efficient and flexible data transfers in BPEL workflows, an implementation of the Flexible SOAP with Attachments (Flex-SwA) architecture is used that allows data transmission in conjunction with SOAP messages. The protocol requirements of services in the case of real-time, streaming or file transfer can be described by a communication policy. Three use cases of multimedia applications are evaluated.	business process execution language;cloud computing;data-intensive computing;digital video;emoticon;file transfer;memory management;orchestration (computing);real-time transcription;requirement;soap with attachments;scalability;service-oriented architecture;service-oriented device architecture;service-oriented infrastructure;streaming media;video content analysis;web service	Steffen Heinzl;Dominik Seiler;Ernst Juhnke;Thilo Stadelmann;Ralph Ewerth;Manfred Grauer;Bernd Freisleben	2009	IJWGS	10.1504/IJWGS.2009.028344	real-time computing;business process execution language;computer science;operating system;service-oriented architecture;database;distributed computing;law;world wide web	HPC	-37.41868408176815	42.77162744139278	105601
f5ad014ef6d3d4088babcee769ca9d7c50366959	freedom from interference for autosar-based ecus: a partitioned autosar stack.		AUTOSAR is a standard for the development of software for embedded devices, primarily created for the automotive domain. It specifies a software architecture with more than 80 software modules that provide services to one or more software components. With the trend towards integrating safety-relevant systems into embedded devices, conformance with standards such as ISO 26262 [ISO11] or ISO/IEC 61508 [IEC10] becomes increasingly important. This article presents an approach to providing freedom from interference between software components by using the MPU available on many modern microcontrollers. Each software component gets its own dedicated memory area, a so-called memory partition. This concept is well known in other industries like the aerospace industry, where the IMA architecture is now well established. The memory partitioning mechanism is implemented by a microkernel, which integrates seamlessly into the architecture specified by AUTOSAR. The development has been performed as SEooC as described in ISO 26262, which is a new development approach. We describe the procedure for developing an SEooC. AUTOSAR: AUTomotive Open System ARchitecture, see [ASR12]. MPU: Memory Protection Unit. 3 IMA: Integrated Modular Avionics, see [RTCA11]. 4 SEooC: Safety Element out of Context, see [ISO11].	autosar;component-based software engineering;conformance testing;embedded system;integrated modular avionics;interference (communication);mpu-401;memory management (operating systems);memory protection;microcontroller;microkernel;modular programming;software architecture	David Haworth;Tobias Jordan;Alexander Mattausch;Alexander Much	2012			embedded system;real-time computing;distributed computing	SE	-47.15416150337303	37.40234583833594	105763
b2f0a9213b28b047bdfa904de551247c92786ece	design of common software architecture as base for application generator and meta-generator for interactive systems		Nowadays, any kind of user-side applications such as enterprise, banking, game, and so forth are almost parts of or invoked through web and/or smart-device native applications. Each vender of the application has its own development environment to keep up with the market needs. The development environment is usually for a specific environment, which consists of platform (operating systems and/or middleware) dependent tools, representation, and languages. The variety of the environment is vast and is a cause of delayed delivery of a product. The software architecture choice is important for high-quality application development but is depend on the platforms. The architecture has many variations because of vast variety of platforms. The purpose of this research is to design the universal architecture for the application. Based on the architecture, we designed generator and meta-generator for development of the application. We have developed a large application in a practical use, and developed several generators for that application based on the universal architecture we designed. The outcomes of the research are: – The universal architecture eases to port a specific environment-dependent techniques and knowledge to another. – We could design and implemented generators and meta generators for the development based on the architecture.	applications architecture;aspect-oriented software development;const (computer programming);data model;fourth-generation programming language;generator (computer programming);machine code;middleware;operating system;reference model;smart device;software architecture	Atsushi Esaka;Masami Noro;Atsushi Sawada	2017	2017 IEEE 41st Annual Computer Software and Applications Conference (COMPSAC)	10.1109/COMPSAC.2017.102	enterprise architecture framework;software engineering;service-oriented modeling;data architecture;reference architecture;applications architecture;computer science;view model;solution architecture;space-based architecture	SE	-40.2207611710052	35.2756553104491	105794
0c3a6429a88fa1ec05126e37ae07af8127b3cf51	a geographically distributed framework for embedded system design and validation	dynamic change;intellectual property;embedded system hardware permission intellectual property switches computer science design engineering protection embedded software assembly systems;systems engineering;simulation framework;embedded system;network topology;high level synthesis;embedded system design;systems analysis;telecommunication;debugging computers;real time systems industrial property high level synthesis systems analysis;validation;industrial property;co simulation framework geographically distributed framework embedded system design validation performance criteria intellectual property simulation environment;simulation environment;geographic distribution;real time systems	The difficulty of emb edded system co-design is increasing rapidly due to the incr easing complexity of individual parts, the variety of parts available and pr essure to use multiple processors to me et performanc e criteria. V alidation tools should contain sever al features in order to keep up with this trend, including the ability to dynamically change detail levels, built in protection for intellectual property, and supp ort for gradual migr ation of functionalityfrom a simulation environment to the real hardware. In this paper, we present our appr oach to the problem which includes a geographically distributed co-simulation framework. This fr amework is a system of nodes such that each can include either portions of the simulator or real hardware. In supp ort of this, the framework includes a me chanism for maintaining consistent versions of virtual time.	central processing unit;co-simulation;embedded system;open road tolling;simulation	Ken Hines;Gaetano Borriello	1998		10.1145/277044.277075	embedded system;systems analysis;electronic engineering;real-time computing;simulation;computer science;engineering;operating system;high-level synthesis;network topology;intellectual property;computer network;computer engineering	EDA	-36.69479645527964	35.558541284074266	105848
4c84ac46d8b6db24a41dede91ac17252f1f99d69	a generic execution model for efficient performance evaluation of system architectures at transaction level	software architecture generic execution model performance evaluation system architectures transaction level models hardware architecture embedded systems architecture exploration heterogeneous architecture analysis lte protocol;computer architecture unified modeling language computational modeling performance evaluation load modeling analytical models data models;software performance evaluation;transaction level modeling performance evaluation architecture modeling;embedded systems;software architecture;software performance evaluation embedded systems software architecture	Models are necessary to assist system architects in evaluating performances of hardware/software architectures and performing early exploration of the design space. Efficient modeling approaches are then required to cope with the still increasing complexity of embedded systems. In this paper, we present a generic execution model to favor creation of transaction level models for performance evaluation and architecture exploration. Based on this generic model, the created models are used to evaluate by simulation expected processing and memory resources related to system architectures. The benefits of the proposed approach are highlighted through the analysis of an heterogeneous architecture implementing the reception part of the physical layer of the LTE protocol.	compaq lte;embedded system;performance evaluation;simulation;transaction-level modeling	Sébastien LeNours;Anthony Barreteau;Olivier Pasquier	2011	FDL 2011 Proceedings		dataflow architecture;multilayered architecture;enterprise architecture framework;reference architecture;embedded system;software architecture;space-based architecture;model-driven architecture;computer architecture;architecture tradeoff analysis method;parallel computing;real-time computing;database-centric architecture;computer science;applications architecture;cellular architecture;service-oriented modeling;software engineering;hardware architecture;solution architecture;software architecture description;view model;resource-oriented architecture;data architecture;systems architecture	EDA	-46.73489541797925	37.408451026262014	106188
ca1ad95e4506a02469228894fc9706752240a32e	refresh: a self-adaptive architecture for autonomous embedded systems	distributed processing;reconfiguration framework for distributed embedded systems for software and hardware self adaptive architecture refresh distributed autonomous embedded systems software reconfiguration hardware reconfiguration task related functional requirements embedded virtual machine components distribution node boundaries nonfunctional requirements visual servoing miniature robot scenario self adaptation complexity;visual servoing distributed processing embedded systems robot vision virtual machines;embedded systems;robot vision;virtual machines;visual servoing;hardware software ports computers computer architecture visual servoing cameras	This paper presents an architecture for automating the reconfiguration of system deal with unforeseen situations, named ReFrESH, for distributed autonomous embedded systems which 1) supports both hardware and software reconfiguration based on task-related functional requirements without disturbing system at runtime; 2) provides a type of Embedded Virtual Machine to facilitate components distribution across node boundaries; 3) generates optimal configurations dynamically based on non-functional requirements. The feasibility of ReFrESH and its management algorithms are evaluated for “visual servoing” of three miniature robot scenario. Moreover, one self-adaptive application is implemented to show the realistic performance of ReFrESH. The results demonstrate that ReFrESH can enable the system to handle various situations dynamically and decrease the complexity of self-adaptation.	adaptive architecture;adaptive system;algorithm;autonomous robot;dependence analysis;distributed computing;embedded system;functional requirement;microbotics;non-functional requirement;run time (program lifecycle phase);virtual machine;visual servoing	Yanzhe Cui;Richard M. Voyles;Mohammad H. Mahoor	2013	2013 IEEE International Conference on Automation Science and Engineering (CASE)	10.1109/CoASE.2013.6654042	embedded system;computer vision;real-time computing;computer science	Robotics	-42.52192115404954	38.2790727051039	106230
d8889da0826e8153be7699f4eef4f0ed2e8a7ea7	distributed heterogeneous event processing: enhancing scalability and interoperability of cep in an industrial context	distributed system;heterogeneous systems;distributed complex event processing;complex event processing;system development;distributed systems;heterogeneous systems and networks;evaluation studies	Although a significant amount of research has investigated the benefits of distributed CEP in terms of scalability and extensibility, there is an ongoing reluctance in deploying distributed CEP in an industrial context. In this paper we present the DHEP system developed together with the IBM® laboratory in Böblingen. It addresses some of the key problems in increasing the acceptance of distributed CEP, for example supporting interoperability between heterogeneous event processing systems. We present the concepts behind the DHEP system and show how those concepts help to achieve scalable and extensible event processing in an industrial context. Moreover, we verify in an evaluation study that the additional cost imposed by the DHEP system is moderate and 'affordable' for the benefits provided.	approximation algorithm;complex event processing;distributed computing;experiment;extensibility;interoperability;scalability	Björn Schilling;Boris Koldehofe;Udo Pletat;Kurt Rothermel	2010		10.1145/1827418.1827453	embedded system;real-time computing;computer science;complex event processing;database;distributed computing	DB	-45.10497219579512	38.8322935663892	106268
cd7b205f8b648e05c588d48f5bc3bc172d166309	ensuring consistency within distributed graph transformation systems	distributed system;software systems;graph transformation	Graph transformation systems can be used for modeling the structure and the behavior of a software system in a visual way. In our project, we extend existing graph transformation systems to model and execute distributed systems. One challenge in this context is the simultaneous and correct modification of the local runtime graphs of the participating applications by visual distributed graph transformations.#R##N##R##N#As the execution of these transformations may cause inconsistencies in the local runtime graphs, we present an approach to avoid inconsistencies: A runtime mechanism translates invalid graph transformations into valid transformations. This translation is based on predefined rules describing the substitution of invalid transformation parts. Thus, new graph transformations are dynamically built at runtime. Furthermore, the runtime mechanism controls access within a distributed system.	graph rewriting	Ulrike Ranger;Thorsten Hermes	2007		10.1007/978-3-540-71289-3_28	wait-for graph;computer science;theoretical computer science;software engineering;distributed computing;graph;moral graph;software system;graph rewriting	OS	-40.55652499382811	37.797119162189624	106510
c14d6df67e04bc0968afc10ec908d11bd2b0d30a	a policy-based framework for qos management in service oriented environments	service provider;service orientation;distributed environment;qos management;handheld device;quality of service;service oriented architecture;mobile user	  The successful integration of the Service Oriented Architecture (SOA) in large distributed environments greatly depends on  their support of quality of service (QoS) management. The aim of QoS management is to guarantee diverse QoS levels to users  issuing requests from a variety of platforms and underlying networks. In this paper, we present our policy-based framework  for QoS management in SOA environment with both traditional and mobile users. The framework is based on a QoS broker that  is in charge of mediating between service requesters and service providers, and carrying out various QoS management operations.  It is also in charge of handling appropriately mobile users that are using various handheld devices to request services.    	quality of service	Elarbi Badidi;Mohamed Adel Serhani;Larbi Esmahi	2008		10.1007/978-90-481-3658-2_82	service provider;service level requirement;service level objective;mobile qos;quality of service;service assurance;service product management;application service provider;business service provider;differentiated service;computer science;knowledge management;basic service;service delivery framework;service-oriented architecture;service design;mobile device;service desk;data as a service;customer service assurance;world wide web;distributed computing environment;computer network;service system	HPC	-47.55390186806024	43.2548237499551	106544
9fd016b7e2f81ef85e1b6117becb328fae0e24df	implementation of the open-software models of switched reluctance motor on model-in-the-loop platform	analytical models;switched reluctance motor;torque;model in the loop;reluctance motors;fpga ni 7841r open software model switched reluctance motor model in the loop platform srm model mil platform 2d magnetostatic model femm octave flux characteristics current characteristics torque characteristics rotor position characteristics 2d fem analysis 2d finite element method hybrid method analytical method software tool labview software veristand software real time computing devices pxi ni 1071 industrial computer ni 8135;geometry;virtual instrumentation electrical engineering computing field programmable gate arrays finite element analysis reluctance motors software tools;embedded systems;computational modeling;rotors;solid modeling;embedded systems switched reluctance motor fem models analytical models model in the loop;fem models;reluctance motors solid modeling analytical models torque rotors computational modeling geometry	This paper presents implementation methods of the SRM (Switched Reluctance Motor) model on the MiL (Model-in-the-Loop) platform. The sub-system is a 2D magnetostatic model of SRM, which was obtained with the use of open-software tools like FEMM and Octave. The models are characteristics of flux, current, torque and rotor position. Characteristics were the results of 2D FEM (Finite Element Method) analysis and of hybrid methods (FEM with analytical methods). The paper shows efficient, automated procedure of the SRM models implementation on the MiL platform. Software tools, which speed up this process were presented. The MiL platform includes a commercial software LabVIEW, software Veristand and real time computing devices like PXI NI 1071, equipped with industrial computer NI 8135 and FPGA NI 7841R.	algorithm;commercial software;federal enterprise architecture;field-programmable gate array;finite element method;formal specification;gnu octave;hardware-in-the-loop simulation;labview;pci extensions for instrumentation;programming tool;r.o.t.o.r.;real-time computing;system reference manual	Sebastian Kula	2015	2015 XXV International Conference on Information, Communication and Automation Technologies (ICAT)	10.1109/ICAT.2015.7340526	control engineering;embedded system;electronic engineering;engineering	Robotics	-38.19180285883389	34.147155332857	106600
074a74150b6c318ebcabd37c93f8aaec01c785b7	bpel4chor: extending bpel for modeling choreographies	business process execution language;bpel4chor;service interaction patterns;web service;data format;choreographies;specification languages;business data processing;interaction pattern;service interaction patterns bpel4chor choreographies business process execution language web services message links participant groundings;web services;control flow;service oriented architecture web services lan interconnection topology grounding concrete buildings software systems computer architecture books;message links;participant groundings;business process;web services business data processing specification languages	The business process execution language (BPEL) is a language to orchestrate web services into a single business process. In a choreography view, several processes are interconnected and their interaction behavior is described from a global perspective. This paper shows how BPEL can be extended for defining choreographies. The proposed extensions (BPEL4Chor) distinguish between three aspects: (i) participant behavior descriptions, i.e. control flow dependencies in each participant, (ii) the participant topology, i.e. the existing participants and their interconnection using message links and (iii) participant groundings, i.e. concrete configurations for data formats and port types. As BPEL itself is used unchanged, the extensions facilitate a seamless integration between service choreographies and orchestrations. The suitability of the extensions is validated by assessing their support for the Service Interaction Patterns.	business process execution language;compiler description language;control flow;interconnection;international conference on web services;lateral thinking;multicast;orchestration (computing);seamless3d;service-oriented architecture;web services description language;web service	Gero Decker;Oliver Kopp;Frank Leymann;Mathias Weske	2007	IEEE International Conference on Web Services (ICWS 2007)	10.1109/ICWS.2007.59	web service;business process execution language;computer science;database;distributed computing;law;world wide web	SE	-37.441519500883615	38.22297144669081	106948
15fe0fede58936732d81b9a9f0aada849cb3d2c0	software architecture of self-organizing systems-of-systems for the internet-of-things with sosadl		A challenging issue in the architectural design of Systems-of-Systems (SoS) for the Internet-of-Things (IoT) is how to architect an SoS in a way that the required behavior to fulfil the SoS mission will emerge. Indeed, on the one hand, at design-time, most often we do not know which are the concrete IoT systems that will become constituents of the SoS, these being predominantly identified at run-time; on the other hand, the correct architecture depends not only on the constituent systems but also, largely, on the operational environment where the SoS will be deployed. To address this challenge, this paper investigates the notion of self-organization, whose mechanism makes possible that the IoT constituent systems themselves create and maintain a valid architecture enabling the production of the required emergent behavior to fulfil the SoS mission. In particular, it describes how SosADL, a formal SoS Architecture Description Language (ADL), based on the novel π-Calculus for SoS, supports the architectural description of self-organizing SoSs for the IoT, upwardly causing SoS emergent behaviors at run-time.	apple sos;architecture description language;emergence;organizing (structure);self-organization;software architecture;system of systems;toolchain;verification and validation;π-calculus	Flávio Oquendo	2017	2017 12th System of Systems Engineering Conference (SoSE)	10.1109/SYSOSE.2017.7994959	architecture;self-organization;software architecture;distributed computing;architecture description language;systems engineering;computer science;internet of things	Robotics	-42.748021399945436	37.62704358246725	107143
5fbcf19a85b63db002b75d076e23fc5d16fff8da	versioning extensions to webdav (web distributed authoring and versioning)		This document specifies a set of methods, headers, and resource types that define the WebDAV (Web Distributed Authoring and Versioning) versioning extensions to the HTTP/1.1 protocol. WebDAV versioning will minimize the complexity of clients that are capable of interoperating with a variety of versioning repository managers, to facilitate widespread deployment of applications capable of utilizing the WebDAV Versioning services. WebDAV versioning includes automatic versioning for versioning-unaware clients, version history management, workspace management, baseline management, activity management, and URL namespace versioning. RFC 3253 Versioning Extensions to WebDAV March 2002	baseline (configuration management);hypertext transfer protocol;software deployment;software versioning;webdav;workspace	Geoffrey Clemm;Jim Amsden;Tim Ellison;Christopher Kaler;E. James Whitehead	2002	RFC	10.17487/RFC3253	computer science;operating system;database;world wide web	Web+IR	-35.22354947437921	44.10704219076797	107144
375e22fa713b4a3906f10ae1ab281d6c57b8e391	optimizing hw/sw codesign towards reliability for critical-application systems	software testing;system reliability;hardware software codesign;test vector set hw sw codesign reliability critical application systems safety critical computing systems system reliability requirements c language handel c language weak mutation analysis technique;mutation analysis;c language;algorithm design and analysis partitioning algorithms costs hardware digital systems application software time factors system testing software safety genetic mutations;safety critical software;c language hardware software codesign safety critical software	This work presents an innovative approach for hardware/software codesign of safety-critical computing systems. The proposed approach is based on system reliability requirements to decide which parts of the system are partitioned into hardware or software. The approach considers as input a complete software description of the design. In our case, we use as the initial description the C language and then, for those parts compiled to hardware, the Handel-C language is applied. After partitioning, we verify system reliability based on an adaptation of the weak mutation analysis technique. This technique was originally proposed for software testing by means of verifying the adequacy of a test vector set for a given program. We also present a case study in order to illustrate the proposed approach.		Fabian Vargas;E. Bezerra;L. Wulff;Daniel Barros	1998		10.1109/ATS.1998.741584	reliability engineering;embedded system;software requirements specification;verification and validation;real-time computing;software sizing;software verification;computer science;engineering;package development process;backporting;software design;software reliability testing;component-based software engineering;software development;software design description;operating system;software engineering;software construction;hardware architecture;mutation testing;software testing;systems development life cycle;programming language;software deployment;software fault tolerance;software system;avionics software	OS	-48.07823767773125	33.71625638318325	107165
dc14094f0e86e927a724bd754d230258ef7441bb	sca-based component framework for software defined radio	software radio packaging communication system software embedded software computer architecture communication standards software standards embedded system software systems environmental management;specialized corba object;component interface;software defined radio;sca based component framework;dynamic component replacement sca based component framework software defined radio software communication architecture design patterns embedded systems software component framework component interface deployment model component model specialized corba object object management functionality package model xml descriptors boot up process lazy application instantiation;software systems;telecommunication computing;embedded systems software;communication system software;packaging;embedded system;software radio;telecommunication computing software radio embedded systems distributed object management;computer architecture;embedded systems;component framework;process support;software communication architecture;design pattern;distributed object management;xml descriptors;communication standards;dynamic component replacement;lazy application instantiation;component model;deployment model;design patterns;software standards;boot up process;environmental management;embedded software;object management functionality;package model	SCA (Software Communication Architecture), which has been adopted as a SDR (Software Defined Radio) Forum standard, provides a framework that successfully exploits common design patterns of embedded systems software. However, the SCA is inadequate as a component framework since it does not explicitly specify (1) a component model that defines how to express a component interface and how to implement it, (2) a package model that defines what and how to package in deployment units, and (3) a deployment model that defines the deployment environment and deployment process. In this paper, we propose a SCA-based component framework for SDR. Specifically, we present (1) a component model that defines a component as a specialized CORBA object that implements object management functionality, (2) a package model exploiting the existing XML descriptors of the SCA, and (3) a deployment model that defines a SCA-based deployment environment with a boot-up process to restore the deployment state and a deployment process supporting lazy application instantiation and dynamic component replacement.	application domain;booting;common object request broker architecture;component-based software engineering;deployment environment;design pattern;etsi satellite digital radio;embedded system;fault tolerance;fold (higher-order function);lazy evaluation;response time (technology);software deployment;software framework;universal instantiation;xml	Saehwa Kim;Jamison Masse;Seongsoo Hong;Naehyuck Chang	2003		10.1109/WSTFES.2003.1201349	embedded system;real-time computing;deployment diagram;computer science;operating system	SE	-38.13107668935822	39.76655715470635	107192
8f3eb7b112efb71cb640dfd588a1d30fe3d7cee4	reliability prediction for web service composition		The key issues in the development of Web service composition are the dynamic and efficient reliability prediction. Reliability of the service-oriented systems heavily depends on the remote Web services as well as the unpredictable Internet. This paper proposes a reliability prediction model based on Petri net. For atomic services, a staged reliability model is provided which predicts reliability from network environment availability, hermit equipment availability, discovery reliability and binding reliability. To address the complex connecting relationship among subservices, places of basic Petri net for Input and Output are extended to some subtypes for multi-source input place and multiuse output place. The approach has been implemented and has been used in the context of travel process mining. Although the results are presented in the context of Petri nets, the approach can be applied to any process modeling language with executable semantics.	executable;internet;modeling language;multi-source;petri net;process modeling;reliability engineering;service composability principle;service-oriented architecture;service-oriented software engineering;web service	Weitao Ha	2017	2017 13th International Conference on Computational Intelligence and Security (CIS)	10.1109/CIS.2017.00132	computer science;artificial intelligence;the internet;machine learning;real-time computing;petri net;quality of service;web service;process mining;executable;input/output;process modeling	HPC	-47.69289766535095	39.91891706964213	107199
a98941a10a1e967d007ce25f205a1cd5dbddce6f	towards verification of hybrid systems in a foundational proof assistant	software;sensors;upper bound;computer architecture;theorem proving formal verification helicopters reasoning about programs;software safety cognition computer architecture upper bound sensors differential equations;altitude limit hybrid system verification proof assistant formal verification coq tla inspired formalism reasoning about hybrid system quadcopter velocity;cognition;safety;differential equations	Unsafe behavior of hybrid systems can have disastrous consequences, motivating the need for formal verification of the software running on these systems. Foundational verification in a proof assistant such as Coq is a promising technique that can provide extremely strong, foundational, guarantees about software systems. In this paper, we show how to apply this technique to hybrid systems. We define a TLA-inspired formalism in Coq for reasoning about hybrid systems and use it to verify two quadcopter modules: the first limits the quadcopter's velocity and the second limits its altitude. We ran both of these modules on an actual quadcopter, and they worked as intended. We also discuss lessons learned from our experience foundationally verifying hybrid systems.	coq (software);formal verification;high-level programming language;hybrid system;liveness;proof assistant;semantics (computer science);shim (computing);software system;velocity (software development);verification and validation	Daniel Ricketts;Gregory Malecha;Mario M. Alvarez;Vignesh Gowda;Sorin Lerner	2015	2015 ACM/IEEE International Conference on Formal Methods and Models for Codesign (MEMOCODE)	10.1109/MEMCOD.2015.7340492	cognition;computer science;sensor;theoretical computer science;upper and lower bounds;programming language;differential equation;algorithm	Logic	-45.19657723743442	36.050467994852085	107344
b87b36b535ccaf80134d4fae7f81e047bafaf587	typed abstractions for client-service interactions in osgi	query language;management system;programming language;type checking;object oriented programming languages;service oriented computing;open service gateway initiative;integrated services	The Open Services Gateway initiative (OSGi) is a successful attempt to bridge the gap between Java and Service Oriented Computing. OSGi provides an LDAP-based query language for fine-tuning service retrieval and offers an eventing mechanism that signals changes to a service’s lifecyle to all clients depending on that service. Nonetheless, a number of challenges remain unsolved. OSGi’s service query language, for instance, bypasses important compile-time guarantees on the syntactical correctness of queries and the language works only for properties that never change during the lifetime of a service. What programmers need, however, is a statically type-checked, robust query language that takes into account dynamically evolving, volatile service characteristics. A second problem is that the lifecycle management system requires programmers to write a considerable amount of boilerplate logic for reacting to service events. This obfuscates the business logic, which in turn decreases code comprehension and increases the odds for introducings bugs when implementing client-service interactions. This paper evaluates OSGi as a platform for programming client-service interactions in Java. After focusing on a number of shortcomings of OSGi’s integrated service query language and its lifecycle management system, we propose a solution based on a programming language extension. After the conceptual definition of these new language concepts, we show how they can be transformed to regular Java code without losing interoperability with the OSGi standard.	apl;business logic;compile time;compiler;correctness (computer science);interaction;interoperability;java;lightweight directory access protocol;osgi;programmer;programming language;query language;service-oriented architecture;software bug;theoretical definition;type safety	Sven De Labey;Eric Steegmans	2008			fourth-generation programming language;first-generation programming language;language primitive;programming domain;reactive programming;computer science;third-generation programming language;service-oriented architecture;functional logic programming;management system;database;distributed computing;programming paradigm;integrated services;fifth-generation programming language;programming language;object-oriented programming;second-generation programming language;high-level programming language;query language	PL	-37.30765560938836	39.48197278117929	107564
3123442e9384878bd7790cb7a74a41754f1635bb	a semi-automated approach to foster the validation of collaborative networks of cyber-physical systems		Cyber-physical systems form collaborative networks dynamically at runtime. In the collaboration of multiple systems, behavior emerges in the interplay of the collaborating instances. This emergent behavior raises challenges for the validation of cyber-physical systems' software, since interoperability of the single systems as well as functional correctness of the entire network of collaborative cyber-physical systems must be validated for all possible configurations of the network. Such network configurations differ, among others, in the number of participating systems, the number of system types involved, and the communication patterns between the participating systems. To aid the validation of behavior emerging from the collaboration, this paper proposes the automated generation of dedicated review diagrams to investigate the collaborative network's behavior for different network configurations. First evaluations using case examples from industry partners show that the use of such automatically generated instance level review diagrams can support the validation of collaborative cyber-physical systems.	collaborative network;communication complexity;correctness (computer science);cyber-physical system;diagram;emergence;interoperability;run time (program lifecycle phase);safety engineering;semiconductor industry;type system	Marian Daun;Jennifer Brings;Thorsten Weyer	2018	2018 IEEE/ACM 4th International Workshop on Software Engineering for Smart Cyber-Physical Systems (SEsCPS)	10.1145/3196478.3196483	collaborative network;cyber-physical system;correctness;interoperability;systems engineering;software;computer science	SE	-42.30423696822573	33.1153708535821	107567
7cc7c3268bce32047a5a1535097ab5e22105addb	design and verification of a health-monitoring driver assistance system	driver information systems;formal verification;medical computing;mobile computing;road safety;road traffic;driver safety;health-monitoring driver assistance system;mobile oriented driver assistance system;service-oriented driver assistance system;verification approach	Health-monitoring driver assistance systems support an independent and self-determined lifestyle enhancing the driver's safety. These systems are health-critical and need to guarantee correct behavior in emergency situations such as heart attacks. Furthermore, they have to be adjustable and extendable with respect to integrated functionalities to fit individual and changing needs. We present a concept for a mobile, service-oriented driver assistance system with dynamic network behavior. Additionally, we introduce a verification approach to ensure correct behavior.	extensibility;service-oriented architecture;service-oriented device architecture	Helena Gruhn;Daniel Stöhr;Mehmet Gövercin;Sabine Glesner	2013	2013 7th International Conference on Pervasive Computing Technologies for Healthcare and Workshops		embedded system;simulation;advanced driver assistance systems;formal verification;computer science;engineering;operating system;reliability;transport engineering;mobile computing;computational model	Robotics	-44.247654221160296	36.052745626960174	108399
5774def3a8de3b69c2d75ddc517789710522ca00	dynamic planning and weaving of dependability concerns for self-adaptive ubiquitous services	aspect oriented pro gramming;component based software engineering;adaptive middleware;service orientation;type of service;aspect oriented programming;middleware;quality of service;planning based adaptation	Ubiquitous computing and service-oriented computing enable the development of a new trend of applications that can opportunely interact with services discovered in the surrounding landscape. Although sporadic, this type of interaction requires the deployment of dependable mechanisms to ensure the correct completion of the interactions. However, the integration and the configuration of these mechanisms depends not only on the type of service accessed, but also on the surrounding environment. Such a variability requires an extensive effort of the developers to support the alternative mechanisms. Thus, to reduce this effort, we propose to integrate the Aspect-Oriented Programming (AOP) principles into the MUSIC planning-based adaptation middleware in order to dynamically plan and weave dependability concerns into the application depending on the execution context. In particular, this paper introduces our continuous support for AOP, which includes i) a uniform model for describing the dependable application configurations and ii) a modular middleware platform for weaving and configuring the dependability concerns when necessary.	aspect-oriented programming;dependability;heart rate variability;heisenbug;interaction;middleware;reactive planning;service-oriented device architecture;software deployment;type of service;ubiquitous computing	Romain Rouvoy;Frank Eliassen;Mikaël Beauvois	2009		10.1145/1529282.1529507	real-time computing;aspect-oriented programming;quality of service;computer science;component-based software engineering;operating system;type of service;software engineering;middleware;database;distributed computing;programming language;world wide web;computer security	SE	-40.90724896070687	40.289914865485635	108409
ab524164b07d772b3b895c51290f36d39cd58bbb	user-centered design of agriculture automation systems using internet of things paradigm		During the past decades, new advances in agriculture automation systems have gained more and more importance and capabilities. In parallel, Internet of Things represents the pervasive presence of a variety of objects (devices, sensors, actuators, mobile phones), which are able to interact with each other, cooperate and create new interfaces (human-machine and machine-machine), to reach common goals. Automation on agriculture systems, or precision agriculture, uses control and communication paradigms to develop new systems: devices, sensors and actuators are interoperable. This technologies (software and hardware) improves the capacity of agricultural installations and agronomists take advantage of new services. This paper presents a research on user-centered design integrated with Internet of Things paradigm. A model-driven development of interactive interfaces that can be adapted and modified by the agronomists in their own agriculturals production is proposed. Additionally, control rules and human-computer interfaces are co-designed by agronomist to adapt the needs of each type of crop and other local and temporal condition (climate, water, energy, nutrients, soil).	automation;internet of things;programming paradigm;user-centered design	Francisco Javier Ferrández Pastor;Juan Manuel García Chamizo;Mario Nieto-Hidalgo;José Mora-Martínez	2017		10.1007/978-3-319-67585-5_7	human–computer interaction;automation;computer science;software;agriculture;interoperability;precision agriculture;user-centered design;internet of things	EDA	-41.05863361365112	43.113885231932755	108486
d921d737110dc4042a1190bec5e37073edf91626	a restfull architecture for enabling rapid development and deployment of companion robot applications	mobile robots cameras temperature sensors robot vision systems;service robots;web services handicapped aids service robots;handicapped aids;web services;restful web services aging population infrastructure social support robots reusable platforms companion robot applications elderly people disabled people low level robotics services end user application components;restful web services companion robots elderly and disabled people architecture applications	The need for companion robots is growing with the dual factors of an aging population and the limited infrastructure/social support. Robots capable of assisting people in daily tasks and providing various services represent part of the solution for the future. The lack of reusable platforms is a significant obstacle to such solutions. In this paper, we propose an architecture that can enable the development and deployment of companion robot applications to assist elderly and disabled people. The architecture consists of a set of components at different layers, ranging from low-level robotics services to end user application components. The multiple layers interact through RESTful web services. This architecture enables the development of a range of applications, and can deal with robots that have varying capabilities and hardware.	component-based software engineering;high- and low-level;interaction;prototype;representational state transfer;robot;robotics;social support;software deployment;web service	Razieh Safaripour;Ferhat Khendek;Roch H. Glitho;Fatna Belqasmi	2014	2014 International Conference on Computing, Networking and Communications (ICNC)	10.1109/ICCNC.2014.6785469	embedded system;simulation;engineering;multimedia;services computing	Robotics	-42.138767860592246	45.96124625922103	108597
db3339a4c8891b92d44643fad103aea7c59332f9	processes, interfaces and platforms. embedded software modeling in metropolis	developpement logiciel;sistema operativo;formal specification;calculateur embarque;software platform;real time;separation of concern;process network;real time operating system;specification programme;embedded system;specification formelle;especificacion formal;metamodel;operating system;metamodele;metamodelo;levels of abstraction;desarrollo logicial;temps reel;software development;boarded computer;tiempo real;systeme exploitation;program specification;calculador embarque;especificacion programa;embedded software	"""The goal of the Metropolis project is to provide a framework for modeling embedded systems across several levels of abstraction, from functional (untimed) to RTL, for various implementation choices, from dedicated hardware to programmable hardware and processors. Emphasis is placed on formal specification and refinement, in order to allow one to apply both synthesis, analysis and verification algorithms at all steps of design. The framework itself provides some such algorithms, as well as allowing one to """"plug in"""" new ones.In this paper we focus on the embedded software design problem, starting from abstract specifications, then decomposing them into networks of processes and communication media, and finally mapping them onto a platform including a processor, a Real Time Operating System and communication components. We illustrate how a clean separation of concerns between functionality and interfaces, as well as between computation and communication, leads to better re-use and a more optimized implementation. We also discuss how the problem of efficiently mapping a process network to a software platform can be formulated and solved."""	embedded software;embedded system;metropolis	Felice Balarin;Luciano Lavagno;Claudio Passerone;Yosinori Watanabe	2002		10.1007/3-540-45828-X_30	metamodeling;embedded system;real-time computing;real-time operating system;embedded software;separation of concerns;computer science;software development;operating system;formal specification;database;distributed computing;programming language;algorithm	Embedded	-40.78886875821764	33.580961866957125	108865
3e613d4e6f73755535d0c689f981d2ea75c4f87b	enhancing web services with diagnostic capabilities	program diagnostics;formal specification;model based diagnosis;system recovery internet program diagnostics fault tolerant computing formal specification formal verification;web service;web service composition;fault tolerant computing;formal verification;system recovery;internet;fault analysis;compensation fault management web service composition model based diagnosis fault analysis anomaly identification recovery;service oriented computing;web services;web services fault diagnosis application software software standards standards development fault detection protocols current supplies service oriented architecture standards publication;diagnosis;fault management	Fault management in Web services composed by individual services from multiple suppliers currently relies on a local analysis that does not span across individual services, thus limiting the effectiveness of recovery strategies. We propose to address this limitation of current standards for Web service composition by employing model-based diagnosis to enhance fault analysis. We propose to add diagnostic Web services to the set of Web services providing the overall service, acting as supervisors of their execution, by identifying anomalies and explaining them in terms of faults to be repaired. This approach poses the basis for the development of specialized recovery and compensation techniques aimed at addressing different problems, which could not be otherwise discriminated.	service composability principle;web service	Liliana Ardissono;Luca Console;Anna Goy;Giovanna Petrone;Claudia Picardi;Marino Segnan;Daniele Theseider Dupré	2005	Third European Conference on Web Services (ECOWS'05)	10.1109/ECOWS.2005.12	web service;real-time computing;computer science;ws-policy;services computing;law;computer security	DB	-46.68864908844415	40.84948580924937	109028
7fc02f440a97aba66d4a2630f1b038f7f2a024b5	rule-based conflict resolution framework for internet of things device management in smart home environment	eca;smart home environment;conflict resolution	Recent developments in Internet of Things (IoT) tremendously have introduced several heterogeneous systems and devices that characterize a smart home. Generally, these heterogeneous systems are dissimilar and accomplish various services and functionalities. Due to the gradual changes of managing resources in smart home, more heterogeneous systems are being introduced from time to time depending on the consumer requirement. As such, more dependencies are created among heterogeneous systems, and this could lead towards conflict occurrences among them. Conflicts could occur in smart home when two or more events generated by heterogeneous systems need to be triggered at an instance of time. In this paper, we present a rule-based conflict resolution framework using scheduling algorithm for managing heterogeneous systems in smart home environment. Events are captured and processed by the framework which performs corresponding conflict resolution on the heterogeneous systems. The developed framework was implemented with several heterogeneous systems to validate their effectiveness in solving conflict occurrences. The framework was ascertained to be consistent in smart home environment.	algorithm;home automation;internet of things;logic programming;scheduling (computing)	Thinagaran Perumal;Md Nasir Sulaiman;Soumya Kanti Datta;Thinaharan Ramachandran;Chui Yew Leong	2016	2016 IEEE 5th Global Conference on Consumer Electronics	10.1109/GCCE.2016.7800444	simulation;engineering;operations management;computer security;internet of things	Embedded	-42.33754606722796	42.18433363187007	109219
5e5daeb219099b5e0d668d95d6124692f7dfbf4f	autosar basic software for complex control units	multi core;open systems;elektrobit automotive;integration support;functional safety;complex control unit;tracing functionality;dirk diekhoff;autosar basic software;automotive open system architecture;software architecture;new autosar basic software;automotive electronics;early phase;diagnostic logging;presentation elektrobit automotive;reliable basic software;multicore system;electronic engineering computing;application software;microcontrollers;automotive engineering;hardware;computer architecture	"""Dirk Diekhoff, Elektrobit Automotive  """"The development of complex control units requires mature and reliable basic software as well as integration support particularly in early phases of the project. In this presentation Elektrobit Automotive will focus on new AUTOSAR basic software features such as multi core and functional safety. We will show how integration and validation will be enhanced by diagnostic logging and tracing functionalities."""""""	autosar;capability maturity model;dirk helbing;engine control unit;multi-core processor;requirement	Dirk Diekhoff	2010	2010 Design, Automation & Test in Europe Conference & Exhibition (DATE 2010)		embedded system;software architecture;application software;real-time computing;computer science;engineering;operating system;open system;functional safety;computer engineering	EDA	-47.214054822502554	36.921988300178846	109247
2318f64edf7e1a1c6681c1b911b6ead478a5491a	slosl--a modelling language for topologies and routing in overlay networks	distributed system;sql;sql overlay networks distributed systems middleware layer internet message forwarding;network topology routing protocols programming profession internet domain specific languages distributed databases scalability middleware prototypes;internet;modelling language;overlay network;sql internet middleware simulation languages;middleware;simulation languages;internet application;data management system;model driven architecture	Overlay networks are a fascinating field in the area of distributed systems. They combine challenges from self-organisation to extreme scalability and provide an interesting middleware layer for server-free Internet applications. The design aspects of their implementations, however, remained largely at the prototype level, which renders their integration and deployment in real applications hard. This paper describes an integrative, platform independent design approach for overlay networks that models topologies as data management systems. Local decisions about neighbours and message forwarding are expressed in an SQL-like language. The mapping to runnable implementations follows the model driven architecture approach	database;distributed computing;domain-specific language;high- and low-level;middleware;model-driven architecture;modeling language;overlay network;prototype;rendering (computer graphics);router (computing);routing;sql;scalability;self-organization;server (computing);software deployment;software engineering	Stefan Behnel	2007	15th EUROMICRO International Conference on Parallel, Distributed and Network-Based Processing (PDP'07)	10.1109/PDP.2007.75	middleware;sql;parallel computing;the internet;overlay network;computer science;operating system;middleware;database;distributed computing;computer network	DB	-34.383710531792964	44.73321424482981	109457
ee45de8c0fca1c3ba869d0dca71b52e314c2ca0f	a modeling approach to analyze the impact of error propagation on reliability of component-based systems	reliability;component based systems;settore ing inf 05 sistemi di elaborazione delle informazioni;error propagation;state based model;cost effectiveness	We present a novel approach to the analysis of the reliability of a component-based system that takes into account an important architectural attribute, namely the error propagation probability. This is the probability that an error, arising somewhere in the system, propagates to other components, possibly up to the system output. As we show in the paper, this attribute may heavily affect decisions on crucial architectural choices. Nonetheless, it is often neglected in modeling the reliability of component-based systems. Our modeling approach provides a useful support to the reliability engineering of component-based systems, since it can be used to drive several significant tasks, such as: (i) placing error detection and recovery mechanisms, (ii) focusing the design, implementation and selection efforts on critical components, (iii) devising cost-effective testing strategies. We illustrate the approach on an ATM example system.	propagation of uncertainty;software propagation	Vittorio Cortellessa;Vincenzo Grassi	2007		10.1007/978-3-540-73551-9_10	reliability engineering;simulation;cost-effectiveness analysis;artificial intelligence;propagation of uncertainty;machine learning;reliability;distributed computing;computer security;algorithm;statistics	Logic	-47.236567785563196	34.41386922150564	109841
fcb2c524a1030b78332ead9afc09713c0bac4e1f	a comprehensive approach to model and use context for adapting applications in pervasive environments	context aware computing;context aware;context information;pervasive computing;web service;service architecture;context model;adaptive applications;adaptation;web services;content adaptation;systems and applications;process model;context modeling;domain specificity	With an increasing diversity of pervasive computing devices integrated in our surroundings and an increasing mobility of users, it will be important for computer systems and applications to be context-aware. Lots of works have already been done in this direction on how to capture context data and how to carry it to the application. Among the remaining challenges are to create the intelligence to analyze the context information and deduce the meaning out of it, and to integrate it into adaptable applications. Our work focuses on these challenges by defining generic context storage and processing model and by studying its impact on the application core. We propose a reusable context ontology model that is based on two levels: a generic level and a domain specific level. We propose a generic adaptation framework to guarantee adaptation of applications to the context in a pervasive computing environment. We also introduce a comprehensive adaptation approach that involves content adaptation and presentation adaptation inline with the adaptation of the core services of applications. Our case study shows that the context model and the application adaptation strategies provide promising service architecture. 2007 Elsevier Inc. All rights reserved.	benchmark (computing);computer;content adaptation;continuation;domain-specific language;environment variable;function model;pervasive informatics;petri net;ubiquitous computing;user interface;web ontology language;web service	Tarak Chaari;Dejene Ejigu;Frédérique Laforest;Vasile-Marian Scuturici	2007	Journal of Systems and Software	10.1016/j.jss.2007.03.010	web service;computer science;knowledge management;data mining;context model;world wide web;ubiquitous computing	HCI	-41.619497005157555	43.0061830938778	110108
f919ac48b19c81115c351b9be5268596ada7fa08	building blocks of the small data ecosystem: from data acquisition and processing to user-facing applications		Author(s): Alquaddoomi, Faisal Sabah | Advisor(s): Palsberg, Jens | Abstract: Small data are the digital traces that we produce regularly when interacting with services or devices. These data are rich, multi-modal, and often personal in nature. This thesis describes the design space of small data systems, enumerating the concerns in acquiring and deriving actionable insights from the data. An idealized architecture is presented, with spe- cific realizations of that architecture, and comparisons between these realized applications, comprising the majority of the work. While the systems discussed have a common core of primitives, the work discusses the peculiarities of each application domain and how these differences eventually lead to separate application stacks. The work closes with observations on ways to continue the exploration of this space – specifically toward small, self-contained stacks where sharing is entertained only when necessary – that draws on the work done so far and the lessons learned in that process.		Faisal Alquaddoomi	2018			application domain;systems engineering;architecture;stack (abstract data type);data acquisition;small data;computer science	DB	-46.143751733955	45.96766894770275	110119
d9844f661f10a7050dd3911e211228cfae08f71f	formal validation and verification of space flight software using statechart-assertions and runtime execution monitoring	natural language specification;space flight;software;instruments;formal specification;runtime verification;log files;space vehicles aerospace computing formal specification formal verification;software platform;uml;flight software;log file based runtime verification;software runtime instruments monitoring testing java usa councils;system of systems;runtime execution monitoring;testing;formal validation;junit tests;usa councils;runtime;brazilian satellite launcher flight software;statechart assertions;formal verification;space flight software;statechart assertion;aerospace computing;monitoring;process support;uml flight software statechart assertions runtime execution monitoring junit tests validation and verification;natural language;junit test formal validation formal verification space flight software statechart assertion runtime execution monitoring brazilian satellite launcher flight software natural language specification formal specification assertion log file based runtime verification;junit test;verification and validation;validation and verification;space vehicles;java;formal specification assertion	Systems of systems must rely on a sound validation and verification process due to their inherent complexity. This paper presents the results of a formal computer-aided validation and verification of critical time-constrained requirements of the Brazilian Satellite Launcher flight software. It describes the entire specification, validation, and verification process that begins with a system requirement as a natural language specification, followed by the creation and computer-aided validation of UML statechart-formal specification assertions, and ends with the log file based runtime verification. These log files were executed as JUnit tests against the assertions. The verification and validation of the flight software uncovered inaccuracies in the requirements understanding and implementation. The results also confirmed the importance of having computer-aided tools deeply integrated into the verification and validation process, supporting requirement behavioral validation and verification of requirements implementation on the hardware and software platforms on which these systems run.	data logger;embedded software;formal specification;junit;natural language;programming language specification;requirement;runtime verification;state diagram;system of systems;system requirements;uml state machine;unified modeling language;verification and validation	Miriam C. Bergue Alves;Doron Drusinsky;James Bret Michael;Man-tak Shing	2011	2011 6th International Conference on System of Systems Engineering	10.1109/SYSOSE.2011.5966590	embedded system;verification and validation;verification and validation of computer simulation models;real-time computing;verification and validation;verification;formal methods;computerized system validation;software verification;physical verification;computer science;high-level verification;runtime verification;programming language;validation rule;post-silicon validation;intelligent verification;functional verification	SE	-44.94266782722578	32.483438665232796	110176
14e7b44732cf825a2d61b0d6763baf51a0575fd3	performance assessment of an architecture with adaptative interfaces for people with special needs	performance patterns and antipatterns;industrial report;software architecture;ict for people with special needs;performance assessment	People in industrial societies carry more and more portable electronic devices (e.g., smartphone or console) with some kind of wireless connectivity support. Interaction with auto-discovered target devices present in the environment (e.g., the air conditioning of a hotel) is not so easy since devices may provide inaccessible user interfaces (e.g., in a foreign language that the user cannot understand). Scalability for multiple concurrent users and response times are still problems in this domain. In this paper, we assess an interoperable architecture, which enables interaction between people with some kind of special need and their environment. The assessment, based on performance patterns and antipatterns, tries to detect performance issues and also tries to enhance the architecture design for improving system performance. As a result of the assessment, the initial design changed substantially. We refactorized the design according to the Fast Path pattern and The Ramp antipattern. Moreover, resources were correctly allocated. Finally, the required response time was fulfilled in all system scenarios. For a specific scenario, response time was reduced from 60 seconds to less than 6 seconds.	anti-pattern;fast path;interoperability;ramp simulation software for modelling reliability, availability and maintainability;refactoring software, architectures, and projects in crisis;response time (technology);scalability;smartphone;user interface	Elena Gómez-Martínez;Rafael González-Cabero;José Merseguer	2013	Empirical Software Engineering	10.1007/s10664-013-9297-1	software architecture;real-time computing;simulation;human–computer interaction;computer science;engineering;software engineering	Mobile	-40.75498536105402	43.573836140501754	110505
7b86773a5d81453549349dfaf8f1fb02c375c8bc	iot-based urban security models		The era of Cyber-Physical Systems (CPS) and IoT1 gives rise to the necessity of multi-proficiency in software, hardware, and the Cyber-Physical Space (CPSp) wherein the IoT components are deployed. Focusing on software engineering aspects, this research proposes a model-driven engineering approach to engineer CPS and model pedestrians flow. To this end, design-time decisions and run-time data ought to be fused to improve the efficiency of crowd monitoring and emergency handling. Moreover, the research aims at building some mathematical models applicable as the core of the system controller to facilitate optimum route selection, crowd movement prediction, and hazard diffusion detection; while considers the architectural characteristics of the complex area to be evacuated.	anisotropic diffusion;cyber-physical system;mathematical model;model-driven architecture;model-driven engineering;software engineering	Mahyar Tourchi Moghaddam	2018	2018 IEEE/ACM 40th International Conference on Software Engineering: Companion (ICSE-Companion)	10.1145/3183440.3183450	computer security model;flow network;computer science;control theory;systems engineering;cyber-physical system;mathematical model;software architecture;software;data modeling	SE	-45.867829521662	38.32178773766932	110591
34f9b101578503c86819292b148181e236c0033b	design patterns for safety-critical embedded systems	nicht funktionale anforderung;embedded system;non functional requirements;informatik;design patterns	Over the last few years, embedded systems have been increasingly used in safetycritical applications where failure can have serious consequences. The design of these systems is a complex process, which is requiring the integration of common design methods both in hardware and software to fulfill functional and non-functional requirements for these safety-critical applications. Design patterns, which give abstract solutions to commonly recurring design problems, have been widely used in the software and hardware domain. In this thesis, the concept of design patterns is adopted in the design of safetycritical embedded system. A catalog of design patterns was constructed to support the design of safety-critical embedded systems. This catalog includes a set of hardware and software design patterns which cover common design problems such as handling of random and systematic faults, safety monitoring, and sequence control. Furthermore, the catalog provides a decision support component that supports the decision process of choosing a suitable pattern for a particular problem based on the available resources and the requirements of the applicable patterns. As non-functional requirements are an important aspect in the design of safety-critical embedded systems, this work focuses on the integration of implications on non-functional properties in the existing design pattern concept. A pattern representation is proposed for safety-critical embedded application design methods by including fields for the implications and side effects of the represented design pattern on the non-functional requirements of the systems. The considered requirements include safety, reliability, modifiability, cost, and execution time. Safety and reliability represent the main non-functional requirements that should be provided in the design of safety-critical applications. Thus, reliability and safety assessment methods are proposed to show the relative safety and reliability improvement which can be achieved when using the design patterns under consideration. Moreover, a Monte Carlo based simulation method is used to illustrate the proposed assessment method which allows comparing different design patterns with respect to their impact on safety and reliability.	decision support system;embedded system;fault (technology);functional requirement;mission critical;monte carlo method;non-functional requirement;run time (program lifecycle phase);simulation;software design pattern	Ashraf Armoush	2010			embedded system;systems engineering;computer engineering	EDA	-47.68331843519238	33.938145691206934	110765
1e1d458ea783e208323cbed94e8953abb3cd001a	application validation on rtdroid		Android is becoming used more frequently in domains that expect some real-time guarantees. To facilitate the adoption of Android for programming real-time systems, this work presents a first effort to apply real-time scheduling theories to a real-time extension on Android, RTDroid. We integrate real-time properties specified in RT-Droid's application manifest with an existing real-time scheduling framework, Cheddar. We leverage Cheddar to perform schedulability analysis and feasibility tests, based on the properties of RTDroid application components specified in the application manifest. This paper details our integration process and reports our experience of validating real-time properties in a real-time application developed on RTDroid.	active message;android;cochlear implant;component-based software engineering;real-time clock;real-time computing;real-time locating system;real-time transcription;scheduling (computing);scheduling analysis real-time systems	Yin Yan;Lukasz Ziarek	2018	SIGBED Review	10.1145/3269482.3269484	computational science;distributed computing;computer science	Embedded	-41.48507343803303	36.14520646914803	110811
811af9f2da5c2095086ce1cb3462aa7112620465	viper: a lightweight approach to the simulation of distributed and embedded software	embedded hardware platform;embedded software;environment runtime;hardware interrupt;virtual hardware;free software;simulation platform;real-time operating system;lightweight approach;model hardware device;hardware abstraction layer;simulation;virtualization	This paper describes a simulation platform for embedded software named ViPER (Virtual Platform and Environment Runtime). ViPER is oriented toward (but not limited to) systems of the automotive domain. It allows to model and simulate distributed embedded hardware platforms in order to ease the early development stages of the embedded software. Each node of the system is virtualized in a process that runs an ad-hoc port of the real-time operating system Trampoline. ViPER manages global time, hardware interrupt and offers a quick and easy way to model hardware devices. In order to close the loop, relevant parts of the environment can be simulated. Once a platform is modeled, ViPER generates description files for each node that ensure the conformance of the hardware abstraction layer to the virtual hardware. ViPER and Trampoline are available as free software.	abstraction layer;application programming interface;compiler;conformance testing;distributed computing;embedded software;embedded system;fault injection;firmware;hardware abstraction;hoc (programming language);identifier;interrupt;observable;posix;real-time operating system;real-time transcription;simulation;virtual machine;x86 virtualization	Jean-Luc Béchennec;Mikaël Briday;Sébastien Faucou;Florent Pavin;Fabien Juif	2010			embedded system;real-time computing;virtualization;simulation;embedded software;computer science;operating system	Embedded	-33.90330305880748	39.93073540336845	110940
6279f2220fb610ce0198cc2e164921c4a07ce74f	an agent-based data-generation tool for situation-aware systems	data gathering agent based data simulation situation awareness situation understanding;sensors;data gathering;situation understanding;agent based data generation tool;heating;situation aware monitoring system;multi agent systems;computational modeling;sensor level behavioural data;program debugging digital simulation multi agent systems;agent based data simulation;schedules;repast;situation awareness;program debugging;repast agent based data generation tool system debugging situation aware monitoring system sensor level behavioural data;system debugging;context;object oriented modeling;sensors heating context computational modeling object oriented modeling schedules data models;digital simulation;data models	This paper describes the design, implementation and evaluation of a simulator that generates plausible data for the debugging and testing of situation-aware monitoring systems. The use of simulated data is necessary because there is very little sensor-level behavioural-data available in the literature and, moreover, these data are very specific of the set-up used to collect them, i.e. the kind of sensors, the people behavior and age, the environment characteristics, and so on. Moreover, data collection requires a long time since the phenomena we are interested in last months or years. The use of a tool like Repast has substantially sped up the design and implementation phase while still achieving the necessary time performance and quality of the data generated.	context-aware pervasive systems;debugging;repast (modeling toolkit);sensor	Davide Merico;Roberto Bisiani	2011	2011 Seventh International Conference on Intelligent Environments	10.1109/IE.2011.14	real-time computing;simulation;computer science;data mining	Robotics	-34.77162110202096	35.21844084472632	111216
4e2b7bd5433fa100f7f2b3318078c6210601bb59	use of denotational mathematics for the formal description of autonomous migration and polymorphism as prerequisites for mobility in home ubihealth	ubiquitous computing health care home computing;nanoscale devices software ontologies context;denotational mathematics ubicomp homecare ubiquitous computing;ubicomp;ubiquitous computing;homecare;denotational mathematics;healthcare denotational mathematics formal description autonomous migration polymorphism home ubihealth home ubiquitous computing environment ad hoc networked computing devices wirelessly networked computing devices sensors monitoring actuators monitoring computer applications software infrastructure conceptual implementation operational prerequisites	In the home ubiquitous computing (UbiComp) environment the wirelessly and ad-hoc networked computing devices are connected with sensors and actuators monitoring, recording, and intervening in the performed activities. The unattended applications operating at this environment must be fault tolerant and redundant. However, the lack of standardization and the uncontrolled evolvement of the developed situations at home result in a hostile environment for computer applications. Also, the need to support the individual's mobility at home increases further the level of difficulty of the associated computing efforts. The individual's mobility is supported providing computing services which can migrate from the currently running device to the neighboring one in order to follow every inhabitant's disposition. Migration presupposes the selection of adequate policies supported by the suitable software infrastructure to exploit the conceptual implementation of polymorphism that allows the preservation of functionality while autonomously transferred to another computing device. This paper provides a formal description with Denotational Mathematics of the operational prerequisites of such an autonomous system that achieves the migration of applications for the continuous support of the individual's mobility. The infrastructure must be capable of enforcing strategies and policies related to migration either by transporting the supporting applications or by referencing them. The achievement of the provision of healthcare at the UbiComp home presupposes the continuous support of the individual's mobility.	as-interface;autonomous robot;autonomous system (internet);computer;fault tolerance;hoc (programming language);redundancy (engineering);sensor;ubiquitous computing;uncontrolled format string	John C. Sarivougioukas;Aristides Th. Vagelatos;Isaac Lagaris	2015	2015 IEEE 14th International Conference on Cognitive Informatics & Cognitive Computing (ICCI*CC)	10.1109/ICCI-CC.2015.7259412	real-time computing;simulation;computer science;computer security	HCI	-39.40673813288336	44.22029681323129	111352
e4fcdecb8316bdaa48f6dab117c8fd39679123b8	policy-based context-aware adaptable software components for mobility computing	policy based context aware adaptable software components;context aware;mobility computing;mobile computer;object oriented programming;policy driven software framework;programming model;software architecture;programming model policy based context aware adaptable software components mobility computing policy driven software framework spontaneous objects runtime architecture;software component;software framework;containers application software computer science runtime environment computer architecture object oriented modeling context modeling object oriented programming dynamic programming communication networks;mobile computing;software architecture mobile computing object oriented programming;spontaneous objects;runtime architecture	The adaptability of software applications is a very demanding feature nowadays. The main contribution of this paper is to propose a concept of policy-driven software framework supporting adaptable components called spontaneous objects. Spontaneous objects are lightweight adaptable context-aware software components. The adaptability mechanism is split between spontaneous objects and a spontaneous object container which creates a runtime environment for spontaneous objects. The paper describes the benefits achieved due to the policy-driven approach, a complete runtime architecture for spontaneous object implementation, a programming model and a case study	component-based software engineering;computer performance;point of view (computer hardware company);programmer;programming model;runtime system;software framework;spontaneous order;universal instantiation	Tomasz Szydlo;Robert Szymacha;Krzysztof Zielinski	2006	2006 10th IEEE International Enterprise Distributed Object Computing Conference (EDOC'06)	10.1109/EDOC.2006.40	software architecture;real-time computing;computer science;software framework;component-based software engineering;object-oriented design;distributed computing;programming paradigm;programming language;object-oriented programming;mobile computing	SE	-39.253288855605554	40.53890979445776	111385
8d4213cadc37f98ab4d3cab41ff6eadcb47aef44	a hierarchical context dissemination framework for managing federated clouds	dynamic change;context cloud computing semantics scalability cognition servers data models;semantic context dissemination;autonomic communications;policy model;data model;computer centres;large scale;data center;fault tolerant computing;technology and engineering;design;semantic context dissemination autonomic communications cloud computing;services;large scale cloud data center hierarchical context dissemination framework federated cloud management internet management complexity autonomic management architecture scalability management component hierarchical structure information aggregation information translation semantics context filtering dynamically changing context requirements cloud computing;large scale systems;cloud computing;large scale systems cloud computing computer centres fault tolerant computing	The growing popularity of the Internet has caused the size and complexity of communications and computing systems to greatly increase in recent years. To alleviate this increased management complexity, novel autonomic management architectures have emerged, in which many automated components manage the network's resources in a distributed fashion. However, in order to achieve effective collaboration between these management components, they need to be able to efficiently exchange information in a timely fashion. In this article, we propose a context dissemination framework that addresses this problem. To achieve scalability, the management components are structured in a hierarchy. The framework facilitates the aggregation and translation of information as it is propagated through the hierarchy. Additionally, by way of semantics, context is filtered based on meaning and is disseminated intelligently according to dynamically changing context requirements. This significantly reduces the exchange of superfluous context and thus further increases scalability. The large size of modern federated cloud computing infrastructures, makes the presented context dissemination framework ideally suited to improve their management efficiency and scalability. The specific context requirements for the management of a cloud data center are identified, and our context dissemination approach is applied to it. Additionally, an extensive evaluation of the framework in a large-scale cloud data center scenario was performed in order to characterize the benefits of our approach, in terms of scalability and reasoning time.	artificial intelligence;autonomic computing;cloud computing;data center;internet;requirement;scalability	Jeroen Famaey;Steven Latré;John Strassner;Filip De Turck	2011	Journal of Communications and Networks	10.1109/JCN.2011.6157473	design;data center;cloud computing;data model;computer science;operating system;database;distributed computing;world wide web;computer network	HPC	-44.14411467565657	43.23887230744988	111386
c9a771a7f421feee804f9f15ea9c28e92aa1c2ac	function blocks for fieldbus diagnostics	program diagnostics;program diagnostics control engineering computing field buses;function block;field buses;control engineering computing;fieldbus diagnostics data function blocks fieldbus installations fieldbus standards;field buses programmable control distributed control control systems hardware investments iec standards automation mechatronics access protocols	Increasingly fieldbuses are used in a variety of applications as the end users make large investments on fieldbus installations. Therefore the availability of these fieldbuses is of paramount importance in smooth plant operation. Although the fieldbus standards specify the type and format of the diagnostics data, the extent, location and sequence of diagnostics data within a controller is entirely vendor dependent. As the number of differing controller makes increase in an installation, so does the problem of accessing fieldbus diagnostics data. This research work defines a unified framework for representing the fieldbus diagnostics data in the form of a data block, and develops diagnostics function blocks to provide the required diagnostics data at the controller and higher levels	fieldbus;unified framework	Hassan Kaghazchi;Ronan Joyce;Donal Heffernan	2006	2006 IEEE Conference on Emerging Technologies and Factory Automation	10.1109/ETFA.2006.355353	control engineering;embedded system;foundation fieldbus h1;real-time computing;engineering;operating system;foundation fieldbus	Robotics	-35.66823996797449	37.940990464180786	111803
1e8e55b88798b6bacc3829333b2ef0007e9a2cc5	from osi to omg experiences from the port of an isode-based application to omg/corba concepts	distributed application;migration;corba;omg;distributed object system;object management group;middleware;common object request broker architecture;osi communication	This paper develops general recommendations for the migration from explicit, OSI-based communication to implicit, OMG/ CORBA based communication. These recommendations are validated by our experiences from the port of the External Reference Manager (XRM) component of the BERKOM multimedia mail system. The former version of the XRM was based on OSI-communication and implemented using the ISODE package. The new XRM uses the CORBA implementation Orbix 1.3 from IONA Ltd Additionally, the paper gives an overview of the problems that will occur during the reimplementation of a monolithic, distributed application using concepts of distributed object systems. It gives an insight into our current and future activities with respect to distributed middleware platforms.		Klaus-Peter Eckert	1996	Computer Communications	10.1016/0140-3664(95)01043-2	real-time computing;computer science;common object request broker architecture;database;distributed computing	HCI	-33.95029594135971	43.15263562187933	112106
9edd8d9f9877a7d46eb14e534127cce223208f8a	using multi-agent geo-simulation techniques for intelligent sensor web management	intelligent sensor;water resource;multi agent system;agent based;sensor web management;large scale;multi agent systems;complex system;simulation technique;community capacity;sensor nodes;sensor web;geo simulation;distributed sensing	Sensor webs consist of a large collection of small nodes providing collaborative and distributed sensing ability in unpredictable environments. Nodes composing such sensor webs, are characterized by their resource restrictions, especially the energy, the processing, and the communication capacities. These nodes are also in constant interaction with each other and with their geographic environment. An efficient system aiming at managing sensor webs must take into account the evolution of the sensor nodes as well as the geographic environment. Such a management process involves coping with a variety of dynamic variables including the nodes characteristics, the environment properties as well as the sensed data. In this context, Multi-Agent Geo-Simulation (MAGS) provides a flexible approach that can be used to easily analyse complex systems such as sensor webs in large scale georeferenced environments. The purpose of this paper is to present SensorMAGS, an agent-based geo-simulation system which manages sensor nodes in virtual geographic environments. This system is applied in the context of a water resource monitoring project.	agent-based model;complex systems;fiber optic sensor;multi-agent system;sensor web;simulation;virtual geographic environments;web development	Mehdi Mekni;Bernard Moulin	2008		10.1145/1456223.1456358	sensor web;simulation;computer science;artificial intelligence;multi-agent system;distributed computing;key distribution in wireless sensor networks;mobile wireless sensor network;world wide web;intelligent sensor	AI	-38.828201472109754	44.69933354661047	112230
8725fdbd7b6b4cc06628ac8d9a821d7e61d14cc4	a taxonomy of artificial intelligence approaches for adaptive distributed real-time embedded systems	ai techniques artificial intelligence adaptive distributed real time embedded systems dre software systems system utility system lifespan adaptive dre system autonomous decision making;embedded systems adaptive systems artificial intelligence decision making distributed processing;adaptive systems power grids computers decision trees robustness expert systems	Distributed real-time embedded (DRE) software systems such as are used to manage critical large-scale infrastructure are important systems to target for increased functionality and resiliency. DRE systems that can adapt to changes in the environment and/or changes in available resources are more robust to unexpected changes and extend both the systems' utility and lifespan. Artificial intelligence techniques are used for adaptation of software systems in general. However, they must meet certain requirements to be appropriate for use with DRE systems. Any artificial intelligence (AI) technique used in an adaptive DRE system should produce consistent results across a distributed system, operate in bounded time, make decisions autonomously, and gracefully handle and learn from previously unencountered environments. This paper surveys a variety of AI techniques, providing a brief overview of each method, evaluating how each technique fits the requirements of an adaptive DRE system, and recognizing the gaps in each technique's ability to meet all of these requirements. Our results show that there is not one single AI technique in our survey that is a perfect fit for adaptive DRE systems, although some techniques address more of these requirements than others.	artificial intelligence;distributed computing;embedded system;fits;real-time clock;requirement;software system	Jeremy Davis;Joe Hoffert;Erik Vanlandingham	2016	2016 IEEE International Conference on Electro Information Technology (EIT)	10.1109/EIT.2016.7535246	embedded system;real-time computing;simulation;engineering;operating system	Embedded	-43.70547363874117	38.224738191041375	112370
593353b6a5317f78475f36403fa6d04cbdbacc97	middleware support for implementing context-aware multimodal user interfaces	multimodal user interfaces;component based development;pervasive networking;context aware applications;middleware	In context-aware pervasive networking (Capnet) environments the user interface of a service application has to be adapted to whatever type of a device the user is using, taking into account the situation at hand, i.e. the user's current context, as well as user's personal preferences. In addition, new and more natural interaction styles have to be provided for the user. When designing and implementing user interfaces, or generating them automatically at runtime, some a priori knowledge of the capabilities of user's device and her personal preferences are required. Furthermore, runtime adaptation calls for mechanisms for recognizing context and delivering it. This paper presents the support that could be provided in middleware level for implementing context-aware multimodal user interfaces and the Capnet middleware user interface architecture model for providing that support. Adaptation algorithms are not discussed. The Capnet middleware backbone provides support for context-awareness via context recognition and automatic delivery of context data through a notification mechanism. For multimodal input and output third party components are required. The proposed architecture model is partly implemented and tested with software prototypes.	algorithm;context awareness;input/output;internet backbone;middleware;multimodal interaction;pervasive informatics;run time (program lifecycle phase);software prototyping;user interface	Pertti Repo;Jukka Riekki	2004		10.1145/1052380.1052411	user interface design;user modeling;computer user satisfaction;human–computer interaction;computer science;component-based software engineering;operating system;middleware;database;user interface;world wide web	HCI	-40.402815944677805	44.87553193366236	112452
33de08593b0120a077e4e355febab36bebec77a1	towards the automatic generation of self-adaptive robotics software: an experience report	software;robot sensing systems;e pucks;e puck;fractal component model;mobile robot;self adjusting systems;diva framework;mobile robots;adaptive behavior;automatic generation;component based software architecture;experience report;autonomous robots;mobile robotics platform;diva;adaptation models context robot sensing systems monitoring software;automated model to text transformation;run time self adaptive architecture;monitoring;lessons learned;cecilia;model driven engineering;runtime self adaptation;model development;fractal;e puck model driven engineering component based software architecture autonomous robotics runtime self adaptation diva fractal;automated model to text transformation self adaptive robotics software diva framework autonomous robots resource constrained robots run time self adaptive architecture fractal component model cecilia e pucks mobile robotics platform;component model;self adaptive robotics software;resource constrained robots;control engineering computing;program compilers;self adjusting systems control engineering computing mobile robots program compilers;adaptation models;adaptive architecture;autonomous robotics;context;autonomous robot	This paper reports the progress on a previous work in which we described our experience in using the high-level models provided by the DiVA Framework to design the self-adaptive behavior of autonomous robots. The main objective of this work is to discuss how these models can be translated into a run-time self-adaptive architecture for resource-constrained robots. In order to achieve this goal, the models developed for the case study presented as part of the previous work (based on a Victim-Rescuer scenario) serve as the starting point to manually obtain a self-adaptive component-based architecture, which we have implemented using Cecilia (a C distribution of the Fractal component model) and deployed on two e-pucks (low-cost mobile robotics platform). Through this implementation, we try to identify the generic rules that will allow us to obtain (by means of an automated Model-to-Text transformation) self-adaptive robotics software from the DiVA design-time models. The lessons learned from this experience are reported at the end of the paper, leaving the way open for further improvements on self-adaptive robotics.	adaptive behavior;adaptive architecture;autonomous robot;component-based software engineering;cooperative mimo;e-puck mobile robot;fractal component model;high- and low-level;m2m (eclipse);mobile robot;model-driven engineering;osgi;program transformation;robotics;transformation language;xpand 3d	Juan F. Inglés-Romero;Cristina Vicente-Chicote;Brice Morin;Olivier Barais	2011	2011 IEEE 20th International Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprises	10.1109/WETICE.2011.54	mobile robot;embedded system;real-time computing;simulation;computer science;artificial intelligence;operating system;distributed computing	Robotics	-42.51518649437748	37.84803128769862	112600
80179f8701424381ae7af0f0ec440a21d9033e46	combination and abstraction of sensors for mobile context-awareness	sensor combination;sensor abstraction;ubiquitous computing	In this paper, we describe a context server application for mobile computing. Its main objective is to assist developers to exploit context-aware features in their applications. This approach uses the extraction of new context information using a combination of sensors and proposes a sensing abstraction layer to avoid having to deal with specific hardware.	abstraction layer;context awareness;mobile computing;sensor;server (computing)	Borja Gamecho;Luis Gardeazabal;Julio Abascal	2013		10.1145/2494091.2496037	embedded system;real-time computing;human–computer interaction;computer science;data mining;ubiquitous computing	Mobile	-40.613120472375535	45.03521675758628	112683
03ebeb283965f03ca698d6b463c5895255c944a8	pipe-depcas: a middleware solution for epc-rfid data acquisition systems	data acquisition system;middleware	The huge growth of the RFID devices market, such as EPC (Electronic Product Code) elements in the most varied areas of the industry and the services, joined to the new advantages that every day are discovered on their intensive use, have provoked the immediate attention of multitude of HW, SW and custom solutions providers. The heterogeneous applications in which these devices can be used makes that the methods and develops for their management and control differ from the classical ones known till now. In this type of applications it is necessary to include some mechanism of acquisition and management of the radio frequency information. In this article a possible solution for this question is presented. It represents a middleware solution based on a pipeline and filter architecture that brings together the suitable proportion of flexibility, power of calculation, connectivity and simplicity of use to achieve suitable solutions for automation, management and control of goods and services. It has been developed in a more generic framework, that we call DEPCAS (Data EPC Acquisition System), and it is denoted as Pipe-DEPCAS. This specific solution contributes in this field with the best practices of design at the time that it assures an effective control of cost on having used standards of opened code and very known, simple and refined architectures. The paper describes DEPCAS and Pipe-DEPCAS new concepts and developments.	best practice;data acquisition;digital data;electronic product code;heterogeneous computing;information system;middleware;pipeline (computing);radio frequency;radio-frequency identification;shattered world;software architecture;software development	Carlos Cerrada;Ismael Abad;José Antonio Cerrada;Vicente Dies	2007			middleware;computer science;middleware;data acquisition	Embedded	-45.62652503682827	46.31002621194492	112717
29c4cf5daed820ff25cffa9803e14bbc6a7f3a6c	hdl code generation from uml/marte sequence diagrams for verification and synthesis	hdl;unified modeling language uml;vsl;timing constraint;marte;sequence diagram	Design of Embedded Systems is becoming more and more complex in terms of verify that requirements are fulfilled at different design levels. This requires the simulation of the system and the checking of its timing and functional properties. model-driven design and UML give a reasonable solution to cope with such complexity since they have mechanisms to model and verify embedded systems. This paper presents a methodology which starts from UML/MARTE sequence diagrams with timing constraints and the automatic generation of executable SystemC/TLM and VHDL code with checkers from such diagrams. The simulation of the generated model allows to verify the specified sequence of exchanged information between components while checkers allow to verify that properties and timing constraints are met. Three case studies are used to show the validity of the approach and a less than linear increase of execution time overhead due to time observation and assertion checkers.	assertion (software development);code generation (compiler);embedded system;executable;field-programmable gate array;hardware description language;model-driven architecture;model-driven engineering;modeling and analysis of real time and embedded systems;overhead (computing);requirement;run time (program lifecycle phase);sequence diagram;simulation;systemc;unified modeling language;vhdl	Emad Samuel Malki Ebeid;Franco Fummi;Davide Quaglia	2015	Design Autom. for Emb. Sys.	10.1007/s10617-014-9158-1	sequence diagram;computer architecture;real-time computing;computer science;software engineering;applications of uml;programming language	Embedded	-41.190283952345204	32.9247151470334	112725
b62beb0917d85502592e85748fcd1532c8ff4eb2	protocol modeling with model program composition	network protocol;real time;software development	Designing and interoperability testing of distributed, ap plication-level network protocols is complex. Windows, for example, suppor ts currently more than 200 protocols, ranging from simple protocols for email exchange to complex ones for distributed file replication or real time commu nication. To fight this increasing complexity problem, we introduce a methodology and formal framework that uses model program composition to specify behavio r of such protocols. A model program can be used to specify an increment of protoco l functionality with a coherent purpose, which can be understood and analyze d separately. The overall behavior of a protocol can be defined by a composite mo del program, which defines how the individual parts interoperate.	coherence (physics);communications protocol;conformance testing;email;interoperability;microsoft windows;test case	Margus Veanes;Wolfram Schulte	2008		10.1007/978-3-540-68855-6_21	communications protocol;real-time computing;computer science;software development;network management application	Networks	-37.86642145636275	35.530981739859605	112779
702151139ea67711ee4189f9be1749e084ecf072	cdpn: communicating dynamic petri net for adaptive multimedia presentation	distributed application;distributed system;community dynamics;model adaptation;e learning system;distributed multimedia;multimedia presentation;petri net;dynamic adaptation;domain specificity	The programmable Dynamic Petri Nets(DPN) can efficiently model interactive and iterative distributed multimedia presentations. However, the dynamic adaption of the presentation is not possible using isolated DPNs. This paper proposes the concept of communicating Dynamic Petri Nets (CDPN). The declaration and utilization of global variables and functions has been used in the paper to augment the existing DPNs with the communicating feature. There are several distributed systems that can be modeled using the proposed CDPN. In this paper a domain specific application illustrating the potential of CDPN to model adaptive e-learning system is presented.	declaration (computer programming);distributed computing;environment variable;global variable;iterative method;list of toolkits;mpeg-21;middleware;petri net;warez	A. P. Sarath Chandar;S. Arun Balaji;G. Venkatesh;Susan Elias	2010		10.1007/978-3-642-15766-0_24	real-time computing;simulation;computer science;multimedia;petri net	SE	-37.170338168032515	41.164922773846044	112844
fafd913723a9cc8a3683c54f748adee00c036265	adapting a component-based model approach to soa: a robotic experience		C-Forge is an approach that combines Component Based Software Engineering (CBSE) and Model Driven Software Development (MDSD), and has been previously used to define the software architecture of robotic systems. However, as robotic systems become part of a dynamic and heterogeneous environment, CBSE becomes limited. A paradigm that promises to easily adapt and integrate collaborative, heterogeneous and distributed systems is Service Oriented Architecture (SOA). In this paper, we enrich C-Forge with service oriented architectural primitives by extending its CBSE metamodel and Model Driven Methodology.	aim alliance;component-based software engineering;distributed computing;forge;metamodeling;model-driven engineering;programming paradigm;robot;service-oriented architecture;software architecture;software development	Francisca Rosique;Nour Ali;Fernando Losilla	2018		10.5220/0006837505910596	systems engineering;computer science	SE	-38.87676284016623	42.084791564285624	112949
b111dc8db317bb6bc18cf2e657526643e49d5d9a	rivus: a stream template language for capturing multimedia requirements	reference model;data processing;qa 76 software;multimedia application;computer programming;client server;open distributed processing	Object based architectures, such as the standardized reference model for Open Distributed Processing (ODP), must not only provide for the simple client-server styles of interaction found in data processing, but must also support the rich variety of different communication configurations and dependencies that are found in multimedia applications. To do this, ODP defines both simple two-party communication and an explicit binding model which can describe a wide range of more complex situations. It encapsulates the complexity within a visible binding object.		Donna Lindsey;Peter F. Linington	1995		10.1007/3-540-61028-6_30	computer science;database;programming language;world wide web	DB	-35.40024136984021	42.876251037045435	113370
ebac8eb3a710bd0f38f6f132a4b416a75fa12de9	proactivity in service based applications	proactive computing service based applications service oriented architectures cloud computing wireless sensor networks;humans context monitoring runtime computer architecture time factors testing;testing;runtime;service based applications;computer architecture;proactive computing;time factors;proactive computing service based applications;monitoring;wireless sensor networks cloud computing service oriented architecture;humans;service oriented architecture;context;wireless sensor networks;cloud computing	Advancements in Service-Oriented Architectures, Cloud Computing and Wireless Sensor Networks pose challenges with respect to dynamic application adaptation, the ability to reconfigure applications so as to support continuous, unimpeded augmentation of services in response to changing environmental circumstances. Proactivity of Service Based applications refers to anticipatory, change-oriented and self initiated behavior in situations and deals with the identification of new services as well as the identification of potential risks and opportunities that require adaptation based on situational and contextual information. In this paper we identify the proactive characteristics of Service Based Applications and we survey existing approaches based on the proposed characteristics.	approximation algorithm;cloud computing;complex event processing;event-driven architecture;service-oriented architecture;service-oriented device architecture	George Vlahakis;Dimitris Apostolou	2012	2012 16th Panhellenic Conference on Informatics	10.1109/PCi.2012.59	embedded system;real-time computing;wireless sensor network;cloud computing;computer science;operating system;service-oriented architecture;distributed computing;software testing	Mobile	-42.6630819262174	41.19201015087615	113478
75da894968925da03e4858238be2b7d28abb499d	mobcon: a generative middleware framework for java mobile applications	session management;middleware java containers application software appropriate technology computer science mobile computing technology management mobile handsets personal digital assistants;application software;physical layer;code generation;technology management;appropriate technology;personal digital assistants;programming model;mobile handsets;middleware;profitability;computer science;mobile computing;mobile application;containers;java	While dedicated technologies such as e.g., Sun's J2ME MIDP offer a simple programming model for mobile applications, appropriate support for modularizing the implementation of technical concerns such as data persistence, screen management, session management, etc. is still missing. As the result, the implementation of such concerns cuts across several applications, or even several places within a single application. In this paper, we introduce the notion of a logical mobile container aimed at automating the process of nearly transparently adding technical concerns to the core functionality of a MIDP application. The container we introduce is logical: Code generation allows us to profit from high-level abstractions without adding physical layers which are too costly for a mobile application. We present an extensible mobile container framework for MIDP applications, called MobCon, which is implemented as a generative framework based on annotations.	abstract type;code generation (compiler);declarative programming;high- and low-level;java;mathematical optimization;middleware;mobile information device profile;mobile app;persistence (computer science);persistent data structure;programmer;programming model;prototype;session (computer science);template method pattern;unified modeling language	Vasian Cepa;Mira Mezini	2005	Proceedings of the 38th Annual Hawaii International Conference on System Sciences	10.1109/HICSS.2005.431	embedded system;application software;real-time computing;computer science;technology management;appropriate technology;operating system;software engineering;middleware;database;programming paradigm;programming language;java;mobile computing;world wide web;physical layer;code generation;profitability index	PL	-36.00940951485623	41.3740389225471	113610
920925d5bcb423733588aed51175c24b187c07d5	the collective: a common information service for self-managed middleware	management system;col;reflective middleware;information management;middleware;information service;self management;adaptive and reflective middleware	As the deployment of self-managed reflective middleware platforms increases, the process of collecting and examining information used within the reflective process becomes ever more complex. The quality of such information is vital to ensure the successful outcome of the self-management process. However, the cost associated with the collection of this information plays a major role in influencing the success of a self-managed system.Within typical deployment environments it is not uncommon for multiple self-managed systems to be deployed, each collecting information for use within their respective reflective computations. In many cases, these systems will collect the same information, replicating the effort required to retrieve the information. Such replication could be avoided by sharing information between systems to reduce the overall cost of collection within the deployment environments.Current self-managed systems lack adequate support for information collection and sharing. This work proposes the use of an independent information service to assist in the collection and management of information within self-managed middleware systems.	computation;introspection;middleware;self-management (computer science);software deployment	Edward Curry;Enda Ridge	2005		10.1145/1101516.1101528	middleware;computer science;knowledge management;message oriented middleware;middleware;management information systems;group information management;database;risk management information systems;information quality;automated information system;world wide web	HPC	-43.024337160873706	42.68096881061364	113682
c6882b71deb509d509c14299772008e61254373d	so-rti: a new rti based on web services	state maintenance invoking so rti web service oriented rti data type inconformity hla federate ambassador service dynamic invoking high level architecture federate compatibility;web services service oriented architecture;hla;web service;web service distributed simulation hla rti;web services;servers simple object access protocol protocols computational modeling xml standards;service oriented architecture;distributed simulation;rti	The traditional RTI is limited in the following aspects. First, it merely runs in the Local Area Network (LAN) or Virtual Private Network (VPN) rather than Wide Area Network (WAN). Second, it does not support the interoperation over the different platforms. The development of web service based RTI is becoming a hot spot of p resent research. By analyzing the merits and drawbacks of the three methods of existed web services based RTI, this paper intends to design and implement a new service oriented RTI, namely, SO-RTI.SO-RTI uses the technologies of separation of RTI ambassador services and federate ambassador services, persistence of the federation state, etc., and resolve the problems, such as the inconformity of the data type between web service and HLA, maintain of the invoking state, invoking federate ambassador service dynamically, and compatibility of the original federate.	backward compatibility;federated identity;hotspot (wi-fi);interoperation;persistence (computer science);run-time infrastructure (simulation);service-oriented device architecture;virtual private network;web service	Xiaofeng Guo;Jianjing Shen;Zuwei Yin;Shanming Wu	2012	2012 IEEE International Conference on Automation and Logistics	10.1109/ICAL.2012.6308219	web service;computer science;operating system;database;world wide web	DB	-34.851150514676824	44.31301420648744	113784
1c1e4e85421514102cb91f33315a854f864e884b	predictable deployment in component-based enterprise distributed real-time and embedded systems	component technology;predictable deployment;component based systems;environmental conditions;component based real time systems;corba component model;middleware;quality of service;performance optimization;real time systems;real time and embedded systems	Component-based middleware, such as the Lightweight CORBA Component Model, are increasingly used to implement large-scale distributed real-time and embedded (DRE) systems. In addition to supporting the quality of service (QoS) requirements of individual DRE systems, component technologies must also support bounded latencies when effecting deployment changes to DRE systems in response to changing environmental conditions and operational requirements. This paper makes three contributions to the study of predictable deployment latencies in DRE systems. First, we describe OMG's Deployment and Configuration (D&C) specification for component-based systems and discuss how conventional implementations of this standard can significantly degrade deployment latencies. Second, we describe architectural changes and performance optimizations implemented within the Locality-Enhanced Deployment and Configuration Engine (LE-DAnCE) implementation of the D&C specification. Finally, we analyze the performance of LE-DAnCE in the context of component deployments on 10 nodes for a representative DRE system consisting of 1,000 components. Our results show LE-DAnCE's optimizations provide a bounded deployment latency of less than 2 seconds with 2 percent jitter.	common object request broker architecture;component-based software engineering;embedded system;locality of reference;middleware;quality of service;real-time clock;requirement;software deployment	William Otte;Aniruddha S. Gokhale;Douglas C. Schmidt	2011		10.1145/2000229.2000233	embedded system;real-time computing;quality of service;deployment diagram;computer science;engineering;operating system;middleware	Embedded	-40.25552793979738	40.68144085580837	114170
6fd7487b1f3ab153a78867d73368c855b71d6f2b	a safety analysis method using fault tree analysis and petri nets	analytical models;forward and backward reachability analysis safety critical systems fault tree analysis petri nets;system behavioral aspect;failure model;hazards;fault trees petri nets aerospace safety failure analysis information analysis performance analysis reachability analysis software safety security software systems;firing;safety analysis;safety critical software;safety;safety critical system;safety critical software fault trees petri nets reachability analysis;petri nets;safety analysis method;petri net;safety critical system safety analysis method fault tree analysis petri nets system behavioral aspect failure model reachability analysis;reachability analysis;forward and backward reachability analysis;safety critical systems;fault tree analysis;fault trees	In this paper, we describe a safety analysis method that utilizes two models, namely, Petri Nets to model the behavioral aspects of a system, and Fault Tree Analysis to model failure and hence unacceptable behaviors of a system. Using Petri nets and Fault Tree Analysis, we should be able to perform both forward and backward reachability analyses that are related to acceptable and unacceptable behaviors of a system. To show the feasibility of our proposed method, a case study, railroad crossing system, has been conducted.	fault tree analysis;petri net;reachability	Hassan Reza;Malvika Pimple;Varun Krishna;Jared Hildle	2009	2009 Sixth International Conference on Information Technology: New Generations	10.1109/ITNG.2009.183	real-time computing;fault tree analysis;petri net	SE	-45.91604669016244	33.869976167190046	114194
dfc77cf6acd21ba682c71094814dfcfbd907113f	development of a control system for teleoperated robots using uml and ada95	architectural design;ada;lenguaje uml;unidad control;langage modelisation unifie;robotics;unite controle;remote operation;control system;object oriented;teleaccion;unified modelling language;control unit;service robot;robotica;oriente objet;robotique;ada language;orientado objeto;reference architecture;teleoperation;object model	In this paper, a control system in the domain of teleoperated service robots is presented. A reference architecture ACROSET has been analyzed and designed following a concurrent object modeling and architectural design methodology (COMET) that uses UML as describing language. The architecture of the whole system has been implemented in a ship’s hull blasting robot GOYA –using Ada 95 and GLADE. Our previous experience in developing teleoperated service robots using Ada is also presented.	abstraction (software engineering);ada;automatic programming;blast;c++;central processing unit;code generation (compiler);compiler;control system;control unit;distributed computing;encapsulation (networking);exception handling;glade interface designer;rational rose;real-time clock;real-time computing;reference architecture;remote procedure call;requirement;robot;software development;software portability;unified modeling language;whole earth 'lectronic link	Francisco J. Ortiz;Alejandro S. Martínez;Bárbara Álvarez;Andrés Iborra;José M. Fernández	2002		10.1007/3-540-48046-3_9	unified modeling language;reference architecture;embedded system;teleoperation;real-time computing;simulation;ada;object model;computer science;control system;operating system;robotics;programming language;object-oriented programming;control unit	Robotics	-34.18964354907648	36.5388206044052	114244
e5ee268df98698ca60fc67e029102d5f043caec4	on the use of embedded debug features for permanent and transient fault resilience in microprocessors	on line test;debug infrastructure;error detection	Microprocessor-based systems are employed in an increasing number of applications where dependability is a major constraint. For this reason detecting faults arising during normal operation while introducing the least possible penalties is a main concern. Different forms of redundancy have been employed to ensure error-free behavior, while error detection mechanisms can be employed where some detection latency is tolerated. However, the high complexity and the low observability of microprocessors' internal resources make the identification of adequate on-line error detection strategies a very challenging task, which can be tackled at circuit or system level. Concerning system-level strategies, a common limitation is in the mechanism used to monitor program execution and then detect errors as soon as possible, so as to reduce their impact on the application. In this work, an on-line error detection approach based on the reuse of available debugging infrastructures is proposed. The approach can be applied to different system architectures profiting from the debug trace port available in most of current microprocessors to observe possible misbehaviors. Two microprocessors have been used to study the applicability of the solution, LEON3 and ARM7TDMI. Results show that the presented fault detection technique enhances observability and thus error detection abilities in microprocessor-based systems without requiring modifications on the core architecture.	embedded system;microprocessor	Marta Portela-García;Michelangelo Grosso;M. Gallardo-Campos;Matteo Sonza Reorda;Luis Entrena;Mario García-Valderas;Celia López-Ongil	2012	Microprocessors and Microsystems - Embedded Hardware Design	10.1016/j.micpro.2012.02.013	embedded system;parallel computing;real-time computing;error detection and correction;computer science;operating system	EDA	-34.69428320946859	36.71269300529721	114316
c52c29dae97d4457bfc874540e11d1b14955fdd5	formal dependability modeling and analysis: a survey		Dependability is an umbrella concept that subsumes many key properties about a system, including reliability, maintainability, safety, availability, confidentiality, and integrity. Various dependability modeling techniques have been developed to effectively capture the failure characteristics of systems over time. Traditionally, dependability models are analyzed using paper-and-pencil proof methods and computer based simulation tools but their results cannot be trusted due to their inherent inaccuracy limitations. The recent developments in probabilistic analysis support using formal methods have enabled the possibility of accurate and rigorous dependability analysis. Thus, the usage of formal methods for dependability analysis is widely advocated for safety-critical domains, such as transportation, aerospace and health. Given the complementary strengths of mainstream formal methods, like theorem proving and model checking, and the variety of dependability models judging the most suitable formal technique for a given dependability model is not a straightforward task. In this paper, we present a comprehensive review of existing formal dependability analysis techniques along with their pros and cons for handling a particular dependability model.	automated theorem proving;confidentiality;dependability;diagram;fault tree analysis;formal methods;markov chain;model checking;probabilistic analysis of algorithms;simulation;telecommunications network;umbrella term;world-system	Waqar Ahmad;Osman Hasan;Sofiène Tahar	2016		10.1007/978-3-319-42547-4_10	reliability engineering;computer science;systems engineering;dependability;computer security	SE	-44.915605014325024	34.83940756677113	114431
92ae41e03ea7b2d3655c11f1f07a4deae29593a2	from platform-independent to platform-specific models using democles	code generation;software systems;visual programming;executable models;platform specific model;domains;platform independent model;modeling tool	Democles is an executable modeling tool. It is based on a formally defined language named EP that allows both the structure and behavior of a system to be represented. Earlier versions of the tool allowed platform-independent models to be described using EP-models, which have the same level of granularity as classes. The present demonstration will focus on two new features of Democles: a high-level grouping of EP-models into domains which more faithfully represent the different subject matters that make up a complex software system, and a mechanism for mapping the platform-independent model to a concrete platform, namely Java, using platform bindings.	executable;expectation propagation;high- and low-level;java;platform as a service;platform-independent model;platform-specific model;software system	Christian Glodt;Pierre Kelsen;Nuno Amálio;Qin Ma	2009		10.1145/1639950.1640019	real-time computing;computer science;theoretical computer science;open platform;visual programming language;programming language;code generation;software system	SE	-40.74965400726242	34.579427490322225	114459
dfd9156a40a3f32e11a6e617e08bb0f47cd24a96	providing interoperable real-time data communication with tena	program diagnostics;groupware;standards organizations;real time;training;department of defense;software systems;object oriented programming;real time data;data communication;tena;middleware programming training standards organizations us department of defense;software architecture;sdo interoperability middleware distributed real time decentralized tena;us department of defense;software reusability;middleware;hla interoperable real time data communication us dod test and training enabling architecture software system interoperation real time data exchange distributed development collaborative development embedded systems tena middleware programming abstraction api compile time programming error detection reusable standardized object models extensible object model compiler data loggers legacy system dis;sdo;interoperability;distributed;program compilers;open systems;programming;software reusability data communication electronic data interchange groupware middleware military computing object oriented programming open systems program compilers program diagnostics software architecture;electronic data interchange;geographic distribution;military computing;decentralized	The U.S. DoD testing and training ranges present enormous interoperability challenges for communicating their real-time data. To address these challenges, the U.S. DoD has developed the Test and Training Enabling Architecture (TENA). Chief among these interoperability challenges is the fact that the developers working to support the ranges are geographically distributed, may have never met each other, and do not report to a common authority. Nevertheless, the software systems created by these developers must somehow interoperate to exchange their data in real-time.	interoperability;real-time clock;real-time data;real-time transcription;software system	J. Russell Noseworthy	2011	2011 - MILCOM 2011 Military Communications Conference	10.1109/MILCOM.2011.6127537	real-time computing;computer science;software engineering;database	Embedded	-33.889780405400344	40.9447421160039	114628
ec1771e1e7f240a0ffdbd669e5d63dd6c6302d1f	architectural constraints in the model-driven development of self-adaptive applications	architectural constraints;component based software development self adaptive applications model driven development architectural constraints variability;art;model driven development approach self adaptive applications component based software development software system architecture adaptation decision;object oriented programming;runtime;model driven development;computer architecture;software architecture;computational modeling;adaptation model;model driven development approach;component framework;adaptive applications;unified modeling language;application software runtime unified modeling language art personal digital assistants batteries adaptation model middleware scalability smart phones;middleware;software architecture object oriented programming;component based software development;self adaptive applications;variability;software system architecture;connected component;adaptation decision	In component-based software development, a composition of connected components represents a software system's architecture. This component framework supports adaptation through application variability. The adaptation decision is made at runtime by resolving the variation points and computing the utility of all application variants. Following the application variability model, a huge number of application variants may arise, many of which are not feasible in reality. Architectural constraints may be applied to filter out such infeasible variants before checking their utilities. This article presents an approach to specify architectural constraints while following a model-driven development approach.	component-based software engineering;connected component (graph theory);heart rate variability;model-driven engineering;run time (program lifecycle phase);software development;software system;spatial variability	Mohammad Ullah Khan;Roland Reichle;Kurt Geihs	2008	IEEE Distributed Systems Online	10.1109/MDSO.2008.19	unified modeling language;software architecture;real-time computing;simulation;connected component;architectural pattern;computer science;component-based software engineering;operating system;middleware;representational state transfer;programming language;object-oriented programming;computational model	SE	-40.964205472789295	40.2626687822044	114644
06c1d15e26c87df2a3fbbf61cacd299a2df632f7	flexible asynchronous simulation of iterated prisoner's dilemma based on actor model		Abstract The wide range of applications of the Iterated prisoner’s dilemma (IPD) game made it a popular subject of study for the research community. As a consequence, numerous experiments have been conducted by researchers along the last decades. However, topics related with scaling simulation leveraging existing HPC infrastructure in the field of IPD did not always play a relevant role in such experimental work. The main contribution of this paper is a new simulation framework, based on asynchronous communication and its implementation oriented to distributed environments. Such framework is based on the modern Akka actor platform, that supports concurrent, distributed and resilient message-driven simulations; which are exemplified over the IPD game as a case study. We also present several interesting results regarding the introduction of asynchrony into the IPD simulation in order to obtain an efficient framework, so the whole simulation becomes scalable when using HPC facilities. The influence of asynchrony on the algorithm itself is also discussed, and the results show that it does not hamper the simulation.	actor model;iteration;prisoner's dilemma;simulation	Grazyna Skiba;Mateusz Starzec;Aleksander Byrski;Katarzyna Rycerz;Marek Kisiel-Dorohinicki;Wojciech Turek;Daniel Krzywicki;Tom Lenaerts;Juan C. Burguillo	2018	Simulation Modelling Practice and Theory	10.1016/j.simpat.2017.12.010	asynchrony;real-time computing;computer science;iterated function;dilemma;scalability;prisoner's dilemma;actor model;distributed computing;asynchronous communication	Logic	-35.92318829863086	40.05932908905825	114683
4cd597d75c45e8c139393700058b0be976555d12	monitoring solution for autonomic middleware-level qos management within iot systems	reliability;software management middleware quality of service;monitoring component autonomic middleware level qos management iot systems internet of things paradigm quality of service issue functional architecture;quality of service monitoring reliability information filters;monitoring;quality of service;information filters;symptoms internet of things quality of service middleware autonomic computing monitoring component	Nowadays, the Internet of Things (IoT) paradigm is expanding immensely. It brings ubiquitous intelligence through the interconnection of equipment (sensors, devices, etc.) to the Internet, allowing the birth of a new era of applications in various fields. One of the main challenges to be considered in the IoT is the Quality of Service (QoS) issue. Aiming to support the vision of an autonomic Middleware-level QoS management for IoT systems, this paper proposes and validates a functional architecture of a monitoring component for the detection of QoS degradation. We also demonstrate the benefits that could be gained from simple QoS-oriented adaptation actions dynamically executed to overcome the detected degradations.	autonomic computing;elegant degradation;interconnection;internet of things;middleware;programming paradigm;quality of service;sensor	Yassine Banouar;Saad Reddad;Codé Diop;Christophe Chassot;Abdellah Zyane	2015	2015 IEEE/ACS 12th International Conference of Computer Systems and Applications (AICCSA)	10.1109/AICCSA.2015.7507202	real-time computing;mobile qos;quality of service;computer science;reliability;computer security;statistics;computer network	Robotics	-43.24247013120511	41.730461025973746	114766
f3d6d1f2412e39ccab9f8881a10d582eda68db1b	damasco: a framework for the automatic composition of component-based and service-oriented architectures	composition;service oriented architectures;monitoring;adaptation;ontology based discovery;component based framework	Although the reuse of software entities has matured in recent years, it has not become standard practice yet, since reusing componentbased or service-oriented architectures requires the selection, composition, adaptation and evolution of prefabricated software parts. Recent research approaches have tackled independently the discovery, composition, adaptation or monitoring processes. We present the DAMASCo architecture, a framework for composing pre-existing services and components. Using model transformation, context-awareness, semantic matchmaking, behavioural compatibility, dependency analysis, and fault tolerance, DAMASCo focuses on discovering, adapting and monitoring the composition of context-aware services and components in mobile and pervasive systems. DAMASCo is made up of a set of tools that implement the different processes, which have been evaluated on several examples.	component-based software engineering;context awareness;context-aware network;dependence analysis;entity;fault tolerance;model transformation;service-oriented architecture;service-oriented infrastructure;service-oriented software engineering;ubiquitous computing	Javier Cubo;Ernesto Pimentel	2011		10.1007/978-3-642-23798-0_41	composition;computer science;systems engineering;data mining;world wide web;adaptation	SE	-41.29084178680223	39.94861471938992	114942
10785982f74dbf9d196f352a8941427c552a55ca	issues and ongoing work on state-driven workload generation for distributed systems		The dependability of a complex distributed system needs to be assured against the several conditions, namely states, in which it can operate. Generating a workload able to cover a desired target state of a distributed system is still a di cult task, since the relationship between the workload and states is nontrivial due to system complexity and non-deterministic factors. This work discusses our ongoing work on a state-driven workload generation approach for distributed systems, based on an evolutionary algorithm, and its preliminary implementation for testing a fault-tolerant distributed system for flight data processing.	dependability;distributed computing;evolutionary algorithm;fault injection;fault tolerance;genetic algorithm	Roberto Natella;Fabio Scippacercola	2013		10.1007/978-3-642-38789-0_9	real-time computing;knowledge management;computer engineering	HPC	-43.987440709748164	37.271351840226764	115387
33b746b27676fe4238c80eb9882a89822b0b0046	flexfi: a flexible fault injection environment for microprocessor-based systems	tolerancia falta;software;microprocessor;architecture systeme;fault tolerant;logiciel;flexible fault injection system;fault tolerance;safety critical system;logicial;arquitectura sistema;fault coverage;microprocesseur;computer hardware;system architecture;fault injection;microprocesador;materiel informatique;material informatica;tolerance faute	Microprocessor-based systems are increasingly used to control safety-critical systems (e.g., air and railway traffic control, nuclear plant control, aircraft and car control). In this case, fault tolerance mechanisms are introduced at the hardware and software level. Debugging and verifying the correct design and implementation of these mechanisms ask for effective environments, and Fault Injection represents a viable solution for their implementation. In this paper we present a flexible environment suitable to compute the fault coverage provided by hardware and software mechanisms existing in most microprocessor-based systems. The environment, called FlexFI, is flexible, since it allows the adoption of different solutions for implementing the most critical modules, which differ in terms of cost, speed, and intrusiveness in the original system behavior.	fault injection;microprocessor	Alfredo Benso;Maurizio Rebaudengo;Matteo Sonza Reorda	1999		10.1007/3-540-48249-0_28	reliability engineering;embedded system;fault tolerance;real-time computing;computer science;engineering;operating system;distributed computing;computer security;software fault tolerance;systems architecture	HPC	-34.794653145048414	36.699046152318964	115447
5db6d79df75da6f580e990d7c8b9867e537c1304	on actors and the rest	web service;model of computation	The prevalence of RESTful services requires that we pay closer attention to how the principles that underlay REST are realized in actual services being implemented. This is especially crucial as REST is being applied to problem domains that require complex operations such as transactions. In this paper we investigate the relationship between RESTful web services and the actor model of computation. We suggest that by formulating RESTful services as a network of actors we can achieve deeper understanding what it means for a service to be RESTful.	actor model;blog;model of computation;problem domain;representational state transfer;web service	Janne Kuuskeri;Tuomas Turto	2010		10.1007/978-3-642-13911-6_10	model of computation;web service;simulation;computer science;world wide web;computer security	Web+IR	-36.23363137039549	41.06771344453733	115528
8dfea70a3e5169aa5a72c72d6e17d6cdee986afc	combining methods for the analysis of a fault-tolerant system	fault tolerant systems protocols electrical capacitance tomography aerospace industry system recovery performance analysis aerospace safety international space station performance evaluation read only memory;electrical capacitance tomography;protocols;byzantine agreement protocol;performance evaluation;byzantine agreement;formal methods;software fault tolerance;international space station;aerospace safety;aerospace industry;program verification;embedded system;byzantine agreement protocol fault tolerant system analysis formal verification embedded system formal methods daimlerchrysler aerospace international space station system correctness deadlock livelock protocol csp specifications model checking;formal method;csp specifications;embedded systems;large scale;fault tolerant system analysis;communicating sequential processes;fault tolerant system;formal verification;system recovery;model checking;aerospace computing;fault tolerant systems;systems analysis;performance analysis;protocol implementation;deadlock;daimlerchrysler aerospace;livelock;system correctness;read only memory;communicating sequential processes software fault tolerance embedded systems systems analysis program verification aerospace computing;protocol	This paper presents experiences gained from the verification of a large-scale real-world embedded system by means of formal methods. This industrial verification project was performed for a fault-tolerant system designed and implemented by DaimlerChrysler Aerospace for the International Space Station ISS. The verification involved various aspects of system correctness, like deadlock and livelock analysis, correct protocol implementation, etc. The approach is based onCSP specifications and uses the model-checking tool FDR. It is realized by combining methods for the development as well as for the analysis. It is illustrated by examples and results obtained during the verification of the Byzantine agreement protocol implementation, where the combination of different abstraction methods is required.	abstract interpretation;byzantine fault tolerance;correctness (computer science);deadlock;embedded system;formal methods;formal verification;hol (proof assistant);heuristic (computer science);isabelle;java;model checking;multithreading (computer architecture);object language;programming language;qnx;real-time clock;real-time operating system;refinement (computing);relevance;thread (computing)	Hui Shi;Jan Peleska;Michel Kouvaras	1999		10.1109/PRDC.1999.816222	reliability engineering;real-time computing;verification;formal methods;computer science;deadlock;distributed computing;high-level verification;runtime verification;programming language;functional verification	Logic	-37.14423801777857	33.44145957552624	115718
2581ececaad521c1ad818a10dc813b34f1ad2c6c	keynote at sies: heterogeneous processors in soc simplifies integration of iec61508 and iso26262 functional safety designs. the zynq7000 experience	design automation;biographies;safety program processors biographies real time systems design automation medical diagnostic imaging software algorithms;system on chip cyber physical systems formal verification iec standards iso standards;heterogeneous processors embedded software verification cyber physical systems iso26262 functional safety design iec61508 functional safety design system on chip soc;safety;software algorithms;program processors;medical diagnostic imaging;real time systems	These keynotes discuss the following: Heterogeneous processors in SoC simplifies integration of IEC61508 and ISO26262 functional safety designs; What is happening to Cyber Physical Systems?; and Scalable (yet precise) Timing Verification of Embedded Software.	central processing unit;embedded software;embedded system;static timing analysis;system on a chip	Giulio Corradi	2016	2016 11th IEEE Symposium on Industrial Embedded Systems (SIES)	10.1109/SIES.2016.7509404	embedded system;real-time computing;electronic design automation;computer science;operating system;programming language	Embedded	-40.124952755268886	33.36984067552974	116315
5a52b8dc7a20d279ddebdbc083671bfce19ce6c2	a monte carlo framework to evaluate context based security policies in pervasive mobile environments	context information;security model;mobile computer;pervasive mobile environments;mobile environment;risk;monte carlo;security;security policy	A pervasive mobile computing environment is typically composed of multiple fixed and mobile entities that interact autonomously with each other with very little central control. Many of these interactions may occur between entities that have not interacted with each other previously. Conventional security models are inadequate for regulating access to data and services, especially when the identities of a dynamic and growing community of entities are not known in advance. In order to cope with this drawback, entities may rely on context data to make security and trust decisions. However, risk is introduced in this process due to the variability and uncertainty of context information. Moreover, by the time the decisions are made, the context data may have already changed and, in which case, the security decisions could become invalid. In this paper, we propose a Monte Carlo based framework to evaluate context based security policies. In this framework, context data is modeled and risk in security decisions is measured.	entity;interaction;mobile computing;monte carlo method;pervasive informatics;spatial variability	Carlos Sánchez;Le Gruenwald;Mauricio Sánchez	2007		10.1145/1254850.1254858	computer security model;cloud computing security;simulation;security through obscurity;security information and event management;computer science;security policy;information security;data mining;risk;mobile computing;computer security;monte carlo method	HCI	-44.05608383122571	43.937355851179234	116627
6b49491cc738078b87422626ea6a089cf0a3daf2	towards service description for mobile environments	wireless systems mobile devices service provisioning lightweight service description mobile environments business aspects contextual aspects nonfunctional aspects functional aspects service registries mobile service providers heterogeneous environment wired systems;web services mobile computing;mobile communication business mobile handsets context quality of service wireless communication;service publishing;wireless communication;service publishing mobile web services service description;business;service description;mobile communication;mobile handsets;quality of service;mobile web services;context	Mobile devices today are increasingly being looked upon as potential platforms for service provisioning rather than mere 'service consumers'. There is, however, much that needs to be done to realize this. A detailed, dynamic, and lightweight service description is an important requirement for the automatic and efficient discovery, selection, and subsequently provisioning of services over mobile devices. Traditional approaches for service provisioning are usually not directly adaptable to the mobile environments owing to the latter's dynamic and distinct nature. Hence, in this paper a lightweight and extensible approach for service description especially designed for mobile environments is proposed. The proposed approach incorporates detailed and rich descriptions covering functional, non-functional, contextual, and business aspects of services to be provisioned over mobile devices. The service descriptions have been partitioned along these lines and the various parts are distributed between service registries and the mobile service providers. This facilitates the service provider to maintain an up-to-date description without having to compromise on the overall consistency of the description. The proposed service description is good for a heterogeneous environment comprising both wired and wireless systems. A prototype of the proposed system has been implemented with the intent of validating the feasibility of the approach.	heterogeneous computing;mobile device;prototype;provisioning;seamless3d;service discovery;web services description language	Rohit Verma;Abhishek Srivastava	2015	2015 IEEE International Conference on Services Computing	10.1109/SCC.2015.28	service provider;service level requirement;mobile search;mobile qos;mobile web;differentiated service;computer science;service delivery framework;mobile technology;location-based service;service design;mobile business development;mobile computing;world wide web;computer security;computer network;mobile payment;trusted service manager	Mobile	-40.27519163202389	46.098838801677786	116683
42170f2903cffe57d2c61ce1a13cd7c2f52e06c0	towards a component infrastructure for cyber-physical systems	component based development;cyber physical systems	The proximity between physical and cyber worlds is permitting the appearance of Cyber-Physical Systems (CPS), formed by users and devices (physical) interacting with services, components and applications (cyber). In CPS, where unpredictability is an important challenge, two characteristics must be present in the developed systems: i) low coupling among interacting modules and ii) self-adaptive capabilities. In that direction, this paper describes an uncoupled sensor and actuator component-based infrastructure for self adaptive CPS. Its main contribution is two-fold: i) a lightweight and interoperable mechanism to specify and manage sensors and actuators, built on top of an ii) uncoupled communication and coordination mechanism for cyber-physical entities.	as-interface;component-based software engineering;cyber-physical system;entity;interaction;interoperability	Marcio E. F. Maia;Rossana M. de Castro Andrade;Windson Viana	2016		10.1145/2851613.2851934	real-time computing;simulation;computer science;component-based software engineering;distributed computing;programming language;cyber-physical system	Robotics	-39.88082464970695	42.16757027816895	116714
d4886649144e1fe8342ded4d4d0c82b2aaf639c9	exploring interfaces in a distributed component-based programming framework for robotics		CoolBOT is a C++ distributed component-based programming framework for robotics. A system can be seen as a distributed network of software components interconnected by port connections where system behavior emerges from the interaction and independent execution of the components integrating the system. Recently we have endowed CoolBOT with two new types of software components: views and probes. On one side, in order to separate and decouple robot control from graphical displays, we have introduced the concept of view as an integrable, composite and reusable graphical interface available for CoolBOT system integrators and developers. On the other side, probes have been devised as interfaces for interoperability with non CoolBOT software.	c++;component-based software engineering;emergence;graphical user interface;infographic;interoperability;robot control;robotics	Antonio Carlos Domínguez-Brito;F. J. Santana-Jorge;Jorge Cabrera-Gámez;José Daniel Hernández Sosa;Jorge Isern González;Enrique Fernández-Perdomo	2012			simulation;human–computer interaction;functional reactive programming	Robotics	-36.21408598609121	40.18357653227183	116796
1d1bb06523bb009181f8484630845ddce7f66956	agent negotiation protocols in time-bounded service composition	service composition;service provider;negotiation protocol	Time is an important non-functional parameter to consider in service compositions, especially in environments where a service must be provided before a deadline. In this paper service composition takes service execution time into account and, to provide the composition with more reliability, considers the workload and availability of service providers. Furthermore, negotiation protocols are used to add flexibility between clients and providers that participate in the service composition. Negotiation protocols increase the chances of reaching an agreement by allowing both, providers and clients, to exchange their proposals in order to adjust the negotiation terms related to service execution time.	service composability principle	Martí Navarro;Elena del Val Noguera;Miguel Rebollo;Vicente Julián	2009		10.1007/978-3-642-04394-9_64	service provider;service level requirement;service level objective;mobile qos;differentiated service;computer science;knowledge management;service delivery framework;service guarantee;service discovery;computer security	NLP	-47.61641638956924	43.096369085414004	116941
9178559f8579d9b260961cf8f492102ff0cb5195	a qos-aware fault tolerant middleware for dependable service composition	distributed system;service composition;context aware;dependable service composition;fault tolerant;perforation;qos aware fault tolerant middleware;soa;web service;context aware algorithm;data mining;fault tolerant computing;web services fault tolerant computing middleware quality of service ubiquitous computing;fault tolerant systems;user collaborated qos model;fault tolerance;web services;context aware algorithm qos aware fault tolerant middleware dependable service composition service oriented architecture soa complex distributed system web service user collaborated qos model;ubiquitous computing;middleware;fault tolerance middleware web services service oriented architecture fault tolerant systems context modeling context aware services buildings computer science web and internet services;quality of service;service oriented architecture;complex distributed system	Based on the framework of service-oriented architecture (SOA), complex distributed systems can be dynamically and automatically composed by integrating distributed Web services provided by different organizations, making dependability of the distributed SOA systems a big challenge. In this paper, we propose a QoS-aware fault tolerant middleware to attack this critical problem. Our middleware includes a user-collaborated QoS model, various fault tolerance strategies, and a context-aware algorithm in determining optimal fault tolerance strategy for both stateless and stateful Web services. The benefits of the proposed middleware are demonstrated by experiments, and the performance of the optimal fault tolerance strategy selection algorithm is investigated extensively. As illustrated by the experimental results, fault tolerance for the distributed SOA systems can be efficient, effective and optimized by the proposed middleware.	dependability;distributed computing;experiment;fault tolerance;middleware;quality of service;requirement;scalability;selection algorithm;service composability principle;service-oriented architecture;service-oriented device architecture;state (computer science);stateless protocol;user requirements document;web service	Zibin Zheng;Michael R. Lyu	2009	2009 IEEE/IFIP International Conference on Dependable Systems & Networks	10.1109/DSN.2009.5270332	web service;middleware;fault tolerance;real-time computing;computer science;service-oriented architecture;middleware;distributed computing;ubiquitous computing;computer network	Robotics	-43.24730502453202	41.714579661692376	117053
a07056e3d4b5b3c3ab6f29e8f851d3d53ea3e2c3	aspect-oriented systemc-based performance evaluation of real-time embedded software		This paper presents the methodology for performance analysis of real-time embedded systems specified on system level. We developed aspect-oriented extensions to the SystemC environment, that enable to include profiling code, as well as code modeling execution time, into the system specification. First, the specification woven with profile aspects is simulated in target environment and information about execution times is saved in a file. Next, the same specification is woven with simulation aspects, that use the information gained in previous step to simulate execution times. In this way accurate timed model of the system is obtained automatically.	aspect-oriented software development;embedded software;embedded system;model checking;performance evaluation;real-time clock;run time (program lifecycle phase);simulation;systemc	Stanislaw Deniziak;Konrad Kurczyna	2012		10.3182/20120523-3-CZ-3015.00015	embedded system;computer architecture;real-time computing;computer science	Embedded	-40.93077805121861	33.26308781692928	117274
aee44d2acf3200f1fe6a0ff5d5e80b65b155ffaa	matching customer requests to service offerings in real-time	service selection;real time;soa;conference paper;internet of things;non functional properties;low latency;mediation;complex event processing;service oriented architecture;data structure;nonfunctional properties;property value	Classic request-response Service-oriented architecture (SOA) has reached a level of maturity where SOA inspired extensions are enabling new and creative domains like the Internet of Things, real-time business or real-time Web. These new domains impose new requirements on SOA, such as a huge data volume, mediation between various data structures and a large number of sources that need to be procured, processed and provided with almost zero latency. Service selection is one of the areas where decisions have to be made based on consumer requests and service offerings. Processing this data requires typical SOA behavior combined with more elaborate approaches to process large amounts of data with near-zero latency. The approach presented in this paper combines pub-sub approaches for processing service offerings and mediations with classical request-response SOA approaches for consumer requests facilitated by Complex Event Processing (CEP). This paper presents a novel approach for subscribing to dynamic service properties and receiving up-to-date information in real-time. Therefore, we are able to select services with near-zero latency since there is no need to pull for property values anymore. The paper shows how to map requests to streaming data, how to process and answer complex requests with low latency and how to enable real-time service selection.	capability maturity model;complex event processing;data structure;internet of things;real-time clock;real-time computing;real-time transcription;real-time web;request–response;requirement;service-oriented architecture;service-oriented device architecture;streaming media	Marcel Tilly;Stephan Reiff-Marganiec	2011		10.1145/1982185.1982285	real-time computing;data structure;computer science;operating system;software engineering;service-oriented architecture;database;world wide web;computer security	Networks	-44.925285246652884	44.722902321588535	117404
4054a3efea299d969fcaa32b64c4ecef70ca171b	tool support for parametric analysis of large software simulation systems	simulink;control simulation;program diagnostics;autobayes;supervised learning;tool support;uml;complex parameterized software systems;bayes methods;software systems;automatic generation;computer programs;statistical properties;unified modeling language object oriented modeling analytical models data models atmospheric modeling nasa software;data analysis;navigation;systems analysis;small satellite;large software simulation systems;monte carlo method;computerized simulation;stateflow;parameter space;satellite system;graphic user interface;complex systems;satellite system tool support parametric analysis large software simulation systems complex parameterized software systems systems simulation advanced monte carlo generation n factor combinatorial parameter variations uml simulink stateflow unsupervised bayesian clustering techniques autobayes;parametric analysis;software tools;systems simulation;guidance motion;monte carlo;n factor combinatorial parameter variations;guidance navigation and control;system simulation;advanced monte carlo generation;monte carlo methods;simulation environment;unsupervised bayesian clustering techniques;critical parameter;digital simulation;combinatorial analysis;software tools bayes methods digital simulation monte carlo methods program diagnostics	The analysis of large and complex parameterized software systems, e.g., systems simulation in aerospace, is very complicated and time-consuming due to the large parameter space, and the complex, highly coupled nonlinear nature of the different system components. Thus, such systems are generally validated only in regions local to anticipated operating points rather than through characterization of the entire feasible operational envelope of the system. We have addressed the factors deterring such an analysis with a tool to support envelope assessment: we utilize a combination of advanced Monte Carlo generation with n-factor combinatorial parameter variations to limit the number of cases, but still explore important interactions in the parameter space in a systematic fashion. Additional test-cases, automatically generated from models (e.g., UML, Simulink, Stateflow) improve the coverage. The distributed test runs of the software system produce vast amounts of data, making manual analysis impossible. Our tool automatically analyzes the generated data through a combination of unsupervised Bayesian clustering techniques (AutoBayes) and supervised learning of critical parameter ranges using the treatment learner TAR3. The tool has been developed around the Trick simulation environment, which is widely used within NASA. We will present this tool with a GN&C (Guidance, Navigation and Control) simulation of a small satellite system.	bayesian network;cluster analysis;coupling (computer programming);guidance, navigation, and control;interaction;monte carlo method;nonlinear system;simulink;software system;stateflow;supervised learning;systems simulation;unified modeling language	Johann Schumann;Karen Gundy-Burlet;Corina S. Pasareanu;Tim Menzies;Tony Barrett	2008	2008 23rd IEEE/ACM International Conference on Automated Software Engineering	10.1109/ASE.2008.89	complex systems;simulation;computer science;theoretical computer science;machine learning;systems simulation;supervised learning;monte carlo method	SE	-48.11898738408031	35.44719081567999	117691
01d3f38c97073d323aaa60936a6bda9cb41ab57e	an approach for deploying and monitoring dynamic security policies	security policies;security framework;dynamic deployment;monitoring;aspect oriented programming	Security policies are enforced through the deployment of certain security functionalities within the applications. When the security policies dynamically change, the associated security functionalities currently deployed within the applications must be adapted at runtime in order to enforce the new security policies. INTER-TRUST is a framework for the speci cation, negotiation, deployment and dynamic adaptation of interoperable security policies, in the context of pervasive systems where devices are constantly exchanging critical information through the network. The dynamic adaptation of the security policies at runtime is addressed using Aspect-Oriented Programming (AOP) that allows enforcing security requirements by dynamically weaving security aspects into the applications. However, a mechanism to guarantee the correct adaptation of the functionality that enforces the changing security policies is needed. In this paper, we present an approach based on the combination of monitoring and detection techniques in order to maintain the correlation between the security policies and the associated functionality deployed using AOP, allowing the INTER-TRUST framework to automatically react when needed.		Jose Miguel Horcas;Mónica Pinto;Lidia Fuentes;Wissam Mallouli;Edgardo Montes de Oca	2016	Computers & Security	10.1016/j.cose.2015.11.007	software security assurance;computer security model;cloud computing security;real-time computing;security through obscurity;aspect-oriented programming;security information and event management;security engineering;covert channel;asset;computer science;security policy;information security standards;security service;application security;internet privacy;security testing;network security policy;computer security	Security	-45.22563766282199	43.16176327841989	117930
eb50aaa97fb0ee7cd519d027a38c1a8a71d9e306	model-based software in-the-loop-test of autonomous systems	uav;in the loop;environment models;simulation based testing	Software for autonomous systems is hard to test, given their complex reactions as well as safety-critical behavior. Here simulation-based testing of the control software using a simulation of the environment and the platform of the system supports verification without threat to system and environment. A model-based construction of the simulated environment enables an effective verification by systematically assessing reliability issues and robustness aspects while improving its efficiency by simplifying the reuse of virtual environment. We demonstrate such a systematic approach for the verification of the control software of an autonomous unmanned arial vehicle, using Simulink as simulation environment.	autonomous robot;autonomous system (internet);clock rate;debugging;fault tolerance;matlab;oracle (software testing);program animation;scripting language;simulation;simulink;system testing;system under test;test automation;test case;unmanned aerial vehicle;virtual reality	Andreas Bayha;Franziska Grüneis;Bernhard Schätz	2012			embedded system;verification and validation;verification and validation of computer simulation models;simulation;software verification;systems engineering;engineering;software construction;software testing	SE	-46.60776319568554	34.89202931006333	118052
86f53c3992785ceacfe6c227a9ce4dd949a79c87	special issue on object-oriented real-time systems: guest editor's introduction	object oriented;real time systems	and no contributions are devoted to the specification, verification, and implementation of other nonfunctional constraints such as reliability and security. Each paper is synopsized in the remainder of the Introduction. The paper by Shangping Ren, Gul Agha, and Masahiko Saito, entitled ‘‘A Modular Approach to Programming Distributed Real-Time Systems,’’ presents a novel approach to the specification of timing constraints, called RTsynchronizer. This high-level construct extends an actor language by defining a collection of temporal constraints on a group of actors. This approach distinguishes clearly between objects that define the functional behaviour (actors) and objects that enforce timing constraints (RTsynchronizers). It supports the independent reuse of application code (how something is done) and of groups of timing constraints (when something is done). Since RTsynchronizers, like actors, can be dynamically created, they support incremental modification of temporal coordination constraints. Because timing constraints are only expressed in terms of actor interfaces and not intermixed with the application code, programs with RTsynchronizers are also easier to analyze. The syntax and the informal semantics of RTsynchronizers are given. The language supports the specification of time constraints, the specification of patterns to abstract over similar messages, and the specification of exception constraints in case the original constraints fail. The paper also explains the approach by a number of examples and describes a metaarchitecture for the implementation of RTsynchronizers. The paper ‘‘Incorporating Temporal Considerations during Assignment and Pre-run-time Scheduling of Objects and Processes,’’ by Jack Verhoosel et al., describes the implementation of hard real-time constraints by static object-assignment and scheduling. The unit of scheduling is the ‘‘bead,’’ a sequence of statements bounded by method invocations. Preemptions can only take place at predefined bead boundaries. The innovative scheduling algorithm is driven by properties such as interobject parallelism, interprocess communication, processor utilization, and feasibility constraints. It balances maximum parallelism against JOURNAL OF PARALLEL AND DISTRIBUTED COMPUTING 36, 1–3 (1996) ARTICLE NO. 0085	actor model;algorithm;distributed computing;exception handling;high- and low-level;inter-process communication;itakura–saito distance;parallel computing;preemption (computing);real-time cmix;real-time computing;real-time operating system;real-time transcription;scheduling (computing)	Dieter K. Hammer;Lonnie R. Welch	1996	J. Parallel Distrib. Comput.	10.1006/jpdc.1996.0085	computer science;programming language;object-oriented programming	PL	-34.258099697910836	33.87661880965311	118697
ce48e9a1971d40b79dfbaf319cec969fe961c7e4	integration of legacy sub-system components into an object-oriented simulation model of a complete pastoral dairy farm	dairy farm;dynamic link library;dll;multiple instance;software integration;programming language;object oriented simulation;legacy components;ipc;com;object oriented;component object model;smalltalk;model development;component model;source code;fortran;simulation model;computer simulation;growth model;component software;inter process communication	An object-oriented (OO) approach to developing a computer simulation of a complete pastoral dairy farm system is outlined. Since component models already existed which encapsulated the functionality of the high level objects in the overall system it was a primary design goal to be able to incorporate them into the OO framework. These components had been developed in procedural programming languages and techniques were investigated to incorporate them with little or no re-coding, and which allow them to be used in an ‘object-like’ way. The techniques involved recompilation of legacy source-code as dynamic link libraries (DLL's), and accessing stand-alone executable programs through inter-process communication (IPC) protocols. A cow metabolism model developed in the proprietary ACSL environment, and a pasture growth model for which FORTRAN source code was available were incorporated into the Smalltalk OO framework using the Microsoft Component Object Model (COM) techniques. Multiple instances of each component (each representing a distinct real farm entity) were required by the OO framework and the COM methodology was able to support this. The integration of these components into the host OO framework involved using proxy objects to provide translation to/from the COM messaging, thus providing the OO framework with consistent inter-object communication.	simulation	P. G. Neil;R. A. Sherlock;K. P. Bright	1999	Environmental Modelling and Software	10.1016/S1364-8152(99)00013-4	computer simulation;real-time computing;computer science;component object model;database;programming language;inter-process communication	SE	-33.87170539334634	42.212224354094815	118707
09e2f1dcc308494f8c1c14e1ec5b5a4256cf6643	stitch: a language for architecture-based self-adaptation	utility;uncertainty;self adaptation;strategy;tactic;rainbow	Requirements for high availability in computing systems today demand that systems be self-adaptive to maintain expected qualities-of-service in the presence of system faults, variable environmental conditions, and changing user requirements. Autonomic computing tackles the challenge of automating tasks that humans would otherwise have to perform to achieve this goal. However, existing approaches to autonomic computing lack the ability to capture routine human repair tasks in a way that takes into account the business context that humans use in selecting an appropriate form of adaptation, while dealing with timing delays and uncertainties in outcome of repair actions. In this article, we present Stitch, a language for representing repair strategies within the context of an architecture-based self-adaptation framework. Stitch supports the explicit representation of repair decision trees together with the ability to express business objectives, allowing a self-adaptive system to select a strategy that has optimal utility in a given context, even in the presence of potential timing delays and outcome uncertainty.	adaptive system;autonomic computing;decision tree;high availability;image stitching;requirement;user requirements document	Shang-Wen Cheng;David Garlan	2012	Journal of Systems and Software	10.1016/j.jss.2012.02.060	real-time computing;simulation;uncertainty;strategy;engineering;utility;statistics	SE	-43.86973860472314	38.42538158132727	118719
116f37e332034ca225bbecb17779556dc732555a	hybridkernel: preemptive kernel with event-driven extension for resource constrained wireless sensor networks	embedded operating systems wireless sensor networks operating system kernels;kernel wireless sensor networks yarn operating systems timing programming profession real time systems accuracy energy consumption energy efficiency;embedded systems;embedded operating systems hybridkernel preemptive kernel event driven extension resource constrained wireless sensor networks dynamic communication protocols;operating system kernels;wireless sensor networks embedded systems operating system kernels;wireless sensor networks	A low-power wireless sensor network (WSN) implements dynamic communication protocols and embedded sensing applications on resource constrained platform. WSNs utilize dozens of tasks, which have differentiated realtime requirements. This requires an efficient implementation with the use of a real-time operating system optimized for WSNs. Current WSN operating systems are based either on preemptive or event-driven kernels. Preemption provides accurate timings but requires large data memory footprint. Event-driven kernels have small footprint but do not support time as accurately. This paper presents a new HybridKernel for WSNs which combines the advantages of both kernels. It meets five key requirements without any major drawbacks: it halves footprint of preemptive kernels, it provides 2 µs timing accuracy, it minimizes energy consumption, and it can be easily configured and used between preemptive and event-driven parts through a coherent system call interface.	coherence (physics);dynamic loading;embedded system;event-driven architecture;event-driven finite-state machine;event-driven programming;kernel (operating system);low-power broadcasting;memory footprint;microcontroller;overhead (computing);preemption (computing);programmer;read-only memory;real-time clock;real-time computing;real-time operating system;requirement;scalability;scheduling (computing);system call	Teemu Laukkarinen;Ville Kaseva;Jukka Suhonen;Timo Hämäläinen;Marko Hännikäinen	2009	2009 IEEE Workshop on Signal Processing Systems	10.1109/SIPS.2009.5336243	embedded system;embedded operating system;real-time computing;wireless sensor network;computer science;operating system;distributed computing;key distribution in wireless sensor networks	Embedded	-37.08330525276424	45.7369718900169	118870
ee5d6a17a0047923270d6a5636a3bab3e186793c	safety management method in complex system engineering	reliability;standards;event trees safety management method complex system engineering complex system development iterative process recursive process requirement management safety requirements nonfunctional requirements system architecture failure mode effects and criticality analysis fmeca fault trees;trees mathematics risk management safety systems engineering;systems engineering and theory;accidents;safety;complex system safety requirement requirement engineering;security;safety accidents reliability systems engineering and theory security fault trees standards;fault trees	The main objective of System Engineering is the successful development of complex system. It is based on the application of iterative and recursive processes on each phase or step of the system development. One critical process is the requirement management, particularly when it deals with the safety requirements. These one are non-functional requirements and are related to emergent properties, which come from the integration of the different system components. They must be identified as soon as possible, because they are guards to validate or not the system, which can require changes in system architecture. Moreover, they are formulated at system level and need to be derived at sub-system level. The objective of this paper is to propose a safety management method based on well-known safety methods, in order to organize the different tasks to make the system safe. The method focuses mainly on the definition of the system safety requirements following risk and hazard analysis, and also on their derivation according to a top-down approach. It is based on the well-known Failure Mode, Effects, and Criticality Analysis (FMECA) and the use of Fault Trees and Event Trees.	complex system;emergence;failure cause;failure mode, effects, and criticality analysis;fault tree analysis;functional requirement;hazard analysis;iterative method;non-functional requirement;recursion;requirements management;self-organized criticality;system safety;systems architecture;systems engineering;top-down and bottom-up design;traceability;whole earth 'lectronic link	Romaric Guillerm;Hamid Demmou	2014	2014 IEEE International Systems Conference Proceedings	10.1109/SysCon.2014.6819247	safety engineering;reliability engineering;fault tree analysis;systems engineering;engineering;requirement;transport engineering;functional safety;system safety;functional requirement;non-functional requirement;failure mode and effects analysis	SE	-45.944350163747586	33.83656871583618	118898
38a9f87cd711e05d8ef0cb23a59acc8be8c0bc18	an information flow architecture for global smart spaces	cluster computing;distributed parallel and cluster computing;programming model;report;information flow;smart spaces;cs dc;communication channels;qa76 computer software	for dissemination) In this paper we describe an architecture which: Permits the deployment and execution of components in appropriate geographical locations. Provides security mechanisms that prevent misuse of the architecture. Supports a programming model that is familiar to application programmers. Permits installed components to share data. Permits the deployed components to communicate via communication channels. Provides evolution mechanisms permitting the dynamic rearrangement of inter-connection topologies the components that they connect. Supports the specification and deployment of distributed component deployments.	information flow;programmer;programming model;software deployment;spaces	Alan Dearle;Graham N. C. Kirby;Andrew J. McCarthy;Juan Carlos Diaz y Carballo	2003	CoRR		embedded system;parallel computing;real-time computing;information flow;computer cluster;computer science;operating system;distributed computing;programming paradigm;statistics;channel	SE	-36.01237358367839	44.540362375496144	119106
920ce865677783de6ab01af7dc7519a0f2595ea7	research on automation integration technology of application systems based on web services	portals;standards;authentication;system integration;business;web services;automation	In the development of practical application projects, there are frequently some duplicated application modules, which may be running on different development platforms, or may be independently autonomous systems. If those application modules could be integrated into different platforms, the efficiency to utilize them would be highly improved. In this paper, the integration technology of unified architecture of application system, the OLE(Object Linking and Embedding) automation and the interaction process of web applications based on Web Services are studied firstly. Then an unified architecture of application integration and an automation integration technology of application systems based on Web Services are proposed. Finally this technology is applied to real projects to make system integration crossing different applications. The practice result shows that different application software and systems targeted at distinct platforms can effectively integrated and created by different plans into a seamless, parallel and easily accessible system. It provides a new way for software integration services and will be highly beneficial to application system integration based on Web Services.	authentication;automation;autonomous system (internet);download;object linking and embedding;replay attack;seamless3d;system integration;unified framework;upload;web application;web service;world wide web	Aiping Xu;Guangming Ling;Wuping Xu;Xu Zhang	2016	2016 12th International Conference on Natural Computation, Fuzzy Systems and Knowledge Discovery (ICNC-FSKD)	10.1109/FSKD.2016.7603524	web service;web application security;middleware;web modeling;enterprise application integration;computer science;automation;service-oriented architecture;authentication;services computing;world wide web;system integration	Robotics	-44.98150789665705	43.67390634485029	119145
3383997ba3c9428aa8624699de98bb75e217c594	cracking the monolith: challenges in data transitioning to cloud native architectures		Application modernization is the process of transforming a monolithic application to cloud native. This involves gradually building a new application consisting of microservices, and running it in conjunction with the monolithic application. Over a period of time, the functionality of the monolith shrinks drastically or transforms into yet another microservice. Solution architects are often faced with the task of ensuring this smooth transition - from monolith to cloud native. For large and complex monoliths, this task is non-trivial as the code base grows non-linearly over a period of time, thus posing multiple challenges.  The complexity of a monolith is moved to the interconnections between microservices, leading to multiple points of failure. This also has implications on scalability and the need for replication. One of the biggest challenges is to maintain data consistency and statefulness across the services and enable a smooth transition of the data. Tracing performance issues also becomes complex as a single transaction can encompass multiple service calls, along with increased operational complexity due to increased demand of managing services.  In this paper, we envision an automated approach that will enable a smooth transition from the monolith to microservices, thus alleviating the complexities faced by a solution architect. Our system leverages the existing data schema along with details obtained using profiling tools (in production or development environment), to understand the data flow and access patterns and use this information to to propose functional modules (microservices).	dataflow;microservices;monolithic application;password cracking;reliability engineering;scalability;solution architect;state (computer science);yet another	Mayank Mishra;Shruti Kunde;Manoj K. Nambiar	2018		10.1145/3241403.3241440	real-time computing;architecture;data consistency;microservices;scalability;computer science;cloud computing;monolithic application;data flow diagram;software modernization	OS	-45.08797876685567	40.514130829768426	119307
40974dd4ac8eaf3f967238ac9536f7f2a68c1b0d	safenet: a methodology for integrating general-purpose unsafe devices in safe-robot rehabilitation systems	system engineering;iso 13489 1;network controlled system;functional safety;robot systems safety;robot assisted rehabilitation	"""Robot-assisted neurorehabilitation often involves networked systems of sensors (""""sensory rooms"""") and powerful devices in physical interaction with weak users. Safety is unquestionably a primary concern. Some lightweight robot platforms and devices designed on purpose include safety properties using redundant sensors or intrinsic safety design (e.g. compliance and backdrivability, limited exchange of energy). Nonetheless, the entire """"sensory room"""" shall be required to be fail-safe and safely monitored as a system at large. Yet, sensor capabilities and control algorithms used in functional therapies require, in general, frequent updates or re-configurations, making a safety-grade release of such devices hardly sustainable in cost-effectiveness and development time. As such, promising integrated platforms for human-in-the-loop therapies could not find clinical application and manufacturing support because of lacking in the maintenance of global fail-safe properties. Under the general context of cross-machinery safety standards, the paper presents a methodology called SafeNet for helping in extending the safety rate of Human Robot Interaction (HRI) systems using unsafe components, including sensors and controllers. SafeNet considers, in fact, the robotic system as a device at large and applies the principles of functional safety (as in ISO 13489-1) through a set of architectural procedures and implementation rules. The enabled capability of monitoring a network of unsafe devices through redundant computational nodes, allows the usage of any custom sensors and algorithms, usually planned and assembled at therapy planning-time rather than at platform design-time. A case study is presented with an actual implementation of the proposed methodology. A specific architectural solution is applied to an example of robot-assisted upper-limb rehabilitation with online motion tracking."""		Federico Vicentini;Nicola Pedrocchi;Matteo Malosio;Lorenzo Molinari Tosatti	2014	Computer methods and programs in biomedicine	10.1016/j.cmpb.2014.03.001	embedded system;simulation;functional safety	Mobile	-42.31876524713038	45.910379708441354	119831
f00046add0bdb55686c06c9d84661aa85d2fab92	genel amacli haberlesme arayuzu simulator yazilimi.		Generic Simulator was developed in order to provide a common framework for generating simulation software which are used to test communication interfaces used by the software units developed for various projects. This paper evaluates the design and usage of Generic Simulator Software which provides a framework that defines common message definition templates for various interfaces and protocols (TCP/UDP IP, ARINC 429, CAN Bus, Discrete line, RS 232/422, MIL-STD-1553B) and also enables the user to define and update the graphical user interface (GUI) dynamically. Anahtar Kelimeler: simülatör, protokol, yazılım test ve doğrulama	arinc 429;can bus;graphical user interface;mil-std-1553;simulation software	Mustafa Gevher;Metin Tekkalmaz;Hakan Yamanyar;Omer Bilgin	2016			simulation;computer science	SE	-36.16055941450753	34.59881846354324	119927
9924ece30d7f91117b96ebe793ee94afaebf3e94	comparative analysis of embedded computer system requirements methods	method improvement;comparative analysis;embedded computer systems;design engineering;method formalization;software systems;requirements methods;formal verification real time systems systems analysis;communication system software;analysis capability;physics computing;reuse;embedded system;systems engineering and theory;model construction;formal verification;mathematical foundation;robust semantics;systems analysis;mathematical model;modification comparative analysis requirements methods embedded computer systems method formalization method synthesis method improvement robust semantics mathematical foundation analysis capability verification capability model construction comprehension reuse;verification capability;robustness;cross section;method synthesis;comprehension;embedded computing;embedded computing systems engineering and theory embedded system hardware mathematical model software systems design engineering communication system software robustness physics computing;modification;hardware;real time systems	Requirements methods proven practical on large embedded computer systems (ECS) are formalized, synthesized, and improved. A cross-section of methods are evaluated for robust semantics, mathematical foundation, capability for analysis and verification, and support for model construction, comprehension, reuse and modification. >	computer;embedded system;requirement;system requirements	Stephanie M. White	1994		10.1109/ICRE.1994.292394	qualitative comparative analysis;systems analysis;comprehension;formal verification;computer science;systems engineering;software engineering;mathematical model;reuse;cross section;programming language;robustness;software system;computer engineering	EDA	-47.16765896037323	32.748908217403645	119945
c79a6d7cd10695e2f43a7ffd755265f8655565a8	application specific component-service-aware trace generation on android-qemu		Programmers depend on virtual platforms, such as Android-QEMU, to build and test their applications as well as system software for the ease of development efforts. It is easy to add tracing modules to the virtual platforms to dump the execution trace of the guest system, which can then be used to estimate and evaluate the performance of alternative system designs. However, tracing in virtual platforms are performed at the architecture level, which makes it difficult to generate traces for specific applications due to the lack of high-level software information. This problem becomes even more challenging for Android systems, which use component-based design strategies, where applications request services from other components. In this paper, we propose a novel Android-QEMU tracing system, which follows the invocations among the service components, generates component-service-aware traces only for specific applications. The evaluation results show that the proposed system improves 152% in simulation time and saves 33% of storage space in average compared to the static QEMU-Tracer.	android;component-based software engineering;file binder;high- and low-level;linux;loadable kernel module;run time (program lifecycle phase);simulation;tracing (software);virtual machine	Hao-Lun Wei;Chung-Ta King;Bhaskar Das;Mei-Chiao Peng;Chen-Chieh Wang;Hsun-Lun Huang;Juin-Ming Lu	2017	2017 30th IEEE International System-on-Chip Conference (SOCC)	10.1109/SOCC.2017.8226069	humanoid robot;android (operating system);architecture;software;tracing;real-time computing;computer science;system software	SE	-33.95455462061221	40.05066317489111	119971
4b9b510de9f0c380cb16ad84f3457a06becef47e	context aware applications in mobile distributed systems			distributed computing	Christof Simons	2008				HCI	-38.88631690189469	45.67330197621177	120306
7eb90f48a26cec8c5241c98e5d937c52db02d1dd	a reconfigurable concurrent function block model and its implementation in real-time java	holonic manufacturing systems;intelligent control;function block;control system;real time java;dynamic adaptation	This paper focuses on the important holonic manufacturing systems issue of automatic and dynamic adaptability to change at the physical machine level of control. We propose a model to support configuration and reconfiguration of real-time distributed control systems that is built upon recent models for distributed intelligent control and provide an example of its implementation on a real-time Java platform.	configuration management;distributed control system;distributed operating system;holon (philosophy);intelligent agent;intelligent control;multi-agent system;prototype;real time java;real-time clock;real-time transcription;reconfigurability	Robert W. Brennan;Xiaokun Zhang;Yuefei Xu;Douglas H. Norrie	2002	Integrated Computer-Aided Engineering	10.3233/ica-2002-9306	embedded system;real-time computing;computer science;control system;artificial intelligence;real time java;intelligent control	Embedded	-34.63093074898081	37.726039428094325	120512
3ca897bd86acecf8883279a68e00deb894789921	genertica: a tool for code generation and aspects weaving	optimized java platform;genertica;model driven design;uml modeling;uml diagram;object oriented methods;distributed real time embedded;distributed processing;embedded real time systems;code generation;distributed real time embedded systems code generation uml modeling aspect orientation;distributed embedded real time system;non functional requirement;aspects weaving;weaving unified modeling language object oriented modeling distributed computing java skeleton embedded system real time systems hardware software performance;aspect oriented paradigm;unified modeling language;unified modeling language genertica aspects weaving model driven design distributed embedded real time system aspect oriented paradigm non functional requirement source code generation uml diagram optimized java platform;aspect oriented;software tools;source code;source code generation;program compilers;unified modeling language distributed processing object oriented methods program compilers real time systems software tools;distributed real time embedded systems;aspect orientation;real time systems	Model-driven design (MDD) can be perceived in the recent literature as an option to deal with the increasing complexity of the design of distributed embedded real-time systems (DERTS). This paper reports some results of a research project aiming to support a MDD approach, which applies concepts of the aspect-oriented (AO) paradigm in order to improve the treatment of non-functional requirements (NFR) in the design of DERTS. A tool named GenERTiCA, which generates source code from UML diagrams and also weaves aspect adaptations, has been developed to support such MDD/AO approach. This paper presents results regarding the use of GenERTiCA to generate code and implement aspects (from a high-level framework of aspect) for the RT-FemtoJava platform, a RTSJ-based and optimized Java platform for DERTS.	ambient occlusion;aspect-oriented programming;aspect-oriented software development;automatic programming;code generation (compiler);compiler;diagram;dreams;embedded system;functional requirement;high- and low-level;metamodeling;model-driven engineering;model-driven integration;non-functional requirement;programming paradigm;real time java;real-time clock;real-time computing;scripting language;separation of concerns;unified modeling language;virtual tape library;windows rt;xml	Marco A. Wehrmeister;Edison Pignaton de Freitas;Carlos Eduardo Pereira;Franz-Josef Rammig	2008	2008 11th IEEE International Symposium on Object and Component-Oriented Real-Time Distributed Computing (ISORC)	10.1109/ISORC.2008.67	unified modeling language;computer architecture;real-time computing;computer science;operating system;programming language	Embedded	-40.943771112702954	35.1315082850526	120722
046f868ae6f94fd0577dfa21fb300ca1802da6e6	reds: a reconfigurable dispatching system	peer to peer network;dynamic reconfiguration;system design;publish subscribe;middleware;peer to peer computing;mobile and peer to peer computing;modular architecture;content based routing	We present a new publish-subscribe middleware called REDS (REconfigurable Dispatching System) designed to tolerate dynamic reconfigurations of the dispatching infrastructure, like those occurring in scenarios characterized by fluid topologies as in mobile and peer-to-peer networks. We illustrate the modular architecture of REDS, which enables programmers to change the internal configuration of the middleware to suit the deployment scenario, focusing on the aspects concerned with the dynamic reconfiguration of the dispatching network.	middleware;peer-to-peer;programmer;publish–subscribe pattern;software deployment	Gianpaolo Cugola;Gian Pietro Picco	2006		10.1145/1210525.1210530	embedded system;real-time computing;computer science;distributed computing	Mobile	-35.92572182266717	44.49452712979323	120819
87ffdc3661562f48880bfbeaa89a3d51827934de	object oriented topology tracing for large scale three phase distribution networks	topology;tracing design patterns distribution management system distribution network applications graph theory large scale object oriented power systems topology processing;demand side management;distribution networks;object oriented modeling unified modeling language dna topology concrete network topology load modeling;object oriented programming;topology demand side management distribution networks object oriented programming power engineering computing;power engineering computing;object oriented topology tracing topology processor distribution management system distribution network application dna visitor pattern object oriented modeling	The Topology Processor (TP) is the core of every Distribution Management System (DMS). It is used to prepare, update and to provide access to the network data. The paper presents an object oriented implementation of the Topology Processor (TP) for Distribution Network Applications (DNA). The implementation is based on the Visitor Pattern which is a well known paradigm in the object oriented modeling. The usage of the Visitor Pattern leads to a code which is efficient, easy to understand, to maintain and to extend. The paper contains some complex scenarios, such as cross phase jumpers and single phase switching. Performance results are also included and analyzed.	jumper (computing);management system;programming paradigm;visitor pattern	Izudin Dzafic;Sylwia Henselmeyer;Nenad Lecek;Thomas Schwietzke;Dino Ablakovic	2012	2012 3rd IEEE PES Innovative Smart Grid Technologies Europe (ISGT Europe)	10.1109/ISGTEurope.2012.6465851	real-time computing;computer science;theoretical computer science;distributed computing;logical topology	HPC	-37.3965385876875	37.72824556606674	121002
74ec9508d2d75ba216320c41afd6646135fc8bfc	autonomous configuration of spatially aware sensor services in service oriented wsns	emulation framework autonomous configuration spatially aware sensor service service oriented architecture soa wireless sensor network wsn input output interoperability spatio temporal constraint policy constraint security constraint intelligent configuration generic cost representation;telecommunication network reliability;wireless sensor networks fabrics graphical user interfaces monitoring cost function mathematical model government;telecommunication computing;telecommunication services;service oriented architecture;wireless sensor networks;wireless sensor networks service oriented architecture telecommunication computing telecommunication network reliability telecommunication services	Service-oriented Architectures (SOA) for Wireless Sensor Networks (WSNs) are an active research topic. Yet, autonomous configuration of services for real life constraints (spatio-temporal, input/output interoperability, policies, security etc.) is still a challenging problem. In this demonstration we describe the results of our research into the automated and intelligent configuration and composition of services for complex tasks. We present a service-oriented system capable of performing service configuration under spatial and relevancy constraints. It can configure services in one of the three following modes: distributed, centralized and hybrid. It also supports automatic reconfiguration in the event of service failures. This system uses a generic cost representation for services that may include spatial coverage of the services in an area of interest along with other service configuration cost metrics. We demonstrate our system using state-of-the-art emulation frameworks with a real life scenario.	autonomous robot;centralized computing;emulator;input/output;interoperability;real life;relevance;service-oriented architecture;service-oriented device architecture;service-oriented software engineering	S. Yousaf Shah;Boleslaw K. Szymanski;Petros Zerfos;Chatschik Bisdikian;Christopher Gibson;Dominic Harries	2013	2013 IEEE International Conference on Pervasive Computing and Communications Workshops (PERCOM Workshops)	10.1109/PerComW.2013.6529503	embedded system;real-time computing;wireless sensor network;computer science;telecommunications service;service-oriented architecture;distributed computing;key distribution in wireless sensor networks;computer network	Robotics	-39.52710157607843	43.98924866090589	121027
90c127b05c9625b69332f33940d54b343084add5	semiformal verification of software-controlled connections		The verification of both hardware and embedded software has become an important subject over the last years. However, neither standalone verification approaches like simulation-based or emulation nor state-of-the-art formal verification approaches are able to co-verify hardware/software modules in complex SoCs. This work proposes a semiformal approach to formally verify software-controlled connections in an attempt to start closing the hardware/software formal co-verification gap. Currently, this architectural aspect is partially verified using simulation. This approach presented interesting results compared to formal verification and simulation methods.	closing (morphology);embedded software;emulator;formal verification;prototype;real-time clock;real-time computing;simulation;software verification;static program analysis	Tomas Grimm;Djones Lettnin;Michael Hübner	2017	2017 IEEE Computer Society Annual Symposium on VLSI (ISVLSI)	10.1109/ISVLSI.2017.103	computer architecture;verification;intelligent verification;formal methods;formal verification;software verification;software verification and validation;high-level verification;functional verification;computer science	EDA	-37.127571882009114	33.25654176984565	121126
17bf07c8949fbb49e1cf88fd88f31b1d1b3963d2	expressing embedded systems verification aspects at higher abstraction level — systemverilog in object constraint language (svocl)	clocks;semantics;embedded systems;svocl mbse ocl systemverilog assertions;unified modeling language;systems modeling language;unified modeling language semantics embedded systems clocks delays systems modeling language;delays	In Model Based System Engineering (MBSE), structural and behavioral aspects of the system are modeled at higher abstraction level. However, verification aspects such as assertions based verification are generally treated at lower abstraction level, resulting in a reduced design productivity. This paper presents an approach to represent SystemVerilog assertions at higher abstraction level along with structural and behavioral aspects by proposing SVOCL (SystemVerilog in Object Constraint Language). The proposed OCL extension allows to represent verification aspects such that the minimum transformation efforts are required due to its close SystemVerilog semantics. Traffic light controller serves as a case study.	abstraction layer;embedded system;object constraint language;software engineering;systemverilog;systems design;universal verification methodology	Muhammad Rashid;Muhammad Waseem Anwar;Farooque Azam	2016	2016 Annual IEEE Systems Conference (SysCon)	10.1109/SYSCON.2016.7490561	real-time computing;computer science;theoretical computer science;programming language	Embedded	-40.72793500176015	32.78705897516105	121139
26f22a3bb65319cea863e727f4d47669de7cf41c	compositional reachability analysis of finite-state distributed systems with user-specified constraints	verification;distributed system;state machine;software architecture;abstraction mappings;finite state machines;cache coherence protocols;model checking;software development;state explosion;distributed systems;compositional analysis;finite state machine;reachability analysis	The software architecture of a distributed system can be described as a hierarchical composition of subsystems, with interacting processes as the leaves of the hierarchy. Process behaviour can be specified using finite-state machines. A global state machine describing the overall system behaviour can be constructed using compositional reachability analysis techniques. These techniques compose the global state machine of a system from its component processes in stages, based on the specified hierarchy, This staged composition may however exacerbate the state explosion problem. A promising way to alleviate this problem is to include, in the analysis of each subsystem, the behaviour constraints imposed by its environment. Behaviour constraints can be derived algorithmically but may be too weak to adequately constrain the compositional analysis. In this paper, we describe a technique which enables software developers to also specify behaviour constraints based on their application knowledge. These constraints can be combined with those derived algorithmically. As constraints specified by software developers may be incorrect, the technlqtre incorporates an effective mechanism to detect incorrect constraints and give an indication of how to correct them. Incorporation of the mechanism does not increase the complexity of analysis. The mechanism is supported by augmenting the state machine model with a special undefined state m The undefined state is used to capture automatically potential errors in the constraints specified by software developers. The mechanism can also be utilised to detect violation of design assumptions, A gas station system is used as a case study in our discussion, Permission to make digital/hard copies of all or part of this material without fee is granted provided that the copies are not made or distributed for profit or mmmeroial advantage, the ACM copyrighVserver notme, the title of the publication and ik date appear, and notice is given that copyright is by permission of the Association for Computing Machinery, Inc. (ACM). To copy ofherwisej to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. SIGSOFT ’95 Washington, D.C.. USA 01995 ACM 0-89791-71 8-2/9510010...$3.50	algorithm;distributed computing;finite-state machine;interaction;reachability;software architecture;software developer;undefined behavior	Shing-Chi Cheung;Jeff Kramer	1995		10.1145/222124.222149	model checking;software architecture;real-time computing;verification;computer science;theoretical computer science;software development;software engineering;distributed computing;finite-state machine;abstract state machines	SE	-35.28874975788586	33.71992179184092	121251
cff09d68d3064b03cbd6cd744ff2bf586bd0762f	real-time environment and vehicle dynamics simulations for space station freedom integrated test and verification environment	integration testing;real time;real time simulation;simula tion environments;reuse;real time test and verification;vehicle dynamics	"""To reduce the costs associated with developing real-time simulations needed for the Space Station Freedom (SSF) Integration, Test and Verification Environment (ITVE), the National Aeronautics and Space Administration (NASA) investigated the possibility of integrating existing simulations with the ITVE. The purpose of this paper is to present a five-step generic approach for """"retro-fitting"""" existing, NASA-owned simulations into the ITVE, as opposed to developing ITVE-specific simulations. The goals of the approach were (1) to minimize the modifications required to successfully integrate an existing simulation with the ITVE, and (2) to minimize the amount of knowledge and insight needed into the simulation to make the modifications. The five-step approach is generic in that it may be applied to any simulation that is being considered for integration with the ITVE. To test the approach, a NASA-MITRE team applied it to a subset of the Multiple Orbital Object Dynamics Simulation (MOODS) system. The results of ..."""	computer simulation;real-time transcription	Carolyn Jayne Guyse;Deborah Elaine Buscher;S. Richard Ellenberger	1994	Simulation	10.1177/003754979406200403	real-time computing;vehicle dynamics;simulation;integration testing;computer science;systems engineering;engineering;artificial intelligence;operating system;reuse	EDA	-43.771879521205726	32.348390890449586	121323
be2bd358c169ee4832f1b4860fad69dbad874bd4	architecting web services applications for improving availability	qa 76 software;computer programming	In this paper, we address the problem of improving the availability and correctness of Web Services. An architectural approach is proposed that incorporates fault-tolerant techniques, such as, self-checking, comparison, and dynamic reconfiguration. The first two techniques are associated with the detection and handling of faults at the component level, while the latter is associated with the system. To demonstrate its applicability, a distributed application was designed and implemented that addresses the problem of obtaining dependable stock quotes from the Web. The system was implemented using Web Services core technologies, and preliminary measurements confirmed the improved availability of the whole application.	web service	Rogério de Lemos	2004		10.1007/11556169_4	web service;reliability engineering;web modeling;real-time computing;computer science;database	HPC	-47.252954210706854	38.794204731537064	121513
ad9a500a891cbeffc767b7bfa9e3dac55ef6a0c5	quantitative analysis of dynamic safety-critical systems using temporal fault trees	computer science		fault tolerance;fault tree analysis	Ernest Edifor	2014			real-time computing;computer science;theoretical computer science;distributed computing	SE	-46.760949908871076	32.95860950102789	121543
f9846ba1820c9f6c57465b5661566beb3106e916	corba: a guide to common object request broker architecture	common object request broker architecture	The object management group the OMG object model the common object request broker architecture language bindings to IDL object services - commmon object services 1 object services - common object services 2 the object database management group - part 1 the object database management group standard IBM's system object model (SOM) Sun's Project DOE (distributed objects everywhere) DEC's object broker and the COM/OLE2 link HP's distributed smalltalk.		Ron Ben-Natan	1995			interoperable object reference;object linking and embedding;common data representation;general inter-orb protocol;method;computer science;object request broker;object;runtime callable wrapper;common object request broker architecture;database;distributed computing;distributed object;.net remoting;world wide web	Arch	-33.91094093526007	42.743138623468056	121723
61bb9d0891738f30540df5c2bb839298ae8dd2c2	automatic generation of observers from marte/ccsl	libraries;analytical models;high level languages;clocks;semantics;observers;unified modeling language embedded systems formal verification high level languages system on chip;embedded systems;formal verification;system on chip;synchronization;synchronization observers clocks unified modeling language semantics libraries analytical models;unified modeling language;state based semantics automatic generation observer nodes modeling and analysis of real time and embedded systems clock constraint specification language marte ccsl unified modeling language uml verification techniques system on chip design high level specification language	The UML (Unified Modeling Language) Profile for Modeling and Analysis of Real-Time and Embedded (MARTE) systems promises a general modeling framework to design and analyze embedded systems. Lots of works have been published on the modeling capabilities offered by MARTE, much less on verification techniques supported. The Clock Constraint Specification Language (CCSL) has been defined in an annex of MARTE precisely to address semantic issues on time and causal aspects in relation with MARTE models. In the context of System-on-Chip design, some early work was proposed to use CCSL as a high-level specification language from which an observation network could be built. That observation network was used to observe early prototype implementations of the system under design and verify its compliance with respect to the CCSL specification. The proposed approach consisted in manually building a library of observer nodes for each CCSL operator and defining a generic mechanism to compose these nodes. This paper introduces a technique to generate a complete observer directly from a CCSL specification without requiring the manual construction of a library. The technique relies on a new state-based semantics given to a selected subset of CCSL operators. The study focuses specifically on boundedness issues with some CCSL operators that were previously artificially bounded to allow for exhaustive analyses.	causal filter;embedded system;high- and low-level;modeling and analysis of real time and embedded systems;petri net;prototype;real-time transcription;specification language;unified modeling language	Frédéric Mallet	2012	2012 23rd IEEE International Symposium on Rapid System Prototyping (RSP)	10.1109/RSP.2012.6380695	system on a chip;unified modeling language;embedded system;synchronization;real-time computing;formal verification;computer science;theoretical computer science;operating system;semantics;programming language;high-level programming language	Embedded	-39.928748934154335	32.84037616274548	121970
631f1741c6df6012c38152f909bfd084e77a864d	formal specification of dsp gateway for data transmission between processor cores of omap platform	data transmission;formal specification;formal model;omap161x platform;communication model;embedded system;embedded systems;discrete event system;model checking;discrete event systems;timed automata;inter processor communication	In this article, formal models for the data transmission mechanism between ARM and DSP cores of OMAP platform 161x via DSP Gateway are presented. These models are represented as timed automata. The automata for the behavior of tasks running in the DSP when receiving requests of read or write operations from ARM are described. Data transmission between ARM and DSP is modelled according to the mechanism offered by tokliBIOS, the system kernel at DSP side. The formal model presented in this work helps developers to understand the communication mechanisms of DSP Gateway and facilitates its usage and future development.	arm architecture;automata theory;digital signal processor;formal specification;omap;timed automaton	Saulo Oliveira Dornellas Luiz;Genildo de Moura Vasconcelos;Leandro Dias da Silva	2008		10.1145/1363686.1364046	model checking;embedded system;parallel computing;real-time computing;models of communication;computer science;operating system;texas instruments davinci;formal specification;data transmission	Embedded	-34.65066987503983	33.42476082694522	122042
577329b11b65d616ae0ef73e8439e1d8e0ade313	enabling dynamic co-evolution of models and runtime applications	software;fractals;dynamic software adaptation;system modeling;synchronisation software engineering;runtime;software engineering;model validation;synchronisation;computer architecture;adaptation model;runtime system dynamic software adaptation consistency checking synchronization;synchronization;consistency checking;driver circuits;runtime system;adaptation model fractals runtime software computer architecture driver circuits programming;dynamic adaptation;programming	Dynamic software adaptation can cause the running system to be out-of-synchronous with its model, and, thus, make the system model obsolete for the use in consistency checking. In this paper, we propose a framework for ensuring the synchronization between the model and the runtime system during dynamic adaptation. I.e., this framework maintains the high-level model of the runtime system, which is essential for system validation. We are also plugging several model validation tools to the framework, for performing system validation during dynamic adaptation.	high- and low-level;runtime system	Prawee Sriplakich;Guillaume Waignier;Anne-Françoise Le Meur	2008	2008 32nd Annual IEEE International Computer Software and Applications Conference	10.1109/COMPSAC.2008.39	synchronization;computer architecture;real-time computing;computer science;distributed computing;runtime verification	SE	-39.222248469685965	38.45205822731552	122561
5623586ecaff487d47c17714961e9bb828d050e0	multi-robot software platform based on robotic device server player	software platform	This article describes a software platform that allows to control multiple robots of any type, through wireless connections and without needing to modify its code to control each particular robot. It is a platform with an architecture in three layers, that uses the robotics device server Player as intermediate layer. The most abstract layer of the architecture is composed by the applications of control elaborated in any language that has socket support. These applications use the interfaces that Player offers to the control of the devices, so that the access to it is transparent. A server application is the most specialized layer that runs on the robot, and it manages the sensors and actuators devices of the robot at Player’s requests. The platform presents two interesting aspects, the first is that allows to control any robot, without having to develop specific drivers in Player that allow to control their devices. That is to say, it is not necessary to modify the code of the platform to integrate a new robot, simply it is necessary to adapt a model of server application, which accedes to the devices, to the robot that is wanted to integrate. The second one, is the possibility of controlling multiples robots simultaneously through wireless connections (also it admits serial connections). Also, it allows to create valid control programs for any robot, without needing to know its operation and architecture. By these reasons, it constitutes a very valid enviroment to work with multi-robot distributed	as-interface;robot software;server (computing);terminal server	Alejandro Morales;Miguel A. Gutiérrez-Naranjo;Jose A. Vicente;Vidal Moreno;Belén Curto	2005			software distribution;embedded system;simulation;computer science;component-based software engineering;monolithic application;open platform;world wide web;software system	Robotics	-37.466628408813506	44.10841499180865	122714
ee0a28ddf912751d86d9ec86bb210dfe726f5d09	specification of real-time systems in real-time temporal interval logic	lighting control;qualitative aspects;time constrained broadcast bus protocol real time systems specification qualitative aspects real time temporal interval logic reasoning quantitative aspects packet network rerouting traffic light controller;packet network;real time systems specification;application software;real time;logic;real time systems logic safety lighting control broadcasting application software aerospace electronics access protocols propagation delay laboratories;real time temporal interval logic;traffic light controller;propagation delay;time constrained broadcast bus protocol;safety;aerospace electronics;formal logic;access protocols;real time systems formal logic;packet networks;broadcasting;reasoning;rerouting;real time systems;quantitative aspects	A real-time variant of temporal interval logic is proposed for the specification and reasoning of real-time systems. In the framework of the logic, it is possible to specify qualitative and quantitative aspects of temporal behaviors of systems. The formalism provides capabilities for quantitative specification of time behavior. The harmonization of temporal interval logic with real-time features leads to a very-high-level notation for the specification of real-time systems. Temporal interval logic, being event-based, also facilitates the specification of quantitative aspects of temporal behavior relative to the occurrence of events in a given context. The use of the formalism is shown for three examples of real-time system specification: a packet network with rerouting, a traffic-light controller, and a time-constrained broadcast bus protocol. >	interval temporal logic;real-time transcription	K. T. Narayana;A. A. Aaby	1988		10.1109/REAL.1988.51104	embedded system;linear temporal logic;real-time computing;interval temporal logic;computation tree logic;computer science;distributed computing;logic;language of temporal ordering specification;temporal logic of actions	Embedded	-37.7186685699922	32.511813180507744	122973
2f50dcaff43b0af055b56312ea8884f690ae8ba8	on the challenges of self-adaptation in systems of systems	feedback loops;software engineering;self adaptation;systems of systems;decentralized control;programvaruteknik	A system of systems (SoS) integrates independently useful systems into a larger system. Examples are integrated surveillance systems and networked smart homes. A SoS offers functions to users that cannot be provided by its individual parts, but emerge as a combination of these. However, providing these functions with a required level of quality is difficult due to inherent uncertainties, such as systems that attach and detach at will and faults that are difficult to predict. Self-adaptation is a well-studied approach that enables a system to reason about itself and adapt to achieve particular quality objectives in the face of uncertainties and change. However, the inherently decentralized nature of SoS raises fundamental challenges to self-adaptation. This paper presents three architectural styles to realize self-adaptation in SoS, discusses key challenges for each style, and outlines starting points that could help to tackle these challenges.	apple sos;self-replication;system of systems	Danny Weyns;Jesper Andersson	2013		10.1145/2489850.2489860	control engineering;simulation;systems engineering;engineering	SE	-43.4580078977094	38.43871185137463	123241
d6a7f2b72e8d4bc1ab26a932e9c9501072dfc822	bio-core: bio-inspired self-organising mechanisms core		This paper discusses the notion of “core bio-inspired services” low-level services providing basic bio-inspired mechanisms, such as evaporation, aggregation or spreading shared by higher-level services or applications. Design patterns descriptions of self-organising mechanisms, such as gossip, morphogenesis, or foraging, show that these higherlevel mechanisms are composed of basic bio-inspired mechanisms (e.g. digital pheromone is composed of spreading, aggregation and evaporation). In order to ease design and implementation of self-organising applications (or high-level services), by supporting reuse of code and algorithms, this paper proposes BIO-CORE, an execution model that provides these low-level services at the heart of any middleware or infrastructure supporting such applications, and provides them as “core” built-in services around which all other services are built.	algorithm;british informatics olympiad;canonical account;dataspaces;emergence;evaporation;exploit (computer security);high- and low-level;interaction;middleware;operating system;self-organization;simulation	Jose Luis Fernandez-Marquez;Giovanna Di Marzo Serugendo;Sara Montagna	2011		10.1007/978-3-642-32711-7_5	computer science;execution model;software design pattern;distributed computing;reuse;middleware	OS	-38.56265945208832	44.01511142149978	123357
3391d3456c5234b6d5a286fd62c9ef7efc0ab5d9	hazard prevention by forced time constraints	forced time constraints;fault tree;software fault tolerance;null;timing information hazard prevention forced time constraints fault tree analysis;software fault tolerance fault trees;hazards time factors timing fault trees control systems rail transportation roads sensor systems signal generators software engineering;hazard prevention;timing information;fault tree analysis;fault trees;time constraint	Minimal cut sets resulting from fault tree analysis (FTA) indicate basic events which, if occur together, can contribute to a hazard. For some applications we can extend event description with timing information and the hazard becomes enabled only if some particular timing relationships occur among the events of a given cut set. In this article we present how the timing information can be introduced to a fault tree and then exploited to identify additional timing requirements imposed on the controllable events of the system. Such requirements, if implemented, lead to the exclusion of some (otherwise feasible) scenarios of hazard occurrence	algorithm;cut (graph theory);fault tree analysis;hazard (computer architecture);requirement;risk management;systems design;user interface	Grzegorz Golaszewski;Janusz Górski	2006	2006 International Conference on Dependability of Computer Systems	10.1109/DEPCOS-RELCOMEX.2006.29	reliability engineering;real-time computing;fault coverage;engineering;stuck-at fault;fault model;computer security	EDA	-46.015593058103654	33.97970180835332	123436
9dcb531b80ba0ad755363211f26a577e3906e4c7	a model-driven approach for engineering trust and reputation into software services	trust;reputation;self adaptation;model driven engineering	The ever-increasing complex, dynamic and distributed nature of current systems demands model-driven techniques that allow working with abstractions and self-adaptive software in order to cope with unforeseeable changes. Models@run.time is a promising model-driven approach that supports the runtime adaptation of distributed, heterogeneous systems. Yet, frameworks that accommodate this paradigm have limited support to address security concerns, hindering their usage in real scenarios. We address this challenge by enhancing models@run.time with the notions of trust and reputation. Trust improves decision-making processes under risk and uncertainty and constitutes a distributed and flexible mechanism that does not entail heavyweight administration. This paper presents a trust and reputation framework that is integrated into a distributed component-model that implements the models@run.time paradigm, thus allowing the system to include trust in their reasoning process. The framework is illustrated in a chat application by implementing several state-of-the-art trust and reputation models. We show that the framework entails negligible computational overhead and that it requires a minimal amount of work for developers.	application programming interface;context (computing);entity;metamodeling;model-driven architecture;model-driven integration;overhead (computing);programming paradigm;regret (decision theory);reputation management;reputation system;smart tv;social messaging;software propagation;usability;vertex-transitive graph;xml	Francisco Moyano;M. Carmen Fernández Gago;Javier López	2016	J. Network and Computer Applications	10.1016/j.jnca.2016.04.018	model-driven architecture;reputation;computer science;knowledge management;trustworthy computing;computer security;computational trust	SE	-45.40094091182858	44.070924249453654	123790
7ac2ba90d964ec27101275b2276f016a1dd13e15	ortega: an efficient and flexible software fault tolerance architecture for real-time control systems	control real time fault tolerance embedded systems;control systems;on demand real time guard;job shop scheduling;real time;resource management;faulty tasks;software fault tolerance;ortega;software fault tolerance control systems real time systems software architecture;computer architecture;embedded systems;software architecture;fault tolerant systems;fault tolerance;software fault tolerance architecture;control;on demand real time guard ortega software fault tolerance architecture real time control systems faulty tasks;communication system control;real time control systems;hardware;real time systems;timing	Fault tolerance is an important aspect in real-time computing. In real-time control systems, tasks could be faulty due to various reasons. Faulty tasks may compromise the performance and safety of the whole system and even cause disastrous consequences. In this paper, we describe ORTEGA (On-demand Real-TimE GuArd), a new software fault tolerance architecture for real-time control systems. ORTEGA has high fault coverage and reliability. Compared with existing real-time fault tolerance architectures, such as Simplex, ORTEGA allows more efficient resource utilizations and enhances flexibility. These advantages are achieved through the on-demand detection and recovery of faulty tasks. ORTEGA is applicable to most industrial control applications where both efficient resource usage and high fault coverage are desired.	benchmark (computing);control system;fault coverage;inverted pendulum;real-time clock;real-time computing;real-time locating system;real-time operating system;real-time transcription;software fault tolerance;testbed	Xue Liu;Hui Ding;Kihwal Lee;Qixin Wang;Lui Sha	2008	2008 Euromicro Conference on Real-Time Systems	10.1109/ECRTS.2008.17	embedded system;job shop scheduling;software architecture;fault tolerance;real-time computing;fault coverage;computer science;control system;resource management;distributed computing;software fault tolerance;scientific control	Embedded	-34.37981246434594	37.58062533656565	123966
4e9929ebaf337d719327bfe4c1de64e8208f7d43	specification and design considerations for reliable embedded systems	error detection and correction;reliability engineering;decision diagrams;optimisation;reliability;design criteria;decision diagram;error tolerance;design flow;dna self assembly;tiling;system implementation;embedded system;checkpointing;embedded systems;control system;embedded system computer errors application software automotive engineering reliability engineering costs single event upset data structures computer science product safety;optimization criterion;reliability decision diagrams embedded systems optimisation;temporal errors;production cost;system implementation embedded systems permanent errors temporal errors safety critical applications automotive domain optimization criterion reliability engineering permanent transient error decision diagrams;permanent errors;safety critical applications;permanent transient error;automotive domain	The objective of this paper is to introduce a novel representation as a means to consider both permanent and temporal errors in order to increase the overall reliability of an embedded system. The deployment of embedded systems in safety critical applications, e.g. in the automotive domain, demands that the fundamental set of design criteria consisting of functionality, timeliness, and production costs be extended to consider of reliability as an optimization criterion. Thus reliability engineering becomes part of the overall design flow for embedded systems. The proposed approach is based on the introduction of Permanent/Transient error Decision Diagrams and on dedicated algorithms for the generation of system implementation sets which feature maximum reliability at minimal costs in terms of redundant resources. The proposed approach is demonstrated for a control system taken from the automotive domain.	algorithm;control system;embedded system;mathematical optimization;reliability engineering;software deployment	Adeel Israr;Sorin A. Huss	2008	2008 Design, Automation and Test in Europe	10.1145/1403375.1403643	reliability engineering;embedded system;electronic engineering;real-time computing;error detection and correction;influence diagram;computer science;systems engineering;control system;design flow;operating system;reliability;implementation	EDA	-42.60281880614879	34.89990887741603	124751
5238f7f85223ce9ca2aa93e4ec44f80112c57544	towards automatic migration of ros components from software to hardware	component based software engineering;robotics;fpga;model driven engineering;ros	The use of the ROS middleware is a growing trend in robotics in general, in particular in experimental branches of robotics such as modular robotics, fields robotics, and the vast area of cyber-physical systems (for example applied to welfare technology). Our main area of interest is in experimental robotics and cyber-physical systems. When building “robot controllers” for the aforementioned systems there are numerous suitable technological platforms. Given specific requirements we can choose an appropriate standardized approach, for example emphasizing flexibility and ease of development by using a generic middleware — such as ROS — or emphasizing real-time performance and direct hardware access by using approaches based on dedicated, embedded hardware. So far ROS and hard real-time embedded systems have however not been easily uniteable while retaining the same overall communication and processing methodology at all levels. In this paper we present an approach aimed at tackling the schism between high-level, flexible software and lowlevel, real-time software. The key idea of our approach is to enable software components written for a high-level publish-subscribe software architecture to be automatically migrated to a dedicated hardware architecture implemented using programmable logic. Our approach is based on the Unity framework, a unified software/hardware framework based on FPGAs for quickly interfacing high-level software to low-level robotics hardware. The vision of Unity is to enable non-expert users to build high-quality interface and control systems using FPGAs and to interface them to highlevel software frameworks, thereby providing a framework for speeding up and increasing innovation in experimental robotics. This paper presents the overall vision and the initial work on the implementation of an architecture supporting a generative approach, based on a declarative specification of how software components are mapped to a hardware architecture; the actual language design is left as future work.	assistive technology;component-based software engineering;control system;cyber-physical system;declarative programming;embedded system;field-programmable gate array;high- and low-level;middleware;programmable logic device;publish–subscribe pattern;real-time clock;real-time computing;real-time transcription;requirement;robot operating system;robotics;software architecture;unity	Anders Blaabjerg Lange;Ulrik Pagh Schultz;Anders Stengaard Sørensen	2014	CoRR		embedded system;model-driven architecture;real-time computing;reactive oxygen species;computer science;engineering;artificial intelligence;social software engineering;software framework;component-based software engineering;software development;software design description;software construction;hardware architecture;robotics;resource-oriented architecture;field-programmable gate array;software system;computer engineering	Robotics	-42.34229367427424	38.02574768970121	124788
50efdfd83576d7d4cf3d847ba3c9e481ef68513b	large-scale, situation-driven and quality-aware event marketplace: the concept, challenges and opportunities	distributed system;heterogeneous environment;large scale;background knowledge;web scale cep;complex event processing;distributed systems;use case;event marketplace	This poster presents a novel approach for large scale, context-driven and quality-aware distributed event processing. We present the conceptual architecture of the system and mapping in an ongoing use-case deployment. In particular we give examples of the usage of the platform in this use-case. Additionally, we present the challenges and opportunities of such an architecture, namely logic-based CEP, combined with historic events and background knowledge, elastic run-time configuration in the cloud for CEP as a Service, maintenance of QoS for events, a unified language for reasoning and querying current and historic events. The approach leads to an Event Marketplace, a platform for mediating between event providers and (complex) event consumers in very large and heterogeneous environments.	cloud computing;complex event processing;quality of service;software deployment;software testing controversies	Roland Stühmer;Nenad Stojanovic	2011		10.1145/2002259.2002332	use case;real-time computing;simulation;computer science;complex event processing;data mining;database;distributed computing	DB	-43.2765002763736	42.67470256885473	124905
d3106c8bfc3eaa80589c4ac8d4d1853e2ccd1752	tool integration and interoperability challenges of a system-level design flow: a case study	design flow;tool interoperability;universiteitsbibliotheek;multimedia systems;research and development;system level design;multiprocessor system on chip;tool integration	Daedalus is a system-level design flow for the design of multiprocessor system-on-chip (MP-SoC) based embedded multimedia systems. It offers a fully integrated tool-flow in which design exploration, system-level synthesis, application mapping, and system prototyping of MP-SoC architectures are highly automated. In this paper, we describe Daedalus from a software perspective, explaining its supporting software infrastructure and the way the various tools interoperate. Moreover, we discuss the lack of support for achieving tool interoperability that we have encountered during the development of Daedalus, and present several ideas of future research directions to address this issue. More specifically, we argue that a so-called Common Design Flow Infrastructure (CDFI) for system-level design flows is needed to improve and stimulate research and development in the area of system-level design methodology.	design flow (eda);electronic system-level design and verification;embedded system;interoperability;level design;mpsoc;multiprocessing;software deployment;software engineering;system on a chip	Andy D. Pimentel;Todor Stefanov;Hristo Nikolov;Mark Thompson;Simon Polstra;Ed F. Deprettere	2008		10.1007/978-3-540-70550-5_19	embedded system;simulation;computer science;design flow;database;electronic system-level design and verification	EDA	-40.686896376955154	35.018569206709735	124908
efd57f8604aa0f73952d5044f171e6e433279844	an iot analytics embodied agent model based on context-aware machine learning		Agent-based Internet of Things (IoT) applications have recently emerged as applications that can involve sensors, wireless devices, machines and software that can exchange data and be accessed remotely. Such applications have been proposed in several domains including health care, smart cities and agriculture. However, despite their increased adoption, deploying these applications in specific settings has been very challenging because of the complex static and dynamic variability of the physical devices such as sensors and actuators, the software application behavior and the environment in which the application is embedded. In this paper, we propose a modeling approach for IoT analytics based on learning embodied agents (i.e. situated agents). The approach involves: (i) a variability model of IoT embodied agents; (ii) feedback evaluative machine learning; and (iii) reconfiguration of a group of agents in accordance with environmental context. The proposed approach advances the state of the art in that it facilitates the development of Agent-based IoT applications by explicitly capturing their complex and dynamic variabilities and supporting their self-configuration based on an context-aware and machine learning-based approach. Keywords-Internet of Things; context-aware; embodied agent; machine learning; feature-model; human-in-the-loop; selfconfigurable system		Nathalia Moraes do Nascimento;Paulo S. C. Alencar;C Lucena;Donald D. Cowan	2018	CoRR		situated;artificial intelligence;feature model;machine learning;wireless;control reconfiguration;embodied agent;computer science;software;human-in-the-loop;analytics	AI	-42.35658218145568	45.83297047674513	125022
d23b0602dacae2d3575ebc985080788ea3a84d31	a systematic mapping study on real-time cloud services		Cloud computing is relatively a new technique to host and use the services and applications from the internet. Although it offers a multitude of advantages like scalability, low operating cost, accessibility and maintainability, etc., they are often not utilized to the fullest due to the lack of timeliness property associated with the cloud. Cloud services are mainly designed to maximize throughput and utilization of resources and hence incorporating predictable execution time properties in to the cloud is arduous. Nevertheless, cloud still remains a highly attractive platform for hosting real-time applications and services owing to features like elasticity, multi-tenancy, ability to survive hardware failures, virtualization support and abstraction layer support which provides flexibility and portability. In order for real-time safety-critical applications to exploit the potential of cloud computing, it is essential to ensure the predictable real-time behavior of cloud services. In this paper, we perform a systematic mapping study on real-time cloud services to identify the current research directions and potential research gaps. Our study focuses on analyzing the current architectures and software techniques that are available at present to incorporate real-time property of the cloud services. We also aim at investigating the current challenges involved in realizing a predictable real-time behavior of cloud services.		Jakob Danielsson;Nandinbaatar Tsog;Ashalatha Kunnappilly	2018	2018 IEEE/ACM International Conference on Utility and Cloud Computing Companion (UCC Companion)	10.1109/UCC-Companion.2018.00063	scalability;virtualization;the internet;maintainability;cloud computing;abstraction layer;software portability;exploit;computer science;distributed computing	Embedded	-45.59696526162419	40.0509730294102	125237
6aadbd7117d99134b32cbd97975df84cc0a4652d	a fault fuzzy-ontology for large scale fault-tolerant wireless sensor networks	internet of things;web ontology language;fuzzy logic;fault tolerance;wireless sensor networks	Fault tolerance is a key research area for many of applications such as those based on sensor network technologies. In a large scale wireless sensor network (WSN), it becomes important to find new methods for fault-tolerance that can meet new application requirements like Internet of things, urbane intelligence and observation systems. The challenge is beyond the limit of a single wireless sensor network and concerns multiple widely interconnected sub networks. The domain of fault grows considerably because of this new configuration. In this context, the paper proposes a fault fuzzy-ontology (FFO) for large scale WSNs to be used within a Web service architecture for diagnosis and testing. c © 2014 The Authors. Published by Elsevier B.V. Peer-review under responsibility of KES International.	failure domain;fault tolerance;internet of things;prototype;requirement;sensor;smart city;web service	Yazid Benazzouz;Oum-El-Kheir Aktouf;Ioannis Parissis	2014		10.1016/j.procs.2014.08.100	real-time computing;wireless wan;wireless sensor network;distributed computing;key distribution in wireless sensor networks;mobile wireless sensor network;computer network	Mobile	-44.50885632173155	46.165859357613144	125842
084a1820dfabfc585959d1f194bf21a023ddeb0e	architectural support for dynamic homecare service provisioning		Providing IT-based care support for elderly people at home (i.e., carereceivers) is proposed as a highly promising approach to address the aging population problem. With the emergence of homecare application service providers, a homecare system can be seen as a set of linked services. Configuring and composing existing homecare application services to create new homecare composite applications can reduce the application development cost. The idea even looks more promising if the service provisioning is dynamic, i.e., if applications can update their behaviours with respect to the contextual changes without or with minimum manpower. Dynamic service provisioning can play an important role to accept homecare systems in practical settings.#R##N# This thesis proposes a Dynamic Homecare Service Provisioning (DHSP) platform to address the homecare contextual changes in an effective and efficient manner. An dynamic service provisioning, a composite application can be reconfigured. This can happen automatically on-the-fly (called adaptive service composition), by endusers for example nurses (which we call tailorable service composition)#R##N# or by a programmer (which we call evolvable service composition). The proposed DHSP platform provides adaptive, tailorable and evolvable service provisioning in the homecare domain.#R##N# To support this, a hybrid service composition approach has been proposed, in which the core of the application logic, which is rather stable, is specified in terms of processes, while rules are employed to specify the conditions and constraints to adapt the application behaviour. The rules are then exposed as a decision service, which can be employed by the process to make adaptation decisions with respect to runtime circumstances.#R##N# As a proof of concept, we have developed a software prototype of our platform. The prototype was subsequently used in a real-world field test, which consists of two experiments, at a care institution in the Netherlands to validate the approach. The validation included both objective and subjective measurements. Being able to combine objective and subjective measurements, would be useful to know which level of effectiveness and efficiency is acceptable in the homecare domain. Moreover, we identified explanations of our observations that allowed us to understand which parts of our approach need further improvement.#R##N# During the field test, the DHSP platform was used daily with more than 400,000 transactions in total over four months among the infrastructure and application services. The goal of the field test was to study the usability of the DHSP platform to address the homecare contextual changes in terms of (a) eectiveness, (b) eciency, and (c) satisfaction, both subjectively and objectively.#R##N# In the first experiment of our field test, we found out that although the application services as actually delivered by the service providers met the users’ requirements, there were architectural mismatches across service providers due to unstated assumptions. Thus we introduced an Assumption-based Risk identification Method (ARM). The ARM method helped us identify several risks before using the DHSP platform in the second experiment of our field test.#R##N# During the field test, we observed that the adaptivity of the homecare applications met the end-users’ (care-receivers and nurses) expectations, at least in the second experiment. The tailorability of the homecare applications also met the nurses’ expectations except for one specific type of homecare application. The nurses were satisfied with the fact that they only needed to use the same tailoring application for all the homecare applications. We also observed that the evolvability of the homecare applications met the programmers’ expectations. This was possible mainly because of using the decision service. Our field test showed that using the decision service improves the evolvability while its cost in terms of time and data communication is rather small.#R##N# Our conclusion from the field test is that the DHSP platform is suitable for homecare service provisioning. However, we only evaluated the proposed DHSP platform with a limited number of participants (care-receivers, care-givers, IT specialist) in one care center in the Netherlands in which care-receivers live in their care homes. Evaluation of the platform in other situations (e.g., a situation where care-receivers live at their own homes and receive support remotely) may have different results. Moreover, the platform should be evaluated using other homecare applications and their required application services.	provisioning	Shanin Alireza Zarghami	2013			simulation;engineering;operations management;computer security	HPC	-41.91042496303502	42.853197351427156	125935
7dff4ee61aba414e6f8ae73cc9277b011def2f7d	stochastic error propagation analysis of model-driven space robotic software implemented in simulink	simulink;error propagation model;space robotic software;model transformation;model driven software;control flow;model based analysis;data flow	Model-driven software development methods are widely used in safety-critical domains including space robotics. The MATLAB Simulink environment is the common choice of control engineers. This article introduces a new method for a fully automatic transformation of a Simulink model to a dual-graph model for stochastic error propagation analysis. The error propagation analysis provides important inputs for system reliability methods, required by industrial standards such as FTA and FMEA. The dual-graph error propagation model is a mathematical abstraction of key system design aspects that influence error propagation processes: control flow, data flow, and component-level reliability properties. This model helps to estimate the likelihood of error propagation to hazardous system parts and quantify the negative impact of a fault in a particular component on the overall system reliability. In praxis, the manual creation of an error propagation model of a complex system requires a huge effort. The transformation method, introduced in this article, is a fast and promising solution. The method is demonstrated as a part of a stochastic analysis of a real-world model-driven space robotic software.	altran praxis;complex system;control flow;dataflow;dual graph;failure mode and effects analysis;key;matlab;model-driven engineering;model-driven integration;propagation of uncertainty;reliability (computer networking);robot;robotic spacecraft;simulink;software development;software propagation;systems design	Andrey Morozov;Klaus Janschek;Thomas Krüger;André Schiele	2016		10.1145/3022099.3022103	real-time computing;simulation;computer science;theoretical computer science	Embedded	-43.83654118089246	33.34479541350459	126073
03f01999b14ad68f2d801232d28d7db60105556f	time-budgeting: a component based development methodology for real-time embedded systems	component based development;requirements engineering;embedded systems;parametric real time specifications;design space exploration	The design of a complex embedded control system involves integration of large number of components. These components need to interact in a timely fashion to achieve the system level end-to-end requirements. In practice, the component level timing specification consists of design attributes like component task mapping, task period and schedule definition but often lack details on their real-time (functional) requirements. As we observe, there is no systematic methodology in place for decomposing the feature level timing requirements into component level timing requirements. This paper proposes an early stage time-budgeting methodology to bridge the above gap. A salient proposal of this methodology is to consider parameterized component timing-requirements. A key step in the methodology involves computing a set of constraints by relating component requirements with feature requirements. This enables the separation of timing constraints from functionality decomposition, and facilitates early optimization of the component time-budget for a complex component based embedded system. This paper formalizes the proposed methodology by using Parametric Temporal Logic. A case study involving two advanced features from the automotive domain, namely Adaptive Cruise Control and Collision Mitigation is given to demonstrate the methodology.	control system;embedded system;end-to-end principle;mathematical optimization;real-time clock;real-time computing;requirement;temporal logic	Manoj G. Dixit;S. Ramesh;Pallab Dasgupta	2012	Formal Aspects of Computing	10.1007/s00165-012-0273-0	real-time computing;computer science;component-based software engineering;requirements engineering;programming language	Embedded	-40.69653088799443	34.69470699828139	126316
d3e6750fe08d9def35e61490f66ef8abb699fbcd	techniques for service level enforcement in web-services based systems	replication;service level;web service;formal representation;web services;experimental evaluation;architectural translucency;system architecture;nonfunctional properties;enterprise architecture;service levels	Web-services based systems present challenges for service level enforcement. Contrary to typical enterprise architectures where we are in control of all services and can easily specify and monitor service levels, here we need self-adapting approaches. The paper proposes techniques for service level enforcement in the context of a four step approach. The proposed techniques are: formalization of requirements using a service level objective, formalization of Web Service properties in a service level capability statement, and adaptive actions based on translucent replication of services. For an experimental evaluation we deployed a Web Service benchmark and our replication framework in Amazon's Elastic Compute Cloud. It provided continuous meeting of specified service levels.	amazon elastic compute cloud (ec2);benchmark (computing);enterprise architecture;requirement;service-oriented architecture;web service	Vladimir Stantchev;Christian Schröpfer	2008		10.1145/1497308.1497316	web service;reliability engineering;service level requirement;service level objective;service catalog;service product management;differentiated service;engineering;basic service;service delivery framework;ws-policy;service design;database;service;data as a service;computer security;service system	Web+IR	-46.612581595229535	43.11129997537161	126406
841f6666398c4bfda8ed1cbc1fe7ffbbba0c3d38	involving the application domain expert in the construction of systems of systems		The system of systems (SoS) is a system whose definition is based on pre-existing independent systems in the runtime environment. The latter is in perpetual evolution thus forcing a recurrent adaptation of the SoS. Thus, during their life cycle the SoS are very exposed to the problem related to the evolution mentioned above. This problem is mainly due to a poor communication between the requirement definition stage and the design stage. In this paper we propose a method for addressing SE for SoS using the concepts Mission and Role. The first one allows the definition of the SoS’s behavior, while the second allows to abstract this definition with respect to the constituent systems that may actually exist in the environment. This definition will be translated into an abstract architecture. The later will serve as a guide and controller of the choices proposed by the system architect during the design and evolution stages. With our approach we have correctly defined an SoS concerning crowd management during a sport event.	activity diagram;apple sos;application domain;emergence;requirement;runtime system;simulation;subject-matter expert;system of systems;systems modeling language;unicom system architect	Imane Cherfa;Salah Sadou;Nicolas Belloir;Régis Fleurquin;Djamel Bennouar	2018	2018 13th Annual Conference on System of Systems Engineering (SoSE)	10.1109/SYSOSE.2018.8428728	control theory;system of systems;real-time computing;application domain;semantics;requirement;architecture;computer science;forcing (mathematics);distributed computing;system architect	EDA	-42.71738923110695	37.460739496821546	126415
59c0b56a745a0503749ae51909dad17d79951590	an integrated platform for dynamic adaptation of multi-tenant single instance saas applications		Software-as-a-Service (SaaS) has recently been adopted by many organizations to get their work done through subscription-based services. To leverage economies of scale, software and hardware resources are shared among multiple tenants who have different requirements that rapidly change with time. Responding to tenantsu0027 diverse needs requires SaaS providers to carefully manage software variability so that every tenant feels like having a distinct instance of the application. Tenantsu0027 evolvable needs require the SaaS instance to dynamically adapt. This paper presents an integrated platform that facilitates the dynamic adaptation of Multi-Tenant Single Instance SaaS applications and supports runtime tenantsu0027 configurations customization. The proposed platform is based on three concepts: Service-Orientation, Software Product Lines (SPLs), and Model Driven Architecture (MDA). The proposed solution spans over two dimensions: Feature-level variability management and runtime variability management. We propose raising the level of abstraction in which the whole adaptation process is addressed to better manage customization. The feasibility of the approach is illustrated via a functioning prototype. A realistic SaaS application was used to exercise the different adaptation scenarios and evaluate the platform prototype implementation.	feature model;heart rate variability;model-driven architecture;multitenancy;prototype;relevance;requirement;run time (program lifecycle phase);scalability;service-orientation;single-instance storage;software as a service;software product line;spatial variability	Fatma Mohamed;Rabeb Mizouni;Mohammad Abu-Matar;Mahmoud Al-Qutayri;Jon Whittle	2017	2017 IEEE 5th International Conference on Future Internet of Things and Cloud (FiCloud)	10.1109/FiCloud.2017.39	economies of scale;real-time computing;personalization;cloud computing;software;architecture;quality of service;software as a service;abstraction;computer science	SE	-44.71243471212584	41.725334316175214	126485
7654ec0cbb464d10bc6763b0a40b06b22e2b9bcc	distributed component architectures security issues	distributed application;components;e commerce;corba;j2ee;net;enterprise information system;component architectures security;component architecture	Enterprise information systems and e-commerce applications are tightly integrated in today ’s modern enterprises. Component architectures are the base for building such multi-tier, distributed applications. This paper examines the security threats those systems must confront and the solutions proposed by the major existing component architectures. A comparative evaluation of both security features and implementation issues is carried out to determine each architecture’s strong points and drawbacks.	common object request broker architecture;computer architecture;distributed computing;e-commerce;emergence;enterprise information system;multitier architecture;non-repudiation;software deployment	Giorgos Gousios;Efthimia Aivaloglou;Stefanos Gritzalis	2005	Computer Standards & Interfaces	10.1016/j.csi.2004.08.003	sherwood applied business security architecture;common component architecture;computer science;software engineering;common object request broker architecture;distributed computing;distributed system security architecture;computer security;enterprise information security architecture;enterprise information system;net	Security	-33.73202046666006	46.18990905294796	126847
361b8b81a3d1c44a274d5a3eef708e124000957d	engineering resilient collective adaptive systems by self-stabilisation		Collective adaptive systems are an emerging class of networked computational systems particularly suited for application domains such as smart cities, complex sensor networks, and the Internet of Things. These systems tend to feature large-scale, heterogeneity of communication model (including opportunistic peer-to-peer wireless interaction) and require inherent self-adaptiveness properties to address unforeseen changes in operating conditions. In this context, it is extremely difficult (if not seemingly intractable) to engineer reusable pieces of distributed behaviour to make them provably correct and smoothly composable.  Building on the field calculus, a computational model (and associated toolchain) capturing the notion of aggregate network-level computation, we address this problem with an engineering methodology coupling formal theory and computer simulation. On the one hand, functional properties are addressed by identifying the largest-to-date field calculus fragment generating self-stabilising behaviour, guaranteed to eventually attain a correct and stable final state despite any transient perturbation in state or topology and including highly reusable building blocks for information spreading, aggregation, and time evolution. On the other hand, dynamical properties are addressed by simulation, empirically evaluating the different performances that can be obtained by switching between implementations of building blocks with provably equivalent functional properties. Overall, our methodology sheds light on how to identify core building blocks of collective behaviour and how to select implementations that improve system performance while leaving overall system function and resiliency properties unchanged.	adaptive system;aggregate data;computation;computational model;computer simulation;correctness (computer science);dynamical system;internet of things;peer-to-peer;performance;self-stabilization;smart city;smoothing;toolchain	Mirko Viroli;Giorgio Audrito;Jacob Beal;Ferruccio Damiani;Danilo Pianini	2018	ACM Trans. Model. Comput. Simul.	10.1145/3177774	implementation;wireless sensor network;adaptive system;distributed algorithm;toolchain;computer science;computation;time evolution;theory;distributed computing	Metrics	-40.76853379006202	37.008952113244916	127105
209331a6508ec72723c452a244d024fb4a210511	a foundational ontology-based model for human activity representation in smart homes		Human activity detection within smart home (SH) is one of the basis of unobtrusive wellness monitoring of a rapidly aging population in developed countries. Most works in this area use the concept of “activity” as the building block with which to construct applications such as healthcare monitoring or ambient assisted living. This paper presents a model for human activity representation. The model has been developed by using the NeON methodology. The proposed human activity model consists of a network of ontologies classified in three categories: user ontologies, SH context ontologies and ADL ontologies, supporting user modelling, SH context modelling and ADL modeling, respectively. Furthermore, the formal definition of the main concepts and properties as well as a proof-of-concept ontology evaluation with a specification scenario are presented. The adoption of DOLCE+DnS Ultralite (DUL) ontology as an upper ontology aims to achieve a high degree of reusability and interoperability within heterogeneous smart home applications.		Qin Ni;Iván Pau;Ana-Belén García-Hernando	2016	JAISE	10.3233/AIS-150359	natural language processing;knowledge management;ontology;data mining	AI	-42.33776212464288	44.796284929543496	127231
774291c242ac70b7fde6c6cf1efd4a64aa44bdbe	a methodology for complex embedded systems design: petri nets within a uml approach	distributed computing;real time embedded system;embedded system;embedded system design;petri net;time constraint	The vast majority of embedded systems are control-dominated systems and traditionally designers specify them using only a state-oriented model, such as FSMs. However, real-time embedded systems are getting quite complex, which implies that a different approach is necessary. The system specification has to fulfil several requirements, namely support for concurrency, timing constraints, hierarchy, data and control flow, and distributed computations. Thus, for modelling more aspects of the systems (namely, data and function), it is important to consider genuine multiple-view models. There is also absolutely no doubt that IT organisations can improve efficiency and productivity if they share the same notation. In this context, the authors recommend the utilisation of some UML views to specify embedded systems, because it is a notation that covers the most relevant modelling aspects of systems and it is an OMG standard.	activity diagram;computation;concurrency (computer science);control flow;embedded system;metamodeling;petri net;real-time clock;requirement;simulation;systems design;unified modeling language	Ricardo J. Machado;João M. Fernandes;Henrique M. Dinis Santos	2000			embedded system;real-time computing;distributed computing;process architecture;petri net	Embedded	-41.16084258386697	33.27932650220298	127254
4b6f2ee147b8d1f7e6081c82d37783db8a76573b	formal verification successes at motorola	verification;microprocessors;formal;design flow;formal verification;design verification;properties	Formal tools are either too labor intensive or are completely impractical for industrial-size problems. This paper describes two formal verification tools used within Motorola, Versys2 and CBV, that challenge this assertion. The two tools are being used in current design verification flows and have shown that it is possible to seamlessly integrate formal tools into existing design flows.	formal verification	Magdy S. Abadir;Ken Albin;John Havlicek;Narayanan Krishnamurthy;Andrew K. Martin	2003	Formal Methods in System Design	10.1023/A:1022917321255	computer architecture;real-time computing;concepts;verification;formal methods;formal verification;software verification;computer science;design flow;formal specification;formal equivalence checking;high-level verification;runtime verification;property;programming language;intelligent verification;functional verification	Logic	-37.1077806496099	33.35051318328896	127353
b9e428dde29ae1cf302da7f25c0f30b425b2b9a2	hogna: a platform for self-adaptive applications in cloud environments		We propose Hogna, a platform for deploying self-managing web applications on cloud. The platform enables the deployment of the applications based on the automation of a set of operations (starting instances, installing necessary software and configuring the instances, etc.), and then the continuous monitoring of the health of the applications. The gathered monitoring data is analyzed using a performance model and an action plan is created and executed. Any components involved (for monitoring, analyzing, planning and deployment changes) can be customized to fit the needs of the application and/or researcher.	software deployment;web application	Cornel Barna;Hamoun Ghanbari;Marin Litoiu;Mark Shtern	2015	2015 IEEE/ACM 10th International Symposium on Software Engineering for Adaptive and Self-Managing Systems		real-time computing;simulation;engineering;data mining	SE	-42.06902321825083	41.5995527623791	127475
2bbf64db3c18e0a668a19af59e7f18ee1338a3e3	testbed architecture for maritime cyber physical systems		Cyber physical Systems (CPS) are a key technology to enable the development of highly automated and autonomous maritime systems. The development of new complex and distributed safety-critical systems increases the challenges of testing due to a variety of Verification and Validation (V+V) methods, strictly required confidence to functional correctness of heterogenous cooperating systems and management of test data. To facilitate these efforts, suitable engineering and risk assessment methods exist which will be performed by using a test environment building the basis for putting the system under test in a controlled test setting. The maritime physical testbed LABSKAUS is per definition a CPS and implements components such as a research boat, sensor infrastructure and a reference waterway as part of an overarching testbed approach for virtual to physical tests along the design process. This paper describes components to support the development of new maritime technologies by a physical testbed following an open and modular design and show the applicability by testing a shore based bridge.	autonomous robot;blueprint;correctness (computer science);cyber-physical system;data model;deployment environment;experiment;message passing;modular design;requirement;risk assessment;seamless3d;system under test;systems engineering;test data;testbed;verification and validation	Marius Brinkmann;Axel Hahn	2017	2017 IEEE 15th International Conference on Industrial Informatics (INDIN)	10.1109/INDIN.2017.8104895	system under test;systems engineering;engineering;architecture;cyber-physical system;data modeling;engineering design process;testbed;modular design;test data	SE	-46.29007578808405	36.52573507780111	127551
80a00ca31a7a596b13d1cf85ab75d10129996200	hlmc: a hybrid logic tool for model checking in verification of administrative processes	hybrid logics;model checking;compliance checking;business event logs	Nowadays, public services can be modeled, analyzed and implemented using notations and tools for the business process (BP) abstraction. Applying such an approach allows public administrations (PAs) to better react to the undergoing transformation in service provisioning, improving service quality in order to satisfy citizens and business requests while coping with decreasing budgets. This paper introduces a novel approach to verifying administrative processes based on HLMC, a hybrid logic model checker	business process;hybrid logic;model checking;provisioning;verification and validation	Anca Goron;Carlos Iván Chesñevar	2016		10.1145/2910019.2910046	reliability engineering;computer science;data mining;database	Logic	-47.53081933124224	42.47310508224225	127595
5b5fe075261f9324857956e8858631f58206cbf7	evidential and continuous integration of software verification tools		The complexity of embedded software and increasing demands on dependability, safety, and security has outpaced the capabilities of current verification and certification methods. In particular traditional verification and certification methods based on manual reviews, process constraints, and testing, which are mandated by current safety standards such as DO-178C [1] and DO-278A [2] for airborne systems and air traffic management systems, ISO 26262 [11] in the automative domain, and IEC 61508 for industrial domains including factory automation and robotics are proving to be overly time- and resource-intensive. For example, costs for developing certification evidence in safety cases according to the DO-178C standard have been shown to range between $50 to $100 per executable line of code, depending on the required safety level [15]. Unless mission-critical embedded software can be developed and verified with less cost and effort, while still satisfying the highest dependability requirements, new mission-critical capabilities such as autonomous control may never reach the market.	continuous integration;software verification	Tewodros A. Beyene;Harald Ruess	2018		10.1007/978-3-319-95582-7_45	computer engineering;automation;computer science;real-time computing;iec 61508;air traffic management;embedded software;certification;software verification;dependability;executable	Logic	-46.403600094869304	36.52347101977802	127619
b1d4937b357d7c5927147b386d64537f4a81a612	7th international workshop on dynamic software product lines (dspl 2013)	water exploration;international workshop;dynamic software product lines;tight schedule;service robotics;unmanned space;life-support device;high-quality software;ubiquitous computing;resource constraint;additional functionality;extensive variation	In emerging domains such as ubiquitous computing, service robotics, unmanned space & water exploration, or medical and life-support devices, software is becoming increasingly complex with extensive variation in both requirements and resource constraints. Developers face growing pressure to deliver high-quality software with additional functionality on tight schedules ever more economically.	requirement;robotics;software product line;ubiquitous computing;unmanned spacecraft	Svein O. Hallsteinsen;Sooyong Park;Michael G. Hinchey;Hoh Peter In;Klaus Schmid	2013		10.1145/2491627.2499883	software engineering	SE	-43.29680669221005	39.054391486420364	127713
38e853f7e1bedb55bb0ac0720bd343dae7701d24	using subject-oriented modeling to develop jini applications	subject-oriented modeling;core business functionality;middleware-specific functionality;jini middleware feature;composition patterns.;subject-oriented software development approach;modeling and meta-modeling;distributed com- puting;business functionality;omg;system design;middleware functionality;uml;jini;middleware plat- forms;primary design subject;jini applications;core functionality;service-oriented ar- chitecture and design;design subject;model driven architecture;unified modeling language;software development;meta model;open systems;object oriented programming;software engineering;middleware;distributed system	A major contributing factor to the complexity of creating and evolving distributed systems is the tangling of middleware-specific functionality with core business functionality in system designs. Changing middleware functionality that is entangled with business functionality can lead to costly and risky rearchitecting of the system or extensive redesign of parts of the system. The subject-oriented software development approach addresses this problem by separating the design of crosscutting features into design subjects. We describe an approach for separating Jini middleware features as design subjects which can be composed with primary design subjects that realize the core functionality of the application. In this context, we identify limitations in the existing specification notation and propose extensions.	aspectj;class diagram;common object request broker architecture;distributed computing;distributed object;home automation;java remote method invocation;library (computing);middleware;sequence diagram;software development;jini	Gagan Tandon;Sudipto Ghosh	2004	Proceedings. Eighth IEEE International Enterprise Distributed Object Computing Conference, 2004. EDOC 2004.	10.1109/EDOC.2004.10009	unified modeling language;real-time computing;computer science;software engineering;database;distributed computing	EDA	-38.32359606270463	40.54694980284512	128243
22b13d7bf5a5b2349cd126819431058455e67da4	fault-adaptive control for robust performance management of computing systems	robust performance management;program diagnostics;performance management;software management;distributed processing;adaptive control;distributed computation system;health management;performance management reliability;fault tolerant computing;software reliability adaptive control distributed processing fault diagnosis fault tolerant computing program diagnostics software management;control systems robust control power system management fault diagnosis resource management automatic control adaptive control quality of service energy management maintenance;fault detection;fault diagnostics fault adaptive control robust performance management computing systems performance management reliability fault detection fault isolation distributed computation system health management;robust performance;computing systems;fault adaptive control;software reliability;fault isolation;fault diagnostics;fault diagnosis	This paper introduces a fault-adaptive control approach for the robust and reliable performance management of computing systems. Fault adaptation involves the detection and isolation of faults, and then taking appropriate control actions to mitigate the fault effects and maintain control.	autonomous robot;autonomy;complex systems;computation;control flow;fault detection and isolation;internet backbone;programming paradigm;runtime system	Sherif Abdelwahed;Nagarajan Kandasamy	2007	Fourth International Conference on Autonomic Computing (ICAC'07)	10.1109/ICAC.2007.17	performance management;real-time computing;adaptive control;computer science;control reconfiguration;fault detection and isolation	Robotics	-36.481627424689414	37.513789658929404	128506
5235955a04ce1f932a477d262850d8565549933e	on synthesizing controllers from bounded-response properties	real time;satisfiability;timed automata	In this paper we propose a complete chain for synthesizing controllers from high-level specifications. From real-time properties expressed in the logic MTL we generate, under bounded-variability assumptions, deterministictimed automata to which we apply safety synthesis algorithms to derive a controller hat satisfies the properties by construction. Some preliminary experimental r esults are reported.	algorithm;arbiter (electronics);automata theory;experiment;heart rate variability;high- and low-level;real-time clock;real-time computing;real-time transcription;scheduling (computing);semantics (computer science);spatial variability;temporal logic;timed automaton	Oded Maler;Dejan Nickovic;Amir Pnueli	2007		10.1007/978-3-540-73368-3_12	real-time computing;computer science;algorithm;satisfiability	Embedded	-38.40612623491796	32.364716180690465	128819
9fea0a667fdf71e727a13005a7ab1b485fa5363d	comparisons between corba and dcom: architectures for distributed computing	application development;distributed processing;distributed computing;object oriented programming;distributed processing object oriented programming;computer architecture distributed computing object oriented programming graphical user interfaces object oriented modeling standards development hardware operating systems security medical services;distributed objects;operating system;object oriented;distributed component object model;operating system corba dcom distributed computing object oriented development methods graphical user interfaces network programming standard architectures distributed object oriented programming object management group common object request broker architecture microsoft distributed component object model;graphic user interface;network programming;common object request broker architecture;program development	Over the last decade object-oriented development methods and techniques have gained rapid acceptance in many areas, for example Graphi-cal User Interfaces and Network Programming. Currently there are two major standard archi-tectures available to support Distributed Object-Oriented Programming: the Object Management Group's Common Object Request Broker Architecture and Microsoft's Distributed Component Object Model. While both standards address the same problems, i.e., language, hardware and operating system independence, they provide diierent sets of features for application developers. This paper provides an overview of both architectures and a comparison of program development under each. We draw some conclusions about the suitability of each architecture for diierent programming requirements based on our experiences developing systems under each.	archi;common object request broker architecture;computer hardware;distributed component object model;distributed computing;distributed object;operating system;requirement	D. Thompson;D. Watkins	1997		10.1109/TOOLS.1997.713554	distributed objects everywhere;interoperable object reference;object linking and embedding;common data representation;general inter-orb protocol;method;real-time computing;computer science;object request broker;object;component-based software engineering;object-relational mapping;common object request broker architecture;distributed computing;distributed object;programming language;object-oriented programming;.net remoting;portable object	PL	-33.696258814165354	44.230894068983595	129010
198626dcd66af1aceb8ce7522b426e6df35af06a	mda for soc design, intensive signal processing experiment	design methodology;signal processing;hardware architecture	The development of embedded applications is very difficult. Several different languages are usually used to specify different parts of the application or of the hardware. Dealing with so many languages can be daunting. A separation of the preoccupations: application, hardware architecture, association between them and the simulation or execution technologies are keys to efficient co-design of embedded applications. The Model Driven Architecture can be used to better deal with the reuse of parts of the design and the interoperability between both the implementation technologies and the various simulation levels. We propose a construction of metamodels to support a co-design methodology. This construction will be experimented on intensive signal processing application co-design to justify the adequacy of this methodology to usual industrial development techniques.	code generation (compiler);embedded system;interoperability;meta-object facility;metamodeling;model-driven architecture;register-transfer level;signal processing;simulation;software deployment;system on a chip;systemc	Pierre Boulet;Jean-Luc Dekeyser;Cédric Dumoulin;Philippe Marquet	2003			computer science;computer architecture;real-time computing;interoperability;design methods;signal processing;hardware architecture;architecture;reuse	EDA	-41.12765790087599	33.74830679885067	129062
07838421138ae1f8d8a44bc300e4e8d7412ad201	a meta-model approach for the deployment of services-oriented applications	electrical equipments;web services power engineering computing utility programs;services oriented applications;service orientation;heterogeneous services;deployment language for services applications;meta model approach;deployment manager for services applications;power distribution;power engineering computing;power distribution meta model approach services oriented applications meta model based approach services applications deployment execution environments heterogeneous services electrical equipments deployment language for services applications deployment manager for services applications;execution environment;web services;utility programs;application software job shop scheduling context aware services conference management resource management power distribution assembly systems software systems computer architecture software tools;services applications deployment;meta model based approach;execution environments;meta model	This paper presents a meta-model based approach to services applications deployment on constrained execution environments (EEs) which contain heterogeneous services implementations. Indeed, the targeted EEs are conceived to be hidden in electrical equipments and so belong to the embedded/reactive domain and to its constraints. The language provided by our meta-model, is called DLSA (deployment language for services applications), which is a services applications language for deployment under the conditions mentioned above. The deployment manager for services applications (DMSA) using our language was implemented to realize and validate our work. Our approach is motivated by a real case from power distribution.	embedded system;metamodeling;method (computer programming);software deployment;system programming language	Antonin Chazalet;Philippe Lalanda	2007	IEEE International Conference on Services Computing (SCC 2007)	10.1109/SCC.2007.11	real-time computing;deployment diagram;computer science;systems engineering;database;services computing	Robotics	-39.06810763357949	40.06176112801195	129170
6a60d9f7b7b8e20261356da433176e0cb4d4a338	osek com-based dynamic priority assignment method on can	automotive electronics;protocols;node priority update protocol;can identifier;job shop scheduling;probability density function;i pdu;controller area networks;job shop scheduling communication system control application software vehicle dynamics dynamic scheduling protocols automotive engineering embedded software educational institutions computer science;data mining;data communication;receivers;scheduling;osek vdx;superluminescent diodes;node priority update protocol osek com based dynamic priority assignment osek vdx automotive electronics data communication behavior can identifier i pdu;data communication behavior;osek com based dynamic priority assignment	OSEK/VDX is an important specification in the field of automotive electronics and OSEK COM specifies the data communication behaviors inter-ECU and intra-ECU, but doesn't appoint specific underlying layer. In this paper,OSEK COM is implemented based on CAN bus. We present a model that dynamically generates properly CAN identifier to schedule I-PDUs of OSEK COM and transmit data that is longer than 8 bytes on CAN. As an important part of CAN identifier, node priority is dynamically adjusted according to the actual network state by the node priority update protocol. The model has implemented on Santana Light Demo System.	byte;can bus;engine control unit;identifier;osek;vdx (library software)	Lvhong Zhang;Hong Li;Li Zhou;Minde Zhao;Zhigang Gao	2009	2009 International Conference on Embedded Software and Systems	10.1109/ICESS.2009.67	embedded system;job shop scheduling;communications protocol;probability density function;real-time computing;computer science;operating system;scheduling;computer network	Embedded	-33.801313436325856	35.197809629599256	129282
19916f1725b2fd4ff4416a072953fa24b4c500fd	kubernetes and the path to cloud native	progress indicators;data skewness;performance profiling;performance prediction;mapreduce;hadoop	We are in the midst of an important shift to higher levels of abstraction than virtual machines. Kubernetes aims to simplify the deployment and management of services, including the construction of applications as sets of interacting but independent services. We explain some of the key concepts in Kubernetes and show how they work together to simplify evolution and scaling.	image scaling;interaction;principle of abstraction;software deployment;virtual machine	Eric A. Brewer	2015		10.1145/2806777.2809955	computer science;data science;operating system;data mining;database	Networks	-46.16645062546955	45.0629684037814	129397
b011bc488a81bdf5cd4a1ea5622ad048e7e1bd94	an architecture for negotiation and enforcement of resource usage policies	termination and enforcement;service provider;policy consistency;service oriented architecture client server systems cloud computing;client server systems;service agreement negotiation;proof of concept;private policies enforcement architecture cloud computing service providers computational resources sophisticated enterprise application services remote clients business transaction legal service agreement service interactions service agreement negotiation service agreement enforcement;infrastructure as a service;service oriented computing;logic gates contracts educational institutions linux usability biology;software as a service;policy consistency service oriented computing service agreement negotiation updating termination and enforcement;service oriented architecture;updating;cloud computing	Advances in Cloud computing are making it possible for service providers to offer computational resources such as storage and compute power (infrastructure as a service, IaaS) to sophisticated enterprise application services (software as a service SaaS) to remote clients for a fee on a highly dynamic basis. As in any business transaction, client access to a service is regulated by a legal Service Agreement (SA). A service agreement needs to be negotiated and agreed between the provider and the client before the latter can use the service. Then on, both the client and the provider will need assurances that service interactions are in accordance with the SA, and any violations are detected and their causes identified. There is thus a need for automated support for negotiation and enforcement of service agreements. This paper discusses key design issues for such a system, of which the main one is to ensure that the policies (termed also clauses) contained in an SA are logically sound and that they work in harmony with any private policies of the client and the provider. The paper presents an architecture and a proof of concept implementation.	cloud computing;computational resource;drools;encode;enterprise software;executable;interaction;representational state transfer;software as a service;software deployment	Carlos Molina-Jiménez;Santosh K. Shrivastava;Stuart M. Wheater	2011	2011 IEEE International Conference on Service-Oriented Computing and Applications (SOCA)	10.1109/SOCA.2011.6166218	service provider;service level requirement;service level objective;service catalog;cloud computing;application service provider;business service provider;differentiated service;computer science;service delivery framework;operating system;service-oriented architecture;service design;database;service;data as a service;law;world wide web;computer security	HPC	-47.10460834717994	43.817819889873846	129445
e00590db3a174e046a67f44560e8575c127cb6a3	implementation of an integrated test bed for avionics system development		An integrated test environment is required to test functions for development of avionics systems. In this paper we introduce an integrated test bed system which utilizes variety functions of the commercial flight simulator X-Plane and the model-based programming language LabView. The test system generates the flight data from X-Plane which linked a running gear and input the data to a display function as 3D map using Google Earth. Our proposed system could drive the flight operation in real time using generated flight data. We could trace the flying route of the simulated data based on the visualized results.	avionics	Hyeon-Gab Shin;Myeong-Chul Park;Jung-Soo Jun;Yong Ho Moon;Seok-wun Ha	2011		10.1007/978-3-642-27207-3_46	embedded system;real-time computing;integrated modular avionics	SE	-37.676054545245265	34.36371513827796	129497
92b36a5dbc6962542ae1a6a43617a1287cf13e67	tartarus: a multi-agent platform for integrating cyber-physical systems and robots	swi prolog;multi agent systems;cyber physical systems cps;networked robots;mobile agent;distributed systems	The pervasive Internet has lured a variety of embedded devices including sensors nodes, controller boards, smartphones, etc. to form their respective niches within its fold. With a heterogeneous set of devices acting as its nodes, using it as a mere passive entity would be a gross under-utilization of such a massive networked resource. By tethering robots as mobile nodes onto this network, it is possible to realize both the flow of information as also on-demand physical actuation. Managing the communication and control of such a Cyber-Physical System (CPS) is a complex task and calls for an integrated platform that can cater to its scalability, heterogeneity, on-the-fly programming and distributed and decentralized control. In this paper, we introduce a multiagent platform, nicknamed Tartarus, designed to network and integrate robots with other heterogeneous devices to form a CPS. Its inherent agent based technology provides a range of features which include autonomy, intelligence, distributed and decentralized control, among others. The paper describes the platform together with an implementation of a CPS integrated with robots to validate its use in real world scenarios.	agent-based model;autonomy;cyber-physical system;distributed computing;distributed control system;embedded system;fold (higher-order function);live coding;multi-agent system;robot;scalability;sensor;smartphone;ubiquitous computing	Tushar Semwal;Manoj Bode;Vivek Singh;Shashi Shekhar Jha;Shivashankar B. Nair	2015		10.1145/2783449.2783469	embedded system;real-time computing;simulation;computer science;artificial intelligence;multi-agent system;mobile agent;cyber-physical system	Robotics	-38.983961353340106	44.95269534563672	129657
da5bd2bfb7f5c66f5de277750d4349624b1f7097	improving system-level verification of systemc models with spin	004;systemc spin promela system level verification	SystemC is a de-facto industry standard for developing, modelling, and simulating embedded systems. As embedded systems become more and more integrated into many aspects of human lives (e.g., transportation, surveillance systems, . . . ), failures of embedded systems might cause dangerous hazards to individuals or groups. Guaranteeing safety of such systems makes formal verification crucial. In this paper we present a novel approach for verifying SystemC models with SPIN. Focusing on system-level verification we reuse compiled and executable code from the original model and embed it into the verifier generated by SPIN. In contrast to most other approaches, which require a complete model transformation, in our approach the transformation focuses only on the relevant parts of the model while leaving functional blocks untransformed. Our technique aims at reducing the state vector size managed by the verifier of SPIN, at improving state exploration performance by avoiding unnecessary model transformation steps, and at concentrating on verifying properties that emerge from the composition of multiple functional units. 1998 ACM Subject Classification F.3.1 Specifying and Verifying and Reasoning about Programs	compiler;embedded system;executable;formal specification;formal verification;model transformation;spin;simulation;systemc;technical standard;verification and validation	Martin Elshuber;Susanne Kandl;Peter P. Puschner	2013		10.4230/OASIcs.FSFMA.2013.74	embedded system;real-time computing;simulation;computer science	Embedded	-43.43884760235607	32.625606144007435	129886
b16821e2149ba23a1a265b7ab391f79888991691	web based collaborative caad	database system;delaunay triangulation;multi user;topography;medical imaging;geometric model;voronoi diagram	Computer Aided Architectural Design(CAAD) of large complexes typically involves interaction between multiple users that concur in developing di erent parts or aspects of the designed structure. In this paper we introduce a new framework that implements a collaborative CAAD software architecture to regulate multiple graphical web clients interacting with multiple distributed computation servers. The key components of the system are: (a) geometric modeling services for CAAD, (b) a shared language interface, (c) a distribution layer for hierarchical object communication and standard JDBC interfaces to database system, (d) collaboration layer for multi-user coordination and control, and (e) a shared Java/VRML browser. The geometric modeling services are based on a geometric programming language PlaSM with an exportable Java interface[23]. PLaSM provides a design system kernel suitable for the initial stages of high level conceptual design and for the nal detailed shape representation. The collaboration layer is provided by the Shastra collaboration toolkit. This toolkit provides connections to multiple distributed network services. This allows for connecting multiple geometric modeling engines to a distributed database server providing persistent storage and safe transactions for concurrent data modi cations. Collaborative users are provided with knowledge of the transactions made by other users endowing them with collaborative awareness of global activity. A java enhanced VRML browser provides a graphical thin-client interface with on demand extensible capabilities that is accessed using regular web browsers. The resulting system is an innovative web based collaborative CAAD system that takes full advantage of interoperability with network services, multi-user coordination, and web connectivity to support collaborative design.	computation;computer-aided architectural design;database server;distributed computing;distributed database;emoticon;geometric modeling;geometric programming;graphical user interface;high-level programming language;interaction;interoperability;jdbc;java;multi-user;plasm;persistence (computer science);server (computing);software architecture;thin client;vrml	Chandrajit L. Bajaj;S. Cutchin;C. Morgia;Alberto Paoluzzi;Valerio Pascucci	1999		10.1145/304012.304063	medical imaging;computer vision;delaunay triangulation;voronoi diagram;topography;geometric modeling;data mining;mathematics;geometry;bowyer–watson algorithm	HCI	-34.48890163400957	44.31188502627942	129994
77299ca81ba3bed2c1a1c0bd00d1bd6d1776a418	conformance relations for distributed testing based on csp	article	CSP is a well established process algebra that provides comprehensive theoretical and practical support for refinement-based design and verification of systems. Recently, a testing theory for CSP has also been presented. In this paper, we explore the problem of testing from a CSP specification when observations are made by a set of distributed testers. We build on previous work on input-output transition systems, but the use of CSP leads to significant differences, since some of its conformance (refinement) relations consider failures as well as traces. In addition, we allow events to be observed by more than one tester. We show how the CSP notions of refinement can be adapted to distributed testing. We consider two contexts: when the testers are entirely independent and when they can cooperate. Finally, we give some preliminary results on test-case generation and the use of coordination messages.	communicating sequential processes;conformance testing;finite-state machine;need to know;process calculus;refinement (computing);tracing (software)	Ana Cavalcanti;Marie-Claude Gaudel;Robert Mark Hierons	2011		10.1007/978-3-642-24580-0_5	reliability engineering;computer science;theoretical computer science;algorithm	Logic	-41.764882560784436	35.35773567418916	130245
115bef56f96ebb0d446693ae6a9f71bca7de2d57	formal analysis of systemc designs in process algebra	verification;mcrl2;computer and information science;formal verification;data och informationsvetenskap;formal analysis;process algebra;asml;process algebras;systemc	SystemC is an IEEE standard system-level language used in ha rdware/software co-design and has been widely adopted in the industry. This paper descr ib a formal approach to verifying SystemC designs by providing a mapping to the process algebr a mCRL2. Our mapping formalizes both the simulation semantics as well as exhaustive state-s pace exploration of SystemC designs. By exploiting the existing reduction techniques of mCRL2 an d also its model-checking tools, we efficiently locate the race conditions in a system and resolv e them. A tool is implemented to automatically perform the proposed mapping. This mapping and the implemented tool enabled us to exploit process-algebraic verification techniques to anal yze a number of case-studies, including the formal analysis of a single-cycle and a pipelined MIPS proce ssor specified in SystemC.	computation;comstock–needham system;confluence;formal verification;hazard (computer architecture);linear algebra;mcrl2;machine translation;model checking;process calculus;race condition;simulation;systemc;transaction-level modeling	Hossein Hojjat;Mohammad Reza Mousavi;Marjan Sirjani	2011	Fundam. Inform.	10.3233/FI-2011-391	computer architecture;process calculus;verification;formal verification;computer science;theoretical computer science;programming language	Logic	-38.90227847208384	32.88674568706278	130292
96189c4a8c0c14a5e99555ad478d66bae393b1a9	a resource-aware framework for resource-constrained service-oriented systems	quality assurance;emergent properties;embedded;runtime architecture;service oriented	As embedded systems become increasingly complex, not only are dependability and timeliness critical quality indicators, but also their ability to dynamically adapt to changes in their runtime environment. Serviceoriented Architecture (SOA) offers a potential solution to this challenge by allowing services to be dynamically bound at runtime. However, resource contention between services and resource saturation can result in significant Quality of Service (QoS) degradation. To address these issues, this paper proposes a runtime, resource-aware architecture that combines resource monitoring with dynamic workflow orchestration to mediate resource contention within the orchestration environment. The architecture was evaluated on a medium-size service-oriented case study, deployed on a resource-constrained device.	dependability;elegant degradation;embedded system;quality of service;resource contention;run time (program lifecycle phase);runtime system;service-oriented architecture;service-oriented device architecture	Peter Newman;Gerald Kotonya	2015	Future Generation Comp. Syst.	10.1016/j.future.2014.09.010	quality assurance;parallel computing;real-time computing;computer science;operating system;database;distributed computing;emergence	Arch	-42.68305327838564	41.091891451853925	130471
5bc81b438721f9af776fc393a6062a831338b4f2	extension of the ocarina tool suite to support reliable replication-based fault-tolerance		Replication is a reliability technique that involves redundancy of software or hardware components to guarantee availability for fault tolerance purposes. Several studies focused on modelling fault tolerance of real-time embedded systems using replication of AADL Architecture Analysis & Design Language components. Manual replication with AADL is a tedious task, error-prone and increases design time.#R##N##R##N#To support the automatic replication of AADL components, we propose in this paper an extension of the AADL Ocarina tool suite. For that, based on a set of transformation rules, we assist the designer to automatically generate standard AADL models enriched with variants and adjudicators. This is based on a three-step model driven approach. First, we enable the designer to model his or her core application using AADL. Second, the designer enriches the model with a property set that we defined to describe replication concepts. Finally, applying a set of transformation rules, we generate an intermediate AADL model enriched with different replicas using Ocarina. This generated model can be analysed, formally verified, used for application code generation or even replication of other components. To illustrate our approach, we apply an active replication to a robot system chosen as a case study.	byzantine fault tolerance	Wafa Gabsi;Bechir Zalila;Mohamed Jmaiel	2016		10.1007/978-3-319-39083-3_9	embedded system;real-time computing;computer science;operating system;programming language	Robotics	-42.57617021743982	33.822800027508045	130493
89af1950d4fd2e35d8321ffc7355aa9f8487b5d0	towards automatic code generation for distributed cyber-physical systems: a first prototype for arduino boards		Embedded controllers are often the basis for cyberphysical systems and offer a pervasive support for the Internet of Things. When those controllers are made of several communicating devices we talk about distributed embedded controllers. The IOPT-Tools is a free cloud-based framework for model-driven development of controllers. From a single graphical model, the tool already generates code to be run in several controllers. Yet, the communication layer to support inter-device communication needs to be manually written and tailored. This paper presents a first prototype of a tool that automatically adds a communication layer to the code generated by IOPT-Tools, using the I2C-bus specification. This allows automatic code generation for globally asynchronous and locally synchronous systems (GALS) supported by Arduino boards. A proof of concept example is presented.	arduino;automatic programming;cloud computing;code generation (compiler);cyber-physical system;embedded system;graphical model;inter-process communication;internet of things;model-driven architecture;model-driven engineering;pervasive informatics;prototype	Artur Ataide;João Paulo Barros;Isabel Sofia Brito;Luís Gomes	2017	2017 22nd IEEE International Conference on Emerging Technologies and Factory Automation (ETFA)	10.1109/ETFA.2017.8247737	proof of concept;real-time computing;cloud computing;engineering;cyber-physical system;petri net;arduino;asynchronous communication;code generation;control system	Embedded	-41.8765749003582	33.35952556183462	130648
fde12788ef220f25532211beb5a788799e923286	an event-driven middleware for mobile context awareness	context aware;middleware	The formulation of a context-aware middleware requires researchers to devise suitable control mechanisms that allow applications to directly participate in resource adaptation in response to dynamic operating environments. This paper describes the design and implementation of an event model for a highly adaptive mobile middleware, Web Proxy for Actively Deployable Services (WebPADS) platform. The event model provides a highly composable event notification framework that uses multiple levels of environment monitors to provide a complex setup of composite events. Based on the event model and the dynamic reconfiguration feature WebPADS supports context awareness and a high level of adaptation to contextual changes through reconfiguration and migration of services.	computation;context awareness;control system;event (computing);event monitoring;helper class;high-level programming language;instance (computer science);interaction;java;mathematical optimization;middleware;multithreading (computer architecture);proxy server;real-time transcription;runtime system;thread (computing)	Alvin T. S. Chan;Siu Nam Chuang;Jiannong Cao;Hong Va Leong	2004	Comput. J.	10.1093/comjnl/47.3.278	middleware;computer science;middleware	SE	-39.1735043027629	41.63326794918677	131072
6c8d079ced722c207b1a5f2bf1b831e602e11693	discrete hybrid automata for safe cyber-physical system: an astronautic case study	computational modeling mathematical model moon safety legged locomotion analytical models automata;discrete hybrid automata lunar rover autonomous walking hysdel hybrid system description language dha modeling frame embedded hybrid system safety critical field cps astronautic case study cyber physical system;lunar rover;specification languages aerospace computing automata theory control engineering computing embedded systems planetary rovers;dha;cps;lunar rover cps dha hysdel;hysdel	Cyber-Physical Systems (CPSs) are interactive, intelligent and distributed-hybrid systems which have computing units embedded in physical environment and widely applied in the safety-critical field. Compared with the traditional embedded hybrid system, the problems of safety, reliability and uncertainty, caused by constant interaction between computing and physical process, are more prominent than ever before. An astronautic case has been taken for example in this paper. Correspondingly, the Discrete Hybrid Automata (DHA) modeling frame and Hybrid System Description Language (HYSDEL) are adopted to build and analyze its behavior model. Besides, combined with the hybrid toolbox, the trajectories of the continuous states and the reachability of system are simulated and analyzed. The usage of the approach to modeling and analysis of CPS has been applied in the scene of lunar rover autonomous walking, which lay a model foundation for the further safety verification.	autonomous robot;behavior model;cyber-physical system;embedded system;hybrid automaton;hybrid system;lunar lander challenge;matlab;optimal control;reachability;rover (the prisoner);simulation	Qiang Wang;Gang Yang;Xingshe Zhou;Yalei Yang	2013	2013 IEEE 11th International Conference on Dependable, Autonomic and Secure Computing	10.1109/DASC.2013.51	embedded system;real-time computing;simulation;engineering	Embedded	-44.99079033035425	35.70614235679741	131323
7cb212a8856ecd651299e1157f84199149d7a4cb	on-demand conversation customization for services in large smart environments	ontologies semantics context xml protocols vocabulary system on a chip;smart environment	"""Services in large smart environments, as defined in this paper, are """"aware"""" of their users' contexts and goals and are able to automatically interact with one another in order to achieve these goals. Unfortunately, interactions between services (i.e., service conversations) are not necessarily compatible, as services could have different interfaces (i.e., signature incompatibilities), as well as different logic for message ordering (i.e., protocol incompatibilities). Such conversation incompatibilities create obstacles for achieving semantic interoperability of services. One approach for handling conversation incompatibilities is to use conversation adapters, which should be created automatically by the middleware in order to be able to support on-demand conversation customization. Existing approaches for automatic adapter generation are strictly limited as they require no changes at the interface level. To overcome such a limitation, this paper proposes a novel ontology-based context-sensitive approach for automatic adapter generation. This approach captures the aggregate conditional substitution semantics of application-domain concepts in a context-based manner and uses these semantics to determine the mappings between the different conversation messages and to generate the corresponding conversion functions. The proposed approach ensures service semantic interoperability and increases the chances for service reuse, which consequently improves the efficiency of the smart environment."""	smart environment	Islam Elgedawy	2011	IBM Journal of Research and Development	10.1147/JRD.2010.2087170	computer science;operating system;database;distributed computing;smart environment;programming language;world wide web	HCI	-40.55218298614114	45.352649146422934	131333
498d850e47f98095f313be048484b87b3d0cf71c	peer services: from description to invocation	distributed environment	In this article, we describe our work on peer services and their description to allow an invocation of them in a distributed environment. The basic idea is that service publication and service invocation are made using descriptions of what is available and what is requested, respectively. There is no prior agreement between services, their descriptions are built independently. Service publications and service requests are sent to a coordinating element of the architecture responsible for matching publications and requests descriptions.	distributed computing;jxta;peer-to-peer;prototype;service discovery	Manuel Oriol	2002		10.1007/3-540-45074-2_3	computer science;database;distributed computing;world wide web	Web+IR	-35.228198239924	44.685326424469125	131671
e372ed94746677c9a00442f15ad59985b6647509	a model-based framework for building extensible, high performance stream processing middleware and programming language for ibm infosphere streams	model based code generation;data stream processing	This work presents an extensive case study on the model-based design of a commercialgrade stream processing middleware (IBM’s InfoSphere Streams), its runtime and language (SPL) compiler. The model-based underpinnings are pervasive throughout the whole environment, from describing inter-process communication interfaces and objects to the design of the extensibility mechanism in the runtime and language. In addition to many software engineering advantages such as consistent, uniform, and self-documented integration among the different parts of the system, we show intrinsic performance benefits to the platform derived from this design approach. First, we demonstrate how an incremental compilation strategy employed by the SPL compiler and rooted on the model description of the application, extracted by the compiler as part of the application building process, leads to better compile-time performance. Second, we discuss how the model-based code generation strategy employed by the SPL compiler also leads to increased runtime performance, by specializing the generated code to particular characteristics of the runtime environment. Finally, we show how the extensibility strategy used in the SPL language leads to automatic syntactic and semantic checks at compile-time, while enabling behavioral reasoning and specific optimizations at runtime.	c++;circuit complexity;code generation (compiler);compile time;debugging;documentation;extensibility;incremental compiler;infosphere;inter-process communication;iteration;java;john d. wiley;middleware;pervasive informatics;programming language;run time (program lifecycle phase);runtime system;streams;software ecosystem;software engineer;software engineering;stream processing;systems design;user interface	Bugra Gedik;Henrique Andrade	2012	Softw., Pract. Exper.	10.1002/spe.1139	compile time;compiler;parallel computing;real-time computing;dynamic compilation;profile-guided optimization;computer science;operating system;programming language	PL	-41.17209573324172	34.78419272065	131902
03a9f5cc708d88a2947a177a8bcc57cf43d5cc68	implementing incremental code migration with xml	hypermedia markup languages;application management;network computers hypermedia markup languages distributed programming java;lines of code;xml java personal digital assistants user interfaces permission bandwidth scalability network servers computer science educational institutions;xml technologies;distributed document management incremental code migration xml code mobility granularity mobile code fine grained code migration user interface management application management mobile thin clients pda;distributed programming;mobile code;network computers;code mobility;incremental code migration;java	We demonstrate how XML and related technologies can be used for code mobility at any granularity, thus overcoming the restrictions of existing approaches. By not fixing a particular granularity for mobile code, we enable complete programs as well as individual lines of code to be sent across the network. We define the concept of incremental code mobility as the ability to migrate and add, remove, or replace code fragments (i.e., increments) in a remote program. The combination of fine-grained and incremental migration achieves a previously unavailable degree of flexibility. We examine the application of incremental and fine-grained code migration to a variety of domains, including user interface management, application management on mobile thin clients, for example PDAs, and management of distributed documents.	application lifecycle management;code mobility;personal digital assistant;source lines of code;thin client;user interface;xml	Wolfgang Emmerich;Cecilia Mascolo;Anthony Finkelstein	2000		10.1145/337180.337227	kpi-driven code analysis;network computer;code access security;computer science;operating system;software engineering;mobile agent;database;application lifecycle management;programming language;java;source lines of code;world wide web;code mobility;code generation;threaded code;source code;remote evaluation	SE	-34.74911552135737	41.69006458563579	132256
790d5d8c96b248ce6384c3c1909445915f529bb8	the autonomic computing paradigm	autonomic computing	The advances in computing and communication technologies and software tools have resulted in an explosive growth in networked applications and information services that cover all aspects of our life. These services and applications are inherently complex, dynamic and heterogeneous. In a similar way, the underlying information infrastructure, e.g. the Internet, is large, complex, heterogeneous and dynamic, globally aggregating large numbers of independent computing and communication resources, data stores and sensor networks. The combination of the two results in application development, configuration and management complexities that break current computing paradigms, which are based on static behaviors, interactions and compositions of components and/or services. As a result, applications, programming environments and information infrastructures are rapidly becoming brittle, unmanageable and insecure. This has led researchers to consider alternative programming paradigms and management techniques that are based on strategies used by biological systems to deal with complexity, dynamism, heterogeneity and uncertainty. Autonomic computing is inspired by the human autonomic nervous system that handles complexity and uncertainties, and aims at realizing computing systems and applications capable of managing themselves with minimum human intervention. In this paper we first give an overview of the architecture	autonomic computing;biological system;data store;information;interaction;internet;programming paradigm	Salim Hariri;Bithika Khargharia;Huoping Chen;Jingmei Yang;Yeliang Zhang;Manish Parashar;Hua Liu	2006	Cluster Computing	10.1007/s10586-006-4893-0	computer science;theoretical computer science;distributed computing;management science;autonomic computing	HPC	-38.32869607962142	43.16618103470953	132292
ca0cdb2722df4c997306407c4e894da12bf2356d	agent-based proactive support in smart environments	software agents object oriented programming;proactive assistance agent based control smart environment;agent based proactive support smart meeting room dynamic device ensemble smart environments;object oriented programming;software agents;agent based control;context multi agent systems hardware middleware joining processes switches;proactive assistance;smart environment	We describe an agent based approach to control a heterogeneous and dynamic device ensemble. The resulting controller provides pro-active assistance to the users of the environment. For this, roles defining the functionality are attached to dynamically constructed agents. Those roles are assigned based on the current situation, that is the accessible state of all devices and the currently assigned roles. The feasibility of the approach is proven by applying it to a non-trivial use case of a smart meeting room. Finally we present the results of a user evaluation.	agent-based model;machine learning;multi-agent system;proactive parallel suite;smart environment;usability testing	Sebastian Bader;Robin Nicolay;Thomas Kirste	2013	2013 9th International Conference on Intelligent Environments	10.1109/IE.2013.30	real-time computing;simulation;engineering;computer security	Robotics	-40.64676057146037	42.51244483855028	132455
8d99a1d66c7bd071e07269f6dd001ebe2107590c	dynamically discovering architectures with discotect	architectural design;architecture design tools and analyses;software architecture;architecture discovery;colored petri net;reverse engineering	One of the challenges for software architects is ensuring that an implemented system faithfully represents its architecture. We describe and demonstrate a tool, called DiscoTect, that addresses this challenge by dynamically monitoring a running system and deriving the software architecture as that system runs. The derivation process is based on mappings that relate low level system-level events to higher-level architectural events. The resulting architecture is then fed into existing architectural design tools so that comparisons can be conducted with the design time architecture and architectural analyses can be re-run to ensure that they are still valid. In addition to the demonstration, we briefly describe the mapping language and formal definition of the language in terms of Colored Petri Nets.	petri net;software architect;software architecture	Bradley R. Schmerl;David Garlan;Hong Yan	2005		10.1145/1081706.1081724	multilayered architecture;enterprise architecture framework;functional software architecture;reference architecture;software architecture;space-based architecture;computer architecture;real-time computing;database-centric architecture;architectural geometry;architectural pattern;computer science;systems engineering;engineering;applications architecture;service-oriented modeling;software engineering;enterprise architecture management;solution architecture;software architecture description;process architecture;view model;resource-oriented architecture;reverse engineering;data architecture;systems architecture	SE	-42.4112856229379	33.142287536299584	132512
7ab9dbd35b83a7ffe8e59342281c9af751fc27ba	portability, extensibility and robustness in iros	time scale;client simplicity iros ubicomp environments middleware platforms;application software;pervasive computing;iros;distributed computing;ubicomp environments;middleware ubiquitous computing;robustness pervasive computing middleware application software hardware computer science scalability ubiquitous computing mobile computing distributed computing;ubiquitous computing;middleware;robustness;scalability;computer science;mobile computing;middleware platforms;client simplicity;hardware	The dynamism and heterogeneity in ubicomp environments on both short and long time scales implies that middleware platforms for these environments need to be designed ground up for portability, extensibility and robustness. In this paper, we describe how we met these requirements in iROS, a middleware platform for a class of ubicomp environments, through the use of three guiding principles - economy of mechanism, client simplicity and levels of indirection. Apart from theoretical arguments and experimental results, experience through several deployments with a variety of apps, in most cases not done by the original designers of the system, provides some validation in practice that the design decisions have in fact resulted in the intended portability, extensibility and robustness. A retrospective examination of the system leads the authors to the following lesson: A logically-centralized design and physically-centralized implementation enables the best behavior in terms of extensibility and portability along with ease of administration, and sufficient behavior in terms of scalability and robustness.	centralized computing;extensibility;iros;indirection;middleware;reliability engineering;requirement;scalability;single point of failure;soft state;software portability;ubiquitous computing;user interface	Shankar Ponnekanti;Brad Johanson;Emre Kiciman;Armando Fox	2003	Proceedings of the First IEEE International Conference on Pervasive Computing and Communications, 2003. (PerCom 2003).	10.1109/PERCOM.2003.1192722	embedded system;application software;real-time computing;scalability;computer science;operating system;middleware;distributed computing;ubiquitous computing;robustness	Robotics	-36.413925698565485	44.52305589286949	132712
61aea2c75acf3e26cd2c34a69ced2f037be32e0d	inclusion of real-time java software in event driven simulations	layered architecture;clocks;real time;biological system modeling;testing;software performance;computer architecture;design technique;program testing;desktop testing real time java software event driven simulation;synchronization;java discrete event simulation system testing real time systems costs software performance computational modeling computer simulation weapons control system synthesis;real time java;event driven simulation;physical environment;real time software;desktop testing;real time java software;program testing discrete event simulation java;event driven simulation real time software layered architecture java;java;real time systems;discrete event simulation	Modeling of complex real-time software intensive systems with high fidelity faces challenges, not only from the usual physical environment and phenomena, but also from modeling the actual performance of the software controlling the system. One method of modeling the software performance is to simply host the code within the simulation program; however, most real-time programs are not written to easily work with event driven simulations. We explore simple design techniques for real-time Java code that allow it to be easily ported to an event driven simulation and identify methods for porting code that does not follow these techniques.	computer simulation;event-driven architecture;event-driven programming;real time java;real-time computing;real-time transcription;software performance testing	George J. Foster;Annette Helm	2009	2009 Third UKSim European Symposium on Computer Modeling and Simulation	10.1109/EMS.2009.83	kpi-driven code analysis;computer architecture;real-time computing;computer science;software development;operating system;software construction;static program analysis	Embedded	-36.87335424435608	35.240775164345585	132804
49a1a9285fe2f6c1e91538b510955882b8b7f4ce	validation and test generation for object-oriented distributed software	analytical models;distributed system;object oriented distributed software;software testing;error recovery;validation tools;seamless oo life cycle;race condition;life cycle;software maintenance;uml;race conditions;automatic testing;unified model ing language;software systems;parallel programming;object oriented programming;automatic programming;program verification;oo technology;random simulation;formal verification;model checking;program testing;object oriented;distributed interactions;telecommunication protocols;fault tolerance;unified modeling language;automatic test generation;test generation;model checking activities;error conditions;distributed systems;verification and validation;deadlocks;oo distributed software;software validation;radio access networks;design methodology	The development of correct OO distributed software is a daunting task as soon as the distributed interactions are not trivial. This is due to the inherent complexity of distributed systems (latency, error recovery, etc.), leading to numerous problems such as deadlocks, race conditions, and many difficulties in trying to detect and reproduce such error conditions and debug them. The OO technology is ill-equipped to deal with this dimension of the problem. On the other hand, the willingness of mastering this complexity in the context of telecommunication protocols gave birth to specific formal verification and validation tools. The aim of this paper is to explore how the underlying technology of these tools could be made available to the designer of OO distributed software. We propose a framework allowing the integration of formal verification and validation technology in a seamless OO life-cycle based on UML, the Unified Modeling Language. From a UML model, this framework would allow to conduct model checking activities as well as random simulation and automatic test generation.	bus mastering;common object request broker architecture;deadlock;distributed computing;distributed object;formal verification;interaction;model checking;race condition;seamless3d;server (computing);simulation;smoothing;software system;unified modeling language;verification and validation	Thierry Jéron;Jean-Marc Jézéquel;Alain Le Guennec	1998		10.1109/PDSE.1998.668156	real-time computing;computer science;distributed computing;programming language	SE	-45.39465525775436	33.91893253045936	133350
6e1d2bfc6ebdfb8834f4924d027e75426903ef2c	animation in conrad: informal analysis of timing properties	control systems;consumption;cybernetics;data production;formal specification;formal specification real time systems software tools computer animation;software engineering environment conrad animation informal analysis time critical system design solution space timing restrictions timing correctness real time systems process activations data production consumption animator;time critical system;limiting;process activations;data processing;timing restrictions;computer aided software engineering;software engineering environment;critical system;animation;timing correctness;system testing;software tools;informal analysis;design solution space;conrad;computer animation;animation timing real time systems computer aided software engineering algorithm design and analysis data processing system testing cybernetics limiting control systems;information analysis;algorithm design and analysis;animator;real time systems;timing	It is suggested that timing restrictions are the fundamental part of the specification of a time-critical system (limiting the possible design solution space), because most of the timing restrictions have been objectively determined by the object to be controlled and thus cannot be changed arbitrarily. Timing correctness in real-time systems means that process activations, data production and consumption take place in time). So as to guarantee this, methods are needed to formally specify various timing properties and prove correctness of the specification. Equally important, however, are methods and tools for informal study of timing properties. Special emphasis is placed on the possibilities provided by the ANIMATOR., which is one of the two main tools in the CONRAD software engineering environment. >		Tarmo Kaldma;Leo Motus;Toomas Tommingas;Rein Paluoja;Jaanus Tekko	1994		10.1109/EMWRTS.1994.336839	anime;algorithm design;real-time computing;simulation;consumption;data processing;cybernetics;computer science;control system;operating system;formal specification;computer animation;data analysis;programming language;system testing;computer-aided software engineering;limiting	Logic	-37.62691563146392	32.79238388490279	133437
8f5cc6e13e5356660fec3d7b21fcf6ed89f55f1d	the object paradigm is to be reconsidered for distributed systems	distributed system	The information hiding property states a clean distinction between external visibility and internal perspective of an object. The external world has reduced visibility of the inside of an object: normally only an interface constitued by operation names is visible. Within any object, instead, there is the full visibility, in particular of the object state. This makes possible thateach object decides its internal policies independently of any environment decision. Object communications produce the global computation in object-based systems. An object can communicate with another if and only if knows it via a reference [Lis79]. In object systems, a communication implies that client objects request operations defined in the interface of server objects. These requests are exchanged by using message-passing mechanisms. Dynamicity of communications means that an object can change its visibility, i.e. the objects it can refer. Classification and factorization by inheritance gives object environments the possibility of applying reusability and extensibility. On the one hand, object applications can be designed and programmed by reusing already developed software. On the other hand, applications based on objectscan evolve to follow changes of specification. In the case of dynamic changes, the possibility of updating classes at run-time constitutes an useful tool.	computation;distributed computing;extensibility;message passing;object-based language;programming paradigm;run time (program lifecycle phase);server (computing)	Antonio Corradi;Letizia Leonardi	1990		10.1145/504136.504185	artificial intelligence;distributed computing;distributed object	SE	-35.58814420354412	43.03480288920714	133548
8c26aeda17be62c92b4dffd9419c4be361b00ba0	developing highly complex distributed systems: a software engineering perspective	computer communication networks;information systems and communication service;computer applications;it in business;computer systems organization and communication networks;processor architectures	What is a highly complex distributed system in the future era? What are the needs that may drive the development of such systems? And what is their life cycle? Is there any new challenge for Software Engineering (SE)? In this paper, we try to provide a partial answer to the above questions by characterizing few application domains that we consider of raising interest in the next years. Our thesis is that there is a need to rethink the whole software process for such systems. The traditional boundaries between static and dynamic activities disappear and development support mingles with run time support thus invading the middleware territory.	application domain;business logic;cloud computing;distributed computing;emergent;fits;future internet;middleware;object lifetime;requirement;run time (program lifecycle phase);service-oriented architecture;service-oriented device architecture;software development process;software engineering	Marco Autili;Paola Inverardi;Patrizio Pelliccione;Massimo Tivoli	2011	Journal of Internet Services and Applications	10.1007/s13174-011-0048-5	computing;simulation;computer science;operating system;middleware;systems development life cycle;computer applications;computer security;software system	SE	-38.53795895416008	42.536642648910465	133707
5b9194796fe7a5fa2539392e6f68c3b2227c63d0	designing cyber-physical systems with adsl: a domain-specific language and tool support		A Cyber-Physical System (CPS) comprises the integration of computation, software, networking, and physical processes. Consequently, CPS models extend traditional embedded system models with an increased support for hybrid and heterogeneous models, networking, time synchronization, and especially interoperability. To assist engineers in designing CPSs, we have developed aDSL, a Domain-Specific Language (DSL) that comes with fully-automated tool support and is tailored to interoperability of CPS. The aDSL tool support includes: (i) interactive model description with input validation; (ii) the computation of possible operation modes of subsystems and parts; and, (iii) checking the adherence to requirements for various design alternatives and finding the Pareto optimal designs given these requirements. Moreover, aDSL generates intuitive visualizations throughout the toolchain which help design engineers to better understand the implications of design decisions and communicate them to stakeholders. aDSL has been applied to an agricultural tractor-trailer system case study in which aDSL quickly evaluated 48 designs and rendered all the visualizations of the results.	algorithm;asymmetric digital subscriber line;computation;concurrency (computer science);cyber-physical system;data validation;design space exploration;domain-specific language;embedded system;executable;fault tree analysis;hood method;interoperability;pareto efficiency;performance evaluation;requirement;requirements traceability;toolchain	Freek van den Berg;Vahid Garousi;Bedir Tekinerdogan;Boudewijn R. Haverkort	2018	2018 13th Annual Conference on System of Systems Engineering (SoSE)	10.1109/SYSOSE.2018.8428770	asymmetric digital subscriber line;systems engineering;real-time computing;data validation;cyber-physical system;interoperability;software;toolchain;domain-specific language;computer science;digital subscriber line	SE	-42.79015697107623	32.73497904667985	133727
aba72770123508263c14a9272f3207f91358ac90	a step towards fault tolerance for multi-agent systems	distributed system;fault classification;multi agent system;fault tolerant;autonomy;fault tolerance;mas design	Robustness, through fault tolerance, is a property often put forward in order to advocate MAS. The question is: What is the first step to be fault tolerant? Obviously the answer is: to know faults. The claim of this paper is that existing fault classification suitable for distributed systems does not fit completely MAS needs because of autonomy, the main characteristic of their components. Actually autonomy is the very distinctive concept of agents and has unquestionable worthwhile properties. But do these properties have no compensation? After a short presentation of the fault classification which prevails in fault tolerance community, the paper will show that autonomy induces a need for significant extension to this classification. It will then make a special review of this extension and present some expectations with regard to the programing of fault tolerant MAS.	autonomous agent;autonomous robot;autonomy;dependability;distributed computing;enumerated type;fault tolerance;interaction;multi-agent system;relevance;software agent	Katia Potiron;Patrick Taillibert;Amal El Fallah-Seghrouchni	2007		10.1007/978-3-540-85058-8_10	reliability engineering;real-time computing;engineering;fault model;computer security	AI	-43.412970574999804	40.457313987855	133763
24d41cbff73c8447c3bea659e4b3b4eafa431441	supporting run-time evolution in seescoa	dynamic component configuration;embedded system;run time system;embedded systems;component dependencies and contracts;component model;interaction model	In this paper, the SEESCOA component model and its run-time system are presented. In the SEESCOA-project, a component methodology was developed that explicitly models component interaction using the port and connector concepts. Since non-functional constraints are important for embedded systems, they are modelled separately in contracts. Using this component interaction model, SEESCOA allows for dynamic component reconfiguration. A detailed description is given on both the process of a component upgrade and the required changes to the run-time architecture. Furthermore, important concepts in the domain of live updates relevant to SEESCOA are given.	component-based software engineering;embedded system;non-functional requirement;runtime system	Yves Vandewoude;Yolande Berbers	2004	Transactions of the SDPS		embedded system;real-time computing;engineering;component;distributed computing	Embedded	-39.45404375031364	38.00103559729188	134041
f7c07e5e04a216f3d59ff70d9caf90e7289784ad	automatic deployment of an rpas mission manager to an arinc-653 compliant system		The development process of avionics system requiring a high level of safety is subjected to rigorous development and verification standards. In order to accelerate and facilitate this process, we present a testbed that uses a suite of methods and tools to comply with aerospace standards for certification. To illustrate the proposed methodology, we designed a Mission Management System for Remotely Piloted Aircraft Systems (RPAS) that was deployed on a particular run-time execution platform called XtratuM, an ARINC-653 compliant system developed in our research group. The paper discusses the system requirements, the software architecture, the key issues for porting designs to XtratuM, and how to automatize this process. Results show that the proposed testbed is a good platform for designing and qualifying avionics applications.	unmanned aerial vehicle	Anca Du&#x0163;&#x0103;;Sumedha Garg;Alfons Crespo;P. Yuste Pérez	2018	Journal of Intelligent and Robotic Systems	10.1007/s10846-017-0694-3	software deployment;avionics;porting;engineering;computer engineering;software architecture;testbed;systems engineering;system requirements;arinc 653;integrated modular avionics	Robotics	-46.329114055339474	36.43138771998263	134207
ff6c9476655459c38a3cd530b24c29ad3d79ce50	test automation and safety assessment in rapid systems prototyping	real time systems software prototyping biomedical equipment medical computing computer aided software engineering safety critical software program testing;test automation;software prototyping;safety assessment;real time;automatic generation;medical computing;computer aided software engineering;program testing;automatic testing system testing automation safety prototypes real time systems software prototyping timing computer science software algorithms;execution environment;safety critical software;reactive system;fluid infusion pump test automation safety assessment rapid systems prototyping real time reactive system attributed event grammar safety critical computer assisted resuscitation algorithm software;biomedical equipment;real time systems	This paper addresses the need for automatic generation of executable environment models to facilitate the testing of real-time reactive systems under development (SUD) in rapid system prototyping. We present an approach that allows users to model the environment in which the SUD will operate in the terms of attributed event grammar (AEG). The AEG provides a uniform approach for automatically generating, executing, and analyzing tests. The approach is supported by a generator that creates test cases from the AEG models. We demonstrate the effectiveness of the proposed approach with using as a case study a prototype of the safety-critical computer-assisted resuscitation algorithm (CARA) software for a casualty intravenous fluid infusion pump.	algorithm;executable;prototype;real-time clock;test automation;test case	Mikhail Auguston;James Bret Michael;Man-tak Shing	2005	16th IEEE International Workshop on Rapid System Prototyping (RSP'05)	10.1109/RSP.2005.49	embedded system;reactive system;computer science;systems engineering;operating system;software engineering;programming language;computer-aided software engineering;computer engineering	SE	-45.047367889750205	32.4672740878433	134711
3f12ba84cf0a6eb72d88d3de2d919ccf305d5b7a	adaptive object-oriented filtering framework for event management applications	filtering;frameworks;monitoring;object oriented;design pattern;design patterns	Event filtering is an essential element in event management applications. In event management environments, the filtering mechanisms are employed to track the events generated from applications at run-time and perform the corresponding appropriate actions. Several key applications domains, such as system and network management, distributed system toolkits, communication protocols and active databases, utilize event filtering for various management purposes. The goal of this paper is to describe the object-oriented design and implementation of an adaptive event filtering framework which can be integrated and reused efficiently to develop event management applications for various domain environments. In our approach, the event filtering framework captures the common components and design patterns of event management in different domains. The major contribution of this work is to provide a flexible event filtering framework that can be efficiently adapted to different domain-specific requirements and with minimal development effort. In this paper, we also present examples of using the event filtering framework for developing event management applications in different domains.	active database;design pattern;distributed computing;list of toolkits;requirement	Ehab Al-Shaer;Mohamed Fayad;Hussein M. Abdel-Wahab	2000	ACM Comput. Surv.	10.1145/351936.351974	filter;software design pattern;real-time computing;computer science;software framework;collaborative filtering;data mining;database;design pattern;programming language;object-oriented programming	DB	-39.407696989295005	37.2784052853596	134725
1aa47e8e721789862d59425a8cd17914452846f5	enforcing interaction properties in aosd-enabled systems	encapsulation;control systems;aspect oriented software development;software systems;aosd;contracts;enforcement;interference;computer architecture;security programming control systems contracts computer architecture software systems interference computer science vehicles encapsulation;enforcement aosd law governed architecture aspects architecture;vehicles;computer science;security;architecture;programming;aspects;law governed architecture	The construction and maintenance of large and complex software systems depend on the existence of global principles describing the structure and the interaction among its various components. Due to their critical nature, such principles have to be explicitly formulated and strictly verified and enforced throughout the lifetime of the software product. Aspect Oriented Software Development (AOSD) provides necessary tools for the formulation of such principles as aspects--called here structural aspects, and for their compile-time verification and dynamic enforcement. This enforcement, however, becomes problematic when aspects are also used as a vehicle for programming the components themselves, due to aspect interference. In this paper we show how the aspects embedded in system's components--called here programming aspects--can interact unfavourably with other components thus invalidating the role of the structural aspects. We present a number of methods that address this problem, and we introduce a DirectedPairWiseWeaver tool we have developed in order to prevent this interference.	aspect-oriented software development;catastrophic interference;compile time;compiler;embedded system;interference (communication);software system	Constantin Serban;Shmuel S. Tyszberowicz	2006	2006 International Conference on Software Engineering Advances (ICSEA'06)	10.1109/ICSEA.2006.78	programming;simulation;encapsulation;computer science;systems engineering;engineering;control system;information security;architecture;software engineering;interference;programming language;management;computer security	SE	-47.21136668452991	33.65459083636526	134777
1f68692d41c92d35e2994ddf29a253909624153e	adaptation of web services to the context based on workflow: approach for self-adaptation of service-oriented architectures to the context		The emergence of Web services in the information space, as well as the advanced technology of SOA, give tremendous opportunities for users in an ambient space or distant, empowerment and organizations in various fields application, such as geolocation, E-learning, healthcare, digital government, etc.. In fact, Web services are a solution for the integration of distributed information systems, autonomous, heterogeneous and self-adaptable to the context. However, as Web services can evolve in a dynamic environment in a well-defined context and according to events automatically, such as time, temperature, location, authentication, etc.. We are interested in improving their SOA to empower the Web services to be self adaptive contexts. In this paper, we propose a new trend of self adaptability of Web services context. Then applying these requirements in the architecture of the platform of adaptability to context “WComp”, by integrating the workflow. Our work is illustrated by a case study of authentication.	.net framework;authentication;autonomous robot;business logic;business rules engine;e-government;emergence;geolocation;information system;mathematical optimization;middleware;requirement;service-oriented architecture;transverse wave;web service;world wide web	Faîçal Felhi;Jalel Akaichi	2012	CoRR	10.5121/ijwest.2012.3401	web service;web application security;web development;web modeling;web mapping;web standards;computer science;knowledge management;ws-policy;service-oriented architecture;data mining;services computing;web engineering;ws-i basic profile;world wide web	DB	-43.738399904905734	45.18298337595416	134806
260c617d59f00d3400e427691cadc69ef2f42da0	abstract interactions and interaction refinement in model-driven design	design process;middleware platform independence abstract interactions interaction refinement model driven design;software architecture;process design middleware yarn telematics information technology message passing unified modeling language;middleware;software architecture middleware;interaction design	In a model-driven design process the interaction between application parts can be described at various levels of platform-independence. At the lowest level of platform-independence, interaction is realized by interaction mechanisms provided by specific middleware platforms. At higher levels of platform-independence, interaction must be described in such a way that it can be further refined and realized onto a number of different middleware platforms, each with its particular interaction mechanisms and implementation constraints. In this paper, we investigate concepts that support interaction design at various levels of middleware-platform-independence. Also, we propose design operations for interaction refinement. The application of these operations to source designs results in target designs that take into account implementation constraints imposed by platforms, while preserving characteristics prescribed in source designs.	abstraction layer;conformance testing;entity;high-level programming language;interaction design;language binding;message-oriented middleware;middleware;model transformation;model-driven architecture;model-driven engineering;model-driven integration;refinement (computing);requirement;simple directmedia layer;system configuration;systems design;unified modeling language	João Paulo A. Almeida;Remco M. Dijkman;Luís Ferreira Pires;Dick A. C. Quartel;Marten van Sinderen	2005	Ninth IEEE International EDOC Enterprise Computing Conference (EDOC'05)	10.1109/EDOC.2005.2	embedded system;software architecture;middleware;real-time computing;design process;computer science;message oriented middleware;operating system;software engineering;interaction design;middleware;database	Visualization	-39.58972771248101	39.000251214797	134918
ed145dc905875a5bf64646ad13aff810c3bd6437	models and model transformations within web applications		Unlike traditional single-user desktop applications, web applications have separated memory and computational resources (the client and the server side) and have to deal with multiple user accounts. This complicates the development process. Is there some approach of creating web applications without thinking about web-specific aspects, as if we are developing stand-alone desktop applications? We say, “yes”, and that is where models and model transformations come in handy. The proposed model-driven approach simplifies the development of web applications and makes it possible to use a single code base for deploying both desktop and web-based versions of the software.	web application	Sergejs Kozlovics	2016		10.1007/978-3-319-40180-5_4	web modeling	Web+IR	-34.61604409936472	40.05701351414183	135064
828442e0a463d6279ec900fc0d091c74ebd0bc69	formal system-level design space exploration	language use;formal specification;logic design;performance property formal system level design space exploration diplodocus environment uml profile systems on chip ttool open source toolkit hardware specification software specification model checking techniques safety property schedulability property;chip;formal verification;model checking;uml profile;complex system;system on chip;system level design;system on chip formal specification formal verification logic design;software specification;system level design space exploration hardware application software system on a chip telecommunications unified modeling language open source software formal verification explosions;open source	The paper focuses on the formal aspects of the DIPLODOCUS environment. DIPLODOCUS is a UML profile intended for the modeling and verification of real-time and embedded applications meant to be executed on complex Systems-on-Chip. Application tasks and architectural elements (e.g., CPUs, bus, memories) are described with a UML-based language, using an open-source toolkit named TTool. Those descriptions may be automatically transformed into a formal hardware and software specification. From that specification, model-checking techniques may be applied to evaluate several properties of the system, e.g., safety, schedulability, and performance properties. The approach is exemplified with an MPEG2 decoding application.	cpu cache;central processing unit;clock rate;combinatory logic;complex systems;control flow;design space exploration;direct memory access;distributed computing;electronic system-level design and verification;embedded system;entity;execution unit;formal methods;formal specification;formal system;level design;mpeg-2;model checking;open-source software;profile (uml);real-time clock;refinement (computing);scheduling (computing);semantics (computer science);simulation;unified modeling language	Daniel Knorreck;Ludovic Apvrille;Renaud Pacalet	2010	2010 10th Annual International Conference on New Technologies of Distributed Systems (NOTERE)	10.1109/NOTERE.2010.5536852	computer architecture;real-time computing;formal methods;specification language;formal verification;computer science;applications of uml;formal specification;formal equivalence checking;programming language;language of temporal ordering specification	Embedded	-39.24004023036498	32.98428696628782	135066
bedb2d156afc8006e0eb64f57ada666e57fd4ca0	a protocol for the atomic capture of multiple molecules at large scale		With the rise of service-oriented computing, applications are more and more based on coordination of autonomous services. Envisioned over largely distributed and highly dynamic platforms, expressing this coordination calls for alternative programming models. The chemical programming paradigm, which models applications as chemical solutions where molecules representing digital entities involved in the computation, react together to produce a result, has been recently shown to provide the needed abstractions for autonomic coordination of services. However, the execution of such programs over large scale platforms raises several problems hindering this paradigm to be actually leveraged. Among them, the atomic capture of molecules participating in concur- rent reactions is one of the most significant. In this paper, we propose a protocol for the atomic capture of these molecules distributed and evolving over a large scale platform. As the density of possible reactions is crucial for the liveness and efficiency of such a capture, the protocol proposed is made up of two sub-protocols, each of them aimed at addressing different levels of densities of potential reactions in the solution. While the decision to choose one or the other is local to each node participating in a program's execution, a global coherent behaviour is obtained. Proof of liveness, as well as intensive simulation results showing the efficiency and limited overhead of the protocol are given.		Marin Bertier;Marko Obrovac;Cédric Tedeschi	2012	CoRR		embedded system;real-time computing;simulation;computer science;operating system;distributed computing;computer security;algorithm	NLP	-40.08993508067875	38.242519216037174	135415
47aa1a8d08573fda37f76c86502cef5270d1c917	issues in tool qualification for safety-critical hardware: what formal approaches can and cannot do	hdl;design tool;formal methods;formal method;system design;safety critical system;pld;hardware design;safety critical systems;tool qualification	Technology has improved to the point that system designers have the ability to trade-off implementing complex functions in either hardware or software. However, clear distinctions exist in the design tools. This paper examines what is unique to hardware design, areas where formal methods can be applied to advantage in hardware design and how errors can exist in the hardware even if formal methods are used to prove the design is correct.	cosmic;do-178b;design tool;formal equivalence checking;formal methods;hardware description language;image noise;place and route;turing completeness;web design	Brian Butka;Janusz Zalewski;Andrew J. Kornecki	2009		10.1007/978-3-642-04468-7_17	reliability engineering;hardware compatibility list;formal methods;computer science;systems engineering;engineering;programmable logic device;design for testing;hardware architecture;formal equivalence checking;life-critical system;programming language;computer engineering;systems design	EDA	-44.00237112982631	35.884098620098705	135451
220da0ff3b6bc72bb73acb20f154c05cf40cee2c	a system performance in presence of faults modeling framework using aadl and gspns		The increasing complexity of new-generation systems which take into account interactions between hardware and software components, particularly the fault-tolerant systems, raises major preoccupations in various critical application domains.These preoccupations concern principally the modeling and analysis requirements of these systems.Thus, designers are interested in the verification of critical proprieties and particularly the Performance and Dependability analysis. In this paper, we present an approach for modeling and analyzing systems with hardware and software components in the presence of faults: an approach based on Architecture Analysis and Design Language (AADL) and Generalized Stochastic Petri Nets (GSPN). This approach starts with the description of the system architecture in AADL. This description is enhanced by the use of two annexes, the existing Error Model Annex and the Activity Model Annex (proposed Annex). By applying existing transformation rules of GSPN models, we build two models: GSPNs Dependability and Performance models. Finally, we apply our composition algorithm, to obtain a global GSPN model allowing to analyze Dependability and Performance measurements.	algorithm;application domain;architecture analysis & design language;complex system;component-based software engineering;dependability;fault tolerance;function model;interaction;java;petri net markup language;petri net;requirement;systems architecture	Belhassen Mazigh;Kais Ben Fadhel	2013			component-based software engineering;reliability engineering;architecture analysis & design language;systems architecture;stochastic petri net;computer science;dependability	SE	-45.254784805210356	33.5855811027057	135861
376d350c8bf516bb2cf1597ba808790b695b9156	an ontology and constraint based approach to cache preloading	encapsulation;constraint satisfaction techniques;cache storage;control systems;ontologies memory management access protocols computer architecture software tools engines controllability encapsulation control systems gas insulated transmission lines;protocols;cache hierarchy;memory management;gas insulated transmission lines;controllability;large scale designs;testing;satisfiability;constraint satisfaction;ontologies artificial intelligence;domain knowledge;computer architecture;large scale;formal verification;engines;complex system;state space;ontologies artificial intelligence cache storage constraint theory formal verification microprocessor chips;access protocols;constraint theory;microprocessor based systems;terminology;ontologies;software tools;magnetic cores;load modeling;ontology;ibm microprocessor based systems cache hierarchy cache preloading technology ontology constraint satisfaction techniques formal verification large scale designs;microprocessor chips;cache preloading technology;ibm	The verification of modern microprocessor-based systems requires stressing the cache hierarchy and effectively covering its huge state space. Cache hierarchy initialization (or preloading) is a technique that enables simulation to start from a rich, complex system-level setup, thereby simplifying the task of dynamically driving the hierarchy into the required corner cases. In this paper we introduce CacheLoader, a new, design-independent cache-preloading technology. The tool's architecture follows the principles of ontology-based software to achieve complete separation between the cache-preloading engine and design dependent knowledge. Constraint satisfaction techniques are used to generate valid, interesting system initialization, and to satisfy explicit user directives. CacheLoader is currently being used by verification teams of several large scale designs in IBM. Results show that this technique provides superior coverage and user controllability, speeds up the construction of mature verification environments, simplifies maintenance, encourages encapsulation of domain knowledge, and enables reuse across verification environments and cache hierarchy designs.	biasing;cpu cache;complex system;constraint satisfaction;corner case;declarative programming;encapsulation (networking);hoc (programming language);microprocessor;plug and play;simulation;state space	Rajiv Bhatia;Eyal Bin;Eitan Marcus;Gil Shurek	2010	2010 IEEE International High Level Design Validation and Test Workshop (HLDVT)	10.1109/HLDVT.2010.5496651	embedded system;communications protocol;cache-oblivious algorithm;real-time computing;controllability;encapsulation;constraint satisfaction;formal verification;computer science;state space;ontology;theoretical computer science;operating system;ontology;database;software testing;programming language;terminology;cache algorithms;domain knowledge;algorithm;ibm;satisfiability;memory management	EDA	-36.908625215818994	33.29138398071061	136089
3d25cf8762f32d3ae9f1eb57e304c3e0b4be45b0	reconciliation service for copies synchronisation	collaborative work;copies reconciliation;mobility;extensible container;component based applications;virtual team;middleware;operational transformation;mobile user	"""The concept of multi-synchronous interaction has become popular in the context of collaborative work [7]. This cooperation mode allows the participants of a virtual team to alternate periods of work in coupled mode collaborating with the other team members with isolated work in uncoupled mode. As divergence may then occur, a reconciliation mechanism is required for team members to synchronize their work.This article deals with collaborative work among mobile users who manipulate component-based applications. We present the architecture of a reconciliation service that can be seen as an extra-fonctional service supported by the components container. More precisely we propose to extend a component-based middleware by the integration of a synchronisation service implementing the SOCT4. (""""Sérialisation des opérations concurrentes par transposition"""") algorithm [23, 24] based on operation transforms technology."""	algorithm;component-based software engineering;middleware	Lydialle Chateigner;Sophie Chabridon;Nawel Sabri;Guy Bernard	2004		10.1145/1050873.1050898	real-time computing;simulation;computer science;distributed computing	HCI	-35.13833858041668	42.959912504161274	136160
3b4d9238bbe0870de17a104e7246d834bdd67893	semantically-rich composition of virtual images	virtualization;measurement;optimization cloud computing virtualization virtual image management systems management;semantics;program verification;systems management;semantic based validation virtual images data centers standardized building blocks semantically rich image building blocks software product cloud agnostic software bundle platform agnostic software bundle virtualization software stacks;virtual machines;virtualisation program verification virtual machines;software algorithms;linux;optimization;virtual image management;virtualisation;concrete;cloud computing;operating systems;semantics concrete operating systems linux software algorithms measurement	Virtualization promises to reduce data centers' total cost of ownership by enabling the creation of a small set of standardized building blocks to be shared and used many times indifferent software stacks. However, without proper methodology and tools, an organization can easily end up with a large number of one-off virtual images, adversely affecting the cost. We propose an approach, tool, and algorithms for constructing high-quality, semantically-rich image building blocks that are easy to share, compose, and reuse. In our approach, domain experts codify knowledge of a particular software product (or a combination thereof) in a platform- and cloud-agnostic software bundle. Image builders easily construct virtual images by composing a set of standardized bundles. Semantic-based validation guarantees a valid and complete image design. Moreover, we propose algorithms to automate image design by searching for an optimal set of building blocks taking into account multiple metrics such as cost, size, and expected build duration.	composability;curve fitting;data center;greedy algorithm;platform as a service;product bundling;requirement;total cost of ownership;user requirements document	Fábio Oliveira;Tamar Eilam;Michael H. Kalantar;Florian Rosenberg	2012	2012 IEEE Fifth International Conference on Cloud Computing	10.1109/CLOUD.2012.40	virtualization;computer science;theoretical computer science;operating system;database;semantics	Visualization	-45.48287847144087	41.608658521094505	136700
555b11960f0d1cfb1f243804660503861b018d71	self-adaptation of mobile systems driven by the common variability language	dynamic reconfiguration;cvl;genetic algorithm;pervasive systems;context;architectural variability	The execution context in which pervasive systems or mobile computing run changes continually. Hence, applications for these systems require support for self-adaptation to the continual context changes. Most of the approaches for self-adaptive systems implement a reconfiguration service that receives as input the list of all possible configurations and the plans to switch between them. In this paper we present an alternative approach for the automatic generation of application configurations and the reconfiguration plans at runtime. With our approach, the generated configurations are optimal as regards different criteria, such as functionality or resource consumption (e.g. battery or memory). This is achieved by: (1) modelling architectural variability at design-time using the Common Variability Language (CVL), and (2) using a genetic algorithm that finds nearly-optimal configurations at run-time using the information provided by the variability model. We also specify a case study and we use it to evaluate our approach, showing that it is efficient and suitable for devices with scarce resources. We specify an approach for the dynamic reconfiguration of mobile applications.We model a mobile application with variability which can be reconfigured at runtime.We simulate the execution of the mobile application when our dynamic reconfiguration service is applied and not applied, respectively.We measure the battery life as well as the overall utility of the application perceived by the user.Applying our dynamic reconfiguration, the battery life is incremented by 45.9% and the utility is incremented by 10.31%.	heart rate variability	Gustavo G. Pascual;Mónica Pinto;Lidia Fuentes	2015	Future Generation Comp. Syst.	10.1016/j.future.2014.08.015	parallel computing;real-time computing;simulation;genetic algorithm;computer science;artificial intelligence;operating system;database;distributed computing	Arch	-40.217023884016456	40.65365501810714	136924
b5970e637d9004341ec1214d802dcb879f814983	useware modeling for ambient intelligent production environments	ambient intelligence;useware;intelligent production environments.;user interfaces;spatial relation;modeling language;development process;software systems;user interface;ubiquitous computing	The impact of user interface quality has grown in software systems engineering, and will grow further with upcoming new paradigms such as Ambient Intelligence or Ubiquitous Computing, which confront the production industry with a huge diversity of new usage situations. In this paper, we will show the adaptation of a task-oriented useware modeling language, which is employed in the model-based useware development process, to future paradigms by extending its existing models with respect to the new upcoming requirements. This language reflects several user groups’ tasks and user interface structure preferences in a common use model described in a system-independent language. It is being enhanced to describe spatial relations, connections between device compounds, and different ways of fulfilling tasks within different interaction zones. For the future, this model is intended to be used for the run-time generation of user interfaces for adaptive software and intelligent environments, especially in the area of production and manufacturing.	ambient intelligence;intelligent environment;modeling language;requirement;software system;systems engineering;ubiquitous computing;user interface	Daniel Görlich;Kai Breiner	2007			modeling language;ubiquitous computing;software system;human–computer interaction;computer science;software;ambient intelligence;ubiquitous robot;intelligent environment;user interface	HCI	-41.19339049831901	42.808426890871694	137127
1de82ecb0064590b3cb658b7b6016124c420e2d2	epics: engineering proprioception in computing systems	financial data processing;self adjusting systems cameras cloud computing distributed sensors financial data processing intelligent sensors interactive systems middleware mobile computing multimedia systems operating systems computers parallel architectures;self adjusting systems;multimedia systems;distributed sensors;parallel architectures;interactive mobile media systems engineering proprioception in computing systems heterogeneous architecture complex architecture distributed architecture application behaviour system environment epics project self awareness self expression customisable hardware software platforms operating systems self aware networking middleware infrastructure computational finance distributed smart cameras;middleware;hardware instruction sets computer architecture educational institutions computational modeling protocols;mobile computing;interactive systems;operating systems computers;intelligent sensors;cameras;cloud computing	Modern compute systems continue to evolve towards increasingly complex, heterogeneous and distributed architectures. At the same time, functionality and performance are no longer the only aspects when developing applications for such systems, and additional concerns such as flexibility, power efficiency, resource usage, reliability and cost are becoming increasingly important. This does not only raise the question of how to efficiently develop applications for such systems, but also how to cope with dynamic changes in the application behaviour or the system environment. The EPiCS Project aims to address these aspects through exploring self-awareness and self-expression. Self-awareness allows systems and applications to gather and maintain information about their current state and environment, and reason about their behaviour. Self-expression enables systems to adapt their behaviour autonomously to changing conditions. Innovations in EPiCS are based on systematic integration of research in concepts and foundations, customisable hardware/software platforms and operating systems, and self-aware networking and middleware infrastructure. The developed technologies are validated in three application domains: computational finance, distributed smart cameras and interactive mobile media systems.	awareness;computational finance;computer architecture;environment variable;heterogeneous computing;mathematical optimization;middleware;mobile media;operating system;parallel computing;performance per watt;self-awareness	Tobias Becker;Andreas Agne;Peter R. Lewis;Rami Bahsoon;Funmilade Faniyi;Lukas Esterle;Ariane Keller;Arjun Chandra;Alexander Refsum Jensenius;Stephan C. Stilkerich	2012	2012 IEEE 15th International Conference on Computational Science and Engineering	10.1109/ICCSE.2012.56	embedded system;middleware;real-time computing;cloud computing;system of systems;computer science;operating system;middleware;database;distributed computing;mobile computing;intelligent sensor;systems design	HPC	-37.93419823868705	45.843614142295436	137256
7b23374f1337215e30aee2497be2e4a0842bbdde	twist actu: a restful testbed platform for remote experimentation with building automation sensors and actuators	gaussian process model;user preference;ashrae;gaussian process;pmv;thermal comfort sampling	"""The TWIST Actu platform is aimed at extending the capabilities of the TWIST testbed at TU Berlin with support for remote experiments involving building automation sensors and actuators, as part of a wider effort to migrate the testbed from a pure sensor network testbed to one that can also effectively host more challenging cyber-physical system experimental scenarios. In this demo paper we summarize the main features of the hardware and software architecture of TWIST Actu, focusing on the design of the RESTful remote experimentation API that supports a """"Testbed as a Service"""" model of use of the testbed resources. We also present a prototype implementation of the platform and scenario for demonstrating its capabilities."""	as-interface;application programming interface;cyber-physical system;experiment;prototype;representational state transfer;software architecture;testbed	Sunkara Vinodh Kumar;Vlado Handziski	2012		10.1145/2422531.2422571	embedded system;simulation;engineering;computer security	Mobile	-39.38535402797049	45.28611285859848	137354
21ff12d162f2392174d1ad7aff6c379f5032b6e1	supporting reconfigurable security policies for mobile programs	distributed application;security model;dynamic classes;separation of concern;programming model;design and implementation;system design;mobile code;access control;adaptive security policy;program specification;security policy;java	Programming models that support code migration have gained prominence, mainly due to a widespread shift from stand-alone to distributed applications. Although appealing in terms of system design and extensibility, mobile programs are a security risk and require strong access control. Further, the mobile code environment is fluid, i.e. the programs and resources located on a host may change rapidly, necessitating an extensible security model. In this paper, we present the design and implementation of a security infrastructure. The model is built around an event=response mechanism, in which a response is executed when a security-related event occurs. We support a fine-grained, conditional access control language, and enforce policies by instrumenting the bytecode of protected classes. This method enhances efficiency and promotes separation of concerns between security policy and program specification. This infrastructure also allows security policies to change at runtime, adapting to varying system state, intrusion, and other events.  2000 Published by Elsevier Science B.V. All rights reserved.	access control;code mobility;conditional access;distributed computing;extensibility;formal specification;instrumentation (computer programming);run time (program lifecycle phase);separation of concerns;systems design	Brant Hashii;Scott Malabarba;Raju Pandey;Matt Bishop	2000	Computer Networks	10.1016/S1389-1286(00)00075-X	software security assurance;computer security model;cloud computing security;real-time computing;security through obscurity;security information and event management;security engineering;security convergence;covert channel;asset;separation of concerns;computer science;security policy;access control;logical security;operating system;information security standards;security service;application security;distributed computing;distributed system security architecture;programming paradigm;security testing;java;network access control;network security policy;computer security;computer network;systems design	Security	-37.455188587798155	40.79830348183529	137371
024ef1b94f474dedf5045be7532d3fc98f4ec49b	modular timing constraints for delay-insensitive systems	logic design discrete time systems;hoon park anping he marly roncken xiaoyu song ivan sutherland 敏感系统 模块化 时序约束 延迟 时序验证 执行时间 握手协议 电路实现 modular timing constraints for delay insensitive systems;asynchronous circuits;digital integrated circuits design and construction	This paper introduces ARCtimer, a framework for modeling, generating, verifying, and enforcing timing constraints for individual self-timed handshake components. The constraints guarantee that the component’s gate-level circuit implementation obeys the component’s handshake protocol specification. Because the handshake protocols are delayinsensitive, self-timed systems built using ARCtimer-verified components are also delay-insensitive. By carefully considering time locally, we can ignore time globally. ARCtimer comes early in the design process as part of building a library of verified components for later system use. The library also stores static timing analysis (STA) code to validate and enforce the component’s constraints in any self-timed system built using the library. The library descriptions of a handshake component’s circuit, protocol, timing constraints, and STA code are robust to circuit modifications applied later in the design process by technology mapping or layout tools. In addition to presenting new work and discussing related work, this paper identifies critical choices and explains what modular timing verification entails and how it works.	algorithm;challenge-handshake authentication protocol;delay insensitive circuit;design pattern;fits;failure analysis;heuristic (computer science);high- and low-level;library (computing);model checking;nusmv;parsing;static timing analysis;verification and validation	Hoon Park;Anping He;Marly Roncken;Xiaoyu Song;Ivan E. Sutherland	2016	Journal of Computer Science and Technology	10.1007/s11390-016-1613-y	real-time computing;simulation;operating system;computer security;algorithm	EDA	-38.482146610773	32.95733938515171	137567
193c9f941dab936d91c7d0a63cf7e83b0ea2a4ce	a hierarchical domain model for safety-critical cyber-physical systems in process automation	safety process control automation semantics actuators automata;safety critical software factory automation formal verification production engineering computing;semantics;actuators;automata;safety;process control;autonomous reconfiguration decision hierarchical domain model safety critical cyber physical system cps industrial process automation formal verification;automation	Cyber-physical systems (CPS) integrate computation with physical processes. For the last years, CPS have been in the focus of research and are getting adopted in multiple domains like health care, automotive and smart factories. The use of CPS promises dynamic adaption of systems to changing environmental and economic conditions through autonomous CPS decisions based on the physical process. In industrial process automation, research and adoption of CPS have to account for the severe safety restrictions that dominate the system design in this domain. To transfer the benefits of CPS application to process automation, the CPS must be able to formally verify the safety of its autonomous reconfiguration decisions. This paper proposes a domain model for safety-critical CPS in industrial process automation to serve as foundation for formal CPS algorithms.	algorithm;algorithm design;automation;autonomous robot;autonomous system (internet);cp system;child process;computation;cyber-physical system;data model;domain model;manual testing;multitier architecture;sensor;separation of concerns;systems design;vortex	Dirk Kuschnerus;Attila Bilgic;Felix Bruns;Thomas Musch	2015	2015 IEEE 13th International Conference on Industrial Informatics (INDIN)	10.1109/INDIN.2015.7281773	embedded system;real-time computing;systems engineering;engineering;process automation system;cyber-physical system;totally integrated automation	EDA	-43.333626504309095	37.00521857263285	137654
31945c08d8023378153c84f8579874200804df9d	a tmo based approach to structuring real-time agents	time triggered;mobile;real time mobile agent structuring;degradation;timing mobile agents real time systems distributed programming object oriented programming knowledge engineering;chaos;mobile agents;real time;specified timing requirements;distributed computing;high level real time distributed object programming approach;object;object oriented programming;mobile object;timeliness;software engineering;protection;agent;timeliness issues;softwareengineering;distributed objects;timeliness issues real time mobile agent structuring distributed computing software engineering output actions specified timing requirements high level real time distributed object programming approach time triggered message triggered object programming scheme;distributed programming;time triggered message triggered object programming scheme;output actions;cost effectiveness;tmo;distributed computing software engineering;time trigger;mobile agent;mobile agents software engineering timing distributed computing protection chaos laboratories computational efficiency degradation security;computational efficiency;security;structuring;real time systems;timing;knowledge engineering	Mobile agent structuring is an increasingly practiced branch of distributed computing software engineering. In this paper we discuss the major issues encountered in producing real-time (RT) agents which are designed to perform output actions in manners meeting specified timing requirements. An approach to structuring of RT agents which is an extension of a highlevel real-time distributed object programming approach called the Time-triggered Message-triggered Object (TMO) programming scheme, is also presented. The TMO based approach is promising because it provides a sound framework in which timeliness issues can be resolved in cost-effective manners.	distributed computing;distributed object;experiment;malware;mobile agent;real-time clock;real-time computing;real-time transcription;requirement;software engineering;web hosting service	K. H. Kim	2002		10.1109/TAI.2002.1180801	real-time computing;simulation;cost-effectiveness analysis;degradation;computer science;object;mobile technology;knowledge engineering;mobile agent;distributed computing;programming language;object-oriented programming	SE	-36.368677832646796	39.55264405877058	137680
7fe290044bc95dc80ff3c2abf249acaaacaf1156	verifiable parameterised behaviour models - for robotic and embedded systems		Logic-labeled Finite-State Machines (LLFSMs) are Communicating Extended Finite State Machines that execute concurrently but with a predefined sequential schedule. This capacity has enabled effective formal verification. Moreover, LLFSMs are very powerful tools for Model-Driven Software Engineering of the behaviour of robotic and embedded systems. Although existing schedulers are capable of executing several instances of the same model, the challenge is to provide mechanisms for creating parameterised models akin to function calls. Since recent task planning algorithms can synthesise behaviours as LLFSMs with parameters and recursion, it becomes necessary to have a useful operational tool that produces compiled executables for such behaviours. Moreover, parameterisation allows replication of generic system components, reducing overall design complexity. We produce safe mechanisms to set actual and formal parameters for multiple, concurrent instances of the same behaviour. We achieve the parameterisation of behaviour models analogous to a procedural abstraction and discuss its advantages and disadvantages on formal verification.	algorithm;behavioral modeling;compiler;concurrent computing;embedded system;executable;finite-state machine;formal verification;high-level programming language;model-driven engineering;model-driven integration;recursion;robot;runtime verification;software engineering	Vladimir Estivill-Castro;René Hexel	2018		10.5220/0006573903640371	verifiable secret sharing;theoretical computer science;embedded system;finite-state machine;computer science;recursion;executable;formal verification;abstraction	EDA	-39.520024070333484	32.35282548951378	137958
81d18870aae37a38703b4d10a480d471992bd12b	service architectures and dynamic solutions for interoperability of iot, network functions and cloud resources		Within an IoT Cloud application, various subsystems and layers of IoT, edge and cloud infrastructures are involved and we need to make sure that the involved components and data are interoperable w.r.t. data models, protocols and access policies. Such requirements must be addressed by IoT Cloud applications and platforms. Furthermore, such requirements often need to be fulfilled at runtime. Tackling such requirements requires huge effort in software development tasks to ensure interoperable interfaces, protocols and data. At runtime, it is also extremely challenging to orchestrate and configure software services for interoperability under elastic demands. In this work, we show our rsiHub toolset which allows to dynamically provision resource slices of IoT, network functions and cloud services that are interoperable for requirements from IoT Cloud applications. We combine various software architecture models and designs with runtime techniques to leverage diverse types of metadata, software services, and data processing functions to enable and simplify interoperability tasks for IoT Cloud developers and users. We will demonstrate the rsiHub framework together with IoTCloudSamples to show how our toolset will substantially simplify effort in building complex interoperable IoT Cloud designs through several real world examples.	cloud computing;component-based software engineering;data model;interoperability;orchestration (computing);prototype;provisioning;requirement;run time (program lifecycle phase);service-oriented architecture;software architecture;software development	Hong-Linh Truong;Lingfan Gao;Michael Hammerer	2018		10.1145/3241403.3241407	systems engineering;interoperability;metadata;cloud computing;software development;software;software architecture;computer science;data modeling;provisioning;distributed computing	Mobile	-44.90948180089869	41.3312129115822	138000
ab76695ae962fba6629f0d48bb8960fa63e8aa09	realizing optimization opportunities for distributed applications in the middleware layer by utilizing indigo framework	distributed application;optimisation;constraint optimization;multicast algorithms;application software;design optimization;assembly;indigo framework optimization opportunities distributed applications middleware layer;engines;optimisation middleware;number of clusters;middleware;middleware algorithm design and analysis application software engines context design optimization information analysis multicast algorithms constraint optimization assembly;optimal algorithm;information analysis;context;algorithm design and analysis	InDiGO framework provides an infrastructure to develop generic but customizable middleware services. It also provides tools to customize the middleware algorithms for specific applications. Such customization allows one to optimize algorithms by removing communication which is redundant in the context of a specific application. In this paper, we apply InDiGO framework to study a class of bidding distributed applications. In particular, we will study how optimization level is affected by varying several application parameters, such as number of clusters, number of components per cluster, number of clusters with local ordering and number of components per process. The results of this study will help us to answer questions like: What type of application information is useful for optimization in InDiGO framework? or How does the application structure or its size affect the level of optimization? We present experimental results to demonstrate the optimizations when our infrastructure is utilized.	component-based software engineering;distributed algorithm;distributed computing;java;mathematical optimization;middleware;raid;topology optimization	Valeriy Kolesnikov	2010	2010 Ninth International Symposium on Parallel and Distributed Computing	10.1109/ISPDC.2010.31	algorithm design;constrained optimization;application software;real-time computing;multidisciplinary design optimization;computer science;theoretical computer science;operating system;middleware;assembly;distributed computing;data analysis	HPC	-35.691717544961975	45.48600404722813	138021
fc8fc826ff103c1ef1ebad5df68d2a1cf0cb39f6	identification criteria in task modeling	institutional repositories;fedora;vital;vtls;ils	Task modeling consists of a fundamental activity that initiates usercentered design in user interface development. It is therefore important to reach the best task model possible and that the task modeling activity remains consistent when the task modeler changes. For this purpose, this paper introduces a set of criteria in order to identify tasks during task modeling in an unambiguous way that results into a task model exhibiting desired properties of quality such as completeness, consistency. In addition, starting and stopping criteria provide designers with guidance on when and how to start and finish the task modeling.	cameleon;process modeling;task analysis;user interface	Josefina Guerrero García;Jean Vanderdonckt;Christophe Lemaigre	2008		10.1007/978-0-387-09678-0_2	real-time computing;simulation;computer science;operating system;data mining;task analysis	Robotics	-43.12281066862048	34.059945341289506	138238
f98a04eb4b3992184a9caad8a2ae12ece3caab55	a polyhedron approach to calculate probability distributions for markov chain usage models	statistical usage testing;markov chain usage model;software systems;metrics;medical application domain;probability distribution;medical application;profile generation;maximum entropy;state transition;markov chain	Statistical usage testing of hardware/software systems is based in the main on a Markov chain usage model. This kind of model represents the expected use of the system by a usage profile, i.e. appropriate probability values that are attached to the state transitions. In this paper we present a constraint-based polyhedron approach to calculate the probability distribution for the MCUM from a given set of usage constraints. Comparing the computed probability distributions of our polyhedron approach with the maximum entropy technique shows that our result is much closer to the intented constraint semantics. Using the polyhedron method, customer profiles can be calculated so that they reflect the intended system usage of different customers or customer types much better. In order to demonstrate the applicability of our approach, workflow testing of a complex RIS/PACS system in the medical domain was carried through and yielded very promising results.	complex systems;customer relationship management;kl-one;kullback–leibler divergence;markov chain;picture archiving and communication system;polyhedron;principle of maximum entropy;software system;test automation;test case;test plan	Winfried Dulz;Stefan Holpp;Reinhard German	2010	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2010.12.012	probability distribution;markov chain;simulation;computer science;continuous-time markov chain;principle of maximum entropy;theoretical computer science;metrics;software system;variable-order markov model	AI	-45.867464211200044	32.758545376061356	138390
a0585b09e94e972bea1fe9a085e4018e699dbd03	context-aware systems for mobile and ubiquitous networks	context aware application;context aware computing;context awareness;context aware;context information;context awareness context aware services mobile computing ubiquitous computing application software computer architecture intelligent sensors information management power system management remote monitoring;application software;computer architecture;power system management;information management;ubiquitous computing;remote monitoring;context aware systems;mobile computing;intelligent sensors;context aware services	Context awareness is the capability of the networking applications to be aware of the existence and characteristics of the user's activities and environments. In rapidly changing scenarios, such as the ones considered in the fields of mobile, pervasive, or ubiquitous computing, systems have to adapt their behavior based on the current conditions and the dynamicity of the environment they are immersed in. In order to function according to a user's expectation, these systems have to consider the situation, activity, and state of the user and all other relevant entities. Such information is commonly referred to as context. This paper provides an overview of context definitions, architectures for supporting context aware applications, approaches to capture and manage context information and the use of context information in contextaware systems. A number of research challenges in context aware computing are also identified and discussed.	context awareness;context-aware pervasive systems;entity;pervasive informatics;ubiquitous computing	Kavi Kumar Khedo	2006	International Conference on Networking, International Conference on Systems and International Conference on Mobile Communications and Learning Technologies (ICNICONSMCL'06)	10.1109/ICNICONSMCL.2006.68	application software;real-time computing;context-aware pervasive systems;computer science;knowledge management;operating system;information management;mobile computing;world wide web;ubiquitous computing;intelligent sensor;rmon	Robotics	-41.45991339938842	43.970306155705984	138633
bf5a26fd9ca262ffd3018aa2a72b710be350d104	probabilistic model-checking support for fmea	program analysis distritrack automated average case analysis moqa program average case execution time analysis language specification;performance analysis java flow graphs computer science real time systems costs embedded system timing data structures terminology;program diagnostics;automated average case analysis;average case analysis;specification languages program diagnostics;indexing terms;average case execution time analysis;distritrack;specification languages;timing analysis;program analysis;language specification;moqa program	Failure Mode and Effect Analysis (FMEA) is a method for assessing cause-consequence relations between component faults and hazards that may occur during the lifetime of a system. The analysis is typically time intensive and informal, and for this reason FMEA has been extended with traditional model checking support. Such support does not take into account the probabilities associated with a component fault occurring, yet such information is crucial to developing hazard reduction strategies for a system. In this paper we propose a method for FMEA which makes use of probabilistic fault injection and probabilistic model checking. Based on this approach safety engineers are able to formally identify if a failure mode occurs with a probability higher than its tolerable hazard rate.	complex systems;failure cause;failure mode and effects analysis;fault injection;formal specification;hazard (logic);human-readable medium;markov chain;model checking;modeling language;natural language;prism (surveillance program);real-time transcription;specification language;statistical model;system safety;the australian	Lars Grunske;Robert Colvin;Kirsten Winter	2007	Fourth International Conference on the Quantitative Evaluation of Systems (QEST 2007)	10.1109/QEST.2007.18	program analysis;real-time computing;index term;specification language;computer science;database;programming language;programming language specification;static timing analysis	SE	-45.307047652504316	32.77246205199129	138659
0f0e137939011e7388b53517075361274167d5c4	scdiot: social cross-domain iot enabling application-to-application communications		Achieving global interoperability among IoT systems has become a very real possibility due to the heterogeneity at all levels of IoT. Besides achieving interoperability, it will become very important to establish social relationships and communications among IoT devices (or things), humans and applications. Social relationships in IoT have been realized through the Social IoT (SIoT) paradigm which is one of the trending feature in the IoT. The SIoT is currently consisted of two types of communications: things-to-things and things-to-human communications; in addition, we propose social cross-domain IoT (SCDIoT), a third type of SIoT communication at a global level which enables application-to-application communication in the IoT. Although interoperability allows the exchange and reuse of data among various applications, it does not focus on the social relationships among IoT applications through which those applications can closely collaborate with each other. SCDIoT fills this gap by operating one level above interoperability. It allows collaboration among IoT applications by enabling them to talk to each other, building social relations and benefitting from each other via various useful services, truly exploiting the advantages of interoperability. We present the concept of SCDIoT, its logical framework and some potential use case scenarios, together with the challenges and possible future research directions.	interoperability;logical framework;programming paradigm	Yasir Saleem;Noël Crespi;Pasquale Pace	2018	2018 IEEE International Conference on Cloud Engineering (IC2E)	10.1109/IC2E.2018.00068	social relation;logical framework;interoperability;reuse;use case;internet of things;computer science;distributed computing	Mobile	-43.29402834671689	45.99633406334569	138693
3628e1f5763b175a35cbce9c172cb19408ac9a27	executable choreographies applied in operando		The objective of this paper is to present the software architecture used for the OPERANDO privacy platform, funded by the European Union in a Horizon 2020 project. For integration, OPERANDO is using SwarmESB, an open source Enterprise Service Bus (ESB) based on executable choreographies. In this paper we are presenting the concept of service transformations, presented as a bridge between the world of REST web services and the world of services implemented with executable choreographies. These transformations are improving the heterogeneity aspects when we are analysing SwarmESB as a distributed system. Five types of transformations that have been analysed and implemented as open source software have been integrated. This proposal is shaped around a common language capable of expressing all these five transformation types we have identified working for OPERANDO. Therefore, the Domain Specific Language proposed, renders the essential elements for transformations among functions, web services and executable choreographies. This unification will trigger a quantitative effect on the productivity of the teams creating or integrating web services in a federated service bus environment which is a key architectural component in the future Internet-of-Things and cloud systems.	data anonymization;distributed computing;domain-specific language;enterprise service bus;executable;future internet;hypertext transfer protocol;open-source software;privacy platform;rendering (computer graphics);request–response;software architecture;swarm;unification (computer science);web service;whole earth 'lectronic link	Sinica Alboaie;Lenuta Alboaie;Mircea-Florin Vaida;Cristina Olariu	2016	The Computer Science Journal of Moldova		discrete mathematics;theoretical computer science;mathematics;programming language;executable	PL	-47.21048787188199	45.83218131129735	138934
306721030ec02912f4498836d681d6eacab334e9	toward extending aadl-osate toolset with color petri nets (cpns)	analytical models;aadl;formal specification;petri nets automotive engineering aerospace safety system recovery real time systems embedded system performance analysis security availability aerospace electronics;real time embedded system;real time embedded systems analysis;metah;model based engineering;embedded system;model based engineering notation;embedded systems;system recovery;color petri nets;specification languages;architectural analysis and description language;real time embedded systems specification;safety;unified modeling language;eclipse adl aadl color petri nets model based engineering metah osate;safety critical system;real time embedded systems analysis aadl osate toolset color petri nets architectural analysis and description language model based engineering notation open source architectural tool environment real time embedded systems specification;colored petri net;eclipse;architecture analysis;society of automotive engineers;system development;petri nets;specification languages embedded systems formal specification petri nets;formal analysis;osate;open source architectural tool environment;petri net;manufacturing system;adl;aadl osate toolset;open source;real time systems	Architectural Analysis and Description Languages (AADLs), a model-based engineering notation, and its supporting toolset, Open Source Architectural Tool Environment (OSATE) are industry standard under the Society of Automotive Engineering (SAE). AADL-OSATE has shown significant promises in the development of highly sophisticated systems. As such, it has been adopted to specify and analyze real-time embedded systems used in the domain of safety critical systems. By using AADL-OSATE, designers are able to specify, analyze, and/or predicate the system-wide properties such as safety, performance, reliability, security, availability, etc. Examples of application systems developed in AADL-OSATE include avionics and aerospace, and manufacturing system. This main shortcoming of AADL-OSTATE is that it is difficult for analyzing the behaviors of components (processes/threads) in ways that deadlock and/or livelock can be detected. To this end, we are proposing to extent the capabilities of AADL-OSATE modeling notation and supporting tool set with Petri nets in a manner that facilitates formal analysis to verify the absence of deadlock and/or livelock phenomenon.	architecture analysis & design language;avionics;deadlock;embedded system;petri net;real-time clock;selective area epitaxy;technical standard	Hassan Reza;Emanuel S. Grant	2009	2009 Sixth International Conference on Information Technology: New Generations	10.1109/ITNG.2009.246	embedded system;real-time computing;computer science;operating system;petri net	SE	-45.47995887277358	33.55897929520485	139217
4a2be99fd51156b888f44d30a66ff7740dcffb89	from mission planning to flight control of unmanned aerial vehicles: strategies and implementation tools	autonomous vehicle;operant conditioning;real time;unmanned aerial vehicle;adaptive control;intelligent control;mission planning;fault tolerant control;trajectory generation;fault detection;autonomous control;flight control	This paper reviews aspects of unmanned aerial vehicle (UAV) autonomy as suggested by the Autonomous Control Logic chart of the U.S. DoD UAV autonomy roadmap; levels of vehicle autonomy addressed through intelligent control practices and a hierarchical/intelligent control architecture are presented for UAVs. Basic modules of the control hierarchy and their enabling technologies are reviewed; of special interest, from an intelligent control perspective, are the middle and high echelons of the hierarchy. Here, mission planning, trajectory generation and vehicle navigation routines are proposed for the highest level. At the middle level, the control role is portrayed by mode transitioning, envelope protection, real-time adaptation and fault detection/control reconfiguration algorithms which are intended to safeguard the UAV’s integrity in the event of component failures, extreme operating conditions or external disturbances. The UAV thus exhibits attributes of robustness and operational reliability assuring a satisfactory degree of autonomy. The control technologies are demonstrated through flight testing results. # 2005 Elsevier Ltd. All rights reserved.	aerial photography;algorithm;autonomy;brian;computer engineering;control reconfiguration;elegant degradation;failure cause;fault detection and isolation;instrumentation (computer programming);intelligent control;linda (coordination language);real-time clock;swarm;unmanned aerial vehicle;eric	George J. Vachtsevanos;Liang Tang;Graham Drozeski;Luis Gutierrez	2005	Annual Reviews in Control	10.1016/j.arcontrol.2004.11.002	control engineering;embedded system;simulation;real-time control system;adaptive control;computer science;engineering;operant conditioning;control theory;fault detection and isolation;intelligent control	Robotics	-36.61652438524548	37.008469114181686	139218
0652f04f0ccd57501733128ac10709f7f69ac3d4	responsibilities and rewards: specifying design patterns	formal specification;object-oriented programming;design patterns;pattern characterization;pattern formalization;pattern specification;rewards component	Design patterns provide guidance to system designers onhow to structure individual classes or groups of classes, aswell as constraints on the interactions among these classes,to enable them to implement flexible and reliable systems.Patterns are usually described informally. While such informaldescriptions are useful and even essential, if we wantto be sure that designers precisely and unambiguously understandthe requirements that must be met when applyinga given pattern, and be able to reliably predict the behaviorsthe resulting system will exhibit, we also need formalcharacterizations of the patterns.In this paper, we develop an approach to formalizing designpatterns. The requirements that a designer must meetwith respect to the structures of the classes, as well as withrespect to the behaviors exhibited by the relevant methods,are captured in the responsibilities component of the patternýsspecification; the benefits that will result by applyingthe pattern, in terms of specific behaviors that the resultingsystem will be guaranteed to exhibit, are captured in therewards component. One important aspect of many designpatterns is their flexibility; our approach is designed to ensurethat this flexibility is retained in the formalization ofthe pattern. We illustrate the approach by applying it to astandard design pattern.	interaction;requirement;software design pattern	Neelam Soundarajan;Jason O. Hallstrom	2004	Proceedings. 26th International Conference on Software Engineering		unified modeling language;software design pattern;real-time computing;simulation;behavioral pattern;information science;resource allocation;computer science;systems engineering;operating system;formal specification;design pattern;programming language;object-oriented programming;structural pattern;ubiquitous computing;systems design	SE	-41.72115367272261	36.94540323953891	139238
203ea60ff9040c69d6351146a0052e61b14dcaea	development of wireless embedded systems using component based software	j2me;mobile device;component based software;embedded system;design pattern;design patterns;embedded mobile devices;component software	Many mobile and wireless devices are connecting to the Internet nowadays, among them, mobile phones and PDAs are the most popular ones. Thus, in this paper, we will focus on how to develop embedded software running on the two devices by using design patterns and Java based software components. Notably, some components may be used directly in an embedded software system, whereas most components must be specialized prior to reuse. Developers have to identify the variation points on these components. In order to develop a reusable embedded software system, we will identify several variation points with some variants, and introduce some useful design patterns for implementing variation points. Consequently, we can customize an embedded software system just through attaching variants on corresponding variation point in our system. The design patterns we are using are property container, strategy, decorator, and model-view-controller. The component technology we are using is J2ME. J2ME is a specification focused on the development of mobile applications. It provides a similar environment as standard Java environment. J2ME’s components programming includes the Spotlet programming for PDA, and the MIDlet programming for Java phone. In addition, along with the XML, J2ME can also provide the XMIDlet programming for dynamic downloading and execution of XML-based applications for PDA and Java phones.	component-based software engineering;decorator pattern;design pattern;desktop computer;download;embedded software;embedded system;java platform, micro edition;midlet;mobile app;mobile phone;model–view–controller;national supercomputer centre in sweden;personal digital assistant;software system;xml;yang	Stephen J. H. Yang;Jeffrey J. P. Tsai;Irene Y. L. Chen	2002	International Journal of Software Engineering and Knowledge Engineering	10.1142/S0218194002000871	software distribution;embedded system;software design pattern;real-time computing;embedded software;computer science;software design;software framework;component-based software engineering;software development;operating system;software construction;mobile device;embedded java;design pattern;programming language;resource-oriented architecture;software system;avionics software	SE	-35.32004169033256	40.49063816199181	139422
50438bc281250088844d454d12c33ee9a00ee710	towards self-protective multi-cloud applications - musa - a holistic framework to support the security-intelligent lifecycle management of multi-cloud applications	software;multi cloud;security by design;cloud slas;devops;qosec;distributed deployment	The most challenging applications in heterogeneous cloud ecosystems are those that are able to maximise the benefits of the combination of the cloud resources in use: multi-cloud applications. They have to deal with the security of the individual components as well as with the overall application security including the communications and the data flow between the components. In this paper we present a novel approach currently in progress, the MUSA framework. The MUSA framework aims to support the security-intelligent lifecycle management of distributed applications over heterogeneous cloud resources. The framework includes security-by-design mechanisms to allow application self-protection at runtime, as well as methods and tools for the integrated security assurance in both the engineering and operation of multi-cloud applications. The MUSA framework leverages security-by-design, agile and DevOps approaches to enable the security-aware development and operation of multi-cloud applications.	agile software development;application security;cloud computing;dataflow;devops;distributed computing;ecosystem;holism;run time (program lifecycle phase);secure by design	Erkuden Rios;Eider Iturbe;Leire Orue-Echevarria Arrieta;Massimiliano Rak;Valentina Casola	2015		10.5220/0005492905510558	secure by design;computer science;devops;database;application lifecycle management;world wide web	HPC	-44.87103073561738	41.9119833349896	139641
425f2957b18a3af1abb92944feb95d8f0b6620af	a model and design of a fully distributed computing environment for virtual reality	distributed virtual reality;distributed system;multiuser detection;personal communication networks;distributed computing multiuser detection power system modeling computational modeling virtual environment computer architecture personal communication networks workstations costs virtual reality;distributed computing;virtual reality;fully distributed computing environment;software engineering;software engineering virtual reality open systems digital simulation;multiple user distributed simulation system;computer architecture;computational modeling;distributed environment;workstations;distributed virtual environment;distributed computing environment;interoperability;virtual environment;power system modeling;distributed simulation;open systems;high level architecture;digital simulation;interoperability fully distributed computing environment virtual reality multiple user distributed simulation system high level architecture	With the evolution of computing technologies, both PCs and workstations have increased computing power with less cost in the recent years. This paper presents a model and design of a fully distributed virtual reality system, called Multiple User Distributed Simulation (MUDS) system, over a network of low-end computers. MUDS system is designed to provide a virtual environment for both a single user and multiple participants over a fully distributed environment. However, only the method and architecture of building a single user distributed virtual environment is presented in this paper. MUDS system adapts and modifies the concepts from High Level Architecture, which is designed by DoD of US to provide interoperability among distributed simulators. Compared to the other existing distributed systems, MUDS system provides a transparent interface among distributed tasks. The prototype of MUDS system has been successfully built in Institute of Computer Science and Information Engineering, Tamkang University. An experiment of using MUDS system along with the experimental result will also be fully discussed in the paper.	distributed computing environment;virtual reality	Jiung-yao Huang;Chao-Tsong Fang-Tsou;Shuenn-Jyi Wang;Wei-Chyuan Wang	1997		10.1109/RTCSA.1997.629198	simulation;human–computer interaction;computer science;operating system;distributed computing;virtual reality;distributed design patterns;distributed computing environment	HPC	-33.807576205253866	45.12174383681057	140430
1b99452f618dabca00d89b81366366f211e0e52b	a tacoma retrospective	distributed application;wrappers;distributed applications;mobile agent system;design and implementation;agent integrity;mobile code;communication and synchronization of agents;technical report;computer science;mobile agent;weak mobility	For seven years, the Tacoma project has investigated the design and implementation of software support for mobile agents. A series of prototypes has been developed, with experiences in distributed applications driving the effort. This paper describes the evolution of these Tacoma prototypes, what primitives each supports, and how the primitives are used in building distributed applications.	distributed computing;experience;mobile agent;software prototyping	Dag Johansen;Kåre J. Lauvset;Robbert van Renesse;Fred B. Schneider;Nils P. Sudmann;Kjetil Jacobsen	2002	Softw., Pract. Exper.	10.1002/spe.451	embedded system;real-time computing;computer science;technical report;operating system;mobile agent;distributed computing	SE	-33.82054951936006	43.599138600179344	140749
c8d9b28a21b5b19032b2f405dda774f7f931519d	designing autonomic management systems by using reactive control techniques	software;realistic multitier application autonomic management systems reactive control techniques software systems ams software evaluation software measurements ad hoc solutions monitoring data flow emitting flows synchronous programming discrete controller synthesis techniques logical coordination problems;sensor systems;actuators;discrete control;automata;reactive programming autonomic computing coordination discrete control;software performance evaluation software management;programming;autonomic computing;reactive programming;coordination;software programming automata sensor systems actuators	The ever growing complexity of software systems has led to the emergence of automated solutions for their management. The software assigned to this work is usually called an Autonomic Management System (AMS). It is ordinarily designed as a composition of several managers, which are pieces of software evaluating the dynamics of the system under management through measurements (e.g., workload, memory usage), taking decisions, and acting upon it so that it stays in a set of acceptable operating states. However, careless combination of managers may lead to inconsistencies in the taken decisions, and classical approaches dealing with these coordination problems often rely on intricate and ad hoc solutions. To tackle this problem, we take a global view and underscore that AMSs are intrinsically reactive, as they react to flows of monitoring data by emitting flows of reconfiguration actions. Therefore we propose a new approach for the design of AMSs, based on synchronous programming and discrete controller synthesis techniques. They provide us with high-level languages for modeling the system to manage, as well as means for statically guaranteeing the absence of logical coordination problems. Hence, they suit our main contribution, which is to obtain guarantees at design time about the absence of logical inconsistencies in the taken decisions. We detail our approach, illustrate it by designing an AMS for a realistic multi-tier application, and evaluate its practicality with an implementation.	amplitude modulation signalling system;autonomic computing;emergence;high- and low-level;hoc (programming language);management system;multitier architecture;software system;synchronous programming language;vhdl-ams	Nicolas Berthier;Éric Rutten;Noel De Palma;Soguy Mak Karé Gueye	2016	IEEE Transactions on Software Engineering	10.1109/TSE.2015.2510004	programming;real-time computing;simulation;reactive programming;computer science;engineering;software design;software framework;component-based software engineering;software development;operating system;software engineering;software construction;distributed computing;automaton;programming language;software system;autonomic computing;actuator	SE	-41.460697338141856	38.78405023746338	140813
4a0796ca015b7872ea702b7eeaf6e8729d56856f	a general-purpose context modeling architecture for adaptive mobile services	context aware computing;context awareness;context aware;human computer interaction;contextual information;context model;mobile learning;mobile service;levels of abstraction;mobile services	Mobile context-aware computing aims at providing services that are optimally adapted to the situation in which a given human actor is. An open problem is that not all mobile services need contextual information at the same level of abstraction, or care for all aspects of the user’s situation. It is therefore impossible to create a unique context model that is useful and valid for all possible mobile services. In this paper we present a compromise: a three-tiered context modeling architecture that offers high-level mobile services a certain freedom in choosing what contextual parameters they are interested in, and on what abstraction level. We believe the proposal offers context modeling power to a wide range of high-level mobile services, thus eliminating the need for each service to maintain complete context models (which would result in severe modeling redundancy if many services run in parallell). Each mobile service must only maintain those parts of the context model that are applicationdependent and specific to the mobile service in question. We exemplify the use of the context model by discussing its application to a mobile learning system.	abstraction layer;client-side;computation;data validation;exemplification;field research;general-purpose modeling;high- and low-level;human–computer interaction;usability;user experience;utility	Thomas Pederson;Carmelo Ardito;Paolo Bottoni;Maria Francesca Costabile	2008		10.1007/978-3-540-87991-6_26	mobile search;mobile qos;computer science;knowledge management;spatial contextual awareness;multimedia;context model;mobile business development;services computing;world wide web	Mobile	-41.59929272714771	42.994146289399836	140843
2d9c29e8219f463861da2815ea0371fbc78a08be	a modular framework for ambient health monitoring	ambient intelligence;assisted living;medical computing;mobile computing;patient monitoring;personal computing;aal infrastructure components;android;activity recognition;ambient assisted living;ambient health monitoring;comprehensive modular system approach;embedded mobile device sensor;gamification method;healthcare service;heterogeneous context sources;holistic system;intrinsic motivation;lifelogging application;modular framework;personal health record;personalized healthy lifestyle;proactive self-monitoring;stationary sensor networks;virtual sensor;wireless medical device sensor;activity recognition;ambient dynamix;ambient health monitoring;personal health record;smartassist	Ambient Health Monitoring is becoming increasingly important for supporting proactive self-monitoring as part of a healthy lifestyle and as an enabler of appropriate healthcare services in Ambient Assisted Living (AAL). However, the heterogeneity of available context sources and AAL infrastructure components hinders the design of holistic systems. In this paper, we describe a comprehensive modular system approach for integrating heterogeneous context sources, including: stationary sensor networks in AAL infrastructure; wireless medical device sensors; embedded mobile device sensors; as well as virtual sensors. We outline the potential use cases of the system by presenting a prototype lifelogging application for Android, which dynamically integrates several sensor types into a personal health record, with a special focus on activity recognition. The application also demonstrates the usage of gamification methods as a persuasive means of enhancing the intrinsic motivation of users towards a personalized healthy lifestyle.	atm adaptation layer;activity recognition;android;embedded system;gamification;holism;lifelog;mobile device;open-source software;personalization;plug-in (computing);prototype;sensor;stationary process;web application	Daniel Burmeister;Andreas Schrader;Darren Carlson	2013	2013 7th International Conference on Pervasive Computing Technologies for Healthcare and Workshops		embedded system;ambient intelligence;human–computer interaction;computer science;engineering;operating system;remote patient monitoring;multimedia;mobile computing;computer security;activity recognition	Mobile	-42.41254206630255	46.09357060732197	141136
03472e5c0547a0d3d350b1ce5f1fa5da0358ac99	choreographing configuration changes	multi agent systems;system recovery;system recovery configuration management multi agent systems;planning object oriented modeling cloud computing conferences system recovery databases;configuration management;agent model execution configuration changes choreography automatic generation reactive agents computing infrastructure agent interactions deadlock live lock free global constraints goal state agent model generation	This paper describes the automatic generation of a set of reactive agents capable of autonomously reconfiguring a computing infrastructure into a specified goal state. The agent interactions are guaranteed to be deadlock/live-lock free, can preserve pre-specified global constraints during their execution, and autonomically maintain the goal state once it has been achieved. We describe novel algorithms for the generation and execution of the agent model, and evaluate the results on some realistic problems, using a prototype implementation.	autonomic networking;autonomous robot;compiler;deadlock;interaction;non-blocking algorithm;prototype;reliability engineering;single point of failure	Herry Herry;Paul Anderson;Michael Rovatsos	2013	Proceedings of the 9th International Conference on Network and Service Management (CNSM 2013)	10.1109/CNSM.2013.6727828	real-time computing;simulation;computer science;multi-agent system;distributed computing;configuration management	Robotics	-40.5572156040874	38.22631969389519	141176
a8e3e7b7ade93352e33ce1754fc0beb19af8bc31	understanding functional resonance through a federation of models: preliminary findings of an avionics case study	avionics;architectures materielles;socio technical systems;systemes embarques;cryptographie et securite;modelisation et simulation;genie logiciel;modeling approaches;interface homme machine	FRAM has been proposed as a method for the analysis of complex socio-technical systems, which may be able to overcome the limitations of traditional methods that focus on simple cause and effect relationships. FRAM on its own may be most useful for modeling the system at a high level of abstraction. There is less evidence about its utility for modeling interactions at greater levels of detail. We applied different modeling approaches to investigate situations that may give rise to functional resonance in an avionics case study. FRAM was used to model higher-level dependencies, HAMSTERS was used to provide a deeper understanding of human functions, and ICO-Petshop was used to model technical system functions. The paper describes preliminary results of the application of this federation of models, and highlights potential benefits as well as challenges that may have to be overcome.	algorithm;automation;avionics;causality;elegant degradation;ferroelectric ram;heart rate variability;high- and low-level;high-level programming language;human error;ico;interaction;interaction technique;performance evaluation;petri net;resonance;sociotechnical system;software system;spatial variability;user interface	Célia Martinie;Philippe A. Palanque;Martina Ragosta;Mark-Alexander Sujan;David Navarre;Alberto Pasquini	2013		10.1007/978-3-642-40793-2_20	avionics;simulation;engineering;sociotechnical system;operations research	SE	-44.8104235029155	34.791122103228965	141219
ebbf56c59b0442df53be53cc660f47ea3b01656c	non-functional computing: towards a more scientific treatment to non-functional requirements	formal specification finite state machines;formal specification;maintenance;availability;nonfunctional requirements specification;computer model;functional computing;physics computing;non functional requirement;quality of service availability security algorithm design and analysis delay physics computing space technology extraterrestrial measurements safety maintenance;finite state machines;scientific treatment;safety;nonfunctional computing;space technology;quality of service;finite state machine nonfunctional computing scientific treatment nonfunctional requirements specification functional computing;extraterrestrial measurements;security;algorithm design and analysis;finite state machine	Non-functional computing should be developed in parallel with functional computing. In order to do so, a plausible starting point is to examine non-functional attributes of existing computing models. A finite state machine (FSM) specifies one or more accept states.	finite-state machine;non-functional requirement	Kai-Yuan Cai	2007	31st Annual International Computer Software and Applications Conference (COMPSAC 2007)	10.1109/COMPSAC.2007.156	reliability engineering;algorithm design;availability;quality of service;computer science;systems engineering;theoretical computer science;operating system;software engineering;end-user computing;formal specification;database;soft computing;utility computing;space technology;finite-state machine;programming language;computer security;non-functional requirement	HPC	-44.203511391323346	37.03797145354943	141228
95a8e458f3fe7a30fa738f028532f55d3042257d	web computing skeleton: a case study	distributed application;skeleton computer aided software engineering internet web server collaboration java distributed computing collaborative work object oriented modeling application software;single user simulation system web computing skeleton distributed collaborative application execution environmental simulation models internet prefabricated web enabled components web connection maintenance web connection opening;groupware;single user simulation system;collaborative work;application software;collaborative application;collaboration;distributed computing;object oriented programming;distributed collaborative application execution;software engineering;skeleton;environmental science computing;web connection maintenance;computer aided software engineering;internet;environmental simulation models;software engineering internet object oriented programming digital simulation groupware environmental science computing;web connection opening;web server;simulation model;object oriented modeling;prefabricated web enabled components;digital simulation;web computing skeleton;java	In this paper an approach to provide Web-based framework for distributed execution of collaborative applications is presented. The work is a part of a wider ongoing project whose aim is to make environmental simulation models publicly available to the Internet users. The Web computing skeleton has been constructed from prefabricated Web-enabled components with the ability to open and maintain Web connections and provide collaboration over the Internet. The case study illustrates how a single-user simulation system can be embedded in the skeleton, thus becoming widely available distributed application.	distributed computing;embedded system;internet;multi-user;simulation;world wide web	Nikola B. Serbedzija;Louis Botha;A. Abbott;J. Bishop	1997		10.1109/PDSE.1997.596838	web service;web application security;web development;web modeling;data web;web-based simulation;web standards;computer science;software engineering;distributed web crawling;distributed computing;world wide web	Web+IR	-34.316601634489345	43.572626667364666	141239
8d1926b5f9b5b3a7d1b84fdea810a911ed205848	persistent object systems and interoperability: linguistic and architectural requirements		An important aspect of currently developed persistent object systems is support for interoperability with other systems. A central issue in supporting interoperability is achieving type compatibility. We argue that abstraction is also a key interoperability issue. The level of abstraction depends on such features as modularity, encapsulation, orthogonality, minimality, clean and precise semantics, universality, extensibility, type safety and genericity, and others. In the paper we discuss these concepts and some architectures of gateways.	abstraction layer;encapsulation (networking);extensibility;gateway (telecommunications);generic programming;interoperability;modularity (networks);requirement;type safety;type system;universality probability	Kazimierz Subieta	1994			semantic interoperability;interoperability;language interoperability;computer science;systems engineering;database;distributed computing;cross-domain interoperability	PL	-36.38414154430292	42.57068839218798	141373
45dafab08c74e02c00a970cec9cb1c7800048783	fault tolerant sensing model for cyber-physical systems		A sensing system is capable of making decisions by using information captured through physical and virtual objects and providing value added information to enhance its global context awareness. Sensing system forms one of the core components of cyber-physical systems (CPSs) which provide the interface for data collection from physical world and detecting various situations. Thus, it becomes critical to develop sensing model that is fault tolerant towards the failure of components such as sensors and actuators. This will enable realization of CPSs that will continue to run even when the interface to the physical world fails. This research work presents the model for defining sensing model for representing sensors and actuators and creating virtual objects that will enable data regeneration when the physical devices fails. The data regeneration algorithm is based on the virtual instance attributed with contextual details of the deployed physical devices. Fault tolerant systems in an important research area for CPSs and this paper addresses this challenge to enable development of robust and smart CPSs.	as-interface;algorithm;context awareness;cyber-physical system;fault tolerance;sensor	Sudeep Ghimire;João Sarraipa;Carlos Agostinho;Ricardo Jardim-Gonçalves	2017			data collection;fault tolerance;real-time computing;cyber-physical system;context awareness;engineering	HCI	-42.23203688793039	46.063225171238585	141403
44e140fcafdaf52d001cab60cf6c882c3a18069e	handling multiple mode switch scenarios in component-based multi-mode systems	software;switches vehicles runtime software protocols complexity theory;mode switch;protocols;complexity theory;object oriented programming;runtime;based;engineering and technology;teknik och teknologier;software reusability;multi mode based mode switch;vehicles;switches;multi mode;software reusability object oriented programming;single mode switch scenario multiple mode switch scenarios component based multimode systems embedded systems software component based software engineering component reuse software complexity system behavior partitioning mode switch logic msl	The growing complexity of embedded systems software entails new development techniques. Component-Based Software Engineering is undoubtedly suitable for the development of complex systems thanks to its inherent component reuse. Another approach to reduce software complexity is by partitioning the system behavior into different operational modes. Each mode is associated with a unique behavior and the system can change behavior by switching between modes. When such a multi-mode system is developed by reusable software components, a crucial issue is how to achieve a seamless composition of multi-mode components and also how to handle mode switch properly. As an integrated solution to the challenges of multi-mode component-based software system development we have proposed the Mode Switch Logic (MSL). The current version of MSL assumes independent handling of a single mode switch scenario, i.e. that no other mode switch is triggered until an ongoing mode switch is completed. For a wide class of systems, this is an unrealistic assumption. In this paper we lift this assumption by proposing an extension of MSL to handle multiple mode switch scenarios concurrently triggered by different components.	complex systems;component-based software engineering;correctness (computer science);critical system;embedded system;model checking;pdf/a;programming complexity;seamless3d;simulation;software system;third-party software component;timeout (computing);usability;world-system	Yin Hang;Hans A. Hansson	2013	2013 20th Asia-Pacific Software Engineering Conference (APSEC)	10.1109/APSEC.2013.61	embedded system;communications protocol;real-time computing;network switch;computer science;engineering;distributed computing;programming language;object-oriented programming;multi-mode optical fiber	SE	-39.35752299317583	36.019044424817125	141930
0fdff6d1fc604343ff0c7474d30e10580d660d8b	faas: federation-as-a-service		This document is the main high-level architecture specification of the SUNFISH cloud federation solution. Its main objective is to introduce the concept of Federation-as-a-Service (FaaS) and the SUNFISH platform. FaaS is the new and innovative cloud federation service proposed by the SUNFISH project. The document defines the functionalities of FaaS, its governance and precise objectives. With respect to these objectives, the document proposes the high-level architecture of the SUNFISH platform: the software architecture that permits realising a FaaS federation. More specifically, the document describes all the components forming the platform, the offered functionalities and their high-level interactions underlying the main FaaS functionalities. The document concludes by outlining the main implementation strategies towards the actual implementation of the proposed cloud federation solution.	high- and low-level;high-level architecture;interaction;serverless computing;software architecture	Francesco Paolo Schiavo;Vladimiro Sassone;Luca Nicoletti;Andrea Margheri	2016	CoRR		simulation;telecommunications;computer security	Web+IR	-44.84852821470158	42.353415167198584	142051
62b869c26e10118da25868547c530536a76ab2ee	an architectural-level exception-handling system for component-based applications	tolerancia falta;lenguaje programacion;seguridad funcionamiento;forward error recovery;fiabilidad;reliability;surete fonctionnement;fault tolerant;programming language;component based systems;software systems;composant logiciel;sistema complejo;component based software;software architecture;systeme complexe;complex system;fiabilite;fault tolerance;dependability;software component;traitement exception;langage programmation;exception handling;source code;off the shelf;tolerance faute;architecture logiciel;architectural style	Component-based software systems built out of reusable software components are being used in a wide range of applications which have high dependability requirements. In order to accomplish the re- quired levels of dependability, it is necessary to incorporate into these complex systems means for to cope with software faults. Exception han- dling is a well-known technique for adding forward error recovery to soft- ware systems supported by various mainstream programming languages. However, exception handling for component-based applications at the architectural level introduces new challenges which are not addressed by traditional exception handling systems, such as unavailability of source code, specially when off-the-shelf components are employed. In this pa- per, we present an exception handling system which adds fault tolerance to component-based systems at the architectural level. Our solution con- siders issues which are specific to component-based applications, such as unavailability of source code. We also present a framework which im- plements the proposed exception handling system for applications built using the C2 architectural style.	component-based software engineering;exception handling	Fernando Castor Filho;Paulo Asterio de Castro Guerra;Cecília M. F. Rubira	2003		10.1007/978-3-540-45214-0_23	embedded system;complex systems;fault tolerance;real-time computing;computer science;operating system;database;programming language;computer security	Robotics	-45.22424898742886	33.89708772727875	142078
8879c1cfefa0ad6f5c578a5f16ae7100b2717472	a software component model with spatial and temporal compositions for grid infrastructures	scientific application;service orientation;grid component model;programming model;software component;software engineering practices;network of excellence	Grids are very complex and volatile infrastructures that exhibit parallel and distributed characteristics. To harness their complexity as well as the increasing intricacy of scientific applications, modern software engineering practices are needed. As of today, two major programming models dominate: software component models that are mainly based on a spatial composition and service oriented models with their associated workflow languages promoting a temporal composition. This paper tends to unify these two forms of composition into a coherent spatio-temporal software component model while keeping their benefits. To attest the validity of the proposed approach, we describe how the Grid Component model, as defined by the CoreGRID Network of Excellence, and the Askalon-AGWL workflow language have been adapted.	component-based software engineering	Hinde-Lilia Bouziane;Christian Pérez;Thierry Priol	2008		10.1007/978-3-540-85451-7_75	software sizing;common component architecture;computer science;social software engineering;component-based software engineering;software development;operating system;software construction;database;distributed computing;programming paradigm;programming language	Robotics	-39.88414265185606	41.634462264644306	142095
564546189070028f6652089cb4e59af92a389dfb	aircraft fuel management reconfigurable system with smart components for distributed decision	distributed system;avionics;aircraft control;reconfigurable systems;reconfigurable system;control distribution concept aircraft fuel management reconfigurable system smart components distributed decision avionic distributed control systems fuel management systems flight testing distributed system;distributed control system;actuators;aircraft fuels aerospace electronics valves distributed control intelligent sensors automatic control control systems testing intelligent actuators;automata;control problem;fuel management;smart components;fuels;aerospace electronics;avionic systems;valves;intelligent materials;distributed control;helicopters;aircraft;reconfigurable systems avionic systems smart components distributed control;intelligent materials aircraft control avionics distributed control	This papers introduces a current research on avionic distributed control systems, using smart components. The research focus on fuel management systems. The nearest experimental target is real flight testing into three years. For safety reasons the new distributed system has to react with pertinent reconfigurations when there are problems in the system, as detected by the smart components. Likewise, it is possible that the fuel plant changes, for instance when extra tanks are added, so the distributed control system has to reconfigure its functionality. The specific experimental platform for the research is an helicopter. The paper describes the control problem, the control distribution concept, the smart components, and the present research for reconfiguration.	distributed computing;distributed control system;reconfigurable computing;relevance;smart card	José Maria Giron-Sierra;Santiago Cifuentes;Juan F. Jiménez;Miguel A. Seminario;Carlos C. Insaurralde	2008	2008 10th International Conference on Control, Automation, Robotics and Vision	10.1109/ICARCV.2008.4795752	avionics;control engineering;embedded system;computer science;engineering;automotive engineering;control theory;distributed control system;automaton;actuator	Robotics	-35.521301318053084	36.455235218757394	142109
5ec80b4d8aceb67129ca9ef81b750c3f8d4aaab3	testing of communicating systems	communicating systems	Following the success of CORBA based systems the OMG has standardized the CORBA Component Model (CCM) to improve the implementation process of large distributed systems. The European project COACH [16] has been set up to build an Open Source development platform to construct CCM applications. As part of COACH a toolset for CCM components and system testing has been defined and implemented. This paper introduces the various components and features which have been foreseen and implemented for test activities such as interactive component testing, test trace visualization, or the application of abstract test specifications. The resulting test infrastructure addresses the CCM specifics but also benefits from CCM, e.g. by incorporating component communication facilities.	common object request broker architecture;distributed computing;system testing;unit testing	Jan van Leeuwen;Roland Groz;Robert Mark Hierons	2004		10.1007/b95741	computer science	SE	-48.228333274943886	34.5034482709256	142666
3afb42306446114b7587834dcb16a42513440957	observation based creation of minimal test suites for autonomous vehicles		Autonomous vehicles pose new challenges to their testing, which is required for safety certification. While Autonomous vehicles will use training sets as specification for machine learning algorithms, traditional validation depends on the system&#x2019;s requirements and design.The presented approach uses training sets which are observations of traffic situations as system specification. It aims at deriving test-cases which incorporate the continuous behavior of other traffic participants. Hence, relevant scenarios are mined by analyzing and categorizing behaviors. By using abstract descriptions of the behaviors we discuss how test-cases can be compared to each other, so that similar test-cases are avoided in the test-suite. We demonstrate our approach using a combination of an overtake assistant and an adaptive cruise control.	algorithm;autonomous robot;categorization;linear temporal logic;machine learning;mined;requirement;sensor;simulation;test case;test engineer;vissim	Christian Wolschke;Thomas Kuhn;H. Dieter Rombach;Peter Liggesmeyer	2017	2017 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)	10.1109/ISSREW.2017.46	computer science;reliability engineering;real-time computing;simulation;certification;system requirements specification;cruise control	SE	-46.02683766613926	35.60198051313878	142790
7bf71b36243540710fa5f216539d82839a4bdff6	a runtime composite service creation and deployment infrastructure and its applications in internet security, e-commerce, and software provisioning	runtime service creation;electronic commerce;e commerce;security association;software engineering;internet;service creation;software engineering internet security of data electronic commerce;component oriented programming runtime composite service creation and deployment infrastructure internet security e commerce software provisioning user defined security associations;runtime web and internet services application software computer architecture computer security systems engineering and theory formal languages reflection computer languages;internet security;security of data;dynamic service composition;software composition	The creation of composite services from service components at runtime can be achieved using several different techniques. In the first approach, a new common interface is constructed at runtime which allows the functionality of two or more components to be accessed from a single entity while the service components themselves remain distinct and potentially distributed within in a network. In the second approach, a new composite service is formed where all of the functionality of the service components is housed within a single new service. In the third approach, a new composite service is formed where all the functionality of the service components is extracted and re-assembled into the body of a single new service. The paper describes the design of an infrastructure to support the runtime creation of composite services. An application to create user-defined security associations dynamically and deploy them between any two points in the Internet is presented to exemplify the need for dynamic service composition techniques. Some other potential applications in e-commerce and software provisioning are also discussed.	e-commerce payment system;internet security;provisioning	David Mennie;Bernard Pagurek	2001		10.1109/CMPSAC.2001.960641	e-commerce;software security assurance;service level requirement;the internet;security association;differentiated service;computer science;service delivery framework;service design;software as a service;internet security;database;security service;function composition;world wide web;computer security	OS	-46.28236037778032	44.540413241526615	142836
5c8c62e778fca640f9a23756f32db8f912148e63	specification and verification of real-time embedded systems using time-constrained reactive automata	formal specification;formal objects;specification;time constrained reactive automata;verification process real time embedded systems time constrained reactive automata specification causal computation tra formalism formal objects;real time embedded system;tra formalism;program verification;causal computation;physics computing;real time embedded systems;embedded system;automata;specification and verification;monitoring;verification process;real time systems automata theory formal specification program verification;aerospace electronics;automata theory;explosions;real time systems embedded system automata embedded computing aerospace electronics physics computing communication system control computer science monitoring explosions;computer science;communication system control;embedded computing;real time systems	The vital role that real time embedded systems are playing and will continue to play in our world coupled with their increasingly complex and critical nature de mand a rigorous and systematic treatment that recog nizes their unique requirements The Time constrained Reactive Automaton TRA is a formal model of com putation that admits these requirements Among its salient features is a fundamental notion of space and time that restricts the expressiveness of the model in a way that allows the speci cation of only reactive spon taneous and causal computations Using the TRA for malism there is no conceptual distinction between a system and a property both are speci ed as formal ob jects This reduces the veri cation process to that of establishing correspondences namely preservation and implementation relationships between such objects In this paper we present the TRA model and brie y overview our experience in using it in the speci cation and veri cation of real time embedded systems	automaton;causal filter;computation;embedded system;formal language;our world;real-time clock;real-time computing;requirement;risk assessment	Azer Bestavros	1991		10.1109/REAL.1991.160380	embedded system;real-time computing;computer science;theoretical computer science;automata theory;formal specification;distributed computing;automaton;specification	Embedded	-37.772584583271254	32.60852428620753	142887
9a7347f2fc72407341370fc612bab278e512e45b	adaptivity to enable an efficient and robust human intranet		The Human Intranet is envisioned as an open, scalable platform that seamlessly integrates an everincreasing number of sensing, actuation, computation, storage, communication, and energy nodes located on, in, or around the human body, acting in symbiosis with the functions provided by the body itself. The limited amount of available energy and the critical nature of its applications require such a network to be extremely efficient and robust. This paper introduces a learning-based adaptive network structure to overcome these challenges. The adaptive structure is implemented and tested in two sample scenarios, and the results are reported.	adaptive architecture;central processing unit;complex adaptive system;computation;intranet;open platform;requirement;robustness (computer science);scalability	Ali Moin;Arno Thielens;Álvaro Araujo;Jan M. Rabaey	2018	CoRR		intranet;distributed computing;computation;scalability;computer science;available energy	Mobile	-39.518055801862396	45.85643528955098	142923
98e2b2015522573ecf26e32e1bd5833891d5df11	supporting the extraction of timed properties for passive testing by using probabilistic user models	probabilistic formal models;user modelling;complex software system;formal specification;system testing data mining software testing software quality software systems performance evaluation time factors runtime formal specifications humans;formal model;probabilistic knowledge;user modelling formal specification program testing software quality software reliability;software systems;formal methods;system under test;testing;data mining;formal method;automata;probabilistic user model;adaptation model;timed properties;program testing;probabilistic logic;passive testing;software reliability;formal method timed properties passive testing probabilistic user model software quality software reliability complex software system probabilistic knowledge system under test;software quality;asynchronous transfer mode;user model;data models;probabilistic formal models passive testing formal methods	Testing is one of the most widely used techniques to increase the quality and reliability of complex software systems. In this paper we extend our previous work on passive testing with invariants to incorporate (probabilistic) knowledge obtained from users of the system under test. In order to apply our technique, we need to obtain a set of invariants compiling the relevant properties of the system under test, and this is a time-intensive task. We present a novel approach to extract invariants from a specification, based on the idea that an invariant is better than another one if it can be checked more times in a given log. We present a formal approach where probabilistic user models are incorporated.	algorithm;compiler;data mining;database;interaction;invariant (computer science);software system;system under test;tracing (software);user experience;user modeling	César Andrés;Mercedes G. Merayo;Manuel Núñez	2009	2009 Ninth International Conference on Quality Software	10.1109/QSIC.2009.27	reliability engineering;formal methods;computer science;theoretical computer science;software engineering;database;software quality	SE	-45.759973547442414	32.47695711635879	142925
e6314f725d7771ed54dd8ba71ce1de04b714753a	relspec: a framework for early reliability refinement of embedded applications	reliability;automotive case studies early reliability refinement design flow relspec safety critical embedded application automatically constructed intermediate probabilistic models;specification;embedded systems;specification reliability embedded systems;probabilistic logic reliability engineering computational modeling analytical models markov processes standards;software reliability automotive engineering embedded systems probability safety critical software	The increasing complexity of safety-critical embedded applications have made it imperative to specify and analyze reliability upfront in the design flow so that reliable systems can be automatically synthesized adhering to such descriptions. This paper develops a framework, RELSPEC, to express the reliability of a safety-critical embedded application at an early-stage of the design flow and enables the reliability analysis leveraging automatically constructed intermediate probabilistic models of the system. Further, our analysis provides a mechanized way to refine the reliability in order to meet a target reliability value of the overall system. Experiments over few automotive case-studies show the efficacy of this methodology.	design flow (eda);embedded system;experiment;imperative programming;prism (surveillance program);refinement (computing);verification and validation	Saurav Kumar Ghosh;Aritra Hazra;Soumyajit Dey	2015	2015 28th International Conference on VLSI Design	10.1109/VLSID.2015.12	reliability engineering;real-time computing;computer science;systems engineering;reliability;specification;statistics	EDA	-43.48019593031874	33.1904393188871	142966
7c66bc22008e8c09527d8ac3ddd757f03b91fe24	self-expression and dynamic attribute-based ensembles in scel	self expression;coordination patterns;ensemble computing;qa75 electronic computers computer science	In the field of distributed autonomous computing the current trend is to develop cooperating computational entities enabled with enhanced self-* properties. The expression self-* indicates the possibility of a component inside an ensemble, i.e. a set of collaborative autonomic components, to self organize, heal (repair), optimize and configure with little or no human interaction. We focus on a self-* property called self-expression, defined as the ability to deploy run-time changes of the coordination pattern of the observed ensemble; the goal of the ensemble is to achieve adaptivity by meeting functional and non-functional requirements when specific tasks have to be completed. The purpose of this paper is to rigorously present the mechanisms involved whenever a change in the coordination pattern is needed, and the interactions that take place. To this aim, we use SCEL (Software Component Ensemble Language), a formal language for describing autonomic components and their interactions, featuring a highly dynamic and flexible way to form ensembles based on components’ attributes.	autonomic computing;autonomous robot;component-based software engineering;entity;formal language;functional requirement;interaction;non-functional requirement;pattern language;self-organization	Giacomo Cabri;Nicola Capodieci;Luca Cesari;Rocco De Nicola;Rosario Pugliese;Francesco Tiezzi;Franco Zambonelli	2014		10.1007/978-3-662-45234-9_11	computer science;artificial intelligence;theoretical computer science;machine learning	AI	-41.368853034083024	37.59853700991875	142988
cfc14adbc6333ac07b6f067f015a9a614875f7ff	requirements-driven dynamic adaptation to mitigate runtime uncertainties for self-adaptive systems		Self-adaptive systems are capable of adjusting their behavior to cope with the changes in environment and itself. These changes may cause runtime uncertainty, which refers to the system state of failing to achieve appropriate reconfigurations. However, it is often infeasible to exhaustively anticipate all the changes. Thus, providing dynamic adaptation mechanisms for mitigating runtime uncertainty becomes a big challenge. This paper suggests solving this challenge at requirements phase by presenting REDAPT, short for REquirement-Driven adAPTation. We propose an adaptive goal model (AGM) by introducing adaptive elements, specify dynamic properties of AGM by providing logic based grammar, derive adaptation mechanisms with AGM specifications and achieve adaptation by monitoring variables, diagnosing requirements violations, determining reconfigurations and execution. Our approach is demonstrated with an example from the Intelligent Transportation System domain and evaluated through a series of simulation experiments.	adaptive system;algorithm;behavior model;belief revision;consistency model;experiment;failure;feedback;requirement;run time (program lifecycle phase);runtime verification;simulation	Zhuoqun Yang;Wei Zhang;Haiyan Zhao;Zhi Jin	2017	CoRR		real-time computing;simulation;engineering	SE	-41.58477500820697	38.14129207680313	143125
07a14efba7fe0b7c6732b427e0982b3dd7388ef4	towards runtime reconfiguration of application control policies in the cloud	dynamic reconfiguration;rule based;cloud;service behavior;application governance	The main contribution of this paper is the description of an architecture for dynamically controlling the behavior of the applications deployed in the Cloud by using a set of high-level rules. This architecture is flexible enough to enable the re-definition of behavior policies at runtime. This makes it possible to adapt the behavior of applications after deployment. It is also able to manage different cloud providers. This architecture has been implemented and the most relevant details of such implementation are also covered in this paper. Moreover, some use cases are also explained in order to provide a better description of the advantages of the proposed architecture.	abstraction layer;business rules engine;cloud computing;domain model;experiment;extensibility;high- and low-level;introspection;java naming and directory interface;java transaction api;lookup table;multitier architecture;open-source software;plug-in (computing);prototype;rete algorithm;rule interchange format;run time (program lifecycle phase);scalability;software deployment;system administrator;transaction processing;virtual appliance;web container	Luis Miguel Vaquero Gonzalez;Daniel Morán;Fermín Galán Márquez;Jose M. Alcaraz Calero	2012	Journal of Network and Systems Management	10.1007/s10922-012-9251-3	rule-based system;real-time computing;simulation;cloud computing;computer science;distributed computing	OS	-40.06337323703798	41.0856115681797	143132
01e91e0d9dc65ec5b23b2f451c1423ab7e1772ab	here's your lego tm security kit: how to give developers all protection mechanisms they will ever need	building block;web service;middleware	The main premise of this paper is that the developers and owners of distributed applications need and can be provided with three things: 1) Lego -like reusable and versatile building blocks, 2) middleware architectures and tools for composing useful customized solutions out of such blocks, and 3) the means of creating their own inexpensive and error-proof building blocks. They could then create custom distributed applications suitable to their needs and environments, while avoiding costly reinvention and reconstruction of generic and, more often than not, quite complex functionality common across applications. And we are not referring to the business logic, which could arguably be included in the list. The focus is on the nonfunctional properties and services (fault tolerance, performance, security, etc.) of distributed applications. The above needs have been determined from the author’s experience of working for end-user, consulting, and vendor organizations. Working on the end-user side showed that no vendor could ever satisfy all requirements for customizing their solutions to our needs and constraints. Vendors’ customization mechanisms required too much effort and expertise from in-house developers. Experience as a consultant, product developer and architect gave convincing evidence that this problem was common to many end-user organizations. To demonstrate that useful building blocks, architectures, and extension means can indeed be provided for customizing nonfunctional properties of distributed applications without demanding seasoned expertise in the subject matter from application developers, we present an authentication and authorization (A &A) architecture for ASP.NET Web services. This architecture, we believe, features all three desired characteristics. It builds on the results of several years of applied research and practical Abstract. By presenting a protection architecture for ASP.NET Web services, this paper demonstrates the feasibility of creating middleware mechanisms in the form of composable, flexible, and extensible building blocks. Like Lego constructor parts, such blocks enable the reduction of the effort of constructing, extending, and adjusting the application properties and middleware services in response to requirements or environment changes.	asp.net;authentication;authorization;business logic;distributed computing;fault tolerance;middleware;requirement;subject matter expert turing test;web service	Konstantin Beznosov	2004		10.1007/11407386_2	web service;embedded system;middleware;computer science;operating system;middleware;world wide web	OS	-45.17495142081609	41.942887804493544	143194
029b382d8b6a0143edf8e88e32a03d5b532a3fb0	design framework for ambient assisted living platforms	quality of life;user interface;ambient intelligence;ambient assisted living;wireless sensor network;adaptive interface;design framework;adaptative interfaces;wireless sensor networks	Nowadays the new technological advances offer the possibility to provide a great number of different personalized services that cover the needs of diverse categories of users. The application of the Ambient Intelligence (AmI) paradigm and the Ambient Assisted Living (AAL) concept makes possible the creation of new applications that can significantly improve the quality of life of elderly and dependant people. This paper presents an interaction framework that provides a new generation of user interfaces for AAL services in the context of an AmI-based platform. This solution aims to develop the technological context where elderly and dependant citizens can increase their life independence.		Patricia Abril-Jiménez;Cecilia Vera-Muñoz;María Fernanda Cabrera-Umpiérrez;María Teresa Arredondo;Juan-Carlos Naranjo	2009		10.1007/978-3-642-02710-9_16	simulation;ambient intelligence;engineering;multimedia;world wide web	Robotics	-42.11316615116306	45.226050992495644	143248
93370a6f26b858090d16052484b3b4e078e67bb0	implementing flexible object group invocation in networked systems	distributed application;teleconferencing;intelligent networks electrical capacitance tomography fault tolerant systems identity based encryption local area networks wide area networks middleware context aware services availability collaboration;client server systems;high latency wan flexible object group invocation networked systems object group service multiple servers group to group request reply flexible corba object group service low latency lan;low latency;design and implementation;distributed object management;networked systems;local area networks;wide area networks teleconferencing distributed object management client server systems local area networks;wide area networks	Distributed applications should be able to make use of an object group service in a number of application specific ways. Three main modes of interactions can be identified: (i) request-reply: a client issues a request to multiple servers and waits for their replies; this represents a commonly occurring scenario when a service is replicated; (ii) group-to-group request-reply: a generalisation of the previous case, where clients are themselves groups; and (iii) Peer Participation: here all the members are regularly multicasting messages (asynchronous invocation); this represents a commonly occurring scenario when the purpose of an application is to share information between members, (e.g., a teleconferencing application). Customisation within each class of interaction is frequently required for obtaining better performance. This paper describes the design and implementation of a flexible CORBA object group service that supports the three types of interactions and enables application specific customisation. Performance figures collected over low latency LAN and high latency WAN are presented to support the case for flexibility.	client (computing);common object request broker architecture;interaction;multicast;personalization;request–response;waits	Graham Morgan;Santosh K. Shrivastava	2000		10.1109/ICDSN.2000.857573	local area network;real-time computing;teleconference;computer science;operating system;dynamic invocation interface;common object request broker architecture;distributed computing;world wide web;computer security;computer network;low latency	Mobile	-34.3589737313271	43.82787963648277	143269
c3546012059bb4c925c6cb8debc349892cb3ea98	software methodologies for vhdl code static analysis based on flow graphs		At a high level of abstraction, the VHDL specification of the functionalities that a circuit shall perform is given by defining the behavioral model. The similarity with procedural programming languages suggested to tailor some software analysis techniques to VHDL behavioral description analysis. The paper presents several analyses of the code, based on data flows, aimed at identifying significant properties of the final circuit from the synthesis and testability points of view.	behavioral modeling;high-level programming language;procedural programming;software testability;static program analysis;vhdl	Donatella Sciuto;Luciano Baresi;Cristiana Bolchini	1996			behavioral modeling;data flow diagram;computer architecture;computer science;theoretical computer science;software analysis pattern;signal processing;procedural programming;hardware description language;data analysis;programming language;static analysis;software development process	SE	-48.07279243755542	33.093944150234805	143282
92a57230d3745c159d8e660dfa82fa86f08ff3a1	an approach for describing concurrency and communication of heterogeneous systems	heterogeneous systems;uml;development process;model based engineering;mbe;top cased;levels of abstraction;theory of computation;time to market;design space exploration;model of computation;cometa;java;open source	The fast development of technology and the time-to-market constraints need well-adapted technical support and development processes to ease design space exploration and the reduction of the productivity gap. Model Based Engineering (MBE) overcomes the increasing complexity of system being highly heterogeneous and integrating concurrent sub-systems. Elsewhere, Models of Computation (MoC) help enforcing MBE with aspects related to the execution semantics of models. In a previous paper, we introduced a language called Cometa providing more expressiveness for these aspects. It allows the capture and analysis of several MoCs at high level of abstraction, highlighting communication and synchronization among parts of a heterogeneous system. The language was tooled in Rhapsody and tested on an industrial case. In this paper, we present the key concepts of the Cometa language and the tooling experiments of Cometa in an open source environment. The objective of this approach is being able to model heterogeneous systems, but also to broaden the scope of the language tooling, by taking benefits from an open source environment.	apple rhapsody;complexity;computation;concurrency (computer science);design space exploration;experiment;high-level programming language;open-source software;technical support	Papa Issa Diallo;Joël Champeau;Vincent Leilde	2011		10.1145/1993956.1993964	real-time computing;computer science;theoretical computer science;distributed computing	SE	-41.49351716013162	32.3314895405147	143707
1930996ceb39687c8509473f9cc37e90d4767cc8	using association aspects to implement organisational contracts	software systems;swinburne;contracts;dynamic environment;organisational structure;association aspects;coordination;coordinate system	The maintenance of organisation is a prerequisite for all viable systems in dynamic environments. In many living systems this organisation is, in part, achieved through coordination systems such as the nervous or endocrinic systems that can be seen as separate from the functional systems they coordinate. As software systems become more open and complex, the definition of separate organisational structures may prove a useful way to maintain their viability while managing their complexity. In this paper we show how a coordination system can be implemented as a separate concern, and posterior, to the definition of the functional system it controls and regulates. Such functional systems are loosely coupled collections of roles played by objects. We show how association-aspects can be used to create contracts that bind these roles together into an organisation. These contracts regulate the flow of control through a structure of roles in the organisation, and allow performance to be specified and monitored. These contracts also bind clusters of roles into self-managed composites — each composite with its own organiser role. The organiser roles can control, create, abrogate and reassign contracts. This ability enables organisers to reconfigure the system in response to changes in external conditions or changes in performance requirements.	arbitrary code execution;aspectj;compiler;complexity;control flow;interaction;library (computing);living systems;loose coupling;overhead (computing);requirement;software system;type signature;viz: the computer game	Alan W. Colman;Jun Han	2006	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2006.03.004	organizational structure;simulation;coordinate system;software system	PL	-41.62627159832484	38.872087217909254	143788
f18264245f26c8fae8ed56a0224fc935639db404	an ontology-driven semantic bus for autonomic communication elements	networks;performance evaluation;autonomic communications;autonomic control loops;autonomic elements;semantic communications bus;message oriented middleware;large scale;technology and engineering;design;autonomous control	Recently, autonomics have been proposed as a solution to tackle the ever-increasing management complexity of large-scale computing and communications infrastructures. Over time, the control loops used to orchestrate the intelligent behaviour of autonomic management architectures have evolved from fully static to highly-dynamic loops comprised of loosely coupled management components. Communication and other interactions between these components is facilitated by a communications substrate. Additionally, in order to achieve truly autonomic behaviour, the interacting components need to be able to understand each other, justifying the need for semantically enriched communications. In this paper, we present a novel semantic communications bus that orchestrates interactions between the components of an autonomic control loop. It employs ontology-based reasoning in order to establish communication contracts, validate message consistency and support semantic topic subscriptions. Additionally, a prototype was designed, implemented and its performance evaluated.	algorithm;automated reasoning;autonomic computing;control flow;control system;interaction;loose coupling;osgi;overhead (computing);performance evaluation;prototype;publish–subscribe pattern	Jeroen Famaey;Steven Latré;John Strassner;Filip De Turck	2010		10.1007/978-3-642-16836-9_4	embedded system;design;real-time computing;computer science;engineering;message oriented middleware;operating system;database;distributed computing;computer security;autonomic computing	SE	-41.11449981242029	40.12228877862262	143829
6ad255006075bfe1e13dce2d96f2d0bf829325e3	from verification to implementation: a model translation tool and a pacemaker case study	model verification;validation verification;real time systems approximation theory automata theory formal verification program compilers program interpreters program testing;design and development;clocks;bepress selected works;model translation;integrable system;model based development model translation medical devices validation verification real time systems;program interpreters;uppaal model translation tool pacemaker case study model driven design cyber physical systems design procedures formal modeling real time system model verification simulation based testing physical implementation model translation tool upp2sf system modeling system verification model based wcet analysis code generation code testing mdd based framework timed automata based models cardiac pacemaker stateflow chart;code generation;semantics;pacemakers;testing;medical devices;cyber physical systems;design rules;approximation theory;automata;cost accounting;formal verification;program testing;model development;model based development;clocks automata modeling cost accounting testing semantics pacemakers;automata theory;timed automata;program compilers;modeling;large classes;real time systems	Model-Driven Design (MDD) of cyber-physical systems advocates for design procedures that start with formal modeling of the real-time system, followed by the model's verification at an early stage. The verified model must then be translated to a more detailed model for simulation-based testing and finally translated into executable code in a physical implementation. As later stages build on the same core model, it is essential that models used earlier in the pipeline are valid approximations of the more detailed models developed downstream. The focus of this effort is on the design and development of a model translation tool, UPP2SF, and how it integrates system modeling, verification, model-based WCET analysis, simulation, code generation and testing into an MDD based framework. UPP2SF facilitates automatic conversion of verified timed automata-based models (in UPPAAL) to models that may be simulated and tested (in Simulink/State flow). We describe the design rules to ensure the conversion is correct, efficient and applicable to a large class of models. We show how the tool enables MDD of an implantable cardiac pacemaker. We demonstrate that UPP2SF preserves behaviors of the pacemaker model from UPPAAL to State flow. The resultant State flow chart is automatically converted into C and tested on a hardware platform for a set of requirements.	approximation;artificial cardiac pacemaker;automata theory;code generation (compiler);cyber-physical system;downstream (software development);executable;flowchart;model-driven engineering;model-driven integration;real-time clock;real-time computing;requirement;resultant;simulation;simulink;systems modeling;timed automaton;uppaal;worst-case execution time	Miroslav Pajic;Zhihao Jiang;Insup Lee;Oleg Sokolsky;Rahul Mangharam	2012	2012 IEEE 18th Real Time and Embedded Technology and Applications Symposium	10.1109/RTAS.2012.25	embedded system;integrable system;real-time computing;simulation;systems modeling;formal verification;computer science;theoretical computer science;operating system;automata theory;semantics;automaton;software testing;programming language;cyber-physical system;code generation;cost accounting;approximation theory	Embedded	-40.7983556887313	32.44350128663975	143921
7e87de4a647af102c6f03b4654858c18e546ecd7	a tree-based reliability model for composite web service with common-cause failures	common cause failure;composite web service;fault tolerant;statistical independence;reliability modeling;web service;reliability model	Reliability is one of the most important quality dimensions for web services. Current reliability models for composite web service assume the statistical independence of its component web services, which is often not the case. In this paper, we research on the reliability correlation of component web services by identifying common-cause failures (CCF) and propose a tree-based reliability model for composite web service. We also present the method to estimate overall reliability of composite web service based on our reliability model. Evaluation shows that our method can improve the accuracy of reliability estimation for composite web service and is particularly valuable when designing fault-tolerant service-based system.	fault tolerance;microsoft customer care framework;service composability principle;web service	Bo Zhou;Keting Yin;Shuai Zhang;Honghong Jiang;Aleksander J. Kavs	2010		10.1007/978-3-642-13067-0_44	web service;independence;reliability engineering;availability;fault tolerance;computer science;database;law;world wide web	Web+IR	-48.03782734711804	40.40046495414348	143970
16eed54c4052faadb955b1add9e08d523cc44961	mission control by coordinating shared resources	cooperative control;job shop scheduling algorithm design and analysis petri nets roads state space methods systems engineering and theory design methodology space missions scheduling algorithm testing;mission control problem;scheduling discrete event systems petri nets resource allocation;mission system;resource allocation;resource management;test bed;multiple hoist scheduling mission control problem coordination algorithm mission system resources sharing event driven aspect;control problem;discrete event system;scheduling;discrete event systems;resources sharing;multiple hoist scheduling;petri nets;petri net;coordination algorithm;event driven aspect;design methodology	The paper presents a design methodology for coordination algorithms which enhance the overall autonomy of a mission system by synchronizing the functionalities of the subsystems through shared resources including space. The planning and the event-driven aspects of the mission control problem are solved by prebooking and scheduling of requests for resources. The algorithm is represented as Petri net, implemented in a mission test bed and applied for multiple hoist scheduling in manufacturing	algorithm;autonomy;coherence (physics);event-driven programming;javascript syntax;mission control;petri net;scheduling (computing);testbed	Wolfgang Meyer;Claudia Fiedler	2006	2006 IEEE/SMC International Conference on System of Systems Engineering	10.1109/SYSOSE.2006.1652276	real-time computing;computer science;resource management;operating system;distributed computing;petri net	Robotics	-35.09222160049825	35.53717612498985	144202
0fb74e69903b1836862ed5dfd38cfc7027a4f5f3	on tasks synchronization with the mms protocol	distributed environment;programmable logic controller	The MMS protocol is a powerful tool for communication as well as for synchronization between manufacturing equipment such as robots, programmable logic controllers, etc. This paper shows how the MMS services can be used to handle tasks synchronization in a distributed environment. The MMS weaknesses regarding temporal aspects and possible directions to alleviate these weaknesses are also presented.	robot;synchronization (computer science)	Justin N. Akazan;Zoubir Mammeri	1995	Real-Time Systems	10.1007/BF01088808	embedded system;real-time computing;computer science;programmable logic controller;distributed computing;distributed computing environment	Embedded	-35.094642011666664	37.32709576180435	144320
7f4dd8d01682a89fb36edd917694164b9a5201ed	smart messages: a distributed computing platform for networks of embedded systems	virtual machine;shared memory;distributed computing;distributed programs;embedded system;real world application;urban area	In this paper, we present the design and implementation of Smart Messages, a distributed computing platform for networks of embedded systems based on execution migration. A Smart Message (SM) is a user-defined distributed program which executes on nodes of interest, named by their properties, and uses an explicit lightweight migration to reach these nodes. During migrations, an SM carries its code and execution state, and it self-routes at each intermediate node between two nodes of interest. The nodes in the network cooperate to support the SM execution by providing a virtual machine and a shared memory region addressable by names (tag space). To illustrate the flexibility of SMs to program real world applications, we describe EZCab, an application for booking cabs in densely populated urban areas. We also present experimental results to quantify the performance achieved by the SM prototype.	distributed computing;elsevier biobase;embedded system;population;prototype verification system;shared memory;virtual machine	Porlin Kang;Cristian Borcea;Gang Xu;Akhilesh Saxena;Ulrich Kremer;Liviu Iftode	2004	Comput. J.	10.1093/comjnl/47.4.475	distributed shared memory;shared memory;embedded system;distributed algorithm;real-time computing;computer science;virtual machine;operating system;distributed computing;distributed design patterns;data diffusion machine;replication;autonomic computing;distributed concurrency control	HPC	-36.21454340105323	44.76394890748588	144384
ceece9fdd55dc069e97cedd81cb479830aca8608	tlm: crossing over from buzz to adoption	project management;transaction level model;simulation;resource management;yield;chip;computer architecture;standards development;system evaluation;permission;levels of abstraction;engineering management;software development;lifting equipment;software standards;programming lifting equipment computer architecture software standards standards development engineering management hardware project management resource management permission;variability;mismatch;programming;monte carlo analysis;telecommunication networks;hardware;modeling and analysis	Transaction-level modeling --- originally used decades ago in the development of telecommunications network architecture --- is now widely used in SoC design. Why? Because the modern SoC is now so complex that systematic modeling and analysis are required to devise the optimal chip architecture. The architectural model is the essential platform that kick-starts two other key tasks --- verification testbench development and software development. In addition, the interoperability imperatives of SoC design and verification, IP reuse, software development, and system evaluation and integration have driven the replacement of proprietary transaction-level modeling methodologies by a TLM standard that leverages the power of SystemC. The standard --- devised by the Open SystemC Initiative (OSCI) in collaboration with the Open Core Protocol International Partnership (OCP-IP) --- covers the multiple levels of abstraction required for all of the foregoing tasks.	interoperability;network architecture;open core protocol;principle of abstraction;semiconductor intellectual property core;software development;system on a chip;systemc;telecommunications network;test bench;transaction-level modeling	Francine Bacchini;Daniel Gajski;Laurent Maillet-Contoz;Haruhisa Kashiwagi;Jack Donovan;Tommi Mäkeläinen;Jack Greenbaum;Rishiyur S. Nikhil	2007	2007 44th ACM/IEEE Design Automation Conference	10.1145/1278480.1278595	chip;project management;embedded system;programming;yield;electronic engineering;real-time computing;telecommunications;computer science;systems engineering;engineering;electrical engineering;resource management;software development;operating system;programming language;algorithm;computer network;monte carlo method;lifting equipment;computer engineering	EDA	-36.78485473287591	34.03549647541112	144859
c23a067a900ed5fd0b86eb0a3f985fa949cfbc44	an incidence matrix-based verification method for business process model in inter-domain network management system	analytical models;semantics;telecommunication network management formal verification matrix algebra petri nets;computational modeling;resource reservation incidence matrix based verification method business process model inter domain network management system petri net formal methods model verification;vectors;business;mathematical model;incidence matrix petri net model verification;business mathematical model analytical models equations computational modeling vectors semantics	Petri net has become one of the major formal methods for modeling and analyzing business processes. Petri net is utilized for business process modeling in inter-domain network management system. However business process models may contain errors. So model verification is of necessity and importance. A new model verification method is proposed based on incidence matrix of Petri net. It can be used to assess the correctness of business process models. The application of resource reservation in the inter-domain network management system is taken as an example to demonstrate the availability of the method.	business process;correctness (computer science);formal methods;incidence matrix;inter-domain;linear equation;petri net;process modeling	Wen Yang;Yuehui Jin;Tan Yang	2013	2013 15th IEEE International Conference on Communication Technology	10.1109/ICCT.2013.6820479	computer science;systems engineering;theoretical computer science;database;business process model and notation;process architecture;petri net	Robotics	-46.32466690506954	34.16945204015448	144939
6d66a323d21d42f63cbef68c8e1ba7c976144729	modular coordination of multiple autonomic managers	automated management;au tomated management;control loops;formal methods;self adaptive systems;software reuse;autonomic computing;component dynamic adaptation	Complex computing systems are increasingly self-adaptive, with an autonomic computing approach for their administration. Real systems require the co-existence of multiple autonomic management loops, each complex to design. However their uncoordinated co-existence leads to performance degradation and possibly to inconsistency. There is a need for methodological supports facilitating the coordination of multiple autonomic managers. In this paper we propose a method focusing on the discrete control of the interactions of managers. We follow a component-based approach and explore modular discrete control, allowing to break down the combinatorial complexity inherent to the state-space exploration technique. This improves scalability of the approach and allows constructing a hierarchical control. It also allows re-using complex managers in different contexts without modifying their control specifications. We build a component-based coordination of managers, with introspection, adaptivity and reconfiguration. We validate our method on a multiple-loop multi-tier system.	algorithm;automata theory;automaton;autonomic computing;autonomic networking;compiler;component-based software engineering;digital subscriber line;elegant degradation;interaction;introspection;multitier architecture;scalability;state space	Gwenaël Delaval;Soguy Mak Karé Gueye;Éric Rutten;Noel De Palma	2014		10.1145/2602458.2602465	real-time computing;simulation;formal methods;computer science;systems engineering;programming language;autonomic computing	SE	-41.74444569630982	38.704368946595764	145259
00de3477fb1e54010ac9e5aab78f74d1924d2638	mode changes in a real-time architecture description language	overall configuration;language use;automatic code assembly;high level languages;application software;architecture description language;prototypes;real time;formal specifications;automatic programming;runtime;metah;architecture description languages;mode changes;architecture description languages runtime aerospace electronics real time systems dispatching assembly systems application software production prototypes formal specifications;aerospace computing;specification languages;scheduling;real time scheduling;aerospace electronics;production;assembly systems;aircraft instrumentation specification languages configuration management high level languages real time systems automatic programming scheduling aerospace computing;real time avionics application;aircraft instrumentation;real time schedulability analysis real time architecture description language metah overall configuration real time avionics application mode changes static declaration automatic code assembly;modes of operation;static declaration;real time schedulability analysis;configuration management;dispatching;real time architecture description language;real time systems	MetaH is a language used to describe the overall configuration or architecture of a real-time avionics application. The language includes a feature called a mode, which allows the set of processes, or the connections between those processes, to be changed dynamically by the application during system operation. The language requires all possible modes of operation to be statically declared, which facilitates both automatic code assembly and real-time schedulability analysis. >	architecture description language;real-time clock	Steve Vestal	1994		10.1109/IWCDS.1994.289928	embedded system;architecture description language;application software;real-time computing;computer science;operating system;prototype;configuration management;low-level programming language;programming language;scheduling;high-level programming language	Embedded	-33.82563316502881	34.16658504060562	145445
241ecc75fa83a598c7df7870ecaa75be2c4cc21f	adaptation for assimilation: shaping context-sensitive m-learning services within a multi-agent environment	mlearning;acl infostations intelligent agents multi agent system mlearning cc pp uaprof jade leap;multi agent system;university campus domain;composite capabilities preference profile based profiles context sensitive m learning services context sensitive infostation based multi agent system mobile e learning university campus domain mtest service java agent development framework based agents;computer aided instruction;multi agent systems computer aided instruction java;materials;mobile e learning;composite capabilities preference profile based profiles;jade leap;computer architecture;context sensitive infostation based multi agent system;multi agent systems;intelligent agents;context sensitive m learning services;cc pp uaprof;mobile communication;intelligent agent;mobile handsets;network architecture;mtest service;context;service provision;java agent development framework based agents;infostations;context aware services multiagent systems electronic learning intelligent agent feedback telecommunication computing mobile computing computer architecture java buildings;containers;multiagent systems;acl;java	This paper presents a context-sensitive InfoStation-based multi-agent system which facilitates mobile eLearning (mLearning) service provision within a University Campus domain. A general overview of the network architecture underlying this mLearning system is presented, as well as brief outline of the interactions involved in the provision of one of the core mLearning services, in this case the mTest service. In the main, this paper highlights a number of implementation issues associated with this system; in particular the utilization of Java Agent Development Framework (JADE)-based agents in conjunction with Composite Capabilities/ Preference Profile (CC/PP)-based profiles for the personalization and contextualization of the presented services.	context-sensitive help;data assimilation;intelligent agent;interaction;java;multi-agent system;network architecture;noise shaping;personalization	Damien Meere;Ivan Ganchev;Mairtin O'Droma;Stanimir Stojanov;Veselina Valkanova	2010	2010 Sixth Advanced International Conference on Telecommunications	10.1109/AICT.2010.63	embedded system;real-time computing;simulation;network architecture;mobile telephony;computer science;engineering;operating system;multi-agent system;java	Robotics	-39.390060709519524	42.90091608101857	145526
10f0f87af4b0c874db2fd61ec286c39aa4c5c101	a framework for secure service composition	secure service composition;formal specification;bpmn;security availability business runtime service oriented architecture biological system modeling;service availability secure service composition bpmn service modelling;trusted computing;service execution secure service composition loosely coupled service composition security requirements trustworthiness requirements service based application composition service specification service building;service availability;service modelling;trusted computing formal specification security of data service oriented architecture;service oriented architecture;security of data	Modern applications are inherently heterogeneous: they are built by composing loosely coupled services that are, usually, offered and operated by different service providers. While this approach increases the flexibility of the composed applications, it makes the implementation of security and trustworthiness requirements difficult. As the number of security requirements is increasing dramatically, there is a need for new approaches that integrate security requirements right from the beginning while composing service-based applications. In this paper, we present a framework for secure service composition using a model-based approach for specifying, building, and executing composed services. As a unique feature, this framework integrates security requirements as a first class citizen and, thus, avoids the ``security as an afterthought'' paradigm.	first-class citizen;first-class function;loose coupling;programming paradigm;requirement;service composability principle;trust (emotion)	Achim D. Brucker;Francesco Malmignati;Madjid Merabti;Qi Shi;Bo Zhou	2013	2013 International Conference on Social Computing	10.1109/SocialCom.2013.97	service level requirement;service level objective;service catalog;sherwood applied business security architecture;service product management;differentiated service;computer science;basic service;service delivery framework;service-oriented architecture;service design;data mining;formal specification;database;security service;business process model and notation;service desk;data as a service;trustworthy computing;world wide web;computer security;trusted service manager	DB	-46.105347827318894	43.360281983448665	145537
40dcd2c6e45b44b9bad554db7d524ae4c4b86cb7	adaptive event communication in component-based systems	components;distributed real time embedded;component based systems;component based adaptive middleware;d 2 10 software engineering design methodologies;cbam;dynamic control;middleware;d 2 2 software engineering design tools and techniques;flow control;transactions;mdse;models	The flow of events and data on the connections between components in an application may have to be controlled at run time based on the application state to optimize performance. For example, a set of components (or a subsystem) may be inactive in a given state and events flowing towards such inactive components can be eliminated. This paper presents a model-driven approach to dynamically control the flow of events on event connections. The proposed model-driven tool chain consists of <i>analysis algorithms</i> which analyze the application to derive metadata for event flow control, and an adaptive event communication framework which provides configurable event communication middleware. The metadata derived by the analysis algorithms is used to automatically configure the middleware for application state-aware propagation of events. The analysis algorithms are specially useful in large scale distributed real-time embedded systems where deriving such metadata manually can be tedious and error-prone. We have applied the proposed mechanisms to application scenarios from the Boeing BoldStroke system.	algorithm;cognitive dimensions of notations;component-based software engineering;embedded system;middleware;model-driven architecture;model-driven integration;real-time locating system;run time (program lifecycle phase);software propagation;state (computer science);toolchain	Qiang Zeng;Prashant S. Kumar;Gurdip Singh	2004		10.1145/1028613.1028617	middleware;real-time computing;computer science;middleware;database;distributed computing	Embedded	-39.47012701686105	37.11557942909007	145579
4636d9f3efe91366b72ecfbfbe97bc967859d645	model based architecting and construction of embedded systems (aces-mb 2009)	debugging;model transformation;cpn;real time embedded system;product line;formal semantics;software engineering;embedded system;domain specific modeling language;modelling language;domain specific language;architecture analysis;runtime model;software synthesis;verification and validation;domain specificity	The second ACES-MB workshop brought together researchers and practitioners interested in model-based software engineering for real-time embedded systems, with a particular focus on the use of models for architecture description and domain-specific design, and for capturing non-functional constraints. Eleven presenters proposed contributions on domain-specific languages for embedded systems, the Architecture Analysis and Design Language (AADL), analysis and formalization, semantics preservation issues, and variability and reconfiguration. In addition, a lively group discussion tackled the issue of combining models from different Domain Specific Modeling Languages (DSMLs). This report presents an overview of the presentations and fruitful discussions that took place during the ACES-MB 2009 workshop.	architecture analysis & design language;domain-specific language;domain-specific modeling;embedded system;heart rate variability;lively kernel;megabyte;real-time transcription;software engineering	Stefan Van Baelen;Thomas Weigert;Ileana Ober;Huáscar Espinoza;Iulian Ober	2009		10.1007/978-3-642-12261-3_7	real-time computing;verification and validation;computer science;systems engineering;domain-specific language;software engineering;formal semantics;programming language;debugging	Embedded	-40.45140829265556	32.894211078139946	146024
6cdaf6ca4e481a78f43515a8b8b8e1be919e9aad	a component based multimedia middleware for content production factory	middleware	Recently specific middlewares have been proposed while those with general capabilities are going to be integrated into the most diffused development platforms and operating systems. This trend has provoked the production of middlewares for industrial automation, home automation, multimedia, etc. In the paper a solution to model a Multimedia middleware is proposed as related to AXMEDIS EC Ru0026D Project in which an MPEG21 compliant content factory is modeled. In that case, the middleware is used for sharing software components dedicated to the content processing and production. In the paper, the architecture of the DISIT-M3W is presented, depicting the general architecture, the class structure, the interactions among components and services, etc. by using the UML formalization.	middleware	Tommaso Martini;Paolo Nesi;Davide Rogai;Andrea Vallotti	2005			computer science;component-based software engineering;automation;architecture;multimedia;database;home automation;middleware (distributed applications);factory;unified modeling language;middleware	Robotics	-37.89058646350481	42.184279907975466	146343
16cbe628960b6c60154ca770e932cc053ae6d7c2	development of context-adaptive applications on the basis of runtime user interface models	user interface development;adaptive user interfaces;user interface;context of use;context model;executable models;adaptive applications;model driven engineering;on the fly;model based user interface development;adaptive user interface;smart environment	One of the challenges faced by developers of applications for smart environments is the diversity of contexts of use. Applications in smart environments must cope with continuously changing context of use, so the developers need to prepare them for a possibly broad range of situations. Since the developer has no access to all environments, in which her application will be executed, it must be possible to simulate different environments and evaluate the behavior of the application at design time. In our demonstration the designer has the possibility to simulate and modify a runtime context model and observe as her application adapts on the fly. In the underlying runtime architecture applications, defined as sets of models, are adapted automatically on the basis of the information held in the runtime context model. A visual tool enables the user interface developer to access and modify the models at any time and immediately observe the behavior of the application.	on the fly;simulation;smart environment;user interface	Grzegorz Lehmann;Marco Blumendorf;Sahin Albayrak	2010		10.1145/1822018.1822068	user interface design;real-time computing;simulation;human–computer interaction;computer science;natural user interface;user interface	HCI	-40.97336849459991	40.28222802951735	146356
c342d93f4db32335403d3dc7d64c854ba6aa1be6	compositionality and cps from a platform perspective	software;real time systems protocols synchronization job shop scheduling software servers resource management;protocols;software engineering design embedded systems object oriented programming;job shop scheduling;software systems cps cyber physical systems embedded computer systems nonfunctional requirements software development modular design compositional design;resource manager;resource management;object oriented programming;software engineering;embedded systems;servers;engineering and technology;teknik och teknologier;synchronization;design;real time systems	Cyber Physical Systems (CPS) comprise the integration of embedded computer systems and the physical processes that these computer systems interact with. Examples of such systems stretch from small embedded devices, e.g., intelligent sensor systems, to larger and often complex industrial systems, e.g., industrial automation systems. These systems are not only subject to functional requirements, but also non-functional requirements such as timing, resource usage, and reliability. CPS development (including software development) is substantially facilitated if the system parts can be developed and verified in isolation, and if the correctness of the system can be inferred from the correctness of its parts. Such modular and compositional design of software systems has for a long time been considered the holy-grail of system design, and is unfortunately only possible in selected scenarios. This paper covers one such scenario: using hierarchical runtime mechanisms in the platform to enable predictable resource usage and temporal isolation of CPS software. Our overall goal is to develop cost efficient mechanisms that are applicable for a wide range of systems.	automation;computer;correctness (computer science);cost efficiency;functional requirement;non-functional requirement;software development;software system;systems design;temporal isolation	Thomas Nolte	2011	2011 IEEE 17th International Conference on Embedded and Real-Time Computing Systems and Applications	10.1109/RTCSA.2011.68	embedded system;synchronization;design;real-time computing;system of systems;computer science;resource management;operating system;distributed computing;systems development life cycle;programming language;cyber-physical system;systems design	Embedded	-41.25468623351699	36.04818267843616	146425
4ad5d0239cd1b9da415ea16856b1fea22d6dc999	a uniform meta-model for mediating formal electronic conferences	formal specification teleconferencing;virtual machine;teleconferencing;formal specification;selected works;robert s rules of order;collaboration collaborative work application software costs internet computer science business communication runtime environment virtual machining encapsulation;meta model uniform meta model formal electronic conferences online meetings collaboration description language runtime environment codl virtual machine;uniformity;bepress;formal electronic conferences;face to face;geographic distribution;meta model	Formal electronic conferences (FEC) refers to online meetings for a geographically distributed group of people that are regulated by a rigorous set of rules. FEC technologies enable organizations to replace face-to-face business meetings with trustworthy virtual online meetings. In This work we present a Robert's rules of order (RRO)-compatible, motion-driven discussion-thread-centered meta-model, which is capable of uniformly modeling formal electronic conference activities. A tailored computerized mechanism, the collaboration description language (CODL) and its runtime environment, is also developed to formalize the model. The CODL virtual machine adds a layer of encapsulation that decouples FEC applications from underlying platforms: therefore, the development of FEC applications will become more reliable, efficient, and secure. Our preliminary experience with this meta-model is also reported.	encapsulation (networking);forward error correction;metamodeling;runtime system;virtual machine	Jia Zhang;Carl K. Chang;Jeffrey M. Voas	2004	Proceedings of the 28th Annual International Computer Software and Applications Conference, 2004. COMPSAC 2004.	10.1109/CMPSAC.2004.1342861	metamodeling;simulation;teleconference;computer science;engineering;virtual machine;artificial intelligence;operating system;software engineering;formal specification;database;multimedia;programming language;management;world wide web;computer security	EDA	-35.882993756973825	41.566946125302955	146525
51cd6fc7991fdd17bce68eef55fb0fb8984bb169	kalimucho : adaptation au contexte pour la gestion de la qualité de service. (kamilucho: context adaptation for quality of service management)		The recent technological overhangs have focused on the democratization of wireless networks and the miniaturization of communication devices. Nowadays we can find a lot of devices increasingly lightweight, tiny, mobile and to be equipped of one or several wireless communication medium such as mobile phones, smart-phones, PDA, laptops and sensors. Moreover, we face with the growing request of rich and customized services. The challenge is to offer applications which suit both the users’needs and the physical environment. This type of mobile devices is able to be aware of its hardware and software environment but also, with the arrival of device such as sensors, they can measure temperature, moisture, move speed or pressure. Integration of such devices in applications can provide services better adapted to their current situation. However, theses devices have features (energy independence, mobility, limited resources) which require adaptations in order to provide services that well function and during a satisfaying time. In this thesis, we chose to address the dynamic context adaptation as a tool for quality of service management. We present a platform for reconfiguration and contextual deployment of applications in constrained environments called Kalimucho (Kalitate Mucho 2). Kalimucho is a distributed platform that has a global representation of the application. It adapts component-based applications through five basic actions : add, delete, move, connect and disconnect. The original idea of this platform is that it exploits the resources of the application as better as possible to use all available devices to support components. For this, it is based on a context categorization and a quality of service definition which take into account the different properties of pervasive applications : devices, mobility, environment and specifications of the application. The definition of quality of service we provide matches two concepts of pervasive applications : the utility of an application and availability of resources. Each of these definitions is associated with a model : a context model and a QoS model. The context model is a simple model based on a knowledge of components and devices but also, the data-gathering during the execution. The platform is informed of context changes about specific context components and generates the appropriate actions. The choice of the action is guided by a design method that assists the designer in modeling the context. It identifies all the events implying reconfiguration and their associated actions. Then, it models all the configurations of an application which aided the decision process. When the decision is taken, the QoS model evaluates quality of service of the application on two levels : the adequacy between the service offered and the 2. Quality in Basque and Much in Spanish	categorization;component-based software engineering;laptop;linear algebra;meme;mobile device;mobile phone;personal digital assistant;pervasive informatics;quality of service;reactions to the november 2015 paris attacks;sensor;sentient computing;smartphone;software deployment;technological singularity	Christine Louberry	2010				Mobile	-42.0993123587657	44.92202181895285	146550
74c8c05084d8af17ea5b36da76560402d2f30cb8	modeling of event-based communication in component-based architectures: state-of-the-art and future directions	component based architecture;distributed systems;event based system	Event-based communication is used in different domains including telecommunications, transportation, and business information systems to build scalable distributed systems. Such systems typically have stringent requirements for performance and scalability as they provide business and mission critical services. While the use of event-based communication enables loosely-coupled interactions between components and leads to improved system scalability, it makes it much harder for developers to estimate the system’s behavior and performance under load due to the decoupling of components and control flow. We present an overview on our approach enabling the modeling and performance prediction of event-based system at the architecture level. Applying a model-to-model transformation, our approach integrates platform-specific performance influences of the underlying middleware while enabling the use of different existing analytical and simulationbased prediction techniques. The results of two real world case studies demonstrate the effectiveness, practicability and accuracy of the proposed modeling and prediction approach.	control flow;coupling (computer programming);distributed computing;interaction;management information system;middleware;mission critical;model transformation;performance prediction;platform-specific model;requirement;scalability	Samuel Kounev;Christoph Rathfelder;Benjamin Klatt	2013	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2013.04.002	real-time computing;simulation;computer science;component-based software engineering;distributed computing;programming language	HPC	-45.12866722198355	38.64859711043076	146761
21cfcfadbb70d46efd5c02d9838b66898f586c37	predictable dynamic deployment of components in embedded systems	resource constraint;dynamic reconfiguration;availability;computer model;computer and information science;testing;usa councils;embedded system;component testing;computer architecture;embedded systems;testing vehicle dynamics computational modeling embedded systems computer architecture usa councils availability;computational modeling;formal verification;system integration;embedded systems component testing dynamic reconfiguration;dynamic deployment mechanism embedded systems dynamic reconfiguration application consistency dependability requirements resources constraints checking component compliance checking;data och informationsvetenskap;program compilers;vehicle dynamics;program compilers embedded systems formal verification	Dynamic reconfiguration - the ability to hot swap a component or to introduce a new component into a system - is essential to supporting evolutionary change in long-live and highly available systems. A major issue related to this process is to ensure application consistency and performance after reconfiguration. This task is especially challenging for embedded systems which run with limited resources and have specific dependability requirements. We focus on checking resources constraints and propose for a component compliance checking to be performed during its deployment. Our main objective is preserving system integrity during and after reconfiguration by developing a resource efficient dynamic deployment mechanism that will include component validation in respect to available system resources and performance requirements.	dependability;embedded system;hot swapping;paging;requirement;software deployment;system integrity	Ana Petricic	2011	2011 33rd International Conference on Software Engineering (ICSE)	10.1145/1985793.1986015	computer simulation;reliability engineering;embedded system;availability;real-time computing;vehicle dynamics;formal verification;computer science;operating system;software testing;unit testing;programming language;computational model;system integration	SE	-40.4579408620841	37.61086020315117	146848
19568182a8f9b4162d460617ee3b6231aaf8b42e	formal description of an approach for power consumption estimation of embedded systems	analytical models;embedded systems;graphical illustrations power consumption estimation embedded systems formal description model based engineering energy efficient automation systems energy consumption processor hardware application model uml marte profile elements stochastic petri net transformation rules formal mathematical language;stochastic processes;energy consumption;unified modeling language;unified modeling language embedded systems formal languages formal specification petri nets power aware computing stochastic processes;power demand;unified modeling language power demand embedded systems stochastic processes hardware energy consumption analytical models;hardware	This paper presents a formal description of an approach for model-based engineering of energy-efficient automation systems. Energy consumption is an important decision criterion, which has to be included in the search for good architectural and design alternatives already on the early system design stages. In the method, we describe an embedded system with an operational model for the processor hardware and an application model for the software. UML extended with MARTE profile elements is used for this part. Both models are transformed into a stochastic Petri net using transformation rules. The procedure steps are described with formal mathematical language and graphical illustrations.	computer hardware;embedded system;graphical user interface;modeling and analysis of real time and embedded systems;performance evaluation;stochastic petri net;systems design;unified modeling language	Dmitriy Shorin;Armin Zimmermann	2014	2014 24th International Workshop on Power and Timing Modeling, Optimization and Simulation (PATMOS)	10.1109/PATMOS.2014.6951890	unified modeling language;stochastic process;embedded system;real-time computing;simulation;formal methods;formal verification;systems modeling language;computer science;theoretical computer science;statistics	EDA	-41.47762737531377	33.93920795883553	147002
a9cf584b0aabe93c50ea06cba21affdaa4360d0a	an xml-based runtime user interface description language for mobile computing devices	extensible markup language;interfase usuario;calculateur embarque;user interface;reutilizacion;mobile computer;calcul mobile;reuse;embedded system;lenguaje descripcion;user interface description language;proceedings paper;boarded computer;xml;interface utilisateur;calculador embarque;langage description;reutilisation;description language	In a time where mobile computing devices and embedded systems gain importance, too much time is spent to reinventing user interfaces for each new device. To enhance future extensibility and reusability of systems and their user interfaces we propose a runtime user interface description language, which can cope with constraints found in embedded systems and mobile computing devices. XML seems to be a suitable tool to do this, when combined with Java. Following the evolution of Java towards XML, it is logical to introduce the concept applied to mobile computing devices and embedded systems.	embedded system;extensibility;interface description language;java;mobile computing;user interface;xml	Kris Luyten;Karin Coninx	2001		10.1007/3-540-45522-1_1	user interface design;xml;human–computer interaction;computer science;operating system;database;distributed computing;programming language;mobile computing	HCI	-35.51882170192369	40.43000130592777	147224
8813c574f3151205c30e713b595c3dcd8e0a7004	validating distributed software modeled with the unified modeling language	developpement logiciel;distributed system;error recovery;race condition;life cycle;graphical language;object oriented programming;specification language;formal verification;telecomunicacion;desarrollo logicial;telecommunication;software development;unified modeling language;verification formelle;lenguaje especificacion;programmation orientee objet;langage specification;lenguaje grafico;langage graphique	The development of correct OO distributed software is a daunting task as soon as the distributed interactions are not trivial. This is due to the inherent complexity of distributed systems (latency, error recovery, etc), leading to numerous problems such as deadlocks, race conditions, and many difficulties in trying to reproduce such error conditions and debug them. The OO technology is ill-equipped to deal with this dimension of the problem. On the other hand, the willingness of mastering this complexity in the context of telecommunication protocols gave birth to specific formal verification and validation tools. The aim of this paper is to explore how the underlying technology of these tools could be made available to the designer of OO distributed software. We propose a framework allowing the integration of formal verification and validation technology in a seamless OO life-cycle based on UML, the Unified Modeling Language.	unified modeling language	Jean-Marc Jézéquel;Alain Le Guennec;François Pennaneac'h	1998		10.1007/978-3-540-48480-6_28	unified modeling language;biological life cycle;specification language;formal verification;computer science;artificial intelligence;theoretical computer science;software development;operating system;database;distributed computing;race condition;programming language;object-oriented programming;algorithm	SE	-45.30169260194229	33.90221484705545	147305
60da582d5d77ff73216829d9815c829e70ad22a6	runtime middleware for the generation of adaptive user interfaces on resource-constrained devices	runtime middleware user interfaces decision support systems;human computer interaction;user interfaces middleware mobile computing;adaptive middleware;user interface;mobile computer;context of use;interactive system;middleware;interactive system runtime middleware adaptive user interfaces resource constrained devices mobile computing human computer interaction;adaptive user interface;mobile computing;user interfaces;mobile application	Mobile computing imposes a profound level of challenges on human-computer interaction because applications are used in the move and services are accessed in different situations. Current approaches favor the design of an interactive system that is suited for a predefined set of contexts. For this reason, an adaptive middleware is needed to generate the user interfaces and adjust their characteristics to the different usage scenarios. To achieve this goal, the middleware needs to enable the separation of the adaptation mechanisms from the core operations of the interaction. Furthermore, a more structured approach is needed to describe the different aspects of the human-computer interaction, which can then be used by the middleware to generate adaptive user interfaces. Specifically, this paper describes a run-time framework that enables the generation of user interfaces on portable devices by a process of mapping and transformation of a set of abstract models, and their adaptation to suit the current context-of-use. We also present a prototype mobile application to illustrate our approach.	adaptive grammar;adaptive user interface;human–computer interaction;interactivity;middleware;mobile app;mobile computing;mobile device;prototype	Karim Yaici;Ahmet M. Kondoz	2008	2008 Third International Conference on Digital Information Management	10.1109/ICDIM.2008.4746724	user interface design;middleware;real-time computing;user modeling;interactive systems engineering;human–computer interaction;computer science;message oriented middleware;operating system;middleware;distributed computing;post-wimp;user interface;mobile computing	HCI	-41.05196212022777	42.930042864764786	147344
324cbc4dde0e0eb593db8e864a7257554741139a	a reflective component model for open systems	distributed application;distributed system;user requirements;modular design;open system;component model;middleware;reusable component	This paper introduces a component model that allows the modular design and development of components and applications for Open and Distributed Systems. It defines the concepts of components and reusable controllers, permits their modular composition to build up applications, and it is devised to address in an independent manner many of the specific issues of these systems, like heterogeneity, evolution and dissemination of their components, dynamic reconfiguration, or environment-awareness. The model offers a basic communication infrastructure and a reflective mechanism to modify the behavior of components according to the user requirements. The main features of the model are presented in this work, together with an example that shows its expressiveness and capabilities.	common object request broker architecture;component-based software engineering;distributed component object model;distributed computing;electronic billing;internet;interoperation;modular design;operational data store;requirement;user requirements document	José M. Troya;Antonio Vallecillo	1998		10.1007/3-540-49255-0_110	embedded system;middleware;real-time computing;common component architecture;computer science;user requirements document;operating system;middleware;component;component object model;open system;modular design	SE	-36.670959807272055	42.31711472500344	147466
5d7e8b5717529d38084db90fa1ea5a8791e48895	on the verification of behavioral and probabilistic web services using transformation	verification;analytical models;software tool;probabilistic;probability;web;web service;program verification;knowledge representation languages;probabilistic model;system recovery;model checking;web services;markov process;process control;mathematical model;software tool behavioral web services probabilistic web services web service verification owl s markov chain diagram markov decision process prism model probabilistic model checker transformation algorithm;web services knowledge representation languages markov processes probability program verification software tools;software tools;services;markov processes;transformation;markov decision process;probabilistic logic;markov processes web services process control probabilistic logic mathematical model system recovery analytical models;model checking web service verification;analytical model;verification model;behavioral;markov chain	In this paper, we propose a preliminary approach for automating web service verification. We use Semantic Markup for Web Services (OWL-S) to describe web service behavior. We parse the OWL-S file and transform it automatically to a corresponding Markov chain diagram or Markov decision process, which are then transformed to a PRISM model to be used as input by PRISM, a probabilistic model checker, to verify automatically the web service behavior. We provide an implementation of the transformation algorithm through a developed software tool automating all the transformation and verification activities.	algorithm;diagram;fits;markov chain;markov decision process;model checking;owl-s;prism (surveillance program);parsing;programming tool;run time (program lifecycle phase);simulation;statistical model;verification and validation;web service	Giti Oghabi;Jamal Bentahar;Abdelghani Benharref	2011	2011 IEEE International Conference on Web Services	10.1109/ICWS.2011.106	web service;web modeling;data web;computer science;theoretical computer science;process control;data mining;database;probabilistic logic;markov process	SE	-45.57689728404463	32.485676907103894	147708
19efee25b9468bd6aac42fe09dffe0fd9f162a43	real-time collaboration in activity-based architectures	session management;groupware;design principle;synchronous collaboration real time collaboration activity based architectures mobile computing ubiquitous computing activity based computing paradigm collaboration handling activity based architecture session management;mobile computing groupware ubiquitous computing software architecture;collaboration pervasive computing biomedical imaging collaborative work computer architecture software architecture x ray imaging application software ubiquitous computing proposals;real time;collaborative system;software architecture;synchronous collaboration;ubiquitous computing;mobile computing;management policy;ubiquitous computing environment	With the growing research into mobile and ubiquitous computing, there is a need for addressing how such infrastructures can support collaboration between nomadic users. We present the activity based computing paradigm and outline a proposal for handling collaboration in an activity-based architecture. We argue that activity-based computing establishes a natural and sound conceptual and architectural basis for session management in real-time, synchronous collaboration.	focal (programming language);organizing (structure);programming paradigm;real-time transcription;refinement (computing);session (computer science);ubiquitous computing	Jakob Eyvind Bardram;Henrik Bærbak Christensen	2004	Proceedings. Fourth Working IEEE/IFIP Conference on Software Architecture (WICSA 2004)	10.1109/WICSA.2004.1310719	software architecture;real-time computing;context-aware pervasive systems;human–computer interaction;computer science;software engineering;end-user computing;distributed computing;utility computing;ubiquitous robot;mobile computing;ubiquitous computing;autonomic computing	SE	-35.98259772155235	46.31904290568695	148089
e9d751f9626ff7cc702443756e768836f056ebbd	evaluating the performance of adaptable systems based on aom: a case study exploring lom	performance evaluation;metadata;frameworks;adaptive object model;adaptation models java metadata computer architecture software systems adaptive systems;adaptable software;performance evaluation adaptable software adaptive object model metadata frameworks;educ service adaptable systems aom lom software system adaptive object model arquitectural style metadata database living object model;software performance evaluation meta data	When we are developing a software system and we know that it will suffer several changes, it is important to make it adaptable, so that changes can be quickly performed with not so much impact. One solution that has been used to develop adaptable systems is the Adaptive Object Model (AOM) Arquitectural Style, through which entities, properties, relationships and behavior are represented as metadata and can be changed by simply changing this metadata stored in a database. However, developing systems with AOM may be complex and its performance is questionable, especially when we want most of the system to be adaptable. One way that has been proposed to quickly develop AOM systems with a lot of reuse is through the LOM (Living Object Model) framework. In this work we show how a system can be developed using this framework and we evaluate the performance overhead of making most of a system adaptable with AOM using LOM. This evaluation is performed through a case study using two versions of a system to manage online exercises, which has been called Educ Service.	associate-o-matic;entity;learning object metadata;overhead (computing);software system	Fernando Mateus de Oliveira;Ayla Dantas;Rodrigo de A. Vilar	2015	2015 IX Brazilian Symposium on Components, Architectures and Reuse Software	10.1109/SBCARS.2015.17	real-time computing;computer science;database;world wide web	SE	-39.14854411359574	38.458098977879175	148302
74572220b245ca5f5fe8a3ec6985ae28352ddd83	runtime verification and enforcement, the (industrial) application perspective (track introduction)		During the last decade, the runtime verification and enforcement (RVE) community has been incredibly prolific in producing many theories, tools and techniques aiming towards the efficient analysis of systems’ executions and guaranteeing their correctness w.r.t. some desired properties. With the major strides made in recent years, much effort is still needed to make RVE attractive and viable methodologies for industrial use. In addition to industry, numerous other domains, such as security, bio-health monitoring, etc., can gain from RVE. The purpose of the “ Runtime Verification and Enforcement: the (industrial) application perspective” track at ISoLA’16 is to bring together RVE experts and potential application domains to try and advance the state-of-theart on how to make RVE more useable and attractive to industry and other disciplines.	british informatics olympiad;correctness (computer science);runtime verification;theory;usability	Ezio Bartocci;Yliès Falcone	2016		10.1007/978-3-319-47169-3_24	embedded system;real-time computing;distributed computing	AI	-45.54266448882463	38.535793420590544	148330
ef8bccf93a68e49b2da15904c72753ce026cceca	verifying programmable logic controllers with abstraction	model checking techniques;control systems;programmable controllers;programmable control logic counting circuits explosions control systems embedded system software safety iec standards embedded software industry applications;logic;programmable control;abstraction;program verification;embedded system;complex embedded system;embedded systems;counting circuits;programmable controllers control engineering computing embedded systems program verification;state explosion problem programmable logic controllers abstraction complex embedded system model checking techniques;iec standards;model checking;software safety;programmable logic controllers;state explosion problem;industrial application;industry applications;explosions;control engineering computing;state explosion;programmable logic controller;embedded software	Functional and nonfunctional validation is an important task in complex embedded system developments. This paper proposes a method of applying model checking techniques to validate programable logic controllers (PLCs). Abstraction is used to ameliorate the state explosion problem. The experiment results of an industry application demonstrate the effectiveness of our approach.	embedded system;model checking;operational semantics;programmable logic device;requirement	Rui Wang;Ming Gu;Xiaoyu Song;Hehua Zhang	2008	2008 International Symposium on Industrial Embedded Systems	10.1109/SIES.2008.4577704	embedded system;real-time computing;computer science;control system;operating system;programmable logic controller;abstraction model checking	Embedded	-44.58541520060564	32.64164522870268	148541
a1016bba3572db88fba8dcbda9d08ea4e0acd56a	supporting the consistent specification of scenarios across multiple abstraction levels	adaptive cruise control;levels of abstraction;requirement engineering;consistency checking;system architecture	Context and motivation) In scenario-based requirements engineer- ing for complex software-intensive systems, scenarios must be specified and kept consistent across several levels of abstraction such as system and compo- nent level. (Question/problem) Existing scenario-based approaches do not provide a systematic support for the transitions between different abstraction levels such as defining component scenarios based on the system scenarios and the system architecture or checking whether the component scenarios are con- sistent with the system scenarios. (Principal ideas/results) This paper presents a systematic approach for developing scenarios at multiple abstraction levels supported by automated consistency checks of scenarios across these abstrac- tion levels. (Contribution) We have implemented the consistency check in a tool prototype and evaluated our approach by applying it to a (simplified) adap- tive cruise control (ACC) system.		Ernst Sikora;Marian Daun;Klaus Pohl	2010		10.1007/978-3-642-14192-8_6	real-time computing;simulation;computer science;systems engineering;engineering;requirements engineering;management;systems architecture	HCI	-43.635978237672305	32.58420897208588	148693
f45b00e389ac1785c261e812446454a1453728fa	exception detection for web service composition using improved bayesian network	bayesian network;exception handling;web service;web service composition	New application systems generated by composition of web services dynamically have become a development trend in network environment.However, since a variety of external services are invoked with different quality of service during processing,the problem of how to keep the execution stable must be addressed in order to improve the reliability and availability of the combination of services.In this paper, an approach of exception detection is presented for web service composition by improved Bayesian network. Firstly, the topological structure of Bayesian network is established, where the causal relationships between underlying web services are mapped to Bayesian network in service combination process. The conventional Bayesian network algorithm is improved to satisfy the demand of better conversion from nodes in web service composition to nodes in Bayesian network.Secondly, the parameter setting in Bayesian network is explored for determining the prior probability of service nodes and the conditional probability of service output node. Thirdly, the algorithm of the improved exception detection model is introduced, with the aim of locating the web services that cause exceptions in the execution of composite services.Lastly, a case study is given and the results analysis is also conducted. The results show that the presented approach not only considers the uncertainty during exception detection, but also can identify the exception web services in the process.	algorithm;anomaly detection;bayesian network;business process;causal filter;causality;cloud computing;entity–relationship model;information security;internet of things;quality of service;semantic web service;service composability principle;service-oriented modeling;service-oriented software engineering;software architecture;trustworthy computing;web service;yao graph;zhi-li zhang	Yao Chen;Shi Ying;Liqiang Zhang;Juebo Wu	2013	JDIM		data mining;web service;quality of service;prior probability;conditional probability;composition (visual arts);bayesian probability;computer science;bayesian network	Web+IR	-47.59962201297455	40.81442550054477	149016
f534740d0d629bf226f6e5a5351a1617419f6446	jini-based mobile agent architecture for human planetary exploration	planetary exploration;mobile agent	Abstract: Planetary exploration requires effective collaborations between planetary explorers in charge of acquiring data in the field and scientists in charge of monitoring exploration activities in habitats, mission control centers, and science centers. To provide such collaborations, NASA needs a new highly flexible, extensible, and robust mobile agent architecture, which allows NASA planetary explorers and scientists working in different locations, using a variety of exploration tools and computing systems to create automatically a unique data record of planetary exploration activities. Such systems should work in a highly dynamic distributed computing environment where the system requirements and the set of exploration tools change; highly specialized computing nodes appear and disappear from computing clusters; and transient wireless communication links undergo rapid changes. In this paper, we present a new component-based approach to developing mobile agent architecture for human planetary exploration. The result is a multi-tier architecture that offers a set of distinct features--beyond the Jini architecture--to address the software flexibility, extensibility, and robustness issues. The Jini system employs mobile objects, but it does not meet all the requirements of mobile agent systems. The new architecture addresses this shortcoming.	agent architecture;mobile agent;planetary scanner;jini	Gilda Pour	2001		10.1109/TOOLS.2001.10023	embedded system;real-time computing;simulation;engineering	AI	-38.567960178448466	44.538753245316755	149020
20b30e01028891e1b72e9f3bbd94b3b11f981267	sysml fault modelling in a traffic management system of systems	dr claire ingram;sos service quality sysml fault modelling traffic management system of systems soss reasoning about faults fault tolerant design architectural level constituent systems partial service architectural engineer fault tolerance sos level failure;traffic engineering computing fault tolerant computing reasoning about programs software quality system recovery;eprints newcastle university;open access;vehicles cascading style sheets collaboration fault tolerance fault tolerant systems monitoring road transportation;dr richard payne;dr zoe andrews	Systems of systems (SoSs) are vulnerable to faults, for example arising as a result of the distribution and independence of their constituent systems. Our previous work has presented an initial framework for reasoning about faults and fault-tolerant design within an SoS at the architectural level, using a simple example of a single failure. In this paper we present a motivating example of an SoS within which failures of constituent systems (CSs) may lead to a degraded or partial service for the SoS. We discuss a possible extension to our earlier framework to allow an architectural engineer to reason about the fault tolerance of an SoS where CSs contribute negatively or positively towards a goal or an SoS-level failure, and where multiple SoS faults may interact to affect SoS service quality.	apple sos;cascading style sheets;design rationale;error detection and correction;fault tolerance;formal verification;human-readable medium;interaction;software bug;system of systems;systems modeling language	Claire Ingram;Zoe Andrews;Richard John Payne;Nico Plat	2014	2014 9th International Conference on System of Systems Engineering (SOSE)	10.1109/SYSOSE.2014.6892475	reliability engineering;systems engineering;engineering;artificial intelligence;operating system;software engineering;computer security;software fault tolerance	SE	-47.19445515006025	34.28943141908141	149344
e4559bae358bea15cf56cfa97510cc1702064b4d	providing spatial integrity for distributed unmanned systems	group behavior;system integration	Due to the increased complexity of tasks delegated to unmanned systems, their collective use is becoming of paramount importance for performing any reasonable jobs. An approach is offered where group behaviors are accomplished automatically rather than set up manually, as usual. Missions in the Distributed Scenario Language (DSL) can be executed jointly by communicating interpreters in system units. Scenarios like reconnaissance, camp security, convoy, mule, and explosive ordnance disposal in DSL, oriented on different numbers of cooperating units, are demonstrated. The approach allows us to effectively manage any teams, from human to robotic, and from homogeneous to heterogeneous, regardless of the number of components in them. A variety of other applications of the technology are outlined too, already researched or prospective, also its relation to the gestalt philosophy, where super-summative whole dominates over system parts, defining their sense and even existence, rather than vice versa. The paradigm discussed may also represent a distributed dynamic world super-machine operating in parallel with both information and physical matter.	computer;control unit;digital subscriber line;distributed computing;ecology;emergence;fortran;gestalt psychology;high- and low-level;high-level programming language;humans;interpreter (computing);java;job stream;mule;on the fly;programming paradigm;prospective search;robert;robot;robotics;run time (program lifecycle phase);supercomputer;universal controls	Peter Sapaty	2009			embedded system;computer science;distributed computing;computer security;group dynamics;system integration	AI	-41.83411777449081	37.24892185733711	149656
a33348c37596dfc54dd835d38834c6468f5803b0	system behaviour capture: from uml to systemc	libraries;object oriented methods;uml;state diagrams uml systemc executable model design patterns design tools case diagrams;actuators;object oriented programming;unified modeling language c language finite state machines object oriented methods object oriented programming;system on a chip;time domain analysis;finite state machines;c language;case diagrams;design pattern;unified modeling language xml libraries system on a chip actuators titanium time domain analysis;unified modeling language;xml;state diagram;design patterns;state diagrams;systemc executable model;design tools;use case;titanium	Design patterns and tools to describe the functionality of a system at a high abstraction level are presented. These design patterns allow the designers to easily go from UML use case and state diagrams to a SystemC executable model.	abstraction layer;design pattern;diagram;executable;systemc;unified modeling language	Joaquín Pérez Ortega;Juan F. Sevillano;Santiago Urcelayeta;Igone Vélez	2008	2008 Forum on Specification, Verification and Design Languages	10.1109/FDL.2008.4641452	unified modeling language;real-time computing;state diagram;computer science;theoretical computer science;applications of uml;finite-state machine;programming language	EDA	-41.34660547533328	32.34826172204744	149683
1fe0e6940855bed841ad4d8dbb643d5aaf078e04	scaling commercial verification to larger systems	linear functionals;formal verification;pilot project;model checking;system design;test coverage;hierarchical design	ion has long been used successfully in pilot projects to apply model checking to entire systems. Abstraction in conjunction with guided-random simulation can be used in the same way to increase coverage for conventional test.	model checking;scalability;simulation	Robert P. Kurshan	2007		10.1007/978-3-540-77966-7_2	model checking;real-time computing;simulation;formal verification;computer science;formal equivalence checking;code coverage;programming language;abstraction model checking;algorithm;functional verification;systems design	Logic	-47.57643448829642	33.250957599693194	149936
930a7be10c0e069b76d3e01d8e747ceecf457ca4	an approach for diagnosing unexpected faults in web service flows	ddl reasoning;business process execution language;ddl;inference mechanisms;web service;runtime;web services fault diagnosis logic grid computing laboratories information processing computers testing runtime engines;unexpected fault diagnosis;web services business data processing fault diagnosis fault tolerant computing formal logic inference mechanisms;fault tolerant computing;business data processing;business;ddl diagnosis self healing web service flow;cognition;web services;self healing service flow execution;formal logic;web service flow;description logic;ddl reasoning unexpected fault diagnosis web service flow business process execution language self healing service flow execution dynamic description logic;diagnosis;dynamic description logic;algorithm design and analysis;self healing;business process;credit cards;fault diagnosis	Potential faults have greatly reduced the dependability of business processes, so fault diagnosis is becoming an important issue which aims at supporting self-healing service flow execution. The existing fault handling mechanism provided by BPEL can only identify the faults which have been pre-defined in standards or by users. However, unexpected faults are also the main cause of failures in service flow execution. Therefore an effective diagnosis approach is needed to solve this problem. In this paper, we propose a logic-based approach for diagnosing unexpected faults in Web service flows. This approach uses dynamic description logic (DDL) to model business processes, and diagnoses faults based on DDL reasoning. We provide the DDL-based diagnosing algorithm, which takes process description and runtime information as inputs, and returns the related information of possible faults as the result. Moreover, to improve the efficiency of online diagnosis, the incremental DDL-based diagnosing algorithm is presented. Experimental results on a demo system show the effectiveness of this approach.	algorithm;business process execution language;dependability;description logic;experiment;run time (program lifecycle phase);transaction processing system;web service	Xu Han;Zhongzhi Shi;Wenjia Niu;Fen Lin;Donglei Zhang	2009	2009 Eighth International Conference on Grid and Cooperative Computing	10.1109/GCC.2009.25	web service;real-time computing;computer science;operating system;database;distributed computing;programming language;law;computer security	SE	-43.68864512083926	40.934036459821435	150018
4ad44c4b1bbf294f14f3f777755396c768abad29	offline simulation of a managed system for testing a developed management system	object oriented methods;management system;software engineering;autonomic system;program testing;program testing software engineering digital simulation object oriented methods;design patterns offline simulation model management system testing autonomous systems information exchange network communication;development time;simulation model;system testing costs computational modeling computer simulation computer science access protocols graphical user interfaces computer network management application software humans;digital simulation	Nowadays, there is a growing need for management systems to manage various autonomous systems. These management systems are difficult to test, since their functionality includes exchange of information with various devices and applications via the network communication. There is a need for efficient methods of development and testing to minimize development time and cost. The solution suggested is an offline simulation model, where the simulation and the tested management system are placed on the same computer. This model decouples the testing of the functional aspects of the developed management system from the testing of the communication aspects. This method saves a great deal of human effort, and therefore reduces development time and cost.	management system;online and offline;simulation	Alexander Eskin;Ariel J. Frank	2003		10.1109/SWSTE.2003.1245435	test strategy;simulation;software performance testing;white-box testing;system integration testing;computer science;acceptance testing;software reliability testing;simulation modeling;management system;operational acceptance testing;software testing;application lifecycle management;system testing;test management approach;software system	AI	-36.03769224608734	37.4070774736988	150161
d3b4c7871bd106f4c4e3d620647300d43696f1f8	efficiently and transparently automating scalable on-demand activation and deactivation of services with the activator pattern	distributed computing;embedded systems;patterns	Computing systems are increasingly designed as a collection of interacting services, which constitute a set of functionality offered by a service provider or server to its clients. Many service-oriented computing systems have constraints on the resources they allocate and manage. In these systems, certain types of services should consume resources only when they are accessed by clients and clients should be shielded from where services are located, how they are deployed, and how their lifecycle is managed. The Activator pattern provides an effective means to efficiently and transparently automate scalable on-demand activation and deactivation of services accessed by many clients. This paper motivates the need for the Activator pattern, describes the structure and dynamics of canonical implementations of the pattern, and examines the benefits and liabilities of applying this pattern to services in resource-constrained computing systems.	interaction;scalability;server (computing);service-oriented device architecture	Michael Stal;Douglas C. Schmidt;William Otte	2013	Softw., Pract. Exper.	10.1002/spe.1119	computer science;operating system;data mining;database;pattern;services computing;world wide web	HPC	-38.01862353927413	45.216587426433904	150205
07a753803379fb613e73d34a55e54d71430adbc2	design phase analysis of software qualities using aspect-oriented programming	analytical models;design model;software maintenance;conference;reliability analysis aspect oriented programming design stage software analysis performance analysis;simulation based design phase analysis software quality aspect oriented programming software development software maintenance;code generation;software systems;object oriented programming;software performance;software quality analytical models performance analysis predictive models costs design methodology software systems software design software architecture stochastic processes;software architecture;quality requirement;stochastic processes;design stage software;aspect oriented programming;software quality object oriented programming software maintenance;phase analysis;software development;performance analysis;simulation based design phase analysis;functional model;reliability analysis;predictive models;analysis;design stage software analysis;software design;software quality;design methodology	If we can analyze software qualities during the design phase of development without waiting until the implementation is completed and tested, the total development cost and time will be significantly saved. Therefore in the past many design analysis methods have been proposed but either they are hard-to-learn and use or, in the case of simulation-based analysis, functionality concerns and quality concerns were intermingled in the design as well as in the implementation thereby making development and maintenance more complicated. In this paper, we propose a simulation-based design phase analysis method based on aspect-oriented programming. In our method, quality aspects remain separate from functionality aspect in the design model and the implementation code for simulation is automatically obtained by injecting quality requirements into the skeleton code generated from the design level functionality model. Our method has advantages over the conventional approach in reducing both the development cost and the maintenance costly	aspect-oriented programming;requirement;simulation	Daesung Park;Sungwon Kang;Jihyun Lee	2006	Seventh ACIS International Conference on Software Engineering, Artificial Intelligence, Networking, and Parallel/Distributed Computing (SNPD'06)	10.1109/SNPD-SAWN.2006.34	stochastic process;software architecture;aspect-oriented programming;software performance testing;design methods;computer science;function model;software design;software development;software engineering;analysis;predictive modelling;object-oriented programming;software maintenance;software quality;code generation;software system	SE	-47.711317530928596	34.35451707423646	150504
98e5e9419705a2868b0d1fbfe667fa77a719ac3a	towards ontology-based formal verification methods for context aware systems	mereotopology;context modelling;pervasive computing;mobile computing system;program verification;context model;formal verification;concurrent systems;ontologies;context aware systems;article;location model	Pervasive computing systems work within, and rely on, a model of the environment they operate in. In this respect, pervasive computing systems differ from other distributed and mobile computing systems, and require new verification methods. A range of methods and tools exist for verifying distributed and mobile concurrent systems, and for checking consistency of ontology-based context models. As a tool for verifying current pervasive computing systems both are not optimal, since the former cover mainly tree-based location models, whereas the latter are not able to address the dynamic aspects of computing systems. We propose to formally describe pervasive computing systems as distributed concurrent systems operating on the background of a mereotopological context model.	context-aware pervasive systems;formal verification	Hedda Rahel Schmidtke;Woontack Woo	2009		10.1007/978-3-642-01516-8_21	context-aware pervasive systems;human–computer interaction;formal verification;computer science;ontology;theoretical computer science;end-user computing;database;distributed computing;context model;ubiquitous computing;mereotopology;autonomic computing	HCI	-40.43251481220068	38.609266745256065	150946
4acd603d47ddf3c9edcb08c2cb117a5ee912d6b4	a corba-based distributed multimedia database management layer: design and implementation aspects	media dedicated storage servers;distributed information management layer;computer languages;design engineering;multimedia applications;java programming;application software;multimedia middleware service;media repository servers;distributed object platform integration;multimedia databases streaming media middleware java proposals object oriented databases design engineering application software computer languages distributed computing;distributed multimedia;distributed computing;multimedia servers;client server systems;corba;multimedia application;corba persistent object service;database management;distributed multimedia database management layer;distributed objects;design and implementation;distributed environment;streaming media;distributed object management;multimedia databases;java programming language;distributed databases;middleware;rm odp;open distributed processing distributed multimedia database management layer multimedia applications distributed environments persistence middleware layer multimedia databases media dedicated storage servers rm odp corba persistent object service distributed object platform integration service implementation java programming language;object oriented databases;open systems;open systems distributed object management multimedia databases distributed databases multimedia servers java client server systems;multimedia database;proposals;persistence middleware layer;open distributed processing;java;distributed environments;service implementation	Multimedia applications executing on distributed environments lack a seamless approach to handle their components’ persistent contents. In this paper; a persistence middleware layer that allows the integration of multimedia databases with media-dedicated storage servers is presented. The design of SGPOM follows the philosophy of RMODP and CORBA Persistent Object Service, thus enabling a clean integration with this distributed object platform. The main aspects related to the service implementation using the Java programming language are also described.	application programming interface;common object request broker architecture;computer data storage;database;delimiter;distributed object;java;middleware;persistence (computer science);programming language;rm-odp;requirement;seamless3d	André L. V. Coelho;Ivan Luiz Marques Ricarte	2000		10.1109/ISCC.2000.860607	application software;real-time computing;rm-odp;computer science;common object request broker architecture;middleware;database;distributed computing;distributed object;open system;java;distributed database;distributed computing environment	DB	-34.06049183450432	43.411902102356485	151107
5f071e3c78dabe64257a06d17c8fcb12e213b36d	a distributed nfv orchestrator based on bdi reasoning		Network function virtualisation (NFV) decouples network functions from physical devices, simplifying the deployment of new services. As opposed to traditional middleboxes, VNFs can be dynamically deployed and reconfigured on demand, posing strict management challenges to networked systems. Selecting VNFs from a repository, defining where they will be placed in the virtualised network as well as chaining them to achieve the desired behaviour are problems that have to be tackled by an orchestrator. In this paper, we propose a distributed approach to NFV orchestration using belief-desire-intention (BDI) reasoning, addressing the selection, placement and chaining problems through the interaction among autonomous software agents, which collectively work in a distributed and decentralised manner. Agents are capable of bidding on the allocation of resources for new VNFs, as well as managing the chaining of VNFs. Further, we validate our theoretical model through a DDoS attack case study, in which we analyse the emergent behaviour of the autonomous agents.	aggregate data;autonomous robot;belief–desire–intention software model;centralisation;computer simulation;decentralised system;denial-of-service attack;emergence;failure cause;middlebox;network function virtualization;placement (eda);selection (user interface);software agent;software deployment;testbed;theory	Frederico Schardong;Ingrid Nunes;Alberto E. Schaeffer Filho	2017	2017 IFIP/IEEE Symposium on Integrated Network and Service Management (IM)	10.23919/INM.2017.7987270	autonomous agent;distributed computing;virtualization;orchestration (computing);computer science;software deployment;software agent;chaining;multi-agent system;resource allocation	AI	-41.99334435536139	39.436227830939146	151162
ee5aab0da59e7067b64a86936a942e8d923a2b53	a universal simulation environment for embedded systems	embedded system		embedded system;simulation	Mathias Sporer;Dieter Monjau	2003			control engineering;mathematics;hardware-in-the-loop simulation	EDA	-34.25218232597348	37.38702166250963	151208
74a7dbaccf54fd302222e04fb015bb19623b1851	sensorware: programming sensor networks beyond code update and querying	distributed programs;sensor network;mobility control;c 2 7 c sensor networks;sensor nodes;d 1 8 distributed programming	Wireless ad hoc sensor networks have been largely designed with static and custom architectures for specific tasks, thus providing inflexible operation and interaction capabilities. Efforts to make sensor networks dynamically programmable stumble upon the problems of algorithmic expressiveness, compactness of transferred code, efficiency of executed code, and ease of programming. In short, the problem is the choice of abstraction for the sensor node run-time environment. Our framework, called SensorWare, defines and supports lightweight and mobile control scripts that allow the computation, communication, and sensing resources at the sensor nodes to be efficiently harnessed in an application-specific fashion, through the use of abstraction services. A key feature is that the run-time abstraction can change by dynamically defining new services. Furthermore, by making the scripts autonomously mobile we enable the deployment of the algorithm to be tied to its execution, a feature that reduces the code transferred, compared to conventional code deployment and update approaches. The implementation of SensorWare on an XScale-based prototype sensor node platform occupies less than 240 KB of code memory. The implementation is used to measure the delay and memory overheads, but more importantly, quantitatively highlight the trade-offs involved in run-time abstraction versatility.		Athanassios Boulis;Chih-Chieh Han;Roy Shea;Mani B. Srivastava	2007	Pervasive and Mobile Computing	10.1016/j.pmcj.2007.04.007	embedded system;real-time computing;wireless sensor network;computer science;theoretical computer science;operating system;distributed computing;key distribution in wireless sensor networks;mobile wireless sensor network;computer security;computer network	Mobile	-37.211677183871075	45.74117561166573	151470
3dae1702fa27d7495ef76de964cadbdcf9e93792	passive interoperability testing for request-response protocols: method, tool and application on coap protocol	coap;interoperability testing;request response protocol;passive testing	Passive testing is a technique that aims at testing a running system by only observing its behavior without introducing any test input. The non-intrusive nature of passive testing makes it an appropriate technique for interoperability testing, which is an important activity to ensure the correct collaboration of different network components in operational environment. In this paper we propose a passive interoperability testing approach, especially for request-response protocols in the context of client-server communications. According to the interaction pattern of request-response protocols, the observed interactions (trace) between the network components under test can be considered as a set of conversations between client and server. Then, a procedure to map each test case into these conversations is carried out, which intends to verify the occurrence of the generated test cases as well as to determine whether interoperability is achieved. The trace verification procedure has been automated in a passive testing tool, which analyzes the collected traces and deduces appropriate verdicts. The proposed method and the testing tool were put into operation in the first interoperability testing event of Constrained Application Protocol (CoAP) held in Paris, March 2012 in the scope of the Internet of Things. By using this approach, an amount of CoAP applications from different vendors were successfully and efficiently tested, revealing their interoperability degree.	client–server model;constrained application protocol;formal verification;interaction design pattern;internet of things;request–response;server (computing);test automation;test case;tracing (software);web services interoperability	Nanxing Chen;César Viho	2012		10.1007/978-3-642-34691-0_8	real-time computing;software performance testing;white-box testing;computer science;system testing;world wide web;computer security	SE	-38.11489252755503	35.56836725330526	151773
b907adfa0f6291557ed9cd5b7d0d79374542a94a	advances in technologies and techniques for ambient intelligence	informatica	Human activity is attracting a lot of research activity in several fields including the use of wireless sensors, positioning technologies and techniques, embedded computing, remote sensing and energy management among others. There are a number of applications where the results of those investigations can be applied, including ambient intelligence to support human activity, particularly the elderly and disabled people. Ambient intelligence is a new paradigm for the information and communications technologies where the electronic/digital environment takes care of the people presence and their needs, becoming an active, adaptive and responsive environment. The research activity on the creation of active environments which are sensitive to the presence of people and their particular activity is gaining a great relevance due to the potential benefits which offers to improve the quality of life. The invention and deployment of those environments includes the design and implementation of appropriate electronics, the creation of friendly interfaces which allows	ambient intelligence;care-of address;digital environment;embedded system;programming paradigm;relevance;sensor;software deployment;the quality of life;wireless router	César Benavente-Peces;Andreas Ahrens;Joaquim Filipe	2014	J. Ambient Intelligence and Humanized Computing	10.1007/s12652-014-0244-9	simulation;ambient intelligence;computer science;multimedia	HCI	-42.08999209243438	45.424524304516105	151784
a39812054d61d4f6eb3e0374cf0414f8e610a21d	computing optimal self-repair actions: damage minimization versus repair time	distributed system;deployment;software systems;dependability;software component;distributed systems;self healing	The dependability of a software system can be improved by online redeployment of failed software components using appropriate system self-repair actions. The effect of different self-repair actions can vary to a great extent w.r.t. the resulting temporary service unavailability and reduced redundancy of services. We therefore developed an approach to efficiently compute self-repair actions which realize requested repair steps in a nearly optimal manner. We show that our approach achieves a suitable compromise between the usually infeasible optimal deployment modification w.r.t. damage minimization and repair time minimization by presenting a number of simulation results.		Matthias Tichy;Holger Giese;Daniela Schilling;Wladimir Pauls	2005	ACM SIGSOFT Software Engineering Notes	10.1145/1082983.1083224	reliability engineering;real-time computing;engineering;component-based software engineering;software engineering;dependability;distributed computing;software deployment;software system	SE	-46.71625144918118	40.323658426000094	151875
3c982f787b3571063154627df744d28cf60e8846	mercury: properties and design of a remote debugging solution using reflection	mirrors;run time evolution;agile development;remote debugging;reflection;se mantic instrumentation;adaptable distribution	Remote debugging facilities are a technical necessity for devices that lack appropriate input/output interfaces (display, keyboard, mouse) for programming (e.g., smartphones, mobile robots) or are simply unreachable for local development (e.g., cloud-servers). Yet remote debugging solutions can prove awkward to use due to re-deployments. Empirical studies show us that on average 10.5 minutes per coding hour (over five 40-hour work weeks per year) are spent for re-deploying applications (including re-deployments during debugging). Moreover current solutions lack facilities that would otherwise be available in a local setting because it is difficult to reproduce them remotely. Our work identifies three desirable properties that a remote debugging solution should exhibit, namely: run-time evolution, semantic instrumentation and adaptable distribution. Given these properties we propose and validate Mercury, a remote debugging model based on reflection. Mercury supports run-time evolution through a causally connected remote meta-level, semantic instrumentation through the reification of the underlying execution environment and adaptable distribution through a modular architecture of the debugging middleware.	debugging;input/output;mercury;middleware;mobile robot;reflection (computer programming);reification (knowledge representation);smartphone;unreachable memory	Nick Papoulias;Noury Bouraqadi;Luc Fabresse;Stéphane Ducasse;Marcus Denker	2015	Journal of Object Technology	10.5381/jot.2015.14.2.a1	embedded system;real-time computing;simulation;reflection;computer science;engineering;software engineering;agile software development;algorithmic program debugging;programming language	Mobile	-38.29396383371335	41.08151993937493	151876
d06adbbc1ddadae319f99ea3c8d00f603e0b0426	reusing user interfaces for multiple embedded systems via differential logical ui modeling		User interface (UI) centric embedded systems such as smart phones, tablets, and smart TVs are ever proliferating. While many model-based UI development environments provide automatic UI executable generation, they are focused on web-based systems and not suitable for embedded systems. Accordingly, developers create a separate UI model for each target embedded system while failing to reuse their UI models.This paper proposes differential logical UI modeling (DLUM) that solves these difficulties. DLUM comprises (1) a graphical modeling language for logical UI model (LUM) and differential LUM, (2) a method for deriving a UI implementation by weaving a base LUM and a differential LUM, and (3) its supporting tool. DLUM enables developers to model only differential parts of UI models compared to a base model. DLU generates LUM from differential LUM, which consequently enables deriving complete UI implementations. We have fully implemented a modeling tool for DLUM as Eclipse plug-in using Eclipse Graphical Modeling Framework (GMF). We have also performed a case study with an alarm application in Android targeted for multiple embedded systems with various resolutions from HVGA to XGA. The case study clearly shows how DLUM makes the modeling of UIs for embedded systems concise and allows reusing UIs for multiple embedded systems.	embedded system;user interface	Saehwa Kim	2012		10.1007/978-3-642-32692-9_42	ui data binding;theoretical computer science	EDA	-42.816088078734836	32.52840729755279	151935
a9b096f3f0603f5f14e999526d5bddd8a9a943d5	model-driven performance prediction of distributed real-time embedded defense systems	analytical models;software;software engineering embedded systems;software engineering;conference paper;scenario driven experimental platform model driven performance prediction distributed real time embedded defense systems autonomous defence systems system execution modelling tools performance requirements;embedded systems;computational modeling;engines;unified modeling language predictive models computational modeling analytical models data models software engines;unified modeling language;predictive models;data models	Autonomous defence systems are typically characterised by hard constraints on space, weight and power. These constraints have a strong impact on the non-functional properties, and performance, of the final system. System execution modelling tools permit early prediction of the performance of model driven systems, however the focus to date has been on understanding the performance of a model rather than determining if it meets performance requirements, and subsequently carrying out analysis to reveal the causes of any requirement violations. In this paper, we propose an integrated approach to performance prediction of model-driven distributed real time embedded defence systems. Our architectural prototyping system supports a scenario-driven experimental platform for evaluating model suitability within a set of deployment and real-time performance constraints. We present an overview of our performance prediction system, demonstrating the integration of modelling, execution and visualisation, and discuss a case study to illustrate our approach.	autonomous robot;computer performance;directory services markup language;domain-specific language;domain-specific modeling;embedded system;emulator;model-driven architecture;model-driven integration;performance prediction;real-time clock;requirement;software deployment;tracing (software);usability	Katrina E. Falkner;Vanea Chiprianov;Nickolas J. G. Falkner;Claudia Szabo;James Hill;Gavin Puddy;Daniel Fraser;Adrian Johnston;Marianne Rieckmann;Andrew Wallis	2013	2013 18th International Conference on Engineering of Complex Computer Systems	10.1109/ICECCS.2013.29	unified modeling language;data modeling;real-time computing;simulation;performance engineering;computer science;systems engineering;operating system;software engineering;predictive modelling;computational model	Embedded	-43.778222475071836	34.18418333843106	152049
adcf8e0258c61e0f5a1dd8cbb50ab23ce71736cd	introduction to the first workshop on qos in self-healing web services (qsws 2008)	composite web service;web service;service level agreement;quality of service	The development of composite services leads to various challenges concerning their Quality of Service (QoS) and similar non  functional characteristics. On the one hand, a composite Web Service depends on the QoS properties of its own Web Service  suppliers in order to provide the user with a satisfactory service. On the other hand, the main issues for the fulfillment  of QoS and service-level agreements are concerned with Web Service performance variability. Indeed, the QoS of a Web Service  may evolve relatively frequently, either because of internal changes or because of workload fluctuations. The performance  of the composite Web Service may be significantly improved by monitoring the execution of the component Web Services and by  flexibly reacting to faults and anomalies in a timely fashion.  	quality of service;web service	Liliana Ardissono;Danilo Ardagna;Khalil Drira	2008		10.1007/978-3-642-00328-8_41	service provider;web service;web application security;service level requirement;service level objective;mobile qos;quality of service;service assurance;web standards;computer science;service delivery framework;ws-policy;service design;database;world wide web;computer network	Theory	-47.66710299949214	43.24593079010947	152062
46898c3bed3f601d21cd65980a1d7bc774a511aa	a service administration design pattern for dynamically configuring communication services in autonomic computing systems	autonomic system;dynamic services;design patterns	"""Rapidly growing collection of communication services is now available on the Internet. A communication service is a component in a server that provides capabilities to clients. Services available on the Internet include: WWW browsing and content retrieval services software distribution service. A common way to implement these services is to develop each one as a separate program and then compile, link, and execute each program in a separate process. However, this """"static"""" approach to configuring services yields inflexible, often inefficient, applications and software architectures. The main problem with static configuration is that it tightly couples the implementation of a particular service with the configuration of the service with respect to other services in an application. In this paper we propose a system for dynamically configuring communication services. Server will invoke and manage services based on time stamp of service. The system will reduce work load of sever all services in executed by different threads based on time services are executed, suspended and resumed. Different patterns are used designing of service administration pattern that are reflective monitoring, strategy and thread per connection. This paper satisfies the properties of autonomic system: For monitoring use reflective monitoring, Decision making we use strategy pattern. Thread per connection is used of executing service in different thread. The pattern is described using a java-like notation for the classes and interfaces. A simple UML class and Sequence diagrams are depicted."""	autonomic computing;software design pattern	Vishnuvardhan Mannava;T. Ramesh	2012		10.1007/978-3-642-28487-8_6	software design pattern;real-time computing;differentiated service;computer science;service delivery framework;operating system;distributed computing;services computing	HPC	-35.81727100010655	42.00364701038538	152076
8c5ef4217c0ee0e7b7aa3a51baa4951edbbe586a	a timed automata-based method to analyze east-adl timing constraint specifications	timing constraints;uppaal;engineering and technology;teknik och teknologier;model based development;timed automata;east adl	The increasing development complexity of automotive embedded systems has led to industrial needs of improved information management, early verification and validation of a system etc. EAST-ADL; an automotive-specific architectural description language provides a structured model-based approach for information management throughout the development process. A method to formally analyze consistency of EAST-ADL based timing constraint specifications using timed-automata is presented. A mapping scheme providing a basis for automated model-transformations between EAST-ADL and timed-automata is the main contribution. The method is demonstrated with a case study of a brake-by-wire system. Guidelines for extending the mapping framework are also provided.	east-adl;timed automaton	Tahir Naseer Qureshi;De-Jiu Chen;Martin Törngren	2012		10.1007/978-3-642-31491-9_23	real-time computing;simulation;computer science;systems engineering;engineering;model-based design	EDA	-41.09837372712055	32.75864645887544	152318
9db80359f2ae5323260df8d3d2c07db28df1d436	seamless cross-domain connectivity for enabling domain autonomy in a federated soa	software architecture business data processing;federated soa;availability;cross domain connectivity federated soa service domain autonomy;maintenance engineering;portfolios;software architecture;business data processing;seamless crossdomain connectivity;domain autonomy;federated soa seamless crossdomain connectivity domain autonomy;availability automation portfolios service oriented architecture maintenance engineering conferences advertising;service domain autonomy;service oriented architecture;cross domain connectivity;conferences;advertising;automation	This paper proposes an approach for cross-domain connectivity that enables domain autonomy and that preserves across domains properties that are taken for granted by services within a domain.	seamless3d;service-oriented architecture	Ignacio Silva-Lepe;Isabelle Rouvellou;Rahul P. Akolkar;Arun Iyengar	2010	2010 IEEE International Conference on Web Services	10.1109/ICWS.2010.57	maintenance engineering;software architecture;availability;computer science;automation;service-oriented architecture;database;distributed computing;world wide web	Robotics	-47.01756091554229	45.20014063316236	153146
57198372fffb57940cc2c674c3cd5a7dd727d4c9	biologically-inspired concepts for self-management of complexity	large class;robust server-side application;rapid development;j2ee constraint;j2ee application;serious challenge;legacy system;j2ee platform;biologically-inspired concepts;human factors engineering;automatic control;complex systems;systems engineering;biomimetics;computational complexity;complex system	Inherent complexity in large-scale applications may be impossible to eliminate or even ameliorate despite a number of promising advances. In such cases, the complexity must be tolerated and managed. Such management may be beyond the abilities of humans, or require such overhead as to make management by humans unrealistic. A number of initiatives inspired by concepts in biology have arisen for self-management of complex systems. We present some ideas and techniques we have been experimenting with, inspired by lesser-known concepts in biology that show promise in protecting complex systems and represent a step towards self-management of complexity	autonomic computing;biological system;complex systems;complexity;computer science;experiment;humans;microsoft software assurance;mike lesser;mission assurance;overhead (computing);self-management (computer science);software engineering;swarm	Roy Sterritt;Michael G. Hinchey	2006	11th IEEE International Conference on Engineering of Complex Computer Systems (ICECCS'06)	10.1109/ICECCS.2006.52	biomimetics;complex systems;computer science;engineering;artificial intelligence;management science;computational complexity theory	DB	-44.03438187267976	39.091285374276005	153193
922baffebae1fd401106dfd844d5ddd37d4d39ae	jcsp agents-based service discovery for pervasive computing	pervasive computing;jcsp;service discovery;agents;csp	Device and service discovery is a very important topic when considering pervasive environments. The discovery mechanism is required to work in networks with dynamic topology and on limited software, and be able to accept different device descriptions. This paper presents a service and device discovery mechanism using JCSP agents and the JCSP network package jcsp.net2.	jcsp;library (computing);mobile agent;mobile social network;personal digital assistant;pervasive informatics;service discovery;software architecture;ubiquitous computing;usability	Anna Magdalena Kosek;Jon M. Kerridge;Aly A. Syed;Alistair Armitage	2009		10.3233/978-1-60750-065-0-363	distributed computing;software;service discovery;ubiquitous computing;computer science;jcsp	HCI	-39.3556555128288	45.93929722617855	153293
1b185a218a3d49029862ba4f5018c2815a47a3a5	a relationship-aware methodology for context-aware service selection	context aware computing;relationship management;service selection;smart objects;relationship context	A future smart space will include many intelligent objects that can operate using ubiquitous computing technology. These intelligent objects should provide personalized, ad hoc application services by automatically recognizing relationships with users. To do so, there should be a method of establishing awareness of the relationship between a user and an object. However, while several recent approaches have suggested simple tools to improve the relationships themselves, very few methods are proposed for recognizing those relationships. Hence, this paper proposes a methodology for reasoning the relationship context between a user and an object. To do so, the Case-Based Reasoning method is adopted and amended. We also implement a prototype system and analyse significance via a laboratory experiment to demonstrate the feasibility of the ideas proposed in this paper.	case-based reasoning;hoc (programming language);personalization;prototype;ubiquitous computing	Ohbyung Kwon;Nam Yeon Lee	2011	Expert Systems	10.1111/j.1468-0394.2010.00548.x	customer relationship management;computer science;knowledge management;data mining;world wide web	HCI	-41.13131684368973	44.96041215503645	153532
701466437faf3baaec16f4e55f6df92899d6b3cd	easing the smart home: semi-automatic adaptation in perceptive environments	smart home;article	"""This paper analyses the requirements of automation and adaptation in the so called perceptive environments. These environments are places with the ability of perceiving the context through sensors and other mechanisms. Focusing on personal/home environments, we present a first approach and prototype to semi-automatic adaptation of Perceptive Environments through a system of rule-based, configurable and modular agents, which are able to explain their behaviors and to adapt to the changing habits of the users. This prototype has been implemented over a real environment: a living room equipped with ambient intelligence capabilities. The core of the system relies on a set of modular agents equipped with rules. Those rules are composed of triggers, conditions and actions that enable them to express desired behaviors of the environment as well as to infer high-level context from low level context. One of the main objectives of the system is to leverage the control of the user over his/her own environment, making it easy to create powerful and personal behaviors without expert assistance. In this sense this work follows Greenberg’s thought of making """"simple ideas simple to be done"""" [Greenberg 07]."""	ambient intelligence;bernard greenberg;control system;database trigger;genie;graphical user interface;high- and low-level;home automation;intelligent agent;keystone effect;logic programming;natural language;prototype;requirement;scalability;semiconductor industry;sensor;software agent;type system	Manuel García-Herranz;Pablo A. Haya;Abraham Esquivel;Germán Montoro;Xavier Alamán	2008	J. UCS	10.3217/jucs-014-09-1529	home automation;simulation;computer science;artificial intelligence;software engineering	HCI	-40.92057125957558	42.14404329531979	153537
a0ce6ac168ad3dd7fed0710cc3b1305f9951a546	a reference architecture and functional model for monitoring and diagnosis of large automated systems	push pull production;computerized monitoring manufacturing automation remote monitoring logistics virtual manufacturing competitive intelligence automatic control control systems materials handling fault diagnosis;hierarchical systems;data communication;scaling up;condition monitoring warehouse automation logistics push pull production hierarchical systems computerised monitoring fault diagnosis large scale systems factory automation;logistics;condition monitoring;functional model;factory automation;computerised monitoring;hierarchical levels reference architecture functional model large distributed automated material handling systems intelligent monitoring fault diagnosis complex automated systems manufacturing logistics intralevel data communication messaging generic functional models artificial intelligence techniques pull communication push communication monitoring and diagnosis units;reference architecture;warehouse automation;large scale systems;fault diagnosis	This research develops a reference architecture and functional model for intelligent monitoring and fault diagnosis of large complex automated systems in manufacturing and logistics. This reference architecture organises the monitoring and diagnosis functions in a modified hierarchical manner with multiple levels, and is therefore easily scalable to meet growing requirements of different application scenarios. The architecture is efficient as it allows problems to he quickly dealt with closer tu their sources; therefore minimising inter-level data communication and messaging. Similarly the proposed functional model fur monitoring and diagnosis unit can he adapted (i.e., scaled u p o r down) to suit the needs of the application, and indeed it tits well into the proposed reference architecture. A successful case of applying the proposed architecture and model is presented which serves to illustrate how they can he implemented in real-life to solve a class of monitoring and diagnosis problems for large automated systems typically found in manufacturing and logistics.	function model;logistics;real life;reference architecture;requirement;scalability	Dan Hong Zhang;Jing-Bing Zhang;Ming Luo;Yue Tang;Liqun Zhuang	2003		10.1109/ETFA.2003.1248742	reference architecture;logistics;embedded system;space-based architecture;systems engineering;engineering;function model;operating system;automation	Robotics	-38.84750463851158	40.34883200479431	153585
1ea1c3040f3c795a9e54db4b42e2604cceddb585	scalable problem-oriented approach for dynamic verification of embedded systems		Abstract   A model-based problem-oriented approach for the dynamic verification of functional properties of embedded systems is presented. It is a generic and scalable approach, especially useful in systems where embedded devices are tightly coupled to physical processes. A set of modeling guidelines and abstraction layers are proposed that provide a better understanding and visibility of an application's behavior and resource usage, and of the interactions between the different components of an embedded device and the physical process it interacts with. An application example is given for the design and verification of a digital PID controller that integrates Simulink models, SystemC models and an ARM Cortex-M3 processor emulator.	embedded system	Francisco Mendoza;Philipp Nenninger;Markus Ruppert;Jürgen Becker	2012		10.3182/20120403-3-DE-3010.00011	embedded system;computer architecture;real-time computing;computer science;functional verification	Embedded	-39.60434852438956	33.98963583311316	153702
9237f160797cc0d6bba7d1eff26efa86658faa59	a generic, scalable reconfiguration infrastructure for sensor networks functionality adaption	wireless sensor networks field programmable gate arrays;abstracts irrigation containers table lookup protocols reliability;generic scalable reconfiguration infrastructure heterogeneous sensor network dynamic adaptation sensor node generic structure fully decentralized communication infrastructure web interface configuration requests fpga based sensor networks reconfiguration infrastructure hardware functionality reconfigurable nodes dynamic reconfiguration sensor network functionality adaption;field programmable gate arrays;wireless sensor networks	By applying dynamic reconfiguration to reconfigurable nodes in a sensor network, parts of their hardware functionality may be adapted at runtime. However, a complex challenge is the dynamic distribution of configurations in a heterogeneous network. This work advocates a novel reconfiguration infrastructure for FPGA-based sensor networks. Configuration requests may be triggered by nodes themselves, remotely by other nodes, or via a web interface. The main advantages of the solution are a fully decentralized communication infrastructure, the generic structure of sensor nodes as well as a dynamic adaptation of both size and functionality of a heterogeneous sensor network at runtime.	field-programmable gate array;run time (program lifecycle phase);scalability;user interface	Alexander Biedermann;Boris Dreyer;Sorin A. Huss	2013	2013 IEEE International SOC Conference	10.1109/SOCC.2013.6749705	sensor web;embedded system;real-time computing;wireless sensor network;computer science;key distribution in wireless sensor networks;mobile wireless sensor network;field-programmable gate array;computer network	Mobile	-38.65101939290868	45.95714153436201	153862
f70664c3be3230426da1d2351e56390ba685c632	a factory to design and build tailorable and verifiable middleware	verifiable middleware;complementary project;limited runtime impact;petri nets;application-tailored middleware;key step;heterogeneous non-functional requirement;middleware engineering;current work;middleware construction;application requirement	Heterogeneous non-functional requirements of Distributed Real-Time Embedded (DRE) system put a limit on middleware engineering: the middlew are must reflect application requirements, with limited runtime impact. Thus, build ing an application-tailored middleware is both a requirement and a challenge . In this paper, we provide an overview of our work on the construction of middleware. We focus on two complementary projects: the definition of middlew are that provides strong support for both tailorability and verification of its inter nals; the definition of a methodology that enables the automatizing of key steps of middleware construction. We illustrate how our current work on PolyORB, Ocarina and the use of Pe tri Nets allows designer to build the middleware that precisely matches its application requirements and comes with precise proof of its properties.	common object request broker architecture;distributed computing;embedded system;expert system;formal verification;functional requirement;high- and low-level;high-level programming language;internet backbone;middleware;non-functional requirement;petri net;real-time computing;real-time transcription;triangular function	Jérôme Hugues;Fabrice Kordon;Laurent Pautet;Thomas Vergnaud	2005		10.1007/978-3-540-71156-8_7	embedded system;middleware;real-time computing;engineering;message oriented middleware;middleware;database	Embedded	-40.46238938715184	33.281320814224735	153895
3fd98737bb20af3f21b7712bd9e3e8b6e5014e99	dealing with scale and adaptation of global web services management	planetlab;standards;service management;web service;scale;adaptation;web services management;middleware;service oriented architecture;use case	Service Oriented Architectures (SOA) are becoming the prevalent approach for realizing modern services and systems. SOA offers superior support for autonomy (decoupling) and heterogeneity compared to previous generation middleware systems, resulting in more scalable and adaptive solutions. However, SOA have not adequately addressed management, while traditional management solutions do not sufficiently scale to address the needs of (global) Web services. We propose scalable management based on models and industry standards. We discuss a use case for global service management and present its design, implementation, and preliminary evaluation. We retain all the benefits of SOA while also enabling global scale manageability. Our approach provides manageability that is comprehensible for administrators yet automated enough for integration into autonomous systems.		William Vambenepe;Carol Thompson;Vanish Talwar;Sandro Rafaeli;Bryan Murray;Dejan S. Milojicic;Subu Iyer;Keith I. Farkas;Martin F. Arlitt	2007	Int. J. Web Service Res.	10.4018/jwsr.2007070104	use case;web service;scale;service management;computer science;knowledge management;service-oriented architecture;middleware;law;world wide web;oasis soa reference model;adaptation	Web+IR	-44.7413594009565	41.07936998899575	153897
0b4c3b7fa10effdb58e327c7deebd82dc2c7563e	intelligent computer-based monitoring and fault isolation for industrial processes	fault isolation		fault detection and isolation	James H. Graham;Patricia A. S. Ralston	2002	I. J. Comput. Appl.		computer science;distributed computing;fault detection and isolation	Logic	-36.38839866016852	36.8424016747665	153898
8db15b7190693e4db9cfb09df004968147cc8ceb	an event-b interpretation for spardl model	analytical models;software;control systems;formal specification;context radiation detectors control systems analytical models context modeling software;automobiles;event b;ambiguities event b interpretation spardl model real time system periodic behavior mode transition mechanism control system development automobile spacecraft requirement modeling language periodic control system;radiation detectors;space vehicles automobiles formal specification formal verification periodic control real time systems simulation languages;radiation detector;modeling language;context model;requirement analysis;software requirements;periodic control;control system;formal verification;requirement analysis spardl event b;simulation languages;context modeling;spardl;context;analytical model;space vehicles;real time systems	Real time systems consisting of periodic behaviors together with the mode transition mechanism are largely applied in the development of control systems for spacecrafts and automobiles in industry. We have proposed a requirement modeling language called SPARDL for modeling and analyzing such periodic control systems in [11]. In this paper, we specify an Event-B interpretation for the SPARDL model. The semantics of SPARDL is presented by Event-B and a refinement framework is introduced to develop the Event-B models based on the features of the SPARDL model. Furthermore, a case study is analyzed to show the effectiveness of our proposed approach to modeling and validation of the SPARDL model by Event-B.	b-method;control system;correctness (computer science);modeling language;refinement (computing);rodin tool;simulation;stepwise regression;top-down and bottom-up design	Jianwen Li;Zheng Wang;Yongxin Zhao;Geguang Pu;Yanxia Qi;Bin Gu	2011	2011 IEEE 13th International Symposium on High-Assurance Systems Engineering	10.1109/HASE.2011.27	control engineering;real-time computing;simulation;computer science;control system;software engineering;context model;programming language;particle detector	Embedded	-44.251082336802405	32.90841896850918	153988
328b4a152a5b4e654891b77a225fdd22c419d093	new solutions for optimal hardware tests of reconfigurable hardware systems	reconfiguration;hardware verification;testing;embedded system;fault collapsing;optimization	This research paper deals with Reconfigurable Hardware Systems (abbreviated, RHS) that should be adapted to their environment under well-defined conditions. A reconfiguration scenario is a run-time hardware operation allowing the addition/removal of hardware components. We classify the reconfiguration scenarios into three levels: Architectural, Structural and Data Reconfiguration Levels. We propose a new solution for optimal hardware tests of RHS based on the definition of new fault collapsing relationships termed Inter-Equivalence, Inter-Dominance and Redundancy.	field-programmable gate array;run time (program lifecycle phase);turing completeness	Asma Ben Ahmed;Olfa Mosbahi;Mohamed Khalgui	2015	2015 International Conference on Pervasive and Embedded Computing and Communication Systems (PECCS)		hardware compatibility list;embedded system;parallel computing;real-time computing;computer science;control reconfiguration;operating system;hardware architecture;software testing	EDA	-47.98967753014768	33.87233439214023	153989
09799b79b1d9e0fc64b49281fd98e811183380f3	using runtime paths for macroanalysis	p2p system;dynamic distributed system;path analysis;software component;statistical inference;internet services;system management	We introduce macro analysis, an approach used to infer the high-level properties of dynamic, distributed systems, and an indispensable tool when faced with tasks where local context and individual component details are insufficient. We present a new methodology, runtime path analysis, where paths are traced through software components and then aggregated to understand global system behavior via statistical inference. Our approach treats components as gray boxes and complements existing micro analysis tools, such as code-level debuggers. We use runtime paths to deduce application state, detect failures, and diagnose problems, all in an application-generic fashion.	complement (complexity);component-based software engineering;debugger;distributed computing;high- and low-level;path analysis (statistics);state (computer science)	Mike Y. Chen;Emre Kiciman;Anthony J. Accardi;Armando Fox;Eric A. Brewer	2003			path analysis;statistical inference;real-time computing;systems management;simulation;computer science;component-based software engineering;operating system;distributed computing	SE	-40.77072698577691	38.004001504203444	153994
5045da85424a8a70cb485d3aa808799ecdf175f1	bio-inspired self-organizing architecture for distributed components	computers;software;dynamic change;biological process bio inspired self organizing architecture distributed modular component dynamically associated modular agent;mobile agents middleware;magnetic heads;agent based;mobile agents;satisfiability;data mining;runtime;computer architecture;dynamically associated modular agent;distributed modular component;biological systems distributed computing biology computing large scale systems computer architecture scalability computer networks centralized control runtime environmental management;mobile communication;self organization;middleware;functional requirement;bio inspired self organizing architecture;biological process	We describe a novel approach for managing self-organizing, distributed modular components in dynamically changing environments. The main concept is to fabricate a system which is composed of dynamically associated modular agents, that can migrate and reorganize by itself while the system is being executed. Association between modular agents can be varied and transmuted according to components' own migration schemes including deployment based on biological processes. This paper presents a self-organizable architecture, which can reorganize and reconfigure a system based on modular agents. It is contrived through observation of biological phenomena, and implements a platform to host the architecture in dynamically changing environments. We draw several key features of the modular agents, describe the principles of the modular agent-based self-organizable framework, and depict how the proposed framework satisfies the functional requirements of network applications, which are made of several agents. We also demonstrate the efficiency and scalability of the framework through examining some simulation results.	agent-based model;autonomous robot;autonomy;british informatics olympiad;distributed computing;distributed element model;functional requirement;middleware;organizing (structure);scalability;self-organization;simulation;software deployment	Ki-Won Yeom;Ji-Hyung Park	2009	2009 International Conference on Ultra Modern Telecommunications & Workshops	10.1109/ICUMT.2009.5345515	real-time computing;self-organization;mobile telephony;computer science;theoretical computer science;operating system;middleware;distributed computing;biological process;functional requirement;satisfiability	Robotics	-38.63331065093507	43.94067357892697	154143
4e98ee53eec73f691852dac7042392a963f68e4a	model-driven development with predictable quality	components;performance;model driven development;development environment;model checking;predictable assembly;component model;performance prediction	The PACC Starter Kit is an eclipse-based development environment that combines a model-driven development approach with reasoning frameworks that apply performance, safety, and security analyses. These analyses predict runtime behavior based on specifications of component behavior and are accompanied by some measure of confidence.	eclipse;model-driven architecture;model-driven engineering;run time (program lifecycle phase)	James Ivers;Gabriel A. Moreno	2007		10.1145/1297846.1297933	model checking;real-time computing;simulation;performance;computer science;component object model;development environment;programming language	SE	-43.816411460443014	33.15755194973891	154791
dc8f723cc646c2ddfaac6aa716e81eea68cc5fdf	synchronous programming techniques for embedded systems: present and future	synchronous programming;code generation;transport system;embedded system;control flow;reactive system;data flow;globally asynchronous locally synchronous;wireless systems	The synchronous programming methodology for reactive systems has been developed since the beginning of the 80's and it is currently used in numerous critical embedded systems projetcs. The methodolody is based on a strong mathematical framework that rigorously established the semantics of synchronous formalisms. The main industrial tools are Scade (Telelogic), Esterel Studio (Esterel Technologies), and Sildex (TNI). Current applications concern avionics, transportation systems, energy, telecom and wireless systems, etc. We present the general synchronous framework and the formalisms tailored to data-flow or control-flow dominated applications. We discuss the main issues in efficient code generation and formal property verification (safety, timing, etc.). We discuss the strength and limits of the basic synchronous paradigms, and present new ways of designing globally asynchronous / locally synchronous (GALS) systems.	embedded system;synchronous programming language	Gérard Berry	2001		10.1007/3-540-45449-7_4	embedded system;data flow diagram;real-time computing;lustre;reactive system;computer science;distributed computing;programming language;control flow;code generation;synchronizer	EDA	-38.944868440570595	32.61709224807904	154813
e7a972392f1a97adc99e09cef53bce3e9783b34b	a framework for isolating connection expection management	group editors;iris;java	This paper presents an abstract, object-oriented application framework for isolating connection related failure management from the main application. It also describes our experience in designing and developing a specific realization of this abstract framework. The isolation is achieved by introducing a “connection layer”, designed as an objectoriented application framework, in between the application and the middleware. The main contribution of such a framework is the loose coupling between the application and the underlying middleware. Furthermore, the “connection layer” provides a simple middleware independent API enabling applications to be migrated to multiple middleware platforms.	application framework;application programming interface;loose coupling;middleware	Partha Pratim Pal	2000	ACM Comput. Surv.	10.1145/351936.351965	real-time computing;computer science;operating system;distributed computing;programming language;java	PL	-35.68657532327314	42.28093870621999	155097
242e7199fb9b9580a6213f5592de597ab06934c4	greenmind - an architecture and realization for energy smart buildings	energy smart buildings;bernoulli building	Existing buildings are responsible for more than 40% of the world’s total primary energy consumption. Current building management systems fail to reduce unnecessary energy consumption and preserve user comfort at the same time mainly because they are unable to cope with dynamic changes caused by user’s interaction with the environment. To cope with this dynamicity, we propose a software architecture for energy smart buildings that includes a set of concrete software solutions that tackle energy consumption subsystems, i.e., heating/cooling, lighting, workstations, and appliances, in order to save significant amount of energy whilst preserving user comfort. Experimental results carried out in the Bernoulli building, a 12.000 square meter building of the University of Groningen, show that the proposed solutions are able to save up to 56% of electricity used for lighting, at least 20% of electricity used for heating while the savings from controlling workstations as well as other appliances are 33% and 10%, respectively. Totally, our solution is expected to bring up to 28% of saving over total energy consumption in buildings such as the Bernoulli building.	battery management system;bernoulli polynomials;brian;computer cooling;euler–bernoulli beam theory;lighting control system;programmer;software architecture;while;workstation	Faris Nizamic;Tuan Anh Nguyen;Alexander Lazovik;Marco Aiello	2014		10.2991/ict4s-14.2014.3	structural engineering;architectural engineering	AI	-35.14567218159747	39.27445063438008	155379
30d426c5cd6052f855c79456fbda7a7200c2620b	a flexible specification framework for hardware-software codesign	fault clustering;hardware software codesign;defect clustering;reject ration;fault coverage;defect level	In this poster, we present a new specification technique for complex hardware-software systems, based on sta dard high-level programming languages, such as C, C++, Java, Scheme, or Ada, without extensions or semantic changes. Unlike previous approaches, the designer may choose the model of computation and the specification language that best suits her needs, while still being able to formally verify the correctness of the specification. The details of the available hardware and software resources, and the implementation of the different models of computation are encapsulated in libraries to maximize reuse in system specifications. Figure 1 shows the basic architecture of our specification framework. The actual model of the application is built on top of two libraries:libarch andlibMoC . The libarch library encapsulates the details of the specific hardware and software resources, so that the system specification remains independent of the target system. Architectural exploration of different implementation alternatives is done by modifying this library. ThelibMoC library encapsulates the details of the specific model of computation. To be verifiable, the application code should use the interface provided by this library. Then, we use external tools to verify different properties of the model of computation. For every pair (specification language, model of computation) we define a new MoC library component, with well-defined interfaces, providing support of the precise semantics of that model of computation from the specification language. libMoC currently supports C++, Java, Ada, and Scheme programming lanImplementation independent Implementation dependent Verifiable part Application HW and SW resources OS Layer libMoC Models of Comp	ada;c++;correctness (computer science);device driver synthesis and verification;encapsulation (networking);formal verification;high- and low-level;high-level programming language;java;library (computing);model of computation;operating system;scheme;software system;specification language	José Manuel Moya;Francisco Moya;Juan Carlos López;Santiago Domínguez	2000		10.1145/343647.344148	embedded system;parallel computing;real-time computing;fault coverage;engineering	PL	-40.38104064146863	34.58119903566832	155428
2a44df0360f50f1ef41a85fae98c0ae65076a6ec	autonomous adaptation of user interfaces to support mobility in ambient intelligence systems	available interaction resource;variable environment condition;ami system;user interface;ami application;embedded device;autonomous adaptation;environment change;different specific interaction resource;interaction device;ambient intelligence system;interaction resource;environment condition;user interfaces;ambient intelligence	The work presented in this paper is focused on building Ambient Intelligence (AmI) applications capable of moving from one environment to another, while their user interface keeps adapting itself, autonomously, to the variable environment conditions and the available interaction resources. AmI applications are expected to interact with users naturally and transparently, therefore, most of their interaction relies on embedded devices that obtain information from the user and environment. This work implements a framework for AmI systems that elevates those embedded devices to the class of interaction resources. It does so by providing a new level of abstraction that decouples applications, conceptually and physically, from the different specific interaction resources available and their underlying heterogeneous technologies. In order to drive the adaptation process to environment changes, the system makes use of a set of models that describe the user, environment conditions and devices, and algorithms for context-aware selection of the interaction devices.	ambient intelligence;user interface	Gervasio Varela	2013		10.1145/2480296.2480335	user interface design;simulation;user modeling;ambient intelligence;human–computer interaction;computer science;user interface;world wide web	HCI	-40.9193754045744	43.021227023800236	155598
9631409d7d12ead2d48119976bec46bed7c58add	an architecture framework for modelling and simulation of situational-aware cyber-physical systems		Situational Aware (SiA) Cyber-physical systems (CPS) harmoniously integrate computational and physical components to being aware of what is happening in the surroundings and using this information to decide and act. Architecture description of SiA-CPS can be a valuable tool to reason about the selected solutions, and to enable code generation and simulation. This paper presents an architecture framework that automatically generates from a SiA-CPS architecture description, an executable code used to simulate the architecture model and evaluate it in terms of data traffic load, battery level and energy consumptions. The framework makes use of a model transformation approach where, three SiA-CPS domain-specific modeling views are automatically transformed into the input language of CupCarbon, an open source tool supporting the simulation of sensor network architectures.	architecture framework;cyber-physical system;simulation	Mohammad Sharaf;Moamin Abughazala;Henry Muccini;Mai Abusair	2017		10.1007/978-3-319-65831-5_7	real-time computing;enterprise architecture framework;computer science;architecture;systems design;cyber-physical system;systems architecture;architecture framework;software architecture description;code generation	EDA	-42.74236298707468	35.848949115858886	155829
9b5e20553e7890dd85319c696e05a877334b417e	enabling flow preservation and portability in multicore implementations of simulink models		Model-Based Design plays an important role in the development of embedded software. Automatic code generation from models is needed to minimize the possibility of introducing errors by manual coding, thereby preserving the validation and verification done on the model. Automatic code generation also eases traceability back to the model as required in most certification processes. The generated code must preserve the model semantics (or at least its properties of interest) and use the platform resources in the most efficient (or cost-effective) way. Achieving correctness and efficiency becomes harder in new multicore platforms. Commercially available multitask code generators from Simulink introduce variations to the model semantics that are dependent on the deployment option and the generated code is specific to a given platform configuration (hardware and OS), which makes reuse and portability more difficult. In this paper, we report on the early stages of a project that will improve on the portability of currently available code generation options from Simulink.	multi-core processor;simulink	Caroline Brandberg;Marco Di Natale	2018		10.1007/978-3-319-95246-8_12	verification and validation;implementation;software deployment;multi-core processor;correctness;embedded software;software portability;code generation;computer science;computer architecture	Embedded	-43.14941472406352	33.544498892564164	155893
5a60eee31be566bffd60833fba1e9a86b36c6d4a	an information-centric system for building the web of things		In recent years, common-use devices has seen a leap transition in terms of equipped technology, introducing the so called “smart things” to the consumer market. This technological and societal revolution has underpinned the realization of the Internet of Things. To take full advantage of the opportunities arising from connectivity capabilities, smart things approached the application realm bringing the novel Web of Things vision to life. The Web, as a collaborative global space of information, is a critical asset to create value-added services. However, such a promising potential entails a number of challenges including data interoperability, data integration, information reuse and collaboration. This Ph.D. work focuses on a novel approach to take a smart thing to the Web, by representing it as graph of granular and individually addressable information called IDN-Document. IDN-Documents are simply structured web resources which can be aggregated, linked, reused and combined to build collaboration oriented, value-added services. IDN-Documents are managed by the InterDataNet middleware leveraging Linked Data and		Stefano Turchi	2013		10.1007/978-3-319-06859-6_49	web service;web application security;web development;web modeling;web of things;web design;web standards;web navigation;social semantic web;web 2.0	AI	-43.84524614708393	46.05307468116623	156071
d27ea0c5e457fe57ed0e7fb46f659679b548489a	a reconfigurable security management system with service oriented architecture	security management;service oriented architecture	This paper proposes an Information Security Management System (ISMS), which is essentially a serviceoriented mechanism. The system supports distributed process changes in run-time and as needed. In addition, this study uses a Service-Oriented Software Engineering (SOSE) development methodology for designing and building a Service Oriented Architecture (SOA) ISMS. These features represent significant improvements upon existing systems because, they allow for a dramatic increase in the ease and efficiency with which system modification can occur. They also allow for the reuse of existing services and their recombination, either with other existing services, or with new software, in order to create new processes. The features afforded by this system hold tremendous potential for use within a range of industries and organizations, especially those that seek to provide on-line services to their customers or product users.	application domain;crossover (genetic algorithm);identity management;information security;management system;model-driven engineering;national supercomputer centre in sweden;online and offline;security management;service-oriented architecture;service-oriented device architecture;service-oriented software engineering;single sign-on;synchronization (computer science)	Ing-Yi Chen;Chao-Chi Huang	2008			chemical engineering;data mining;software engineering;computer science;aqueous solution	SE	-42.4421836856216	40.41098686831845	156142
b71522df610058a674bf3761c8e0398178c48f6f	high-assurance service-oriented architectures	quality attributes;reliability;real time response;real time response web service high assurance service oriented architectures quality attributes reliability attribute availability attribute performance attribute security attribute;special issues and sections;software services;real time;reliability attribute;service oriented architectures;web service;service oriented architecture application software security computer network reliability availability real time systems middleware authentication software testing computer architecture;software architecture;performance attribute;web services;software services service oriented architectures;assured service;availability attribute;quality of service;web services security of data software architecture software quality software reliability;service oriented architecture;software reliability;high assurance service oriented architectures;security attribute;security of data;software quality;real time systems	Assuring multiple quality attributes-such as reliability, availability, performance, security, and real-time response-for a variety of critical applications makes it essential to develop practical techniques for implementing high-assurance service-oriented systems.	list of system quality attributes;real-time clock;service-oriented architecture;service-oriented device architecture	Jing Dong;Raymond A. Paul;Liang-Jie Zhang	2008	Computer	10.1109/MC.2008.298	web service;computer science;operating system;service-oriented architecture;database;law;software quality	DB	-47.63675068615322	40.60803242464535	156152
1673cbae5f1f1cdbb83832f2159f495ea539b453	resilient web services for timeless business processes	resilient web services;soa;wsmf;business continuity;monitoring	Many business and scientific processes make extensive use of service-oriented architectures, using distributed services. These are often provided by third parties and are thus not under direct control of process owners. In this paper we discuss the issues of ensuring continuous and faithful execution of processes in distributed environments, focusing specifically on Web Services. Recently, we introduced a specification of Resilient Web Services, that makes current Web Services more robust, and a framework for the monitoring of Web Services, that allows detecting anomalies. In this paper, we describe alternative implementations of the framework for monitoring of Web Services. We also present possible approaches easing the deployment of Resilient Web Services: a framework consisting of tools deployable at the Web Service operator site enabling easy transformation of a regular Web Service into a Resilient Web Service, and a registry with notifications that decorates existing Web Services with resilient methods.	business process;sensor;service-oriented architecture;software deployment;web service;world wide web	Tomasz Miksa;Rudolf Mayer;Marco Unterberger;Andreas Rauber	2014		10.1145/2684200.2684281	web service;web application security;web development;web modeling;business process execution language;data web;web analytics;web design;web standards;engineering;ws-policy;service-oriented architecture;web navigation;ws-addressing;database;services computing;web intelligence;ws-i basic profile;web 2.0;world wide web;computer security;devices profile for web services	Web+IR	-45.58273856857149	43.3251495959297	156327
f3e8d14a91109ec6d284040c50b7d0a2b6cf3d3c	design of a reliable qos requirement based on rcsm by using masq architecture	education and training;distributed multimedia;situation awareness;middleware;education system;error detection	A QoS resource error detection-recovery model called “IPM_RQOS” was proposed for situation-aware middleware as RCSM. IPM_RQOS model was used to detect and recover the QoS resource errors among actions. An example of situation-aware applications is a multimedia education system. Education system for distributed multimedia holds the promise of greatly improving all forms of remote education and training. The model aims at guaranteeing it through application QoS. IPM_RQOS model is proposed for supporting QoS resource errors detection-recovery in the situation-aware middleware.	quality of service	Eung Nam Ko;SoonGohn Kim	2008		10.1007/978-3-540-85930-7_65	education;situation awareness;real-time computing;simulation;error detection and correction;computer science;middleware	Embedded	-39.89393944028647	43.424442624994875	156345
87c0a8ad2812b8b2dd8fdbb28af6823bd0007974	multi-agent support for multiple concurrent applications and dynamic data-gathering in wireless sensor networks	multi paradigm;multiprocessing programs;sensomax;telecommunication computing;wsn;wireless sensor networks middleware hardware java sun monitoring;multi agent;software architecture;multi agent systems;concurrency;java sensomax multi agent concurrency dynamic wsn multi paradigm;middleware;wireless sensor networks java middleware multi agent systems multiprocessing programs software architecture telecommunication computing;dynamic reprogramming multiagent support multiple concurrent applications dynamic data gathering wireless sensor networks wsn hardware platforms on board resources software solutions middleware solution java se programming platforms java me programming platforms task distribution modulated architecture;architecture;dynamic;wireless sensor networks;java	WSNs have gained increasing attention for monitoring various variables of interest for wide variety of applications ranging from tracking environmental conditions to medical and structural monitoring. There are many WSN hardware platforms with a wide range of on-board resources. There also exist many software solutions for programming and re-programming WSNs. Most of the existing software solutions are either tightly coupled to their associated hardware, or very application-specific. Such diversity introduces many challenges for application developers. In this paper we propose a novel middleware solution, which runs on Java (SE and ME) programming platforms for easy task distribution and data gathering integrated in a modulated architecture that supports the serving of multiple concurrent applications, dynamic reprogramming, good scalability, and multiple operational paradigms.	dynamic data;java platform, standard edition;middleware;modulation;on-board data handling;scalability	Mo Haghighi;Dave Cliff	2013	2013 Seventh International Conference on Innovative Mobile and Internet Services in Ubiquitous Computing	10.1109/IMIS.2013.60	embedded system;software architecture;real-time computing;concurrency;computer science;architecture;operating system;multi-agent system;middleware;distributed computing;java;computer network	Robotics	-36.9311110627967	45.60260524306973	156373
a6c7483c126a0e33b0f33c63071dd2dc6006ec28	discussion on cscw methods for embedded systems	embedded system;computer supported collaborative work;networked systems	This paper discusses the Computer Supported Collaborative Work (CSCW) methods that can facilitate the work of embedded systems.  The focus is on how to design and build effective embedded network architecture, and which CSCW tools should be used in embedded  system. A brief conception of CSCW and embedded system is presented, followed by designing and building an embedded network  system currently available, and CSCW tools used in embedded systems are discussed additionally. Finally, predictions are made  on what CSCW for embedded systems might expect to be in future years.  	computer-supported cooperative work;embedded system	Tao Yu;Tan Liu;Shuzhen Yang;Wenbin Wang	2006		10.1007/0-387-34403-9_82	real-time computing;human–computer interaction;computer science;distributed computing	EDA	-38.33195163918154	37.55276425900444	156677
83477ea69b751616c63786ff84db06fd3fc1d957	aspect-aware operating system development	analysis and design;aspect aware design;operating system;aspect oriented programming;aspect oriented programming aop;aspectc;ciao	"""The domain of operating systems has often been mentioned as an """"ideal candidate"""" for the application of AOP; fundamental policies we find in these systems, such as synchronization or preemption, seem to be inherently cross-cutting in their implementation. Their clear separation into dedicated aspect modules should facilitate better evolvability and - the focus of this paper - configurability. Our experience with applying AOP to the domain of highly configurable embedded operating systems has shown, however, that these advantages can by no means be taken for granted. To reveal maximum configurability of central system policies, aspects and their potential interactions with the system have to be taken into account much earlier, that is, """"from the very beginning"""". We propose the analysis and design process of aspect-aware development, which leads to such an """"aspect-friendly"""" system structure and demonstrate its feasibility on the example of CiAO, an AUTOSAR-OS-compliant operating system that provides configurability of all fundamental system policies by means of AOP."""	autosar;ciao;complex systems;embedded operating system;embedded system;hobbyist operating system development;interaction;preemption (computing);requirement	Daniel Lohmann;Wanja Hofer;Wolfgang Schröder-Preikschat;Olaf Spinczyk	2011		10.1145/1960275.1960285	real-time computing;simulation;aspect-oriented programming;computer science;programming language	Embedded	-39.317275467312214	35.81908295917219	156697
3fcf29fc2abd742836e39c90de9461a85d2d7d06	architecture for modeling, simulation, and execution of plc based manufacturing system	computer graphics;control engineering computing;discrete event systems;formal specification;manufacturing systems;programmable controllers;software architecture;3d graphic model;devs model;device level executable code generation;discrete event system specification;high level modeling;high level system model;manufacturing system;programmable logic controller;sequence of operations;shop floor controller system;simulation;system architecture	In this paper, we propose an integrated architecture for modeling, simulation, and execution of PLC (Programmable Logic Controller) based manufacturing system. The main objective is to integrate the high level modeling, simulation, and device level executable code generation. This architecture can improve the fidelity between high level system model and lower level PLC controlled devices. In this paper, we model the shop floor controller system using DEVS (Discrete Event System Specification) formalism, subsequently, simulate the model and generate SOP (sequence of operations). We added two algorithms in conventional DEVS, the first algorithm makes an interface between 3D graphic model and DEVS model, whereas, the second algorithm generates SOP. As a result, the generated SOP can be mapped with PLC I/O (Input/Output) address to generate an executable controller code. For the purpose of further validation and implementation, the generated program can be downloaded to software or hardware PLC.	algorithm;code generation (compiler);devs;executable;high-level programming language;input/output;power-line communication;programmable logic device;semantics (computer science);simulation	Devinder Thapa;Chang Mok Park;Kwan Hee Han;Sang C. Park;Gi-Nam Wang	2008	2008 Winter Simulation Conference		embedded system;real-time computing;simulation;computer science;programmable logic controller;programming language;systems architecture;3d computer graphics;computer engineering	EDA	-37.91951733331828	33.60639586175216	156782
7a33661ed10a294377cbfc1ca34c351ce6045e50	trustworthiness monitoring and prediction of composite services	service oriented architecture trustworthiness monitoring composite service prediction service composition resource capacity supply and demand trustworthiness requirement service composition capability;data privacy;service oriented architecture data privacy;security monitoring reliability business mathematical model genetic algorithms equations;service oriented architecture	This paper presents an approach to monitoring and predicting the trustworthiness of services that are assembled from component services. In service compositions the number of component services that need to be aggregated may be large and dynamically changing. Additionally, the component services may vary in their importance to the value of the composite service and in their trustworthiness and resource capacity. Service compositions require the capability to dynamically adapt to changes that may occur at runtime. Those changes can occur in supply and demand, in the environment or in the component services' properties and behaviour. Service composers need to be able to respond swiftly to changed trustworthiness requirements and capabilities of service compositions, where those changes may not be easily predictable. With the availability of alternatives providing the same functionality as those already integrated in a composition, service composers can take advantage of this by replacing degrading or unsatisfactory components.	access control;algorithm;mathematical optimization;quality of service;requirement;run time (program lifecycle phase);service composability principle;service-oriented modeling;trust (emotion)	Hisain Elshaafi;Jimmy McGibney;Dmitri Botvich	2012	2012 IEEE Symposium on Computers and Communications (ISCC)	10.1109/ISCC.2012.6249359	service level requirement;service level objective;information privacy;service product management;differentiated service;computer science;service delivery framework;service-oriented architecture;world wide web;computer security;service system	SE	-46.82973076571774	43.33876105186764	156812
e0b225073f45e87449a4c6b5d61ad7ee4d42051f	trust as a facilitator in cloud computing: a survey	information systems applications incl internet;software engineering programming and operating systems;computer communication networks;special purpose and application based systems;computer system implementation;computer systems organization and communication networks	Cloud computing offers massively scalable, elastic resources (e.g., data, computing power, and services) over the internet from remote data centres to the consumers. The growing market penetration, with an evermore diverse provider and service landscape, turns Cloud computing marketplaces a highly competitive one. In this highly competitive and distributed service environment, the assurances are insufficient for the consumers to identify the dependable and trustworthy Cloud providers. This paper provides a landscape and discusses incentives and hindrances to adopt Cloud computing from Cloud consumers’ perspective. Due to these hindrances, potential consumers are not sure whether they can trust the Cloud providers in offering dependable services. Trust-aided unified evaluation framework by leveraging trust and reputation systems can be used to assess trustworthiness (or dependability) of Cloud providers. Hence, cloud-related specific parameters (QoS + ) are required for the trust and reputation systems in Cloud environments. We identify the essential properties and corresponding research challenges to integrate the QoS + parameters into trust and reputation systems. Finally, we survey and analyse the existing trust and reputation systems in various application domains, characterizing their individual strengths and weaknesses. Our work contributes to understanding 1) why trust establishment is important in the Cloud computing landscape, 2) how trust can act as a facilitator in this context and 3) what are the exact requirements for trust and reputation models (or systems) to support the consumers in establishing trust on Cloud providers.	application domain;cloud computing;dependability;essence;internet;reputation system;requirement;scalability;trust (emotion)	Sheikh Mahbub Habib;Sascha Hauke;Sebastian Ries;Max Mühlhäuser	2012	Journal of Cloud Computing: Advances, Systems and Applications	10.1186/2192-113X-1-19	cloud computing security;cloud computing;knowledge management;world wide web;computer security;computational trust	Metrics	-45.65842110437097	44.63821405865117	156828
7d250abc785b1247c9c75a7b0d8c666991ab7b2e	a mechatronic can-based functional design and verification unified approach		A mechatronic system needs an integrated design, implementation and verification unified approach due to multi-disciplinary interactive sub-system components. This paper presents a systematic methodology for a detailed migration from “model in the loop” (MIL), and “software in the loop” (SIL) to “hardware in the loop” (HIL) in order to full fill complicated mechatronic automotive system requirements. Break by wire anti-blocking car system model is implemented and simulated on Matlab™ in real time. For MIL, and SIL a virtual CAN bus channel is designed in order to communicate sensors and actuators signals to/from several electronic control units (ECUs). HIL is implemented to experiment the actual embedded controller performance over a real CAN bus with the real time simulated car model. Both virtual and real experimental results show the efficiency of the proposed approach.		Mohamed Shedeed;M. Galal Elshafey;Mohamed Sobh;Sherif Hammad	2009		10.3182/20090921-3-TR-3005.00079	embedded system;real-time computing;operating system	EDA	-37.93385498421581	33.933603239807205	156928
51b79e8cd37a52aa7bdb96df1406ed874971a314	simulation based studies of machine-to-machine communications		Simulations are essential for understanding complex systems such as Cyber Physical Systems. The creation of reliable multi-disciplinary simulation tools that can be used to support the entire development process has been identified as a major scientific goal in several research roadmaps and agendas for the coming 15 years. This chapter presents two showcases, which highlight the necessity of trustworthy simulation tools, especially in the case of machine-to-machine communications. First the performance of UWB radio technology in context of vehicle automation is evaluated. Second the experiences from performing the entire cycle of protocol development for machine-to-machine communications are presented. The two presented showcases support a conclusion that a successful simulation platform should have a user-friendly simulation framework and models that support virtualization. This will enable the incorporation of simulations into day-to-day engineering practice and thereby shrink the gap between the real and the virtual developing environments.	machine to machine;simulation	Evgeny Osipov;Laurynas Riliskis;Timo Lehikoinen;Jukka Kämäräinen;Marko Pellinen	2014		10.1007/978-3-319-10834-6_13	virtualization;automation;trustworthiness;complex system;cyber-physical system;systems engineering;machine to machine;engineering	HCI	-45.874946225937606	38.38746603909461	156947
13dea664e0bd62b3c9ca3b2b36465bdd35145136	model-driven development of self-organising control applications		In this article we present a software development methodology and a supporting algorithm toolbox for Organic Computing applications that were developed in the context of the MODOC project. We focus on control applications for dynamic actuator/sensor networks that have no skilled human administrator and that are subject to frequent random hardware failures. To deal with these characteristics, applications in this setting should be self-organising and self-stabilising. However, realising self-organising and self-stabilising applications is usually a complex task requiring expert knowledge. Thus, we show that the development of such applications can be greatly simplified by shifting complexity into a model-driven tool chain. Developers implement their application in a high-level language based on a role abstraction focusing on application functionality. In order to hide the remaining complexity, we developed a tool chain which is responsible for transforming the high-level code to executable machine code that is automatically enriched by self-x properties such as self-organisation and self-stabilisation, which are not explicitly defined by the application programmer. Thereby, the application benefits from extended fault-tolerance and availability. A major part of the tool chain is a toolbox containing self-x algorithms commonly required for Organic Computing applications. The heart of the toolbox is an algorithm stack realised by our publish/subscribe middleware Rebeca that is able to efficiently realise self-organisation even in case of large networks.	model-driven engineering;model-driven integration	Helge Parzyjegla;Arnd Schröter;Enrico Seib;Sebastian Holzapfel;Matthäus Wander;Jan Richling;Arno Wacker;Hans-Ulrich Heiß;Gero Mühl;Torben Weis	2011		10.1007/978-3-0348-0130-0_8	wireless sensor network;organic computing;real-time computing;software development process;machine code;toolbox;executable;programmer;computer science;middleware	SE	-40.685781715484495	39.219509254080535	156972
3e595945a726d89be59df3a4a96a8a33fa96c6d1	proteus: a semantic context-aware adaptive policy model	context awareness;groupware;operative run time condition;leverage policy adaptation;context aware;portable devices;information security;pervasive collaboration scenario;availability;collaboration;semantic technologies;runtime;context visibility;policy specification;access control policy;logic programming;guidelines;design guideline;proteus;security of data groupware;ontologies;resource availability;access control;information secure sharing;logic programs;dynamic adaptation;leverage policy adaptation semantic context aware adaptive policy model proteus portable devices pervasive collaboration scenario information secure sharing operative run time condition policy specification context visibility semantic technologies;context modeling;security of data;semantic context aware adaptive policy model;context modeling collaboration context awareness availability access control information security runtime guidelines ontologies logic programming	The growing diffusion of portable devices enables users to benefit from anytime and anywhere impromptu collaboration. Appropriate policy models that take into account the dynamicity and heterogeneity of the new pervasive collaboration scenario are crucial to ensure secure sharing of information. Collaborating entities cannot be predetermined and resource availability frequently varies, even unpredictably, due to user/device mobility, thus complicating resource access control. Policies cannot be defined based on entity's identities/roles, as in traditional security solutions, or be specified a priori to face any operative run-time condition, and require continuous adjustments to adapt to the current situation. To address these issues this paper advocates the adoption of a semantic context-aware paradigm to policy specification. Context- awareness allows operations on resources to be controlled based on context visibility whereas semantic technologies allow the high-level description and reasoning about context/policies. The paper describes Proteus that, as a key feature, combines these two design guidelines to enable dynamic adaptation of policies depending on context changes. In particular, the paper shows how ontologies and logic programming rules can be used to leverage policy adaptation.	access control;anytime algorithm;context awareness;encode;entity;high- and low-level;impromptu;logic programming;middleware;mobile device;ontology (information science);pervasive informatics;programming paradigm;proteus;prototype;refinement (computing);semantic web rule language;software deployment;web ontology language;web service	Alessandra Toninelli;Rebecca Montanari;Lalana Kagal;Ora Lassila	2007	Eighth IEEE International Workshop on Policies for Distributed Systems and Networks (POLICY'07)	10.1109/POLICY.2007.40	computer science;knowledge management;database;computer security	Mobile	-44.135184641806596	43.65746950487192	157046
ab3321fe4479635e4e6266a6cd6e14257e112f34	fault tolerance as an aspect using jreplica	distributed system;formal specification;fault tolerant;formal specification distributed object management specification languages software fault tolerance java;fault tolerance object oriented modeling programming profession fault tolerant systems computer science unified modeling language middleware protocols contracts availability;software fault tolerance;development process;fault tolerant system;specification languages;aspect oriented programming;object replication;distributed object management;uml distributed systems object replication mechanisms replication policies jreplica aspect oriented programming functional behaviour transparency fault tolerance requirements fault tolerance systems;java	Reliability and availability are very important trends in the development process of distributed systems. In order to improve these features, object replication mechanisms have been introduced. Programming replication policies for a given application is not an easy task, and this is the reason why transparency for the programmer has been one of the most important properties offered by all replication models. However, this transparency for the programmer is not always desirable. In this paper we present a replication model, JReplica, based on Aspect Oriented Programming (AOP). JReplica allows the separated specification of the replication code from the functional behaviour of objects, providing not only a high degree of transparency, as done by previous models, but also the possibility for programmers to introduce new behaviour to specify different fault tolerance requirements. Moreover, the replication aspect has been introduced at design time, and in this way, UML has been extended in order to consider replication issues separately when designing fault tolerance systems.		Miguel Toro;José Luis Herrero	2001		10.1109/FTDCS.2001.969642	real-time computing;computer science;distributed computing;programming language;software fault tolerance;replication	Embedded	-38.090613224663585	39.38569800019241	157200
407feb5477d539acd579d30da5b9df55c1cca368	model-based autonomous systems in the new millenium	mobile robot	A new generation of sensor rich, massively distributed, autonomous systems is being developed that has the potential for unprecedented performance, such as networks of smart buildings, reconfigurable factories, spacecraft constellations and remote earth ecosystem monitoring. To achieve high performance these immobile robots will need to use their sensors to accurately model themselves and their environment on a grand scale. They will use these models to reconfigure themselves dramatically if they are to survive decades of autonomous operations. To be economicaUy viable they will need to be programmable purely through high level compositional models. Self modeling, self configuration, deliberated reactions and compositional, model-based programming axe the four key elements of a model-based autonomous systems architecture that is taking us into the New Millenium.	autonomous robot;autonomous system (internet);ecosystem;high-level programming language;sensor;systems architecture	Brian C. Williams	1996				Robotics	-42.064891877877585	37.47720582940774	157202
2adc657dc4d4b9da768afdbe1e229051a33c5374	design and programming tools for time critical applications	design tool;programming environment;real time;simulation;non functional requirement;development environment;scheduling;real time scheduling;interactive graphics;real time application;programming tool;hard real time	The development of time critical applications needs specific tools able to cope with both functional and non-functional requirements. In this paper we describe a design and programming environment to assist the development of hard real-time applications. An interactive graphic interface is provided to facilitate the design of the application according to three hierarchical levels. The development model we propose is based on an iterative process in which the real-time scheduling support is considered from the beginning of the design phases. Our graphic environment integrates several tools to analyze, test, and simulate the real-time application under development. In particular, the tools we have implemented are: a Design Tool, to describe the structure of the application, a Schedulability Analyser Tool (SAT), to verify off-line the feasibility of the schedule of a critical task set, a Scheduling Simulator, to test the average behavior of the application, and a Maximum Execution Time (MET) estimator to bound the worst case duration of each task.	algorithm;alloy analyzer;best, worst and average case;comparison of command shells;computation;control system;design tool;functional requirement;graphical user interface;integrated development environment;iteration;iterative method;metamodeling;non-functional requirement;online and offline;organic user interface;programming tool;real-time clock;real-time computing;real-time locating system;real-time operating system;real-time transcription;schedule (project management);scheduling (computing);simulation;time complexity	Paolo Ancilotti;Giorgio C. Buttazzo;Marco Di Natale;Marco Spuri	1998	Real-Time Systems	10.1023/A:1007916307060	computer architecture;real-time computing;simulation;computer science;operating system;development environment;scheduling;non-functional requirement	Embedded	-43.048461019574724	34.24241031534046	157448
095be740715833185e68b39d988535e19d8fa7b3	the role of models@run.time in supporting on-the-fly interoperability	runtime interoperability;distributed system;runtime models;68n99;adaptive system;middleware;mediators;networked systems;model coupling;ontology;68 xx	Models at runtime can be defined as abstract representations of a system, including its structure and behaviour, which exist in tandem with the given system during the actual execution time of that system. Furthermore, these models should be causally connected to the system being modelled, offering a reflective capability. Significant advances have been made in recent years in applying this concept, most notably in adaptive systems. In this paper we argue that a similar approach can also be used to support the dynamic generation of software artefacts at execution time. An important area where this is relevant is the generation of software mediators to tackle the crucial problem of interoperability in distributed systems. We refer to this approach as emergent middleware, representing a fundamentally new approach to resolving interoperability problems in the complex distributed systems of today. In this context, the runtime models are used to capture meta-information about the underlying networked systems that need to interoperate, including their interfaces and additional knowledge about their associated behaviour. This is supplemented by ontological information to enable semantic reasoning. This paper focuses on this novel use of models at runtime, examining in detail the nature of such runtime models coupled with consideration of the supportive algorithms and tools that extract this knowledge and use it to synthesise the appropriate emergent middleware.	adaptive system;algorithm;distributed computing;emergence;interoperability;middleware;ontology (information science);reflection (computer programming);requirement;run time (program lifecycle phase);runtime system;software development;software system;spontaneous order	Nelly Bencomo;Amel Bennaceur;Paul Grace;Gordon S. Blair;Valérie Issarny	2012	Computing	10.1007/s00607-012-0224-x	real-time computing;simulation;computer science;adaptive system;ontology;middleware;distributed computing;runtime verification	SE	-40.90956301898993	39.92850243491259	157480
22c5b37b3824c7a45aa2a75b62c86dac498ebf63	towards a mobile architecture description language	programming language semantics;cbabel;rewrite theory;logic semantics rewriting mobile architecture description language internet wireless communication network software component mobility primitives rewrite theory cbabel declarative architecture description language;mobility;architecture description language;maude;architecture description languages logic application software connectors ip networks topology gsm wireless communication lan interconnection contracts;mobility primitives;mobile architecture description language;architecture description languages;wireless communication;internet;declarative architecture description language;network mobility;rewriting systems;specification languages;wireless communication network;logic semantics rewriting;rewriting logic;software component;architecture description languages mobility rewriting logic maude;specification languages programming language semantics rewriting systems	Due to the proliferation of Internet and wireless communication networks, mobility of software components is pervasive in current applications. However, most of the existing Architecture Description Languages (ADLS) lack operators to express mobility primitives. In this paper, we propose a generic rewrite theory for mobility in CBabel, a Declarative Architecture Description Language. Rademaker et al. have associated a rewriting logic semantics to the different constructors of CBabel. We exploit such semantics to extend CBabel with mobility primitives by defining a rewrite theory called mobility-primitives. Our objective is two folds: We propose a rewrite theory for mobility in CBabel. Then, we generalize it to any Architecture Description Language that can be translated to rewriting logic. Such generalization will be obtained by introducing the parameterization notion of Full Maude to the mobility-primitives rewrite theory.	architecture description language;broadcast television systems inc.;component-based software engineering;internet;maude system;mobile app;object file;partial template specialization;pervasive informatics;rewrite (programming);rewriting;telecommunications network	Chafia Bouanaka;Faiza Belala	2008	2008 IEEE/ACS International Conference on Computer Systems and Applications	10.1109/AICCSA.2008.4493610	architecture description language;the internet;rewriting;computer science;theoretical computer science;component-based software engineering;operating system;database;programming language;mobile computing;wireless	SE	-37.40698083790512	43.46049247392091	157746
6be2e29147883cbc16bf49a561d34186ef5b2345	a run time executable task model for ambient intelligent environments	program diagnostics;user centered systems;software prototyping;ambient intelligence;proactive system;ambient intelligent environments;software prototyping ambient intelligence program diagnostics;user tasks monitoring and assistance;context aware system run time executable task model ambient intelligent environments static task models runtime task states monitoring and assistance system dynamic task model software prototype;executable task model;proactive system executable task model user centered systems user tasks monitoring and assistance ambient intelligent environments;conferences	Existing task models are static and used only at design time. The information contained in the model is taken into account only when designing the application and will no longer be changed. In this paper we propose to use the task model at runtime, in order to track user actions, verify that he/she has not made any errors while accomplishing his/her tasks and to give help when asked for. In particular, we present a task model specific to the interactions with an ambient environment and we extend the notion of static task models to allow its dynamic update at run time. Our extension consists in giving runtime task states suitable with information received from the environment. Our second contribution is a monitoring and assistance system based on our dynamic task model. We present a simulation of our application based on a software prototype. This application shows how the interactions with the task model at runtime allow us to produce a dynamic and context aware system dedicated to the help of the user to do his/her daily tasks.	executable;intelligent environment;interaction;prototype;run time (program lifecycle phase);simulation;software prototyping	Asma Gharsellaoui;Yacine Bellik;Christophe Jacquet	2013	2013 IEEE 10th International Conference on Ubiquitous Intelligence and Computing and 2013 IEEE 10th International Conference on Autonomic and Trusted Computing	10.1109/UIC-ATC.2013.55	embedded system;real-time computing;simulation;ambient intelligence;human–computer interaction;computer science;operating system;task analysis	Robotics	-38.940071524613785	41.149564892281624	157761
572174ad62909e2b10e16915492ae6dc8f352fc5	netkit: a software component-based approach to programmable networking	components;programming language;programming paradigm;component middleware;active network;qa75 electronic computers computer science;run time reconfigurable;operating system;execution environment;programmable networking;software component;middleware;institutional repository research archive oaister;programmable networks;reflection	While there has already been significant research in support of openness and programmability in networks, this paper argues that there remains a need for generic support for the integrated development, deployment and management of programmable networking software. We further argue that this support should explicitly address the management of run-time reconfiguration of systems, and should be independent of any particular programming paradigm (e.g. active networking or open signaling), programming language, or hardware/ operating system platform. In line with these aims, we outline an approach to the structuring of programmable networking software in terms of a ubiquitously applied software component model that can accommodate all levels of a programmable networking system from low-level system support, to in-band packet handling, to active networking execution environments to signaling and coordination.	active networking;component-based software engineering;high- and low-level;network packet;openness;operating system;programming language;programming paradigm;software deployment	Geoff Coulson;Gordon S. Blair;David Hutchison;Ackbar Joolia;Kevin Lee;Jo Ueyama;Antônio Tadeu A. Gomes;Yimin Ye	2003	Computer Communication Review	10.1145/963985.963991	active networking;real-time computing;reflection;computer science;component-based software engineering;software development;operating system;middleware;distributed computing;networking hardware;software-defined networking;programming paradigm;computer network	Networks	-36.35286721497966	43.83381670920386	158056
856b466e1c4cf411f125ef2a728f28462634f367	self-management of machine-to-machine communications: a multi-models approach	multi models;dynamic reconfiguration;graph based modelling;information sharing;graph rewriting;etsi m2m architecture;machine to machine communications;m2m communications;m2m standards;autonomic computing;self management;smart meters	Machine-to-Machine (M2M) paradigm apply to systems composed by numerous devices sharing information and making cooperative decisions with little or no human intervention. The M2M standard defined by the European Telecommunications Standards Institute (ETSI) is the only one providing an end-to-end view of the global M2M architecture. Noticeably, it furnishes a standardised framework for inter-operable M2M services that satisfies most of M2M modelling requirements. However, and even though M2M systems usually operate in highly evolving contexts, this standard does not address the issue of system adaptations. It is furthermore unsuitable for building self-managed systems. This paper introduces a multi-model approach for modelling manageable M2M systems. Said approach consists in a formal graph-based model on top of the ETSI M2M standard, alongside bi-directional updates that ensure layer coherency. Its fitness for enforcing self-management properties is demonstrated by designing high-level reconfiguration rules. Finally, its applicability is illustrated and evaluated using a smart-metering application.	ambiguous name resolution;autonomic computing;bi-directional text;computer architecture;concurrency (computer science);defense in depth (computing);end-to-end principle;graph rewriting;high- and low-level;machine to machine;mathematical optimization;multi-model database;norm (social);operability;programming paradigm;requirement;scalability;self-management (computer science);semantics (computer science);smart tv;systems management	Cédric Eichler;Ghada Gharbi;Thierry Monteil;Patricia Stolf;Nawal Guermouche	2016	IJAACS	10.1504/IJAACS.2016.079626	embedded system;real-time computing;simulation;telecommunications;computer science;artificial intelligence;operating system;distributed computing;computer security;computer network;autonomic computing;graph rewriting	SE	-40.27589151221384	43.66283712097948	158084
70e6dfc4a90b4ededfd7393a30de53aa8b1e83eb	exploiting runtime bytecode manipulation to add roles to java agents	agent based;separation of concern;interactions;dynamic bytecode modification;java agents;social agent;roles	Thanks to their sociality, agents can interact w i h other agents in a cooperative or competitive way. Such interactions must be carefully ta ken into consideration in the development of agent-based applications. A good paradigm for modeling such interactions is the one based on the concept of roles, which is fully exploited in the BRAIN framewo rk. The use of roles achieves several advantages, from separation of concerns between the algorithmic issues and the interaction ones, to the reuse of solutions and experiences in different applications. In this paper, we propose an interaction infrastructure for enabling Java agents to dynamically assume roles at runtime and then to use them. Our approach is based on the capability of modifying the bytecode of Java agents at runtime in order to add the members of role classes. An applicatio n example an d a comparison with other approaches show the effectiveness of our approach. © 2004 Elsevier B.V. All rights reserved.	agent-based model;compiler;download;hoc (programming language);interaction;java;locality of reference;operating system;process migration;programmer;programming paradigm;run time (program lifecycle phase);separation of concerns	Giacomo Cabri;Luca Ferrari;Letizia Leonardi	2005	Sci. Comput. Program.	10.1016/j.scico.2004.05.007	interaction;real-time computing;separation of concerns;computer science;theoretical computer science;role;distributed computing;programming language	AI	-36.77229147929785	39.19478722107376	158237
886f047da4ddcbff5e27642cd9ca1198cdb0c494	integrating psl properties into systemc transactional modeling — application to the verification of a modem soc	system on a chip semantics program processors hardware registers switches;transaction processing data flow analysis program verification system on chip;semantics;program verification;system on a chip;hardware software interactions psl properties systemc transactional modeling soc verification assertion based verification hardware embedded systems software embedded systems electronic system level automatic instrumentation systemc tlm platforms property checkers psl assertions runtime verification digital radio reception thales communications security;system on chip;registers;data flow analysis;transaction processing;switches;program processors;hardware	This paper focuses on the assertion-based verification (ABV) of hardware/software embedded systems, described at the Electronic System Level. We first summarize the features of a tool that enables the automatic instrumentation of SystemC TLM platforms with property checkers produced from PSL assertions and the runtime verification of these requirements. We also present its last improvements. Then we describe a return of experience using as case study a SoC modem for digital radio reception developed by Thales Communications & Security. Various temporal properties that capture the intended requirements, regarding hardware or hardware/software interactions, are formalized in PSL and checked during simulation.	assertion (software development);deadlock;electronic system-level design and verification;embedded software;embedded system;experiment;integrated circuit;interaction;modem;multi-core processor;multiprocessing;peripheral;programmer;real-time clock;real-time transcription;requirement;runtime verification;scheduling (computing);simulation;software bug;system on a chip;systemc;test case	Laurence Pierre;Luca Ferro;Zeineb Bel Hadj Amor;Philippe Bourgon;Jérôme Quévremont	2012	7th IEEE International Symposium on Industrial Embedded Systems (SIES'12)	10.1109/SIES.2012.6356588	system on a chip;embedded system;computer architecture;parallel computing;real-time computing;verification;software verification;computer science;operating system;semantics;high-level verification;programming language;intelligent verification	Embedded	-38.75897788551668	33.17965953284512	158245
1111a9101a9d491c79088f646f624066a176c5bc	avida-mde: a digital evolution approach to generating models of adaptive software behavior	generic model;behavior modeling;environmental conditions;digital evolution;autonomic system;model checking;natural selection;model driven engineering;autonomic computing;finite state machine;autonomous robot	Increasingly, high-assurance applications rely on autonomic systems to respond to changes in their environment. The inherent uncertainty present in the environment of autonomic systems makes it difficult for developers to identify and model resilient autonomic behavior prior to deployment. In this paper, we propose Avida-MDE, a digital evolution approach to the generation of behavioral models (i.e., a set of interacting finite state machines) that capture autonomic system behavior that is potentially resilient to a variety of environmental conditions. We use an evolving population of digital organisms to generate behavioral models, where the organisms are subjected to natural selection and are rewarded for generating behavioral models that meet developer requirements. To illustrate this approach, we successfully applied it to the generation of behavioral models describing the navigation behavior of an autonomous robot.	autonomic computing;autonomous robot;avida;digital organism;finite-state machine;interaction;model-driven engineering;requirement;software deployment	Heather Goldsby;Betty H. C. Cheng	2008		10.1145/1389095.1389434	behavioral modeling;model checking;natural selection;model-driven architecture;simulation;computer science;artificial intelligence;machine learning;autonomic computing	SE	-43.8528185891451	38.89729576327779	158342
7b5036be65d5bc76d425fe73061e01892b351190	robots: a real-time systems architectural style	dynamic reconfiguration;architecture description language;operational semantics;architectural style;real time systems	This paper presents an architectural style for real-time systems, and an associated formal architectural description language, called Robots. A basic specification in Robots consists of a synchronous control task that is responsible for the dynamic reconfiguration of the system controller as a set of asynchronous observer and process tasks. The controller architecture evolves by hierarchical refinement of observers and processes into lower level control tasks each dominating a new set of observers and processes. Robots is given operational semantics by statecharts. Also, the architectural style is embedded in Robots by semantic rules that allow formal checking of the consistency and completeness of architectural specifications.	embedded system;observer (quantum physics);operational semantics;process (computing);real-time clock;real-time computing;real-time transcription;refinement (computing);robot	Vered Gafni	1999			computer architecture;real-time computing;architectural geometry;architectural pattern;computer science;representational state transfer;programming language	Embedded	-34.276824418268646	34.10032685396852	158404
64c0d2e3f754806fc688a318484f6bbbc9c616e6	extensions to the uml profile for marte for distributed embedded systems	automata;embedded systems;computational modeling;unified modeling language distributed processing embedded systems;unified modeling language computational modeling embedded systems automata delays quality of service mathematical model;unified modeling language;mathematical model;quality of service;smart systems model driven design network uml profiles deploymentdiagram stereotypes modeling languages internet ofthings;network profile uml profile extensions distributed embedded systems standard modeling languages semantics specification unified modeling language marte profile real time embedded systems syntactic extension semantic extension;delays	The design of distributed embedded systems is a challenging task that requires raising the level of abstraction to handle the different involved concerns. In particular, standard modeling languages and precise semantics specification are necessary to address the networking-related aspects at a high level of abstraction. The Unified Modeling Language (UML) and its MARTE profile are valid formalisms to model real-time embedded systems but they lack precise modeling elements when addressing applications and platforms forming distributed embedded systems. In this work, we formalize a coherent set of modeling elements for the design and deployment of distributed embedded systems. A novel UML profile for networking is proposed as a semantic and syntactic extension to the UML Profile for MARTE: The Network Profile.	abstraction layer;coherence (physics);embedded system;high-level programming language;modeling and analysis of real time and embedded systems;profile (uml);real-time clock;software deployment;unified modeling language	Emad Samuel Malki Ebeid;Julio L. Medina Pasaje;Davide Quaglia;Franco Fummi	2015	2015 Forum on Specification and Design Languages (FDL)	10.1109/FDL.2015.7306092	unified modeling language;embedded system;real-time computing;quality of service;systems modeling language;uml tool;computer science;theoretical computer science;applications of uml;mathematical model;automaton;modeling language;programming language;computational model;node	Embedded	-40.125733459980964	32.890558829946045	158460
8f228ebeeee64ffca204408ecabd5d937fbc196c	concord: a proactive lightweight middleware to enable seamless connectivity in a pervasive environment	ubiquitous;pervasive computing;concord;middleware;proactive behavior	"""One of the major components of any pervasive system is its proactive behavior. Various models have been developed to provide system wide changes which would enable proactive behavior. A major drawback of these approaches is that they do not address the need to make use of existing applications without modifying the applications. To overcome this drawback, a middleware architecture called """"Concord"""" is proposed. Concord is based on a simple model which consists of Lookup Server and Database. The rewards for this simple model are many. First, Concord uses the existing computing infrastructure. Second, Concord standardizes the interfaces for all services and platforms. Third, new services can be added dynamically without any need for reconfiguration. Finally, Concord consists of Database that can maintain and publish the active set of available resources. Thus Concord provides a solid system for integration of various entities to provide seamless connectivity and enable proactive behavior."""	middleware;seamless3d	Sam Hsu;Mahesh Mutha;Abhijit S. Pandya;Young-Uhg Lho	2005	Int. J. Fuzzy Logic and Intelligent Systems	10.5391/IJFIS.2005.5.3.189	real-time computing;computer science;operating system;database	Robotics	-39.93123572212621	45.34397661112941	158681
15eab4f5894ba60654d480269264922aa065a0c7	principle and framework of information grid evaluation	life cycle;grid applications;production services;service level agreement;evaluation framework	Information grid researches on enabling technologies for sharing information and application effectively and expediently in a wide-area enterprise environment. The Grid-Key/Grid architecture of Vega Information Grid aims to enable user to use grid application at anytime, anywhere by any device, and to achieve a high productivity services. Accordingly, the evaluation of information grid needs to measure those functionalities and performance that can embody these features. This paper presents how to use the full life cycle principle to evaluate and analyze information grid, and provides an evaluation framework based on Service Level Agreement.	anytime algorithm;service-level agreement	Hui Li;Xiaolin Li;Zhiwei Xu;Ning Yang	2003		10.1007/978-3-540-24679-4_114	biological life cycle;computer science;data mining	HPC	-47.956985506206536	43.906226572459275	158706
36b88e1d6e36cf7b1ab05cc15cb265258d23face	an event algebra for specifying and scheduling workflows	heterogeneous systems	Heterogeneous systems arise when preexisting or legacy information systems are integrated in such a way as to preserve their autonomy and past applications. Workflows are the semantically appropriate units of activity in such environments. They involve a variety of tasks and are best represented by different extended transaction models or combinations thereof. We present an approach by which workflows can be efficiently scheduled. Oux novel contribution is an event algebra in which dependencies characterizing workflows can be declaratively expressed. We show how to symbolically process these dependencies to determine which events can or must occur, and when. Our approach can represent dependencies compactly and reason with them efficiently.	information system;scheduling (computing)	Munindar P. Singh;Greg Meredith;Christine Tomlinson;Paul C. Attie	1995			real-time computing;computer science;theoretical computer science;distributed computing	DB	-35.07400885965566	34.5233652274642	158856
0208449a31de2365e4724788f7d8dbed6f89b5bd	hybrid cell: an implementation of an object based strongly distributed system	distributed system;object mapping;protocols;nodes;object oriented methods;telecommunication network reliability;information security;availability;prototypes;distributed processing;abstract data types;distributed computing;biomembranes;computational modeling;distributed objects;object based strongly distributed system;information security biomembranes prototypes access protocols telecommunication network reliability availability partitioning algorithms computational modeling distributed computing;type matching;trading protocols hybrid cell object based strongly distributed system nodes cell prototype type matching object mapping connection trading;hybrid system;access protocols;protocols abstract data types distributed processing object oriented methods;cell prototype;connection trading;trading protocols;partitioning algorithms;hybrid cell	The Cell is a framework for the design of strongly distributed object based systems that preserves the autonomy of the nodes. The Hybrid system was transformed to a cell prototype with the introduction of a membrane providing the services of Type Matching, Object Mapping and Connection Trading. A Type Matching language was designed and the connection and trading protocols were defined.	autonomy;distributed computing;distributed object;hybrid system;object-based language;prototype	Dimitri Konstantas	1993		10.1109/ISADS.1993.262722	communications protocol;availability;real-time computing;computer science;information security;theoretical computer science;database;distributed computing;prototype;node;computational model;abstract data type;hybrid system	Robotics	-34.311362169803445	45.037230978150006	158974
9dce7f402ab41a35d65b18daf0192121cfee3187	building a semantic ontology for internet of things (iot) systems		The complexity of Internet of Things (IoT) systems requires designers, operators, and users to understand both the structure and semantics embedded in the IoT architecture. A semantic IoT ontology must support a full understanding of system flows, services, and qualities (FSQ). In our research, we will discuss how sematic ontologies are currently utilized in IoT systems and how they could be extended to include semantic definitions for critical flows, services, and qualities in IoT applications. We suggest that a focus on the semantics of the system and the entities in the system be enriched with a definition and understanding of FSQ semantics. Examples of FSQ semantics in an actual IoT environment are presented and discussed.	arm architecture;complex systems;embedded system;entity;ibm an/fsq-31 sac data processing system;internet of things;ontology (information science);real-time computing;real-time transcription;reference architecture;reference model;smart city	Allen Ronald DeSerranno;Matthew T. Mullarkey;Alan R. Hevner	2017			ontology;world wide web;ontology (information science);internet privacy;web of things;internet of things;upper ontology;computer science	AI	-43.115331386761454	45.6048441493131	158979
d2a8b8546a384bc37ae71a84e2e934563be1a467	an automated dependability analysis method for cots-based systems	fault tree;dependence analysis;component based software engineering;swinburne;failure mode;embedded system;080309 software engineering;quantitative analysis;reliability analysis	The increasing application of COTS-components and component-based software engineering has entailed the development of appropriate component specifications. In the embedded systems domain it would be desirable to benefit from these component specifications to integrate and automate safety and reliability analysis. For this reason, we propose in this paper a component-based dependability analysis technique that annotates components with failure mode assumptions. The probabilities and dependencies of these failure modes are specified by Component Fault Trees (CFT's). Based on these CFT's and the architectural model the propagation of failures throughout the system can be automatically determined and a quantitative analysis is possible.	dependability	Lars Grunske;Bernhard Kaiser	2005		10.1007/978-3-540-30587-3_28	safety engineering;reliability engineering;real-time computing;systems engineering;engineering;dependability;failure mode and effects analysis	Logic	-46.24226488520827	33.11955330260596	159335
6e72d7339d6a946e1026bac27bd0f1c77e4bca9c	a design and management framework for mobile agent systems	libraries;petri net simulations;port contention;meeting design pattern;computer languages;hosts;mobile agents java libraries computer languages security algebra computer science read only memory prototypes reactive power;software libraries;agent registration;software libraries software agents java digital simulation petri nets software management;programming libraries mobile agent systems management petri net models meeting design pattern aglets workbench interaction design pattern java source programs stochastic parameters port contention hosts agent registration background workloads scalability performance petri net simulations greatspn simulator;performance estimation;mobile agent systems;mobile agents;prototypes;aglets workbench;software management;performance;aglets;stochastic parameters;programming libraries;software agents;qa75 electronic computers computer science;mobile agent system;petri net models;background workloads;algebra;design pattern;interaction design pattern;greatspn simulator;java source programs;design patterns;scalability;computer science;petri nets;petri net;security;management;read only memory;digital simulation;java;reactive power	A framework for developing ‘mobile agent’ systems is described based on Petri net models of design patterns in the Aglets workbench [12]. The ‘Meeting’ and ‘Interaction’ design patterns are investigated. The models can be automatically configured from Java source programs, and can account for stochastic parameters such as port contention at hosts, agent registration, background workloads and scalability issues, such as bounds on total number of agents that may be supported at a host. The models are verified by comparing the performance of an application in Aglets with Petri net simulations on the GreatSPN simulator [2].	aglets;distributed computing;expect;integrated development environment;interaction design;java;library (computing);mobile agent;petri net;programming paradigm;rapid application development;scalability;semantics (computer science);simulation;software design pattern;software engineering;stochastic modelling (insurance);workbench	Omer F. Rana	1999		10.1109/MASCOT.1999.805069	real-time computing;computer science;information security;theoretical computer science;operating system;distributed computing;petri net	SE	-34.633782386743164	41.852491053646084	159750
c267dc5d9e1d0c14b76374d781d3a4f01d7e0411	nist smart data flow system ii: speaker localization	nist;middleware;algorithms;information processing;distributed computing;application software;data flow graph;face detection;speaker recognition;wireless sensor networks;data streams;java;data acquisition;standardization;sensor network;performance;data flow;design;computer networks;intelligent sensors	Multimodal applications require the acquisition and processing of massive amounts of information from multiple sensors. Because this process is beyond the capabilities of a single machine, we developed a sensor network data transport system that can employ the numerous computing devices required to perform the task. The computational and data acquisition processes are thus allocated to components spread across a network of systems. We present the NIST Smart Data Flow System II, which is a middleware layer that represents applications as data flow graphs, and transports information streams between the different computational components of the application.	dataflow	Antoine Fillinger;Lukas Diduch;Imad Hamchi;Stéphane Degré;Vincent M. Stanford	2007		10.1109/IPSN.2007.4379719	speaker recognition;embedded system;real-time computing;wireless sensor network;information processing;computer science;theoretical computer science	Robotics	-36.42060315785533	46.14889719831509	160443
2e53c61ab0db9c54d70ffa011d9e6e1decc81818	an executable semantics for synchronous task graphs: from sdrt to ada		We study a graph-based real-time task model in which intertask synchronization can be specified through a rendezvous mechanism. Previously, efficient methods have been proposed for timing analysis of the corresponding task sets. In this paper, we first formally specify an operational semantics for the model. Next, we describe a method for Ada code generation for a set of such task graphs. We also specify extensions of the approach to cover a notion of broadcasting, as well as global interrelease separation time of real-time jobs. We have implemented the proposed method in a graphical tool which facilitates a model-based design and implementation of real-time software.	ada;broadcast domain;code generation (compiler);directed graph;embedded system;end-to-end principle;executable;graphical user interface;nondeterministic algorithm;operational semantics;p (complexity);real-time clock;real-time transcription;runtime system;scheduling (computing);static timing analysis	Morteza Mohaqeqi;Jakaria Abdullah;Wang Yi	2017		10.1007/978-3-319-60588-3_9	programming language;computer science;real-time computing;operational semantics;rendezvous;code generation;software;ada;semantics;executable;static timing analysis	Embedded	-33.7684909846532	33.53850458064228	160449
570c797e43be950ed830632c607ea5ce20eec7b8	transparent resource management and self-adaptability using multitasking virtual machine rm api	virtual machine;resource manager;resource management;isolates;self adaptability;transparent management;multitasking virtual machine;java	The Multitasking Virtual Machine has been provided with many useful features like Isolation API or Resource Consumption Management API. The latter one can be used to help in managing resources in Java applications. However, using RM API does not guarantee separation between a resource management activity and a business activity. In this paper we present the concept of The Transparent Resource Management (TRM) system. The system can be used to run Java applications with resource management policies added dynamically, as a separate aspect. Each application runningin the TRM system can be started with a reusable graph of different states. Each state encapsulates currently used resource management policy. An active state can change automatically during runtime, depending on the state of an application, the state of the whole system, as well as on the utilization of different resources in different applications.	application programming interface;aspect-oriented programming;business logic;computer multitasking;entity;federal enterprise architecture;graph (discrete mathematics);high- and low-level;java;java management extensions;java virtual machine;management system;run time (program lifecycle phase);virtual machine	Arkadiusz Janik;Krzysztof Zielinski	2006		10.1145/1137677.1137688	real-time computing;engineering;operating system;database;human resource management system	HCI	-39.4815103950441	40.54458093447941	160580
0a39b4700488b67276f8c9c5c616e1824ccd18c4	stochastic satisfiability modulo theories: a symbolic technique for the analysis of probabilistic hybrid systems		In today’s high-tech world, embedded computer systems interacting with technical, physical, or even biological environments are our permanent companions. While several of these applications are almost free of risk and just contribute to a better quality of life such as the use of cellular phones, washing machines, and refrigerators, other embedded systems operate in a safety-critical context where the health of people might be jeopardized like, for instance, in airplanes, automobiles, and medical devices. It is thus of utmost importance that embedded and, in particular, safety-critical systems never run into unsafe situations causing disastrous consequences. Such real-world safety-critical applications exhibit an intricate system behavior comprising discrete computations like of embedded digital controllers, continuous dynamics of technical environments like the continuous evolution of the temperature, as well as their interaction by means of sensors and actuators. These systems are commonly known under the term of hybrid discrete-continuous systems. When permitting a more realistic view on real-world embedded systems, it becomes apparent that their dynamics are frequently influenced by randomness. For instance, the landing maneuver of an airplane is, among others, subject to the wind speed and wind direction. These physical entities however are controlled by nature and can be forecast only with uncertainty. That is to say, statements about safe landing maneuvers should also incorporate stochastic predictions of the evolution of wind. Other sources of randomness can be found in the hardware itself like unpredictable failures of circuits, noise in measurements affecting sensors, and actuators missing their setpoints. Such more realistic systems are referred to as stochastic or probabilistic hybrid systems. When safety-critical applications are subject to stochastic dynamics, preventing unsafe situations by design usually is impossible or economically infeasible, such that a residual risk has to be accepted. The notion of safety in this context is slightly relaxed, requiring that the probability of reaching the unsafe system states always is below an acceptable threshold like, for instance, 1h. In order to certify safety of real-world applications, manual inspection becomes more and more impracticable due to their rapid-growing complexity. This motivates the development of computer-aided certification methods. The research area dealing with automatic analysis procedures for stochastic and probabilistic hybrid systems has attracted wide interest in recent years and has yielded diverse analysis approaches which are chiefly based on simulation or finite-state abstractions. In this thesis, we pioneer a completely different approach, namely a symbolic technique for the safety analysis of probabilistic hybrid automata (PHAs) involving a simple model of randomness, that is, probabilistic events from a finite sample space as is the case with throwing dice. Our approach builds on bounded model checking (BMC), where the step-bounded state reachability problem of non-probabilistic hybrid systems is reduced to the satisfiability problem of logical formulae involving arithmetic constraints. For nonprobabilistic hybrid systems, the latter is a quantifier-free satisfiability modulo theories	as-interface;automata theory;boolean satisfiability problem;computation;computer;embedded system;entity;hybrid automaton;hybrid system;instrument landing system;interaction;mobile phone;model checking;modulo operation;quantifier (logic);randomness;reachability problem;satisfiability modulo theories;sensor;simulation;stochastic process;washing machine	Tino Teige	2012				Embedded	-45.102786947739446	36.03888472582595	160643
d091110c7eb842abcf27d1b7d51ba7d94d60c8f5	supporting software intelligence in ubiquitous environment exploits mobile agent		Mobile agent (MA) is a popular approach being applied to numerous applications to achieve predefined goal. A ubiquitous computing engages many computational devices and systems simultaneously, and may not necessarily even be aware that they are doing so. The context of MA, including traveling path and manipulation method, may be dynamically changed according to current state of environment. Therefore, a flexible framework that can handle various MAs for a variety of applications in a ubiquitous environment is necessary. In this paper, we present an integrated and flexible framework that can adopt various applications in which the functionality of mobile agent is distinguishable in diversity of networks or systems. We design and implement an agent-based platform that can guide various MAs that are initiated by mobile devices to complete their goal. In addition, we also conduct three experiments to evaluate the performance of MAG system. The evaluation result shows that the latency is reasonable and acceptable.	mobile agent;software intelligence	Yue-Shan Chang;Chih-Tien Fan;Tong-Ying Tony Juang	2012	J. Ambient Intelligence and Humanized Computing	10.1007/s12652-011-0080-0	embedded system;real-time computing;simulation;artificial intelligence	AI	-40.65784665952789	45.17896087747726	160787
bbee5aabf583adcc8678e4e21b95f6521cffd750	architecture logicielles pour des applications hétérogènes, distribuées et reconfigurables		The recent apparition of mobile wireless sensor aware to their physical environment and able to process information must allow proposing applications able to take into account their physical context and to react according to the changes of the environment. It suppose to design applications integrating both software and hardware components able to communicate. Applications must use context information from components to measure the quality of the proposed services in order to adapt them in real time. This work is interested in the integration of sensors in distributed applications. It present a service oriented software architecture allowing to manage and to reconfigure applications in heterogeneous environment where entities of different nature collaborate: software components and wireless sensors.	component-based software engineering;distributed computing;entity;mobile phone;sensor;software architecture	Christine Louberry;Marc Dalmau;Philippe Roose	2008	CoRR		service-orientation;computer science;wireless sensor network;component-based software engineering;software;resource-oriented architecture;software architecture;hardware architecture;middleware;distributed computing	Mobile	-38.99937485523783	45.668844849234674	160833
4a2cceed428ab810c798efdc4008dbdf77f9e198	lava: model-driven development of configurable mpsoc hardware structures for robots		Deploying multicore or multiprocessor hardware for robotics applications is highly beneficial. Parallel hardware structures can be utilized to improve the performance, real-time characteristics, or fault tolerance. Special accelerator components can boost the performance and energy efficiency even more. However, the optimal hardware design is application-specific. This is a dilemma especially for modular general purpose robots, because the application scenario is unknown at design time. Therefore, more and more robots are being equipped with configurable hardware such as FPGAs. In this paper we describe the LavA framework, which facilitates the development of application-specific MPSoC hardware structures. Our prototype can interact with Lego Mindstorms NXT sensors and actuators. A DSL is used to describe the hardware structure. Syntactic and semantic checks are performed on the high-level hardware model and a resource model quickly provides an estimate of the required FPGA resources. The hardware synthesis itself is fully automated and requires no special know how. Optionally, the framework can even statically analyze the C/C++ application code. Based on the hardware access patterns found in the code, a suitable hardware description is derived automatically.	as-interface;abstraction layer;application programming interface;aspect-oriented programming;aspect-oriented software development;c++;cognitive dimensions of notations;digital subscriber line;domain-specific language;embedded system;fault tolerance;field-programmable gate array;hlh orion;high- and low-level;informatics;international standard book number;lego mindstorms;mpsoc;model-driven architecture;model-driven engineering;multi-core processor;multiprocessing;nxt;operating system;prototype;real-time clock;robot;robotics	Matthias Meier;Olaf Spinczyk	2011			hardware compatibility list;embedded system;real-time computing;simulation;hardware acceleration;computer science;hardware architecture;hardware register	EDA	-41.882387926205766	37.178448177637044	161369
b4a5478ec44986b3b79c153519aa3956c2278468	a comprehensive architecture for autonomic service management	service orientation;service management;formal reasoning;service oriented computing;system architecture;service oriented architecture;system management;autonomic computing	Service-Oriented Computing reveals features which are not commonly found in conventional computing paradigms; loose coupling, dynamism, black box, evolvability, and heterogeneity. These features make diagnosing and healing faults found in deployed services and service-related elements more challenging than managing conventional systems. Hence, service-oriented systems management often results in problems of increased cost/effort, decreased effectiveness, and irresolvable service faults. Applying key disciplines of autonomic computing to services management would effectively resolve these problems and automate the task. This paper presents a comprehensive framework, for managing service faults in autonomous manner, called Symptom-Cause-Actuator Framework (SCAF). We first present a 5-phase process for autonomic service management. Then, we define functionality of SCAF and present the system architecture of the framework. Then, we propose formal reasoning system to diagnose services faults and actuate causes for the framework. The framework is not limited to providing a theoretical basis for service management, but it can be practically applied with current service-oriented architecture standards.	autonomic computing;autonomous robot;black box;loose coupling;reason;reasoning system;service-oriented architecture;service-oriented device architecture;systems architecture;systems management	Du Wan Cheun;Jae Yoo Lee;Soo Dong Kim	2010		10.1145/2108616.2108703	embedded system;real-time computing;service product management;differentiated service;computer science;knowledge management;service delivery framework;operating system;service-oriented architecture;service design;database;data as a service;computer security;computer network;autonomic computing	Web+IR	-43.25928902434534	41.0800164945371	161824
1077174c50f7770c242ba5450bcb366c200e12d1	improving grid fault tolerance by means of global behavior modeling	informatica;control systems;image storage;fault tolerance fault tolerant systems grid computing distributed computing large scale systems cloud computing image storage control systems degradation resource management;degradation;service level;grid fault tolerance;fault tolerant;service level fault tolerance grid fault tolerance global behavior modeling self adaptive fault tolerance framework distributed environments;global behavior;behavior modeling;resource management;distributed computing;software fault tolerance;software fault tolerance grid computing;distributed environment;fault tolerant systems;adaptive fault tolerance;matematicas;fault tolerance;global behavior grid fault tolerance;point of view;grid computing;grid system;large scale systems;cloud computing	Grid systems have proved to be one of the most important new alternatives to face challenging problems but, to exploit its benefits, dependability and fault tolerance are key aspects. However, the vast complexity of these systems limits the efficiency of traditional fault tolerance techniques. It seems necessary to distinguish between resource-level fault tolerance (focused on every machine) and service-level fault tolerance (focused on global behavior). Techniques based on these concepts can handle system complexity and increase dependability. We present an autonomous, self-adaptive fault tolerance framework for grid systems, based on a new approach to model distributed environments. The grid is considered as a single entity, instead of a set of independent resources. This point of view focuses on service-level fault tolerance, allowing us to see the big picture and understand the system's global behavior. The resulting model's simplicity is the key to provide system-wide fault tolerance.	autonomic computing;autonomous robot;behavior model;data access;dependability;fault tolerance;finite-state machine;grid systems corporation;time series	Jesús Montes;Alberto Sánchez;María S. Pérez-Hernández	2010	2010 Ninth International Symposium on Parallel and Distributed Computing	10.1109/ISPDC.2010.20	fault tolerance;real-time computing;computer science;resource management;operating system;fault model;distributed computing;software fault tolerance	HPC	-44.29608480769877	40.30391440769343	161896
899eeb1761576ba2b118850beb2f8d6f4ac6c190	mesh networking in cyber-physical production systems: towards modular industrial equipment integration		Ensuring uninterrupted interaction of modular industrial equipment units is one of the most important engineering tasks. The concept of Cyber-Physical Production Systems (CPPS) assumes that the distributed network should correspond to the current industrial process and be able to quickly reorganize it when changes occur. If composition of the equipment becomes more complicated, a standard topology with one central control node might get ineffective. This article describes the application of mesh-network technology to ensure the interaction of industrial devices and sensors included in the modular equipment. Virtual deployment of the network and a description network nodes interaction including new node registration in the dispatcher registry are given.		Maxim Ya. Afanasev;Anastasiya A. Krylova;Sergey A. Shorokhov;Yuri V. Fedosov;Kseniia V. Zimenko	2018	2018 23rd Conference of Open Innovations Association (FRUCT)	10.23919/FRUCT.2018.8588083	software deployment;node (networking);cyber-physical system;wireless;mesh networking;modular design;distributed computing;computer science	Robotics	-39.065442201278024	44.487355391782124	162240
041a88eccbec5ae9870ed53ef1b4ff6852fcb8b5	a qos-aware middleware for ensuring web services reliability	reliability;web service;web services;reliable messaging;quality of service qos;middleware;web services reliability	As Web services are widely adopted, the demands for high Quality of Service (QoS) are increasing continuously and remarkably. Reliability, as one of the key components of QoS, needs to be guaranteed first and foremost even in the cases of network/system failures or service unavailability. To address these requirements, we design Reliable Web Services Bus (RBUS), a QoS-aware middleware for ensuring Web services reliability, which adopts different approaches to implement three important QoS features of reliability. These features include: 1) reliable messaging, implemented by incorporating advanced retransmission and persistence store mechanism; 2) service fault tolerance, achieved by providing the Virtual Service (VS) concept and equivalent service selection algorithm for choosing redundant replaceable services; and 3) service priority, ensuring that the services with higher priorities are more reliable than those with lower priorities. This paper discusses RBUS architecture and reports some experimental results to demonstrate its effectiveness.	middleware;quality of service;web service	Yan Zhu;Dianfu Ma;Hailong Sun;Shun Zhang;Jing Li	2007			web service;middleware;mobile qos;differentiated service;computer science;service delivery framework;ws-policy;service-oriented architecture;service design;ws-addressing;database;services computing;world wide web;devices profile for web services;computer network;service system	HPC	-43.39493431828219	42.062459133965525	162302
99d467c5d0466757d153faa915145c77c6d3bc1e	a simple, efficient, and scalable behavior-based architecture for robotic applications		In the robotics field, behavior-based architectures are software systems that define how complex robot behaviors are decomposed into single units, how they access sensors and motors, and the mechanisms for communication, monitoring, and setup. This paper describes the main ideas of a simple, efficient, and scalable software architecture for robotic applications. Using a convenient design of the basic building blocks and their interaction, developers can face complex applications without any limitations. This architecture has proven to be convenient for different applications like robot soccer and therapy for Alzheimer patients.	robotics	Francisco Martín;Carlos E. Agüero-Durán;José María Cañas	2015		10.1007/978-3-319-27149-1_47	simulation;computer engineering;robot;software system;architecture;computer science;software architecture;scalability;artificial intelligence;robotics	Robotics	-34.41493808706621	38.621281663007494	162397
5b90c08a54ff2d8c6c8896fd5de25a7caaf86e66	the emergence of a business object component architecture	disparate enterprise applications;web object technology software reuse plug compatible business object components object management group business object domain task force standardization accredited standards committee x3h7 object information management oopsla business object component design and implementation workshop w3c xml standards interoperability disparate enterprise applications;electrical capacitance tomography;iso;application software;web;accredited standards committee x3h7 object information management;w3c xml standards;standardisation;computer architecture;standards development;software standards business data processing standardisation open systems distributed object management;design and implementation;oopsla business object component design and implementation workshop;plug compatible business object components;flexible delivery;business data processing;information management;distributed object management;focal point;object management group;force measurement;national electric code;object management group business object domain task force;software standards;interoperability;component architecture;open systems;component architectures electrical capacitance tomography standardization iso concrete application software computer architecture force measurement standards development national electric code;object technology;software reuse;standardization;concrete;component architectures	Object technology, a necessary but not sufficient condition for software reuse, requires an infrastructure that supports plug compatible Business Object Components for fast and flexible delivery of products to the marketplace. The Object Management Group (OMG) Business Object Domain Task Force (BODTF) was the initial focal point for standardization of a Business Object Component Architecture (BOCA). Priming this effort required joint work with the Accredited Standards Committee X3H7 Object Information Management, and their joint sponsorship of the OOPSLA Business Object Component Design and Implementation Workshop for the years 1995-99. Emergence of W3C XML standards will further enhance BOCA and enable a distributed business object system that provides interoperability between disparate enterprise applications on the Web. 3	business object;code reuse;emergence;enterprise software;focal (programming language);information management;interoperability;plug compatible;world wide web;xml	Jeff Sutherland	1999		10.1109/ENABL.1999.805223	object linking and embedding;business object;computer science;operating system;software engineering;common object request broker architecture;database;distributed computing;information management;world wide web;computer security;business process modeling;standardization;business architecture	DB	-34.37678090932603	42.82794807548001	162505
6d7921b40d430f031d09aff5e8b08a1bc05239e3	a qos-aware web service composition approach based on cloud model		An appropriate selection is of great importance to Web service composition. Current approaches normally focus on the average performance of quality of service (QoS) of Web services while not paying more attention to the performance such as stability considering the changing environments. In addition, Web services are differentiated from others with same functions which are provided by various physical origins of service requesters and service providers, which will lead to unexpected QoS of Web service system. To solve the two issues, this paper presents a QoS-aware strategy for Web service composition based on cloud model, and correspondingly designs a multi-objective Web service composition algorithm based on quantum genetic algorithm. The simulation based on a typical dataset validates the proposed approach finally.	best, worst and average case;genetic algorithm;quality of service;service composability principle;simulation;web service	Taiqi Wang;Ting He;Fu-Jun Shi;Tianyang Li	2016	2016 9th International Conference on Service Science (ICSS)	10.1109/ICSS.2016.11	service delivery framework;mobile qos;web service;web modeling;service provider;computer network;data mining;cloud testing;service level requirement;computer science;ws-policy	HPC	-47.89757802033167	42.99397967799999	162522
58cc7823234223ff6ad51f7418a0d43d8abb4019	deriving performance-relevant infrastructure properties through model-based experiments with ginpex	deriving infrastructure properties;metamodelling;experiments;performance prediction;measurements;infrastructure	To predict the performance of an application, it is crucial to consider the performance of the underlying infrastructure. Thus, to yield accurate prediction results, performance-relevant properties and behaviour of the infrastructure have to be integrated into performance models. However, capturing these properties is a cumbersome and error-prone task, as it requires carefully engineered measurements and experiments. Existing approaches for creating infrastructure performance models require manual coding of these experiments, or ignore the detailed properties in the models. The contribution of this paper is the Goal-oriented INfrastructure Performance EXperiments (Ginpex) approach, which introduces goal-oriented and model-based specification and generation of executable performance experiments for automatically detecting and quantifying performance-relevant infrastructure properties. Ginpex provides a metamodel for experiment specification and comes with predefined experiment templates that provide automated experiment execution on the target platform and also automate the evaluation of the experiment results. We evaluate Ginpex using three case studies, where experiments are executed to quantify various infrastructure properties.	central processing unit;cognitive dimensions of notations;computer performance;documentation;executable;experiment;hard disk drive;hypervisor;load (computing);metamodeling;model-based specification;open platform;operating system;overhead (computing);performance prediction;scheduling (computing);sensor;software performance testing;universal instantiation	Michael Hauck;Michael Kuperberg;Nikolaus Huber;Ralf H. Reussner	2013	Software & Systems Modeling	10.1007/s10270-013-0335-7	simulation;computer science;systems engineering;engineering;software engineering;data mining;measurement	SE	-43.76475563136096	34.41645501111414	162609
7def69e813be01ba4637ee6eea09490414f95a04	framework for middleware in ubiquitous computing systems	system software development;disconnected operation;heterogeneous environment;management entity system software development ubiquitous computing system middleware service oriented architecture group based communication;management entity;middleware ubiquitous computing;software engineering;ubiquitous computing system;middleware ubiquitous computing mobile communication simple object access protocol service oriented architecture pervasive computing hardware user interfaces system software mobile computing;client server;distributed object management;group based communication;corba component model;communication protocol;ubiquitous computing;middleware;service oriented architecture;ubiquitous computing distributed object management middleware software engineering	Developing system software for ubiquitous computing makes consideration of numerous requirements necessary. This is primarily due to the dynamic, mobile, unpredictable and heterogeneous environment of ubiquitous computing systems. Middleware provide solutions to common tasks in ubiquitous computing, e.g. communication, discovery, deployment, personalisation, group management etc. Middleware are developed using frameworks. Existing frameworks such as CORBA component model, Webservices, and Jini support middleware in certain aspects, e.g. communication protocols, but restrict them to certain assumptions, e.g. no disconnected operation or the client/server model. In this paper a framework for middleware in ubiquitous computing is presented. The framework is used to develop middleware with the service oriented architecture paradigm. The framework presented is applied to a middleware to allow for group based communication. The middleware, and especially the management entity of the middleware, is described in greater detail in this paper	client–server model;common object request broker architecture;component-based software engineering;middleware;personalization;programming paradigm;requirement;server (computing);service-oriented architecture;software deployment;ubiquitous computing;web service;jini	Björn Wüst;Olaf Drögehorn;Klaus David	2005	2005 IEEE 16th International Symposium on Personal, Indoor and Mobile Radio Communications	10.1109/PIMRC.2005.1651848	communications protocol;middleware;real-time computing;computer science;message oriented middleware;operating system;service-oriented architecture;middleware;database;distributed computing;ubiquitous computing;client–server model	SE	-38.9259790405986	43.07861785856933	162828
d2f975f0cdd97cd65ff504bd2adbe6fdec89135e	mobieureka: an approach for enhancing the discovery of mobile web services	service discovery protocol;mobile device;device aware discovery;mobile databases;web service;ranking mobile services;cc pp;mobile web;mobile service;middleware architecture;ranking;experimental validation;middleware;mobile metadata;service discovery;mobile services;mobile web services	While several service discovery protocols and standards have been proposed for supporting service discovery from mobile devices, this remains a challenging problem. In many cases, mobile clients may discover services which they consider relevant but soon realize that such services are not completely usable on their mobile devices due to compatibility and interoperability issues. Without integrating device capabilities into the discovery process, or a device-aware mobile service discovery, it becomes extremely difficult to determine whether discovered services may or may not function properly within the device’s constraints. This paper introduces a solution known as MobiEureka, a mobile device-aware system for enhancing the discovery of mobile web services from mobile devices. Experimental validation, results, and analysis of the introduced ideas are discussed.	cc system;functional requirement;interoperability;mobile device;non-functional requirement;quality of service;relevance;service discovery;web service;world wide web	Eyhab Al-Masri;Qusay H. Mahmoud	2009	Personal and Ubiquitous Computing	10.1007/s00779-009-0252-5	mobile search;mobile qos;computer science;operating system;database;service discovery;mobile business development;internet privacy;mobile computing;world wide web	Mobile	-40.48034725380445	45.86080426502127	162849
9ceb33cd0f5e074139fbcf9b15175c9ab10c7616	coca: collaborative objects coordination architecture	distributed system;virtual machine;groupware;collaboration;coordination language;collaborative system;coordination languages;specification language;logic programming;cscw;logic programs;distributed systems	Coordination policies vary from collaboration to collaboration and are even subject to evolution in different phases of the same collaboration. It is vital for collaborative systems to be flexible enough to accommodate changes to the coordination policies du ring development and the lifetime of the collaboration. Motivated by previous work of separating coordinati on and computation, we propose COCA as a generic framework for developing collaborative systems and modeling the coordination policies. Participants ex plicitly adopt roles, and coordination policies are specifie d in terms of roles in a logic-based specification langu age. Policies are interpreted at runtime at each collabo r ti n site by a COCA virtual machine. It is easy to chang e the coordination policies both during development and a t runtime.	computation;run time (program lifecycle phase);titanium nitride;virtual machine	Du Li;Richard R. Muntz	1998		10.1145/289444.289492	real-time computing;specification language;computer science;virtual machine;computer-supported cooperative work;distributed computing;programming language;logic programming;management;collaboration	AI	-37.71892497942887	39.84659489217667	162991
5d854d599c096ac4d3e206d056b9bef7873283e8	effect of data validity on the reliability of data-centric web services	databases;software reliability web services computational modeling databases data models;computational modeling;web services;software reliability;data models	Reliability is an essential quality requirement for web services. Existing techniques for measuring reliability of web services mainly focus on failures caused by code-based defects. For data-centric web services, the reliability of services can be significantly affected by the quality of data used to provide services. However, the impact of data quality on the reliability of web services has rarely been explored. We present an approach to estimate data quality and to incorporate data quality with the reliability of software components in the reliability estimation of web services. To demonstrate the proposed approach, we present a case study on a government web service. In this study we observed that more than 60% of service failures reported over a three-month period were caused by invalid data. The results show that by taking into account data quality, the reliability estimate of the web service is more accurate than the traditional reliability measurement.	component-based software engineering;consistency model;data quality;web service	Ewa Musial;Mei-Hwa Chen	2012	2012 IEEE 19th International Conference on Web Services	10.1109/ICWS.2012.95	web service;reliability engineering;data modeling;computer science;data mining;database;computational model;software quality	DB	-48.09667097720509	40.387560662644276	163396
3eaed97fdffc25334c2d9540c5a99672b48482b0	formal certification and compliance for run-time service environments	analytical models;security of data cloud computing formal verification;progressive event driven model checking formal certification run time service environment service security service safety on demand distributed service provisioning cloud infrastructure service engineering design time checking progressive certification run time monitoring service execution environment runtime behavioural compliance checking service architecture;monitoring analytical models abstracts security mechanical factors algorithm design and analysis computer architecture;mechanical factors;qa75 electronic computers computer science;computer architecture;formal verification;monitoring;abstracts;security;security of data;algorithm design and analysis;cloud computing	With the increased awareness of security and safety of services in on-demand distributed service provisioning (such as the recent adoption of Cloud infrastructures), certification and compliance checking of services is becoming a key element for service engineering. Existing certification techniques tend to support mainly design-time checking of service properties and tend not to support the run-time monitoring and progressive certification in the service execution environment. In this paper we discuss an approach which provides both design-time and runtime behavioural compliance checking for a services architecture, through enabling a progressive event-driven model-checking technique. Providing an integrated approach to certification and compliance is a challenge however using analysis and monitoring techniques we present such an approach for on-going compliance checking.	event-driven programming;local tangent space alignment;mathematical model;mathematical optimization;model checking;open-source software;provisioning;run time (program lifecycle phase);scalability;trustworthy computing	Howard Foster;George Spanoudakis;Khaled Mahbub	2012	2012 IEEE Ninth International Conference on Services Computing	10.1109/SCC.2012.23	real-time computing;computer science;service delivery framework;service design;database;security service;computer security	SE	-45.320983882143494	42.675526492912496	163694
b5fe353717365e143604ba36ed85012caad005ca	aggregating service level agreements in services bundling: a semiring-based approach		Business services arguably play a central role in service-based information systems as they fill in the gap between the technicality of Service-Oriented Architecture and the business aspects captured in Enterprise Architecture. Business services have distinctive features that are not typically observed in Web services, e.g. significant portions of the functionality of business services might be executed in a human-mediated fashion. As such, service level agreement (SLA) should be described as a mixture of human-mediated functionality (e.g., service penalty) and computer-interpretable measurement (e.g., reliability, payment). In this paper, we propose a formal framework for reasoning about the SLAs from the perspective of services bundling – the practice of innovatively organizing business services into a bulkier service offering that creates new values. Specifically, we (a) represent multi-level SLA of a business service in terms of service reliability, payment and penalty using the mathematical structure of semiring; (b) provide formality for aggregating SLAs of the constituent services that make up the service bundling; (c) make multi-level SLAs of a bundled service technically comparable. The main contribution of this work is a machinery for handling a large number of SLAs generated through services bundling, allowing to the service consumers to pick up the right service offering according to their preference.	service-level agreement	Trung-Viet Nguyen;Lam-Son Lê;Khuong Nguyen-An	2016		10.1007/978-3-319-48057-2_27	process management;service (economics);business;architecture;information system;enterprise architecture;web service;service-level agreement;terms of service;service level	HPC	-47.05331145318525	43.93253491022294	163760
fb23adc4605b348d356dbcc6fa4e919d90d047ea	a flexible and extensible component-oriented middleware for creating context-aware applications	context aware application;j2cs system;programming interface;context information;java 2 context service;life cycle;run time performance;object oriented programming;software architecture;component oriented middleware;software architecture java middleware object oriented programming;run time performance component oriented middleware context aware application java 2 context service j2cs system component life cycle contextlets software architecture programming interface;middleware;contextlets;middleware application software context aware services containers java context acoustic sensors pervasive computing wearable computers ubiquitous computing;component life cycle;java	In this paper, we describe a middleware system, called J2CS (Java 2 Context Service), that provides support to most of the tasks involved in designing context-aware applications in Java. The J2CS system can be classified as a lightweighted, flexible, extensible and component-oriented middleware. In the proposed platform, containers manage the life cycle of components called contextlets which are used to infer high-level events from. low-level sensed data. Containers are also in charge of handling communication details with sensors and other sources of context information. In this paper, we discuss the software architecture, the programming interface, the run-time performance and the implementation of J2CS. We also present some examples of context-aware applications based on the proposed middleware	application programming interface;high- and low-level;java version history;middleware;sensor;software architecture	Daniel Coutinho de Miranda;Marco Tulio Valente	2006	2006 ACS/IEEE International Conference on Pervasive Services	10.1109/PERSER.2006.1652224	embedded system;biological life cycle;software architecture;middleware;real-time computing;computer science;message oriented middleware;operating system;middleware;object-oriented programming;java	HPC	-39.12193153590756	41.6219603027634	163892
8a9c60c520a91f88800fa741e99d9f3014532ad3	a simple, safe reconfigurable object model with loosely-coupled communication	dynamic change;state preservation;availability;separation of concern;software systems;internal structure;informatics facsimile availability runtime resilience character generation safety middleware software systems hardware;runtime;juice 2 safe reconfigurable object model loosely coupled communication separation of concern soc meta object communication state preservation middleware;meta object communication;juice 2;distributed objects;resilience;facsimile;distributed environment;character generation;loosely coupled communication;safety;distributed object management;middleware;soc;informatics;safe reconfigurable object model;middleware distributed object management;object model;hardware	Dynamic changes in open distributed environments damage the continuous execution of distributed objects. A distributed environment consisting of reconfigurable distributed objects would have higher reliability and availability, and a greater resilience to unexpected requirement changes. In this paper, we propose a reconfigurable, object model that dynamically changes the object's behavior to fit the current environment by modifying its internal structure. The proposed object consists of communicating concurrent meta-objects. Each meta-object contains functions for adaptation, remote communication, and administration. Therefore, this model provides the required separation of concerns (SoC). Generative communication, which allows meta-object communication, gives the proposed reconfigurable objects the following characteristics: flexibility; ability of allowing a variety of configurations; safety that ensures consistency; and a unification of state preservation and communication. The proposed object model was successfully implemented in a middleware framework called Juice 2.	distributed object;metaobject;middleware;reconfigurable computing;separation of concerns;unification (computer science)	Kentaro Oda;Hiroki Najima;Yoshihiro Yasutake;Takaichi Yoshida	2006	20th International Conference on Advanced Information Networking and Applications - Volume 1 (AINA'06)	10.1109/AINA.2006.59	system on a chip;availability;real-time computing;object model;separation of concerns;computer science;operating system;middleware;database;distributed computing;distributed object;programming language;informatics;computer security;psychological resilience;distributed computing environment;software system	Robotics	-38.59843478638562	39.462855280782094	164022
b08acbd4a34de2a2896769c95f7351ba948fea7f	a software architecture for transportation planning and monitoring in a collaborative network		Transportation planners require software support to easily monitor and dispatch transportation resources, especially when transportation is multi-modal and when resources from different companies in their network are being used. We call such an application a transportation control tower. This paper presents a software architecture for transportation control towers. It focuses in particular on the novel aspects of the software architecture. These are: the ability to easily configure the monitoring of resources and tasks; the ability to create the statements for monitoring resources and tasks based on the transportation plan; and the ability to dynamically adjust the monitoring statements. A prototype of the software architecture is implemented and evaluated on three usage scenarios.	collaborative network;software architecture	Anne Baumgraß;Remco M. Dijkman;Paul W. P. J. Grefen;Shaya Pourmirza;Hagen Völzer;Mathias Weske	2015		10.1007/978-3-319-24141-8_25	enterprise architecture framework;systems engineering;software engineering;transport engineering;resource-oriented architecture	ML	-41.94710902918597	41.65615617982675	164143
f34518eb088af40ff25111ad5a111ec253900681	model problem (crowdnav) and framework (rtx) for self-adaptation based on big data analytics (artifact)		This artifact supports our research in selfadaptation in large-scale software-intensive distributed systems. The main problem in making such systems self-adaptive is that their adaptation needs to consider the current situation in the whole system. However, developing a complete and accurate model of such systems at design time is very challenging. We are instead investigating a novel approach where the system model consists only of the essential input and output parameters and Big Data analytics is used to guide self-adaptation based on a continuous stream of operational data. In this artifact, we provide a concrete model problem that can be used as a case study for evaluating different self-adaptation techniques pertinent to complex large-scale distributed systems. We also provide an extensible tool-based framework for endorsing an arbitrary system with self-adaptation based on analysis of operational data coming from the system. The model problem (CrowdNav) and the framework (RTX) have been packaged together in this artifact, but can also work independently. 1998 ACM Subject Classification C.1.3 Other Architecture Styles–Adaptable Architectures	big data;distributed computing;input/output;rtx, rtx64;relevance	Sanny Schmid;Ilias Gerostathopoulos;Christian Prehofer;Tomás Bures	2017	DARTS	10.4230/DARTS.3.1.5	input/output;data mining;extensibility;big data;system model;analytics;computer science	SE	-44.080141540396355	39.49115304238936	164418
b9b918c2c7fa3f0a7cd375fa37c500fd2cf419d1	verification of external specifications of reactive systems	real time specification models;formal specification;object oriented language;history;formal specifications;formal verification specification languages real time systems object oriented languages formal specification;specification language;systems engineering and theory;power engineering and energy;temporal constraints;formal verification;tool object oriented machine state tool;object oriented;specification languages;object oriented modeling history real time systems specification languages costs power engineering and energy systems engineering and theory formal specifications councils message passing;message passing;reactive system;tool object oriented machine state tool external specifications reactive systems tempo reale object oriented language temporal constraints completeness consistency real time specification models;councils;system development;external specifications;reactive systems;completeness;object oriented languages;tempo reale object oriented language;object oriented modeling;consistency;real time systems	The external specification is currently approached by specification languages for describing and analyzing system requirements. The external specification can be defined during the early stages of the system development and can be very useful for: checking the class/system/subsystem requirements; checking the system composition; evaluating costs of reuse; defining validated reference requirements, histories, and traces for the final validation. This paper presents a collection of criteria in order to formally verify the external specification of reactive systems/subsystems. The verification criteria are grounded on the Tempo Reale Object-oriented Language (TROL) specification model for real-time systems. In TROL, the external specification is expressed in terms of ports and clauses with temporal constraints. The goal of the verification criteria presented is to check the completeness and consistency of the external specification with special attention to temporal constraints. These criteria can be applied to other real-time specification models and have been enforced in the Tool Object Oriented Machine State (TOOMS) tool. A practical example illustrates the verification process that embodies these criteria.	real-time cmix;real-time clock;real-time computing;requirement;specification language;system requirements;tracing (software);type system	Pierfrancesco Bellini;Mario Andres Bruno;Paolo Nesi	2000	IEEE Trans. Systems, Man, and Cybernetics, Part A	10.1109/3468.895892	software requirements specification;real-time computing;verification;specification language;reactive system;computer science;system requirements specification;programming language;object-oriented programming;language of temporal ordering specification	SE	-33.94283505321186	33.83874753757106	164568
a497d80e0b0fefa746a8147053022892b3db2808	an asm model for the procure to pay case study	organizational meta model;organizational model;authorization;access control;cloud services	This paper describes a model for the p2p [3] case study using the ASM method [2]. We show how the model clearly distinguishes between the different activities that are part of the process. The model also abstracts from scheduling policies and details contained in the requirements yet providing a precise description that captures them. Finally we highlight some points in which refinements can easily adapt the model to requirements changes.	procurement;requirement;scheduling (computing)	Simone Zenzaro	2015		10.1145/2723839.2723865	simulation;cloud computing;computer science;systems engineering;engineering;access control;data mining;database;authorization	SE	-46.74416466692852	43.110738207735196	164682
41cbe37b5591d29d92599d33f35f0f3974049e80	automation of flow injection methods in the winery industry through a computer program based on a multilayer model	computer program;automation wineries wine industry computer industry nonhomogeneous media hardware automatic control buildings electrical equipment industry humans;flow injection;computerised monitoring design of experiments flow production systems manufacturing processes beverage industry direct digital control;manufacturing processes;design of experiments;beverage industry;direct digital control;quality control flow injection automation winery industry multilayer model wine analysis design of experiments control flow time governed model analytical monitoring driver layer communication layer production processes c language java language xml language;control flow;flow production systems;computerised monitoring;design of experiment	A system dedicated to the automation of wine analysis processes making use of the flow injection technique is presented in this work. The system thus developed allows both the design of experiments making use of different hardware and analytical instrumentation, and the subsequent development of wines analysis in a fully computer-controlled manner. The system is built under a multilayer model in which each layer is formed by different components and it has a specific functionality. The control flow in which the experiment actions are carried out by the hardware is defined under a time-governed model, and triggers are used in order to take into account the system state at the end of the process.	automation;computer program	Manuel Urbano-Cuadrado;María Dolores Luque de Castro;Miguel Ángel Gómez-Nieto	2003		10.1109/ETFA.2003.1248744	embedded system;simulation;computer science;engineering;electrical engineering;operating system;design of experiments;statistics;manufacturing engineering	EDA	-37.61906830972629	34.349503738977475	164710
505d98783080f4bff7a38f536368537a521f11be	the miles before formal methods - a case study on modeling and analyzing a passenger lift system		Cyber-Physical Systems (CPS) pervade our everyday lives. As users, we need assurances that such systems satisfy requirements on safety, reliability, security and interoperability. CPS presents a major challenge for formal analysis because of their complexity, physical dependencies and non-linearity, and for smart CPS - the ability to improve their behavior over time. Existing approaches on analyzing CPS (e.g., model checking and model-based testing) often assume the existence of a system model. Such approaches have limited application in practice as the models often do not exist. In this work, we report our experience on applying a three-step approach to analyzing a practical CPS: a passenger lift system in a commercial building. The three steps are (1) determining the right level of system abstraction, (2) building the model automatically using grammatical inference, and (3) analyzing the model. The inferred model is in the form of a probabilistic deterministic real time automaton, which allows us to verify the system against properties demanded by the lift requirement. The resulting models form the basis of formal analysis and potentially other approaches. We believe that our approach and experience are applicable to other CPSs.	formal methods	Teck Ping Khoo;Jun Sun	2018		10.1007/978-3-030-02450-5_4	model checking;theoretical computer science;interoperability;formal methods;automaton;probabilistic logic;system model;grammar induction;computer science;abstraction	Logic	-44.47268945255646	35.44858142996963	164757
7113f130452b81a4018e94b76f68d326539b84dc	a model-based methodology to generate code for timer units	timer unit;code generation;embedded systems	In this paper we present a model-based methodology and a tool-chain supporting pseudo-automated code generation for different Timer Units, which represent a new approach in this field. Programmable Timer Units are timing co-processors used to elaborate complex high-resolution timing functions subject to hard real-time constraints. Verification at the different design stages, as required per safety standards’ certification, is becoming a major concern for Timer Units code development life-cycle. Enabling correct-by-construction code generation, our methodology supports code development, integration and testing across all design phases. We show how high-level functional models derived from functional requirements can be mapped onto the target architecture and how architecture-specific code can be generated. Our methodology is then applied to an automotive reference example.		Marco Marazza;Francesco Menichelli;Mauro Olivieri;Orlando Ferrante;Alberto Ferrari	2014		10.1007/978-3-319-20227-3_26	embedded system;real-time computing;computer hardware;watchdog timer	SE	-41.3115390020885	33.66774689544818	164822
f09963706677377ebfb73f0e24ce501162f40cd5	functional safety verification on railway signaling system with colored petri nets	traffic engineering computing control engineering computing formal verification petri nets rail traffic control railways;hazards petri nets rail transportation analytical models radiation detectors formal verification;communication based train control system functional safety verification railway signaling system colored petri nets national railway urban rail transportation formal verification;positive train control;automatic train control;urban areas;railroad safety;railroad traffic control;petri nets;railroad signaling	Signaling system acts very important safety role in both national railway and urban rail transportation. This paper provides a formal verification framework on functional safety desired by railway industry application. The presented work chooses Colored Petri Nets for functional modeling and verification. The modelling approaches of internal faults and undesired external influences are proposed by introducing a countering place, and the verification criteria is established based on credible hazard set. An application of this framework on Communication Based Train Control system is also presented.	coloured petri net;control system;formal verification;liveness;multidimensional digital pre-distortion;point of view (computer hardware company);reachability;signalling system no. 7	Xiaoli She;Jiyuan Zhao;Jian Yang	2014	17th International IEEE Conference on Intelligent Transportation Systems (ITSC)	10.1109/ITSC.2014.6958124	engineering;automotive engineering;transport engineering;computer security	Robotics	-45.27553743910476	35.110660244540625	164906
92ed8d27b916de778cb118ad5e62d5b7a53a9fe0	redom: an oo language to define and on-line manipulate regulations in the resource (re)scheduling problem	oo language	In the class of (re)scheduling problems where humans constitute the main resource, the scheduling process is influenced by a great number of complex and frequently changing regulations. The complexity and the dynamic nature of these regulations impose the need for an efficient, flexible and user-friendly way to express and manage them. A solution to this problem, in the form of an object-oriented high-level language with semantics highly-tailored to the user needs, is presented. The language, called REDOM, can be applied to different scheduling application domains with a minimum degree of effort, because it is based on a generic meta-model of the resource scheduling problem. An application programming interface facilitates REDOM integration into existing scheduling systems. REDOM is currently being utilised by the DAYSY resource management system, that is implemented as a constraint satisfaction system based on a partial test-and-generate approach. The combination of REDOM and CHIP (Constraint Handling In Prolog), which was used for the implementation of the solution generation subsystem, resulted in a highly-efficient and flexible (re)scheduling system, well-accepted by users.  1997 by John Wiley & Sons, Ltd.	application programming interface;constraint satisfaction;high- and low-level;high-level programming language;john d. wiley;metamodeling;prolog;scheduling (computing);usability	K. X. Thrampoulidis;N. Diamantopoulos;Efthymios Housos	1997	Softw., Pract. Exper.	10.1002/(SICI)1097-024X(199710)27:10%3C1135::AID-SPE121%3E3.0.CO;2-T	fair-share scheduling;nurse scheduling problem;job shop scheduling;real-time computing;flow shop scheduling;constraint satisfaction;dynamic priority scheduling;computer science;genetic algorithm scheduling;operating system;two-level scheduling;database;distributed computing;scheduling;programming language;multiprocessor scheduling	AI	-39.02005539230174	35.71283087834435	164950
e000d9aca1ffd0e96d85a97769150f284ae16ce6	a new design method of software based on state transition	developpement logiciel;software;requirements structure;logiciel;listing necessary states;real time processing;logical structure;conception;tratamiento tiempo real;traitement temps reel;design method;desarrollo logicial;software development;diseno;logicial;design;necessary state;software design;real time software;state transition	An understanding of state transitions is essential in real-time software design. However, satisfactory research has not been performed on methodologies to list the necessary states. A method is needed to systematically identify necessary states in order 30 meet the given requirements. The two points that must be clarified when identifying necessary states are which states are necessary states and what causes lead to considering a state necessary. We begin this paper by clarifying the necessary states in software design that must be introduced into the software when elements other than state parameters external to the software are required to determine the correct response when multiple responses are obtained from the same input. Next, by focusing on the relationship between the input and the output, we illustrate that the software requirements have a hierarchical structure and selections from alternative realization methods based on the structure cause consideration on states. This requirement structure designates the logical structure of the requirements specified in the design process. Design and specification (implementation) of the requirements make is possible to list necessary states systematically.	real-time clock;real-time computing;requirement;software design;software requirements;state transition table	Naoko Yokoi;Takeshi Kaneko;Yoshinori Iizuka	1994	Systems and Computers in Japan	10.1002/scj.4690250203	design;software requirements specification;computer science;software design;software development;algorithm	SE	-41.32748565270358	33.23729448175065	164995
62b2a4ca3f1259213cb9c99a9a1266b962a324a5	a thin client application development using ocl and conceptual schema	databases;application development;computers;unified modeling language business databases maintenance engineering computers prototypes servers;web based applications;data integrity;client server architecture;software maintenance;database management systems;prototypes;client server systems;maintenance engineering;orm;servers;conceptual schema;graphical user interfaces;internet;specification languages;ocl;application program interfaces;integrity constraint;business;unified modeling language;thin client;integrity constraints;graphic user interface;object role modeling;orm thin client integrity constraint conceptual schema ocl;specification languages application program interfaces client server systems data integrity database management systems graphical user interfaces internet software maintenance;commercially available dbms thin client application development ocl conceptual schema client server architecture client program computing resources web based applications graphical user interface browser program back end servers business rules application logic application program modifications rules modifications application maintenance database management system combined object constraint language object role model orm integrity constraints modeling;database management system;business rules;object constraint language	According to the client-server architecture, a thin client is a client program which relies heavily on the computing resources of the server. Current implementations include web-based applications that only have their graphical user interface displayed on a browser program, and the rest of the application run on back-end servers. Business rules, however, are normally parts of the application logic and are hard-coded as an integral part of the application program. Rules maintenance thus implies costly application program modifications. Also rules modifications could involve modifications of several programs that refer to the same rules. Thus makes application maintenance even more challenging. In fact, it has long been recognized that integrity constraints including business rules, as described by a conceptual schema, should be enforced by the database management system. This paper presents a combined Object Constraint Language (OCL) and Object Role Model (ORM) for integrity constraints modeling, and demonstrates an implementation which enforces them by using a commercially available DBMS.	business logic;client (computing);client–server model;conceptual schema;data integrity;database;floor and ceiling functions;graphical user interface;hard coding;object constraint language;server (computing);thin client;web application	Jane Saetent;Nattawut Vejkanchana;Suphamit Chittayasothorn	2011	2011 International Conference for Internet Technology and Secured Transactions		semantics of business vocabulary and business rules;computer science;operating system;database;world wide web	DB	-34.67947977124772	41.5348018277752	165197
7589987875e22c79a4c16686d135dfbe0feff8fc	pattern-based modeling of high-performance computing resilience		With the growing scale and complexity of high-performance computing (HPC) systems, resilience solutions that ensure continuity of service despite frequent errors and component failures must be methodically designed to balance the reliability requirements with the overheads to performance and power. Design patterns enable a structured approach to the development of resilience solutions, providing hardware and software designers with the building block elements for the rapid development of novel solutions and for adapting existing technologies for emerging, extreme-scale HPC environments. In this paper, we develop analytical models that enable designers to evaluate the reliability and performance characteristics of the design patterns. These models are particularly useful in building a unified framework that analyzes and compares various resilience solutions built using a combination of patterns.	event-driven architecture;programming paradigm;software design pattern;universal instantiation	Saurabh Hukerikar;Christian Engelmann	2017		10.1007/978-3-319-75178-8_45	psychological resilience;it service continuity;software design pattern;software;overhead (business);distributed computing;computer science;supercomputer	EDA	-44.89419661219746	40.45121510480217	165243
55f20fa240a13bd82e3fefc1cc6bc59877598e8d	transaction support using unit of work modeling in the context of mda	model design;transaction management;transformation model;distributed transactions;model transformation;business data processing;model integrated computing;unified modeling language;context modeling application software middleware unified modeling language computer architecture operating systems security software design software architecture computer science;transparent transaction management transaction support unit of work modeling enterprise computing model driven architecture uml profile mercator;transaction processing;software design;model driven architecture;unified modeling language transaction processing business data processing	"""Transactions are an important part of most enterprise computing systems. Sometimes they are supported by DBMS and sometimes by transaction monitors. In either case, they are part of the platform used by application developers. A platform independent model of enterprise computing must abstract away transactions and provide platform independent ways of describing them. This paper shows how """"unit of work"""" can be used to support platform independent descriptions of enterprise computing systems that use transactions. Our paper is in the context of the OMG's model driven architecture so we provide a UML profile for describing unit of work. We have developed a tool, Mercator, that can translate platform independent models using the unit of work profile to platform dependent models using transactions. When added to our previous work on persistence, this provides a general way of handling transparent transaction management in MDA."""	applications architecture;database transaction;distributed computing environment;domain-driven design;enterprise software;exception handling;hibernate orm;high-level programming language;java transaction api;library (computing);middleware;model transformation;model-driven architecture;persistence (computer science);platform-independent model;profile (uml);prototype;requirement;retry;software developer;transaction processing;transformers;unified modeling language	Weerasak Witthawaskul;Ralph E. Johnson	2005	Ninth IEEE International EDOC Enterprise Computing Conference (EDOC'05)	10.1109/EDOC.2005.32	unified modeling language;model-driven architecture;real-time computing;rm-odp;database transaction;transaction processing;distributed transaction;computer science;systems engineering;software design;operating system;service-oriented modeling;software engineering;process modeling;database;online transaction processing;programming language;transaction processing system	SE	-34.36176721393214	42.215018863007906	165658
da75ec1191751a401cc1d985474623d79145bc78	modern c++ as a modeling language for automated driving and human-robot collaboration	human robot collaboration;c 14;c 11;robot operating system ros;automated driving;pid control;signal flow diagrams;modern c;object oriented modeling;simulation environment	Signal-flow diagrams, state-space models and finite-state machines are established modeling concepts in embedded controller software development. However, in the emerging areas of automated driving and human-robot collaboration, the dynamic management of system and environmental objects is mandatory. For this, object-oriented concepts are required in addition to the established modeling concepts. This paper demonstrates the application of signal-flow diagrams together with object-oriented models in Modern C++ for the software development in the area of submicroscopic traffic control. Both the vehicle dynamics and the longitudinal controllers are modeled as signal-flow diagrams and state-space models. Above this control layer, the dynamic creation and removal of individual vehicles and environmental objects are modeled in Modern C++. Together with Boost odeint these models are directly represented on a high abstraction level. Modern C++ is no longer limited to programming but is used as an object-oriented modeling language both for reliable embedded software and simulation environments.	abstraction layer;autonomous car;c++;diagram;embedded controller;embedded software;embedded system;finite-state machine;modeling language;simulation;software development;state space	Daniel Tuchscherer;Alexander Weibert;Frank Tränkle	2016		10.1145/2976767.2976772	pid controller;embedded system;real-time computing;simulation;computer science;systems engineering;engineering;carbon-14	SE	-43.72181621741244	33.071727312421785	165837
f8726da9452da8198f54e56f7e7c109405c4cb6b	an application of formal analysis to software in a fault-tolerant environment	nuclear power stations;application software fault tolerance hardware laboratories software safety fault tolerant systems inductors sufficient conditions availability system analysis and design;nuclear engineering computing;formal specification;fault tolerant;department of energy;data exchange;formal analysis methodology;automated reasoning;satisfiability;system fault tolerance formal analysis fault tolerant environment hardware software modeling charles stark draper laboratory fault tolerant processor safety related function integral fast reactor experimental breeder reactor ii hardware failures data exchange instructions ftp program data control flows abstract application program sensor failures application software sufficient conditions;modeling and analysis of software and hardware;fault tolerant computing;power engineering computing;safety critical software;fault tolerance;control flow;power engineering computing formal specification fault tolerant computing safety critical software nuclear engineering computing nuclear power stations;formal analysis;modeling and analysis	ÐThis paper describes work that represents the culmination of a comprehensive hardware/software modeling and analysis project concerning the Charles Stark Draper Laboratory Fault-Tolerant Processor (FTP). The FTP performs a safety-related function at the Integral Fast Reactor (IFR previously known as the Experimental Breeder Reactor-II) operated by Argonne National Laboratory for the Department of Energy. Previously, we demonstrated the tolerance to hardware failures of data exchange instructions on the FTP. Here, we describe a methodology for assuring that the software executing on the FTP is also tolerant to hardware failures. This methodology is based on an abstraction of the program data and control flows in terms of the specification of an abstract application program that operates on the FTP. We then prove the fault tolerance of the abstract application program to hardware and sensor failures. Based on a more detailed specification and analysis of the code that is used in the application software, we demonstrate that this code satisfies the sufficient conditions developed for the abstract application program to claim system fault tolerance. Index TermsÐFormal analysis methodology, modeling and analysis of software and hardware, automated reasoning, fault tolerance.	automated reasoning;compiler;computer hardware;control flow;data dependency;formal methods;instrument flight rules;modeling language;programming paradigm;reactor (software);requirements analysis;software design;system fault tolerance	Gregory H. Chisholm;Anthony S. Wojcik	1999	IEEE Trans. Computers	10.1109/12.805155	embedded system;fault tolerance;parallel computing;real-time computing;computer science;operating system;programming language	Embedded	-44.67269228828788	34.32454637856605	166021
0b3cc1b5f0d732ac60f120991ff5002bc4c69e17	data organization and data comparison for model validation in faster-than-real-time simulation	faster than real time simulation;multiserver processing system data comparison model validation faster than real time simulation validation data complexity validation process conceptual design formal data organization data model single queue processing system;communication networks;formal data organization;multiserver processing system;queueing theory;single queue processing system;real time;atherosclerosis;predictive models data models real time systems process design timing automation atherosclerosis communication networks military communication transportation;military communication;data model;process design;model validation;conceptual design;formal verification;validation process conceptual design;formal verification data handling real time systems queueing theory data models multiprocessing systems;transportation;simulation study;predictive models;multiprocessing systems;data handling;validation data complexity;data models;real time systems;data comparison;timing;automation	Validation is an essential feature of faster-than-real-simulation (FRTS), since models must be validated prior used for near-future predictions. As no relevant approaches exist in the literature, the paper contribution is to propose an approach a) accomplishing validation as a real-time, automated process, with low time overhead, b) dealing with the complexity of validation data, as the number and type of the data compared may be changing and c) realizing the transition from validation process conceptual design to an efficient real-time execution. A formal data organization scheme (data model) and algorithms for constructing and accessing it are implemented for this purpose. Realization of model validation in a FRTS experiment on a single-queue/multi-server processing system is presented to exhibit the applicability of the proposed approach. The proposed organization scheme may also be applied in simulation studies where timing and automation requirements are not critical.	algorithm;data model;emoticon;overhead (computing);real-time clock;real-time operating system;requirement;server (computing);simulation	Dimosthenis Anagnostopoulos;Mara Nikolaidou	2006	39th Annual Simulation Symposium (ANSS'06)	10.1109/ANSS.2006.16	real-time computing;simulation;computerized system validation;computer science;data validation;database;validation rule	Embedded	-39.07279853619316	34.54969002484819	166080
91e903dd545960302c505394beb899cb7476a2b8	quantitative verification of system safety in event-b	quantitative verification;system safety;system behaviour;safety-critical system;system development;formal system modelling;quantitative demonstration;quantitative safety analysis;quantitative assessment;formal verification;formal modelling framework;system property	Certification of safety-critical systems requires formal verification of system properties and behaviour as well as quantitative demonstration of safety. Usually, formal modelling frameworks do not include quantitative assessment of safety. This has a negative impact on productivity and predictability of system development. In this paper we present an approach to integrating quantitative safety analysis into formal system modelling and verification in Event-B. The proposed approach is based on an extension of Event-B, which allows us to perform quantitative assessment of safety within proofbased verification of system behaviour. This enables development of systems that are not only correct but also safe by construction. The approach is demonstrated by a case study – an automatic railway crossing system.	b-method;formal system;formal verification;system safety	Anton Tarasyuk;Elena Troubitsyna;Linas Laibinis	2011		10.1007/978-3-642-24124-6_3	reliability engineering;systems engineering;engineering;transport engineering;runtime verification;functional verification	SE	-44.0937920788602	32.47267576559923	166138
18813dddb58e166d63ea57c65abd6d509141a4f7	artificial immunology for collective adaptive systems design and implementation	artificial immune system;autonomic computing;framework	Distributed autonomous systems consisting of large numbers of components with no central control point need to be able to dynamically adapt their control mechanisms to deal with an unpredictable and changing environment. Existing frameworks for engineering self-adaptive systems fail to account for the need to incorporate self-expression—that is, the capability of a system to dynamically adapt its coordination pattern during runtime. Although the benefits of incorporating self-expression are well known, currently there is no principled means of enabling this during system design. We propose a conceptual framework for principled design of systems that exhibit self-expression, based on inspiration from the natural immune system. The framework is described as a set of design principles and customizable algorithms and then is instantiated in three case studies, including two from robotics and one from artificial chemistry. We show that it enables self-expression in each case, resulting in systems that are able to adapt their choice of coordination pattern during runtime to optimize functional and nonfunctional goals, as well as to discover novel patterns and architectures.	adaptive system;algorithm;artificial chemistry;autonomous robot;autonomous system (internet);bootstrapping (compilers);color;control point (mathematics);control system;emergence;expected utility hypothesis;functional programming;functional requirement;hoare logic;mathematical optimization;model checking;non-functional requirement;nonlinear gameplay;optimization problem;regular expression;robotics;run time (program lifecycle phase);self-organization;semantic network;sharp mz;software design pattern;swarm robotics;systems design;systems engineering;the stanley parable;time-scale calculus;verification and validation	Nicola Capodieci;Emma Hart;Giacomo Cabri	2016	TAAS	10.1145/2897372	simulation;computer science;artificial intelligence;software framework;distributed computing;artificial immune system;autonomic computing	AI	-43.67537148596146	38.732445883326484	166155
f078cbe338a049bacb4abb9be3a23673c3f1a701	putting preemptive time petri nets to work in a v-model sw life cycle	analytical models;trace analysis;program diagnostics;preemptive scheduling;formal specification;v model;life cycle;coverage analysis;automated code generation;real time;scheduling formal specification petri nets program diagnostics program testing safety critical software;execution time estimation;model transformation;coverage evaluation preemptive time petri nets v model sw life cycle concurrent timed sw components fixed priority preemptive scheduling symbolic state space analysis difference bounds matrix zones compositional modularization trace analysis overapproximation safety critical sw components model driven development framework semiformal specification automated compilation ptpn models real time code measurement based execution time estimation test case selection test case execution;sw life cycle;real time systems analytical models unified modeling language petri nets mathematical model computer architecture;fixed priority;automated model transformation;test case selection and execution;model driven development;computer architecture;time petri net;program testing;coverage analysis real time systems safety critical sw components sw life cycle v model preemptive time petri nets symbolic state space analysis model driven development automated model transformation automated code generation execution time estimation real time testing test case selection and execution;symbolic state space analysis;scheduling;state space;safety critical software;real time testing;unified modeling language;mathematical model;petri nets;petri net;preemptive time petri nets;safety critical sw components;analytical model;modeling and analysis;real time systems;timing	Preemptive Time Petri Nets (pTPNs) support modeling and analysis of concurrent timed SW components running under fixed priority preemptive scheduling. The model is supported by a well-established theory based on symbolic state space analysis through Difference Bounds Matrix (DBM) zones, with specific contributions on compositional modularization, trace analysis, and efficient overapproximation and cleanup in the management of suspension deriving from preemptive behavior. In this paper, we devise and implement a framework that brings the theory to application. To this end, we cast the theory into an organic tailoring of design, coding, and testing activities within a V-Model SW life cycle in respect of the principles of regulatory standards applied to the construction of safety-critical SW components. To implement the toolchain subtended by the overall approach into a Model Driven Development (MDD) framework, we complement the theory of state space analysis with methods and techniques supporting semiformal specification and automated compilation into pTPN models and real-time code, measurement-based Execution Time estimation, test case selection and execution, coverage evaluation.	compiler;dbm;model-driven engineering;petri net;preemption (computing);real-time clock;scheduling (computing);shattered world;state space;test case;toolchain;v-model	Laura Carnevali;Lorenzo Ridi;Enrico Vicario	2011	IEEE Transactions on Software Engineering	10.1109/TSE.2011.4	reliability engineering;embedded system;real-time computing;computer science;operating system;petri net	SE	-43.62735088079345	32.71852633679279	166219
25f82fc443168015efa5329c68c8526e96d54767	modeling and verification of safety-critical systems using safecharts	consumidor;systeme temps reel;modelizacion;distributed system;avionics;verificacion modelo;science and technology;systeme reparti;formal specification;aplicacion medical;securite;consommateur;pervasive computing;systeme critique;theorie contrainte;metodo formal;methode formelle;safety systems;verification modele;semantics;model based approach;automate temporise;consumer electronics;riesgo accidente;program verification;semantica;semantique;test conformite;sistema reactivo;formal method;automata contemporizado;risque accidentel;specification formelle;exclusion mutual;mutual exclusion;informatica difusa;synchronisation;modelisation;especificacion formal;software architecture;verificacion programa;formal verification;sistema repartido;critical system;model checking;informatique diffuse;consumer;synchronization;safety;prueba conformidad;safety critical system;reactive system;avionica;constraint theory;systeme reactif;systeme securite;architecture basee modele;verification formelle;real time system;medical application;timed automata;sistema tiempo real;sincronizacion;exclusion mutuelle;verification programme;seguridad;modeling;hazard;model driven architecture;compliance test;architecture logiciel;arquitectura basada modelo;application medicale;avionique	With rapid development in science and technology, we now see the ubiquitous use of different types of safety-critical systems in our daily lives such as in avionics, consumer electronics, and medical systems. In such systems, unintentional design faults might result in injury or even death to human beings. To make sure that safety-critical systems are really safe, there is need to verify them formally. However, the verification of such systems is getting more and more difficult, because the designs are becoming very complex. To cope with high design complexity, currently model-driven architecture design is becoming a well-accepted trend. However, conventional methods of code testing and standards conformance do not fit very well with such model-based approaches. To bridge this gap, we propose a model-based formal verification technique for safety-critical systems. In this work, the model checking paradigm is applied to the Safecharts model which was used for modeling, but not yet used for verification. Our contributions are five folds. Firstly, the safety constraints in Safecharts are mapped to semantic equivalents in timed automata for verification. Secondly, the theory for safety constraint verification is proved and implemented in a compositional model checker (SGM). Thirdly, prioritized transitions are implemented in SGM to model the risk semantics in Safecharts. Fourthly, it is shown how the original Safecharts lacked synchronization semantics which could lead to safety hazards. A solution to this issue is also proposed. Finally, it is shown that prioritybased approach to mutual exclusion of resource usage in the original Safecharts is unsafe and corresponding solutions are proposed here. Application examples show the feasibility and benefits of the proposed model-driven verification of safety-critical systems.	automata theory;avionics;conformance testing;critical system;formal methods;formal verification;model checking;model-driven architecture;mutual exclusion;pervasive informatics;programming paradigm;second generation multiplex;timed automaton	Pao-Ann Hsiung;Yen-Hung Lin	2005		10.1007/11562436_22	avionics;embedded system;synchronization;simulation;formal methods;computer science;semantics;programming language;algorithm	SE	-43.047863819046555	32.35578187990286	166231
c70c500d034097167d5b3b0609d372a42a2d188e	two-stage adaptation for dependable service-oriented system	distributed application;component services;self healing system dependable service oriented system distributed applications business processes component services quality of service self adaptive soa system service oriented architecture proactive adaptation reactive adaptation apache servicemix system self protecting system;service orientation;self adaptive soa system;soa;proactive adaptation;reactive adaptation;distributed applications;dependable service oriented system;software architecture;dependable systems;fault tolerant computing;adaptation model;engines;execution environment;self protecting system;web services;apache servicemix;ieee press;web services fault tolerant computing software architecture;self healing system;apache servicemix soa dependable system proactive adaptation reactive adaptation;dependable system;communities;service oriented architecture prototypes web services educational institutions information science buildings application software availability semiconductor optical amplifiers monitoring;quality of service;service oriented architecture;apache servicemix system;requirement specification;business process;business processes	The development of Service-Oriented Systems has gained a considerable momentum as a means for building distributed applications and business processes. It emphasizes the loosely coupled construction of services from independent providers over the network. As a consequence, the dependability of such systems strongly depends on their ability to self-adapt to changes in its execution environment, such as unreachable component services, or changed delivered QoS. In this paper, we propose a two-stage approach to realize a self-adaptive SOA system, aimed at the fulfillment of dependability requirements. Specifically, we divide the adaptation process into two stages, proactive adaptation and reactive adaptation, to implement self-protecting and self-healing respectively, and provide a methodology driving the system adaptation. To bring this approach to fruition, a prototype system A-ServiceMix is developed by extending Apache ServiceMix.	apache servicemix;business process;ccir system a;dependability;distributed computing;heuristic;loose coupling;prototype;requirement;service-oriented architecture;service-oriented device architecture;unreachable memory	Jun Na;Bin Zhang;Xiangyu Zhang;Zhiliang Zhu;Dancheng Li	2010	2010 International Conference on Service Sciences	10.1109/ICSS.2010.21	real-time computing;systems engineering;engineering;distributed computing	SE	-43.22886269389533	41.095335245691814	166333
091929b5a96caf9543e0505d6c55054e58988a0b	systems-theoretic safety assessment of robotic telesurgical systems	robotic surgery;stpa;fda maude database;telerobotics;fault injection;article;system safety;stamp;hazard analysis	Robotic surgical systems are among the most complex medical cyberphysical systems on the market. Despite significant improvements in design of those systems through the years, there have been ongoing occurrences of safety incidents that negatively impact patients during procedures. This paper presents an approach for systems-theoretic safety assessment of robotic telesurgical systems using software-implemented fault-injection. We used a systems-theoretic hazard analysis technique (STPA) to identify the potential safety hazard scenarios and their contributing causes in RAVEN II, an open-source telerobotic surgical platform. We integrated the robot control software with a software-implemented fault-injection engine that measures the resilience of system to the identified hazard scenarios by automatically inserting faults into different parts of the software. Representative hazard scenarios from real robotic surgery incidents reported to the U.S. Food and Drug Administration (FDA) MAUDE database were used to demonstrate the feasibility of the proposed approach for safety-based design of robotic telesurgical systems.	biorobotics;causal filter;causality;emulator;fault injection;hazard analysis;open-source software;robot control;sensor;simulation;software propagation;system safety;telerobotics;theory	Homa Alemzadeh;Daniel Chen;Andrew Lewis;Zbigniew T. Kalbarczyk;Ravishankar K. Iyer	2015		10.1007/978-3-319-24255-2_16	telerobotics;reliability engineering;simulation;robotic surgery;engineering;hazard analysis;system safety;computer security	Robotics	-46.41643874297481	35.471332456371385	166392
948532d6fea7621928ddec5b2b3935a986ae86a8	a lightweight process engine for enabling advanced mobile applications		The widespread dissemination of smart mobile devices offers new perspectives for timely data collection in large-scale scenarios. However, realizing sophisticated mobile data collection applications raises various technical issues like the support of different mobile operating systems and their platform-specific features. Often, specifically tailored mobile applications are implemented in order to meet particular requirements. In this context, changes of the data collection procedure become costly and profound programming skills are needed to adapt the respective mobile application accordingly. To remedy this drawback, we developed a model-driven approach, enabling end-users to create mobile data collection applications themselves. Basis to this approach are elements for flexibly defining sophisticated questionnaires, called instruments, which not only contain information about the data to be collected, but also on how the instrument shall be processed on different mobile operating systems. For the latter purpose, we provide an advanced mobile (kernel) service that is capable of processing the logic of sophisticated instruments on various platforms. The paper discusses fundamental requirements for such a kernel and introduces a generic architecture. The feasibility of this architecture is demonstrated through a prototypical implementation. Altogether, the mobile service allows for the effective use of smart mobile devices in a multitude of different data collection application scenarios (e.g., clinical and psychological trials).	algorithm;complex event processing;domain-specific language;executable;light-weight process;microsoft outlook for mac;mobile app;mobile device;mobile operating system;model-driven architecture;platform-specific model;requirement;run time (program lifecycle phase);sensor;smart device;subject-matter expert;user experience;user interface	Johannes Schobel;Rüdiger Pryss;Marc Schickler;Manfred Reichert	2016		10.1007/978-3-319-48472-3_33	embedded system;simulation;engineering;data mining;mobile business development;mobile computing	Mobile	-42.55222652420715	46.329469483312245	166595
4d538398dbb69eb13d061fe55e67efec03460d23	context awareness for group interaction support	context aware application;context awareness;context aware;contextual information;location sensing;support group;distributed computing environment;sensor fusion;group interaction	In this paper, we present an implemented system for supporting group interaction in mobile distributed computing environments. First, an introduction to context computing and a motivation for using contextual information to facilitate group interaction is given. We then present the architecture of our system, which consists of two parts: a subsystem for location sensing that acquires information about the location of users as well as spatial proximities between them, and one for the actual context-aware application, which provides services for group interaction.	algorithm;context awareness;distributed computing;instant messaging;sensor	Alois Ferscha;Clemens Holzmann;Stefan Oppl	2004		10.1145/1023783.1023801	computer science;knowledge management;spatial contextual awareness;sensor fusion;context model;world wide web;distributed computing environment	HCI	-40.346447707474745	45.179514045186224	166615
dba86fbdfc8e9579e70982d7b1b76166247d4256	hw resource componentizing for smooth migration from single-function ecu to multi-function ecu	hw resource componentizing;automotive software;paradigm shift;software component;multi function ecu;electronic control unit;physical properties	"""The automotive design paradigm is shifting from the """"one-function on one ECU (Electronic Control Unit)"""" paradigm toward the """"multi-function on one ECU"""" paradigm to reduce the ever increasing number of ECUs in a vehicle. In order to support such paradigm shift, this paper proposes a HW (hardware) resource componentizing technique that provides the illusion of a physically isolated ECU component for each automotive SW (software) component even when a multi-function ECU is actually shared by multiple concurrent SW components. With this technique, each SW component's physical properties such as timing behavior can be invariant with its surrounding SW components and hence the automaker can easily compose and verify a complex future automotive system. In order to effectively realize this HW resource componentizing, we propose an""""active window based share provisioning"""" that provides a HW share to a SW component only when it is active. This way, the ECU capacity can be divided not only in the spatial (i.e., share) domain but also in the temporal domain, providing a large number of fine-granular HW components for serving a large number of SW components. The effectiveness of the proposed HW com-ponentizing technique is validated through both simulation and actual implementation with real automotive workload."""	active window;component-based software engineering;electronic control unit;engine control unit;programming paradigm;provisioning;shattered world;simulation	Jong-Chan Kim;Kyoung-Soo We;Chang-Gun Lee;Kwei-Jay Lin;Yun Sang Lee	2012		10.1145/2245276.2232072	paradigm shift;embedded system;electronic control unit;real-time computing;computer science;component-based software engineering;operating system;programming language;physical property	Arch	-39.219375115576554	37.7145933480535	167101
46dd357994deefb2838ac29f8c648cf281cb2f0e	modeling adaptive streaming applications with parameterized polyhedral process networks	verification;analytical models;design time analyzability;ppn;performance evaluation;computer model;adaptive embedded systems;operational semantics;model adaptation;process network;semantics;adaptive dynamics;run time reconfiguration;kahn process network model;embedded system;integrated circuit design;computational modeling;multiprocessor systems on chip designs;run time reconfigurable;system on chip;parameterized polyhedral process networks;map streaming;process control;time use;verification model of computation adaptive embedded systems;multiprocessor system on chip;timing analysis;adaptation models computational modeling process control semantics analytical models electronics packaging ip networks;ip networks;multiprocessing systems;system on chip field programmable gate arrays integrated circuit design multiprocessing systems;model of computation;kahn process network;p 3 n model;field programmable gate arrays;run time reconfiguration adaptive streaming parameterized polyhedral process networks kahn process network model model of computation map streaming multiprocessor systems on chip designs ppn p 3 n model design time analyzability design time analysis fpga based mpsoc platform;electronics packaging;adaptation models;adaptive streaming;analytical model;verification model;fpga based mpsoc platform;design time analysis	The Kahn Process Network (KPN) model is a widely used model-of-computation to specify and map streaming applications onto multiprocessor systems-on-chips. In general, KPNs are difficult to analyze at design-time. Thus a special case of the KPN model, called Polyhedral Process Networks (PPN), has been proposed to address the analyzability issue. However, the PPN model is not able to capture adaptive/dynamic behavior. Such behavior is usually expressed by using parameters which values are reconfigured at run-time. To model the adaptive/dynamic applications, in this paper we introduce an extension of the PPN model, called Parameterized Polyhedral Process Networks (P3N), which still provides design-time analyzability to some extent. We first formally define the P3N model and its operational semantics. In addition, we devise a design-time analysis to extract relations between parameters. Based on the analysis, we propose an approach to ensure that consistent execution of the P3N model is preserved at run-time. Using an FPGA-based MPSoC platform, we present a performance evaluation of the possible overhead caused by the run-time reconfiguration.	field-programmable gate array;kahn process networks;mpsoc;model of computation;multiprocessing;operational semantics;overhead (computing);performance evaluation;polyhedral;run time (program lifecycle phase);system on a chip	Jiali Teddy Zhai;Hristo Nikolov;Todor Stefanov	2011	2011 48th ACM/EDAC/IEEE Design Automation Conference (DAC)	10.1145/2024724.2024752	model of computation;system on a chip;embedded system;electronic engineering;parallel computing;real-time computing;verification;computer science;operating system;process control;semantics;electronic packaging;operational semantics;computational model;static timing analysis;field-programmable gate array;integrated circuit design	EDA	-38.7428240414844	33.12550314983133	167133
cf27d7f530add8edf337c32c89ab0f29e1705188	cloud transition: integrating cloud calls into workflow petri nets		Extended Abstract In this paper, we present the Cloud Workflow Transition. An extension of Petri nets formalisms to adopt Cloud interactions. This allows workflows to request compute or storage services from the cloud. Such refinements permit to codify operational procedures into Petri net models and reduce user implication during the specification of their workflows. The main purpose behind our proposed refinements is to allow users to automatically execute workflows on distributed infrastructures (Cloud, SOA, grid, cluster). Through the Cloud transition users can specify their requests formulated as tasks and parameters (see Figure 1). These requests will be treated in a transparent way i.e. that technical information is hidden from the user. The WFMS will then either accept the request and make the connection to the specified Cloud services according to user inputs or will reject it. The input places of the Cloud transition model the preconditions of an event, the input data for the computational task. The output places of the transition model the post-conditions associated with an event, the results of the computational task. Our approach uses workflow Petri nets [1]. More specifically we use the reference net formalism [2] extended with a specialized workflow task transition [3]. Renew, the Reference Net Workshop, is our chosen tool for modeling with reference nets. A very interesting and useful property of reference nets in Renew is their use of the so-called shadow layer. It hides the technical details from the user, who can concentrate on simply the nets. The technical integration of the Cloud transition into our workflow nets and workflow managment system is carried out in three main steps: The integration into the existing workflow net formalism for Renew [3], the integration into the current WFMS in Renew [4] and finally the integration into the user interface. Due to the dynamic aspect of the cloud computing, further integration issues are investigated such as including Quality-of-Service (QoS) requirements (time and expenditure limit). The WFMS should be able to identify and handle failures and support reliable execution in the presence of concurrency to guarantee a high level of performance and availability of services.	box counting;cloud computing;computation;computer cluster;concurrency (computer science);high-level programming language;interaction;petri net;precondition;quality of service;reference architecture;requirement;semantics (computer science);service-oriented architecture;user interface	Sofiane Bendoukha;Thomas Wagner	2012			workflow management system;database;cloud computing;simulation;process architecture;petri net;workflow;computer science	HPC	-38.20790417381796	37.11314191256773	167562
4c02e6f774985d2e5a054e331cacbe0dcd2dab36	extending stil 1450 standard for test program flow	test program flow description;design-to-test automation tool;extending stil;program component;ate platforms;automatic test pattern generation;test program;stil 1450 standard;automatic test equipment;stil standard;full program generation;time to market;design to test automation tools;ieee standards;greater automation;ieee p1450.4;design for testability;test program flow extension;greater reuse;ieee p1450;program generation;semiconductor industry;portability;new product introduction	The IEEE P1450.4 test program flow extension to the STIL standard provides a test program flow description that allow full program generation by design-to-test automation tools, the portability and interchange of test programs between different ATE platforms, and enable greater reuse of program components. With the recent adoption of IEEE 1450 STIL and its extensions, the test program flow extension provide the semiconductor industry the means to greater automation and decrease the time-to-market aspects of new product introductions.	control flow;converge;formal specification;operating system;semiconductor industry;software portability;tom;test automation;test case;eric	David Dowding;Ernie Wahl;Don Organ	2004	2004 International Conferce on Test	10.1109/ITC.2004.74	reliability engineering;embedded system;automatic test equipment;electronic engineering;computer science;engineering;automatic test pattern generation;software engineering;design for testing;test management approach;new product development;computer engineering;test harness	SE	-36.194273828210214	34.39783046272485	167609
e98f69b4ed240aa24e861b090c69c165c83b165a	stream my models: reactive peer-to-peer distributed models@run.time	peer to peer models run time distributed models reactive programming asynchronous programming;asynchronous programming;biological system modeling;object oriented modeling peer to peer computing runtime load modeling programming biological system modeling data models;runtime;distributed models;models run time;peer to peer computing;peer to peer;load modeling;programming;object oriented modeling;reactive programming;data models	The models@run.time paradigm promotes the use of models during the execution of cyber-physical systems to represent their context and to reason about their runtime behaviour. However, current modeling techniques do not allow to cope at the same time with the large-scale, distributed, and constantly changing nature of these systems. In this paper, we introduce a distributed models@run.time approach, combining ideas from reactive programming, peer-to-peer distribution, and large-scale models@run.time. We define distributed models as observable streams of chunks that are exchanged between nodes in a peer-to-peer manner. A lazy loading strategy allows to transparently access the complete virtual model from every node, although chunks are actually distributed across nodes. Observers and automatic reloading of chunks enable a reactive programming style. We integrated our approach into the Kevoree Modeling Framework and demonstrate that it enables frequently changing, reactive distributed models that can scale to millions of elements and several thousand nodes.	3d modeling;application programming interface;client–server model;complex systems;cyber-physical system;java;javascript;kevoree;lazy evaluation;lazy loading;metamodeling;observable;peer-to-peer;programming paradigm;programming style;reactive programming;self-replicating machine;server (computing);service-oriented architecture	Thomas Hartmann;Assaad Moawad;François Fouquet;Grégory Nain;Jacques Klein;Yves Le Traon	2015	2015 ACM/IEEE 18th International Conference on Model Driven Engineering Languages and Systems (MODELS)	10.1109/MODELS.2015.7338238	data modeling;programming;real-time computing;reactive programming;functional reactive programming;computer science;theoretical computer science;distributed computing;programming language;management	HPC	-38.96494354930182	38.764600253721525	167732
c4d0b6b19eb6403e8083e9bec64fd1395e3cdea2	an adaptive replanning mechanism for dependable service-based systems	empirical study;service selection;heuristic algorithms adaptation model quality of service optimization approximation algorithms computational efficiency measurement;planning artificial intelligence;replanning mechanism;search scope determination;service reselection dependable service based system adaptation replanning mechanism replanning trigger search scope determination;adaptation;dependable service based system;web services;cost effectiveness;replanning trigger;replanning service bindings adaptive replanning mechanism dependable service based systems cost effective replanning methods;service oriented architecture;web services planning artificial intelligence service oriented architecture;service reselection	A promising way to guarantee dependability of service-based systems (SBSs) is replanning service bindings dynamically with the environment changing. As embedded into system execution, such replanning process will directly affect the overall performance of SBSs. While various replanning techniques have been proposed up to now, it is still challenging that how to provide cost-effective replanning methods for high-quality SBSs. In this paper, we propose a practical solution by improving the flexibility of replanning and establish an adaptive replanning mechanism for that. This new mechanism places more emphasis on the cause-effect relationship among system execution states, solution space changes, replanning strategies and their potential effects in system adaptation, and focuses on improving the following three leading aspects, i.e. replanning trigger, search scope determination and service selection, which affect the actual cost and effect of replanning. The main idea and key algorithms for implementing this adaptive replanning mechanism are presented. Besides this, empirical study based on a load rate querying service is used to illustrate and evaluate our approach.	adaptive grammar;algorithm;dependability;embedded system;feasible region	Jun Na;Guo-hong Li;Bin Zhang;Xiang Lin;Zhiliang Zhu	2010	2010 IEEE 7th International Conference on E-Business Engineering	10.1109/ICEBE.2010.68	web service;real-time computing;simulation;cost-effectiveness analysis;service-oriented architecture;empirical research;law;adaptation	SE	-47.27934109862381	40.47528119065859	167850
0860db5a27aec9bef6a8fb52e28ff50211814b63	java business integration	lenguaje programacion;java business integration;web services java business integration java specification request java 2 platform j2se j2ee;programming language;java programming;langage java;web service;enterprise integration;java computer languages protocols service oriented architecture web services impedance world wide web relational databases data security programming profession;distributed programming;langage programmation;lenguaje java;distributed programming java;java language;java	F or as long as I can remember, an argument has been making the rounds in distributed computing circles about how best to define interfaces for distributed elements. Some advocate the use of an interface definition language (IDL), whereas others prefer to use programming languages directly. (There are even those who prefer to avoid explicitly defining interfaces altogether, but I’ll ignore that position for now.) Not surprisingly, the Java community has traditionally sided with the programming language approach — arguing, in part, that IDLs are too far removed from the languages that developers use for implementation, and that the resulting mismatch often makes it difficult to map between the two. In practice, this means that either the IDL forces the developer to use an unnatural programming style, or the interface developer is stuck defining cumbersome interfaces to match the programming language. One of the most blatant examples I’ve personally experienced of this impedance mismatch is the Corba Java-to-IDL reverse mapping,1 which is intended to let developers define Corba interfaces in pure Java and map the results into Corba IDL. Although the approach produces reasonable results for systems defined entirely in Java, the resulting IDL is strange and overly complex, creating further complications if it must subsequently be mapped to a language other than Java. The desire to avoid such mismatches has led, in part, to the development of various approaches centered on “plain ol’ Java objects” (POJOs). One such example is the Hibernate framework (www. hibernate.org), which provides developers with transparent support for storing Java objects in relational databases. Rather than relying on detailed component interfaces or complex object hierarchies characteristic of older frameworks, the POJO approach lets developers focus on producing normal Java code, while relying on tools and reflective infrastructure to transparently adapt that code for persistence, security, transactions, and other orthogonal qualities and capabilities. The POJO approach works well if you’re a Java programmer developing a pure Java system, but what happens when such purity isn’t possible? The world of enterprise integration is often an “impure” place in which heterogeneous networks include everything from mainframes to blades running an amalgam of operating systems and applications. Given that Java is unlikely to be the only language in use in such settings, there’s a clear need to step above individual programming languages and define services at a more abstract level that applies equally to various scripting, transformation, and programming languages.	characteristic impedance;common object request broker architecture;distributed computing;distributed element model;enterprise integration;interface description language;java business integration;mainframe computer;operating system;persistence (computer science);programmer;programming language;programming style;pure function;relational database;world wide web	Steve Vinoski	2005	IEEE Internet Computing	10.1109/MIC.2005.86	java data objects;web service;java card;java api for xml-based rpc;plug-in;jsr 94;java concurrency;application programming interface;jar;computer science;operating system;java modeling language;interface;strictfp;database;distributed computing;real time java;enterprise integration;programming language;java;war;world wide web;generics in java;scala;java applet;java annotation;non-blocking i/o	PL	-33.89117972630025	41.81298042209137	167994
9e68409e35c95856861a930aac612573fb4d9db6	a uniform software architecture for cooperation, reliability and reconfiguration of autonomous decentralized systems	reconfiguration;reliability;long period;uniform software architecture;concurrent computing;failure;dynamic reconfiguration;application software;job shop scheduling;reconfigurable architectures;cooperation;distributed processing;software architecture manufacturing;general techniques;software engineering;computer networks;decentralized system;software architecture;software reliability distributed processing reconfigurable architectures computer integrated manufacturing software engineering finite state machines;finite state machines;manufacturing processes;computer aided manufacturing;manufacturing;minimal disruption;finite state machines uniform software architecture cooperation reliability reconfiguration autonomous decentralized systems autonomous components minimal disruption failure application dependent policies manufacturing;software design;software reliability;computer integrated manufacturing;robotics and automation;autonomous components;autonomous decentralized systems;application dependent policies;robot kinematics	Large and complex decentralized systems with au tonomous components often require appropriate mech anisms for cooperation reliability and dynamic recon guration It is crucial that these mechanisms allow the system to execute continuously for a long period of time with minimal disruption despite failure or recon guration of some components They should also allow various components to interact in complex ways We develop a uniform software architecture for implement ing these mechanisms using generalized techniques and common functionalities These mechanisms also sup port a variety of application dependent policies	autonomous decentralized system;denial-of-service attack;registry recon;software architecture	Alvin S. Lim	1995		10.1109/ISADS.1995.398952	job shop scheduling;software architecture;application software;real-time computing;concurrent computing;decentralised system;computer science;software design;control reconfiguration;reliability;distributed computing;computer-integrated manufacturing;manufacturing;cooperation;robot kinematics;software quality	SE	-36.30239492967013	38.7472089273305	168136
da66843375f1c0a89cebf7587422dbcc03a33cc4	model-based high availability configuration framework for cloud	high availability;model driven approach;runtime software architecture;cloud computing;dynamic configuration	Since cloud computing has emerged as a commercial reality, guaranteeing high availability (HA) has become a critical requirement. Many kinds of HA mechanisms have been developed with the rapid expansion of cloud computing. However, selection and configuration are difficult in practice. In the development phase, developers must choose HA mechanisms for cloud computing based on their experience. In the use phase, users must choose and configure the HA mechanisms for their virtual machines (VMs) or services deployed on VMs. In this paper, we proposed a model-based HA configuration framework for the cloud. For the developer, we proposed an open HA mechanism library and an automatic configuration process. For users, we intend to ease the selection of HA mechanisms in the ever-changing cloud environment. We are implementing our approach in our model-based cloud platform, JadeCloud.	cloud computing;high availability;virtual machine	Yihan Wu;Gang Huang	2013		10.1145/2541534.2541595	real-time computing;simulation;cloud computing;engineering;distributed computing	HPC	-44.86466041655769	41.43871814470984	168167
d6ce1be04b6f810ef02a27e551803facf258bd1a	maximizing concurrency and analyzable timing behavior in component-oriented real-time distributed computing application systems	real time;distributed computing	Demands have been growing in safety-critical application fields for producing networked real-time embedded computing (NREC) systems together with acceptable assurances of tight service time bounds (STBs). Here a service time can be defined as the amount of time that the NREC system could take in accepting a request, executing an appropriate service method, and returning a valid result. Enabling systematic composition of large-scale NREC systems with STB certifications has been recognized as a highly desirable goal by the research community for many years. An appealing approach for pursuing such a goal is to establish a hard-real-time (HRT) component model that contains its own STB as an integral part. The TMO (Time-Triggered Message-Triggered Object) programming scheme is one HRT distributed computing (DC) component model established by the first co-author and his collaborators over the past 15 years. The TMO programming scheme has been intended to be an advanced high-level RT DC programming scheme that enables development of NREC systems and validation of tight STBs of such systems with efforts far smaller than those required when any existing lower-level RT DC programming scheme is used. An additional goal is to enable maximum exploitation of concurrency without damaging any major structuring and execution approaches adopted for meeting the first two goals. A number of previously untried program structuring approaches and execution rules were adopted from the early development stage of the TMO scheme. This paper presents new concrete justifications for those approaches and rules, and also discusses new extensions of the TMO scheme intended to enable further exploitation of concurrency in NREC system design and programming.	bricx command center;component-based software engineering;computation;concurrency (computer science);denotational semantics;distributed computing;embedded system;floor and ceiling functions;high- and low-level;national robotics engineering center;non-blocking algorithm;real-time clock;real-time computing;real-time transcription;run time (program lifecycle phase);scheduling (computing);set-top box;software release life cycle;systems design	K. H. Kim;Juan A. Colmenares	2007	JCSE		real-time computing;simulation;computer science;distributed computing	Embedded	-39.09701598794929	35.98940510357919	168188
8f389cdd6de400356b86b7f60c4bd0625da51a6c	gateway as a service: a cloud computing framework for web of things	application development;iaas;service composition;aging;web service;engines;logic gates;gallium arsenide;business;web services;paas;business process management;it systems gateway as a service cloud computing framework web of things concept heterogeneous devices restful web services business process;simple object access protocol;web services cloud computing;logic gate;use case;logic gates business gallium arsenide aging engines simple object access protocol;saas cloud computing web of things service composition business process management iaas paas;business process;cloud computing;web of things;saas	The Web of Things concept has been proposed to integrate heterogeneous devices and provide a light-weight and easy-to-use way for application development by leveraging RESTful web services. However, Web of Things still does not address the issue of composition of physical resources, especially of how business process could be managed among different organizations to automate process of activities. On the other hand, cloud computing framework is based on web services technologies which focus on reusing and composing legacy resources to facilitate developing and managing IT systems. In this paper we have proposed the concept of Gateway as a Service which is a cloud computing framework for Web of Things. Within the proposed concept we introduce the technical architecture of three-layered stack based on study of an aging care use case. Implementations based on the aging care use case are also discussed and results are analyzed to illustrate the feasibility and reasonability of the proposed concept.	business process;cloud computing security;information technology architecture;management system;representational state transfer;service composability principle;web of things;web service;workflow engine;world wide web	Zhenyu Wu;Timo Itälä;Tingan Tang;Chunhong Zhang;Yang Ji;Matti Hämäläinen;Yunjie Liu	2012	2012 19th International Conference on Telecommunications (ICT)	10.1109/ICTEL.2012.6221246	web service;web development;web modeling;web of things;logic gate;web standards;computer science;service-oriented architecture;database;distributed computing;web 2.0;world wide web;computer network	SE	-42.833504688160275	45.392703916031536	168467
7e3718bcc41964265b9087b1d53257c91fbe587b	placement of replicated message mediation components	directed acyclic graph;distributed networks;message oriented middleware;middleware	In this paper, we propose a technique for placing components of mediation flows within a Message-Oriented Middleware where components can be replicated. A mediation flow is a directed acyclic graph of message transformations (also known as mediations) connecting sources and sinks of messages. The source nodes correspond to producers, who enter messages into the middleware; the sink nodes correspond to consumers, who receive results derived from the input messages. All other nodes in the graph represent transformations of messages in the middleware. A placement is an assignment of nodes of the mediation flow graph to physical machines (brokers) in a distributed network.	algorithm;directed acyclic graph;end-to-end principle;experiment;message-oriented middleware;stateless protocol	Ying Li;Robert E. Strom;Chitra Dorai	2007		10.1145/1377943.1377946	real-time computing;computer science;message oriented middleware;database;distributed computing;message broker	HPC	-35.18886047510842	45.03623670100909	168470
ef82cd793dfcbda717437877dbf9aea89cdc3de7	advances in conceptual modeling	conpetual modelling;variability er;secogis;fp uml;wism;computer science;onto com	Improved sensing technologies and cheap sensor devices facilitate the creation of Ambient Assisted Living (AAL) environments. Whereas the increasing manifoldness of sensing possibilities helps to gain detailed and precise information about the environment, the task of dynamically mapping data from different sensor sources to a processable data model becomes more and more complex. Especially in AAL environments which build upon different sensors and sensor networks, the integration of distinct data sources becomes an issue. Most systems cope with this issue by requiring hand written adapters which encapsulate the device communication as well as the data mapping logic. Within this paper we tackle the problem of mapping perceived sensor data to a formal (ontology-based) model with a semi-automated approach. We split up the mapping in two separate parts: (i) a protocol specific adapter which encapsulates the communication with the sensor device and (ii) a mapping description. The mapping description is specific for each sensor type and defines how the sensed data is mapped to the data model. In addition the mapping description can be used to enrich the data model with additional information, like time and space.	atm adaptation layer;data model;formal ontology;integrated development environment;semiconductor industry;sensor	Gerhard Goos;Juris Hartmanis;Jan van Leeuwen;David Hutchison;Silvana Castano;Panos Vassiliadis;Laks V. S. Lakshmanan;Mong Li;Lee Eds	2012		10.1007/978-3-642-33999-8	computer science;systems engineering;theoretical computer science	Robotics	-42.62755351236188	45.095968081149515	168564
3271daac4869528b4e0ce165bdf0af1d771261ea	extending driving simulator capabilities toward hardware-in-the-loop testbeds and remote vehicle interfaces	software metrics;program diagnostics;formal specification;vehicles software vehicle dynamics testing cameras hardware roads;software performance evaluation;tele op hardware in the loop driving simulator robot operating system gazebo;public domain software;driving simulator capabilities robot operating system inter hardware delays system latency metrics system performance open source hil centric driving simulator driving simulator software analysis gazebo ros remote vehicle interfaces hardware in the loop testbeds;traffic engineering computing digital simulation formal specification program diagnostics public domain software;traffic engineering computing digital simulation operating systems computers public domain software software metrics software performance evaluation;traffic engineering computing;operating systems computers;interhardware delay minimization driving simulator capability hardware in the loop testbed remote vehicle interfaces hil driving simulator ros gazebo driving simulator software hil simulator requirements open source hil centric driving simulator system performance system latency;digital simulation	This paper describes the development of a Hardware-in-the-Loop (HIL) driving simulator designed with ROS and Gazebo. An analysis of current driving simulator software is conducted focusing on the requirements for HIL simulators versus traditional simulator implementations. Finally, the process for implementing an open-source HIL-centric driving simulator is documented, along with an analysis of system performance emphasizing metrics of system latency and strategies to minimize inter-hardware delays.	central processing unit;computer;driving simulator;hil bus;hardware-in-the-loop simulation;interconnection;map;open-source software;radar;requirement;robot operating system;scene graph;testbed	Kevin S. Swanson;Alexander A. Brown;Sean N. Brennan;Cynthia M. LaJambe	2013	2013 IEEE Intelligent Vehicles Symposium (IV)	10.1109/IVS.2013.6629458	embedded system;computer architecture simulator;simulation;engineering;power system simulator for engineering;computer engineering	Embedded	-37.64978876828072	34.703526861673886	168611
f53f990a22967b3eb6c9e9cde81d50a63b6a46d5	exploiting learning and scenario-based specification languages for the verification and validation of highly automated driving		We propose a series of methods based on learning key structural properties from traffic data-basis and on statistical model checking, ultimately leading to the construction of a scenario catalogue capturing requirements for controlling criticality for highly autonomous vehicles. We sketch underlying mathematical foundations which allow to derive formal confidence levels that vehicles tested by such a scenario catalogue will maintain the required control of criticality in real traffic matching the probability distributions of key parameters of data recorded in the reference data base employed for this process.	autonomous robot;criticality matrix;database;model checking;requirement;statistical model;verification and validation	Werner Damm;Roland Galbas	2018	2018 IEEE/ACM 1st International Workshop on Software Engineering for AI in Autonomous Systems (SEFAIAS)	10.1145/3194085.3194086	probability distribution;formal specification;vehicle dynamics;machine learning;verification and validation;sketch;reference data (financial markets);requirements analysis;statistical model;artificial intelligence;computer science	SE	-45.55320105744382	34.85510641863783	168632
d0d98abe64fb745c51c2f58e29a8792f49be17bf	scan technology at work	scan technology	Our Multiple-Mode USB interface products are optimized for the point-of-sale environment. Whether using our direct connect Multiple-Mode USB devices, or our Multiple-Mode USB Adaptor with any legacy PS/2 keyboard device, your data can be sent as USB Keyboard, Serial, HID, OPOS and other interfaces all in a single unit. The Multiple-Mode capabilities ensure a broad range of compatibility with customer applications.	direct connect (protocol);human interface device;ibm personal system/2;ps/2 port;point of sale;usb	Ben Bennetts	1991		10.1007/978-3-642-76930-6_11	computer engineering;magnetic reluctance;computer science	HCI	-34.5985587953106	39.236195727555696	168780
4b8afb30fd673286ceb164dbb451ea60c58c5190	flexible soa lifecycle on the cloud using sca	integrated approach;semiconductor optical amplifiers;architectural design;electronic mail;semiconductor optical amplifier;monitoring runtime semiconductor optical amplifiers business quality of service electronic mail travel services;runtime;monitoring;cloud computing service oriented architecture sca design monitoring;business;service oriented architecture cloud computing;travel services;design;sca;profitability;quality of service;service oriented architecture;service component architecture flexible soa lifecycle service oriented architecture cloud computing;cloud computing;open source	We present an integrated approach to design, monitor and manage the lifecycle of applications based on the Service Oriented Architecture (SOA) principles and capable of taking advantage of cloud computing environments. The integrated framework takes profit of publicly available open source tools and standards in an effective and coherent way, and covers the steps from business and architectural design of the application, to deployment and runtime support. We exemplify our approach with a walkthrough in a simple yet illustrative scenario.	business process;central processing unit;cloud computing;coherence (physics);cross-cutting concern;exemplification;google cloud messaging;open-source software;oracle soa suite;requirement;run time (program lifecycle phase);service-level agreement;service-oriented architecture;software deployment;software walkthrough	Cristian Ruz;Françoise Baude;Bastien Sauvan;Adrian Mos;Alain Boulze	2011	2011 IEEE 15th International Enterprise Distributed Object Computing Conference Workshops	10.1109/EDOCW.2011.51	embedded system;design;real-time computing;quality of service;cloud computing;computer science;engineering;operating system;database	Visualization	-45.145872864724154	42.05610895430491	168816
9bb96f1ba18f07a5cff89551b0223af194200533	space shuttle onboard software (obs) development and maintenance process automation	maintenance process automation;space shuttle onboard software	Without Abstract	automation;optical burst switching	L. B. Strader;M. K. Aune;J. A. Rodgers;M. A. Beims	1995		10.1007/3-540-59205-9_40	embedded system;real-time computing;engineering;remote sensing	Robotics	-46.54417740553105	36.53614424839171	168823
27455453a96f02bc3181b0f1e6535e6b2bd3bdd0	model-driven performance analysis	mda;quality attributes;bepress selected works;real time;rate monotonic analysis;performance;code generation;software systems;mde;development environment;mda mde model driven performance analysis architecture;model driven engineering;performance analysis;model driven;analysis;architecture	Model-Driven Engineering (MDE) is an approach to develop software systems by creating models and applying automated transformations to them to ultimately generate the implementation for a target platform. Although the main focus of MDE is on the generation of code, it is also necessary to support the analysis of the designs with respect to quality attributes such as performance. To complement the model-toimplementation path of MDE approaches, an MDE tool infrastructure should provide what we call model-driven analysis. This paper describes an approach to model-driven analysis based on reasoning frameworks. In particular, it describes a performance reasoning framework that can transform a design into a model suitable for analysis of real-time performance properties with different evaluation procedures including rate monotonic analysis and simulation. The concepts presented in this paper have been implemented in the PACC Starter Kit, a development environment that supports code generation and analysis from the same	code generation (compiler);java development kit (jdk);list of system quality attributes;model-driven architecture;model-driven engineering;model-driven integration;profiling (computer programming);real-time clock;simulation;software system	Gabriel A. Moreno;Paulo Merson	2008		10.1007/978-3-540-87879-7_9	real-time computing;simulation;performance;computer science;systems engineering;engineering;architecture;software engineering;analysis;development environment;code generation	SE	-43.84530739281466	33.542355446806994	168952
bee828f492d358c3912aaa146f7c4b58d347886d	an integrated microspacecraft avionics architecture using 3d multichip module building blocks	avionics;system reliability;reliability;computer languages;avionics system;programming language;building block;new millennium program;3d multichip module building blocks;module testing;continued miniaturization;software engineering;system buses;special purpose computers;building block elements;multichip module;multichip modules;aerospace computing;operating system;aerospace electronics space vehicles multichip modules system buses system testing computer languages operating systems programming reliability costs;software development environment;deep space one asteroid flyby mission;aerospace electronics;spacecraft electronics;system testing;aircraft computers;spacecraft avionics system;work in progress;programming;integrated microspacecraft avionics architecture;jet propulsion laboratory integrated microspacecraft avionics architecture 3d multichip module building blocks continued miniaturization spacecraft electronics avionics system building block elements stackable multichip module 3d architecture module testing operating systems software development environments system reliability spacecraft avionics system deep space one asteroid flyby mission;software development environments;stackable multichip module 3d architecture;space vehicles;jet propulsion laboratory;operating systems	In this paper, we describe current results from work in progress on the continued miniaturization of all spacecraft electronics into a single avionics system, using building-block elements. Each element is assumed to be a 'slice' within a stackable multichip module (MCM) 3D-architecture. The proposed architecture is new for the space community, but, is familiar to the commercial world. That is, we have proposed the use of only standard commercial interfaces for both the local (inter-slice) bus, inter-node system bus, and all the other interfaces for module testing and integration. Moreover, only commercially available programming languages, operating systems and software development environments are considered. The goal is to provide high levels of system reliability at a low cost. We plan to achieve this goal by applying hardware redundancy where necessary, and by maintaining a commercially compatible architecture that will achieve reliability through high volume production and mass usage. The first opportunity to validate the proposed spacecraft avionics system will be in July 1998 on-board the Deep-Space One asteroid-flyby mission. This will be the first in a series of high-tech missions within the New Millennium Program managed by the Jet propulsion Laboratory.		Leon Alkalai;Wai-Chi Fang	1996		10.1109/ICCD.1996.563548	avionics;embedded system;electronic engineering;computer science;engineering;operating system;development environment;programming language;computer engineering	Arch	-35.530580123474344	35.14393776875332	169070
f2c4b389919d1fb0170b8a72fe58b638e001d9e7	sharing with a difference: realizing service-based saas applications with runtime sharing and variation in dynamic software product lines	formal specification;software reusability cloud computing economies of scale formal specification product development software architecture;swinburne;multi tenancy;compositional multi tenancy spl saas variability;software architecture;software reusability;compositional;variability;economies of scale;multitenancy support service based saas applications single instance multitenant simt saas application saas provider economies of scale runtime sharing tenant specific variations dynamic software product lines dspl architecture collaboration units feature based high level representation tenants requirements commonality tenants requirements variability runtime creation development effort sharing degree runtime overhead;runtime maintenance engineering software as a service contracts collaboration companies;spl;cloud computing;saas;product development	A single-instance multi-tenant (SIMT) SaaS application enables a SaaS provider to achieve economies of scale through runtime sharing. However, runtime sharing can make tenant-specific variations difficult to achieve in such an application. In this paper, we propose an approach to realizing SIMT SaaS applications, which is based on Dynamic Software Product Lines (DSPL) and supports runtime sharing and variation. With the collaboration among a subset of services as the unit of composition, the commonality among the tenants' requirements is realized in the DSPL architecture by sharing collaboration units, and their variability is realized by composing different collaboration units, all at runtime. In addition, we adopt a feature-based high-level representation of the commonality and variability between the tenants' requirements to facilitate the runtime creation and reconfiguration of their application variants. We compare our approach with two alternative approaches in terms of development effort and degree of sharing. We further quantify the runtime overhead incurred by our multi-tenancy support.	cyclic redundancy check;heart rate variability;high- and low-level;multitenancy;overhead (computing);qualitative comparative analysis;requirement;run time (program lifecycle phase);service-oriented device architecture;single instruction, multiple threads;single-instance storage;software as a service;software product line;the australian	Indika Kumara;Jun Han;Alan W. Colman;Tuan Minh Nguyen;Malinda Kapuruge	2013	2013 IEEE International Conference on Services Computing	10.1109/SCC.2013.30	reliability engineering;real-time computing;systems engineering;engineering	SE	-45.645314853567946	41.8069486317395	169343
2c728c7311d8de75ce3f7ffa8dc3d0ec6057a28a	formalization of reliability block diagrams in higher-order logic	probability theory;reliability block diagrams rbds;virtualization configuration;higher order logic;virtual data centers	Reliability Block Diagrams (RBDs) allow us to model the failure relationships of complex systems and their sub-components and are extensively used for system reliability, availability and maintainability analyses. Traditionally, these RBD-based analyses are done using paper-and-pencil proofs or computer simulations, which cannot ascertain absolute correctness due to their inherent limitations. As a complementary approach, we propose to use the higher-order-logic theorem prover HOL to conduct RBD-based analysis. For this purpose, we present a higher-order-logic formalization of commonly used RBD configurations, such as series, parallel, parallel-series and series-parallel, and the formal verification of their equivalent mathematical expressions. A distinguishing feature of the proposed RBD formalization is the ability to model nested RBD configurations, which are RBDs having blocks that also represent RBD configurations. This generality allows us to formally analyze the reliability of many real-world systems. For illustration purposes, we formally analyze the reliability of a generic Virtual Data Center (VDC) in a cloud computing infrastructure exhibiting the nested series-parallel RBD configuration.	automated theorem proving;cloud computing;complex systems;computer simulation;correctness (computer science);data center;diagram;formal verification;graphical user interface;hol (proof assistant);mit engineering systems division;pipeline (computing);reliability engineering;series-parallel graph;world-system	Waqar Ahmad;Osman Hasan;Sofiène Tahar	2016	J. Applied Logic	10.1016/j.jal.2016.05.007	probability theory;higher-order logic;computer science;theoretical computer science;reliability block diagram;programming language;algorithm;statistics	PL	-42.33746834029735	33.30329769055942	169344
b28f89cf4217b54d71183e16aa5b99bcd322f9f2	a graphical model-level debugger for heterogenous reconfigurable architectures	matlab stateflow models;software tool;graphical model level debugger;simulation languages reconfigurable architectures rendering computer graphics;dynamically reconfigurable slot based fpga runtime environment graphical model level debugger heterogenous reconfigurable architectures graphical modeling languages mixed hardware software systems high abstraction level model based development process matlab stateflow models eclipse based software tool;dynamic reconfiguration;reconfigurable architectures;software systems;heterogenous reconfigurable architectures;eclipse based software tool;dynamically reconfigurable slot based fpga runtime environment;reconfigurable architecture;high abstraction level;model based development;graphical model;simulation languages;graphical modeling languages;reconfigurable architectures mathematical model debugging field programmable gate arrays unified modeling language context modeling runtime power system modeling graphical models computational modeling;rendering computer graphics;mixed hardware software systems;model based development process;software implementation	Graphical modeling languages allow to specify structure and behavior of mixed hardware-and software-systems on high abstraction level and can be automatically rendered into deployable implementations. In this paper we extend a model-based development process by means to debug functionality specified using Matlab Stateflow models in its hardware-and software-implementation on the target system. The user can control and view the system state graphically from the model's level. We introduce an Eclipse based software-tool based on our approach and apply it to a dynamically reconfigurable slot-based FPGA runtime environment.	abstraction layer;debugger;eclipse;field-programmable gate array;graphical model;graphical user interface;matlab;model-driven engineering;modeling language;reconfigurability;runtime system;stateflow	Philipp Graf;Michael Hübner;Klaus D. Müller-Glaser;Jürgen Becker	2007	2007 International Conference on Field Programmable Logic and Applications	10.1109/FPL.2007.4380754	embedded system;computer architecture;parallel computing;real-time computing;computer science;operating system;graphical model;model-based design;software system	EDA	-41.10886677847142	32.62837733758357	169502
7cfee5caabcfc6d9f1aac48e445d411ff6c5bedf	separation of distributed real-time embedded concerns with theme/uml	system modeling;distributed real time embedded;info eu repo semantics workingpaper;uml;aspect oriented design approach;aspect oriented software development;separation of concern;aspect oriented design;real time embedded system;object oriented programming;unified modeling language object oriented modeling model driven engineering programming timing real time systems quality of service memory management embedded software computer science;unified modelling language distributed real time embedded system aspect oriented design approach aspect oriented software development model driven engineering theme approach uml;software engineering;real time embedded systems;conference paper;theme approach;embedded systems;real time embedded systems theme uml model driven engineering distributed;theme uml;mde;unified modelling language;unified modeling language;model driven engineering;distributed real time embedded system;platform specific model;distributed models;multiple model;crosscutting concerns;platform independent model;aspect oriented;computer science;distributed;object oriented languages;unified modeling language embedded systems object oriented languages object oriented programming	Model-driven engineering (MDE) addresses platform complexity issues by abstracting platform- independent models for subsequent transformation to platform-specific models. This facilitates the design of a single system model and the subsequent generation of multiple model transformations targeted towards specific platforms. However, the increasing complexity of distributed real-time embedded (DRE) systems complicates the development of adequate system models by requiring multiple concerns, some of which may be crosscutting, to be modelled. Separation of concerns, a software engineering technique that decomposes systems into distinct features with minimal overlap, can be used to manage complexity. Aspect-oriented software development (AOSD) is an emerging technique to separate crosscutting concerns in software and has been demonstrated to improve modularity and thereby reduce the complexity of software. In this paper we show how Theme/UML, an aspect-oriented design approach, can be used to better modularise DRE concerns at the model level.	aspect-oriented software development;cross-cutting concern;embedded system;model-driven engineering;model-driven integration;platform-specific model;real-time clock;real-time operating system;real-time transcription;separation of concerns;software engineering;unified modeling language	Cormac Driver;Vinny Cahill;Siobhán Clarke	2008	2008 5th International Workshop on Model-based Methodologies for Pervasive and Embedded Software	10.1109/MOMPES.2008.8	unified modeling language;real-time computing;computer science;systems engineering;programming language	Embedded	-41.40010848599986	34.18287484284234	169653
8cfbd29e6995571a5d8ff8f092e9bf2400ec0f10	context analysis approach for context aware applications deployed on pervasive environments		The increase of mobile and interconnected devices leads to the growth of demands for context aware applications. These applications deployed on top of pervasive environments must adapt themselves to context changes. Context aware applications have to continuously sense their physical environment, and adapt their behavior accordingly. These applications must perform four phases starting by collecting and monitoring context, then analyzing context, deciding adaptation actions and finally executing the planned adaptation actions to deal with the context changes. In this paper, we focus on the second phase.We propose a context analysis approach that relies on different thresholds defined according to the user needs to detect context changes and raise notifications when changes occur. The analysis approach is performed according to three different steps. A context storage step, a context classification step, and a threshold calculation step. Received on 12 December 2014; accepted on 05 March 2015; published on 04 August 2015	autonomic computing;autoregressive model;mathematical model;pervasive informatics;sensor;software widget	Nesrine Khabou;Ismael Bouassida Rodriguez;Mohamed Jmaiel	2015	EAI Endorsed Trans. Context-aware Syst. & Appl.	10.4108/eai.4-8-2015.150041	real-time computing;database-centric architecture;deployment diagram;computer science;systems engineering;theoretical computer science;software deployment	SE	-42.559079042811625	41.42813146608942	169671
36e935a4fc45eca6949780e21f73fbd1eaa9b0f8	developing a monitoring infrastructure for iec 61499 devices	public domain software;embedded systems;iec standards;factory automation;program debugging;public domain software computerised monitoring distributed control embedded systems factory automation iec standards program debugging;computerised monitoring;monitoring iec standards debugging decentralized control ports computers automation;distributed control;distributed control system development improvement iec 61499 device monitoring infrastructure develop ent flexible adaptive production system industrial automation system architecture debugging infrastructure embedded control devices 4diac open source framework	In order to cope with the upcoming demands for flexible adaptive production system a new architecture for industrial automation systems has been introduced called IEC 61499. Up to now no monitoring and debugging infrastructure has been defined for IEC 61499 although, this is a key feature for industrial automation systems as break downs and unexpected standstills needs to be solved immediately. To improve this situation this work evaluates whether existing IEC 61499 means can be used for monitoring and debugging. As existing means are either not powerful enough or not suitable for small embedded control devices a new monitoring and debugging approach is developed. The developed infrastructure has been implemented as part of the 4DIAC open source framework. Testing the new monitoring and infrastructure showed that it is capable of fulfilling the requirements and that it greatly improves distributed control system development.	automation;binary file;ccir system a;debugging;distributed control system;embedded system;management interface;microsoft outlook for mac;open-source software;overhead (computing);printing;production system (computer science);requirement;user interface;wiring;xml	Alois Zoitl;Gerhard Ebenhofer;Michael Hofmann	2013	2013 IEEE 18th Conference on Emerging Technologies & Factory Automation (ETFA)	10.1109/ETFA.2013.6647968	embedded system;real-time computing;computer science;engineering;operating system;automation;public domain software;computer engineering;scada	Robotics	-35.27363156164576	38.51346958070342	169762
d13fee047c26e0863aaffa77afda9b76a572384d	an architecture of a quality of service resource manager middleware for flexible embedded multimedia systems	resource manager;consumer electronics;multimedia application;multimedia systems;embedded system;middleware;time to market;quality of service;set top box;management policy	There is a growing interest in multimedia applications and, in particular, in Consumer Electronics Embedded Multimedia Systems (CEEMS), such as set-top boxes and VTRs. At present, fimctionality changes and enhancement in CEEMSs are frequent. Manufacturers must adapt to such changes to keep in the market. Therefore, they must reduce time to market for their products. One of the clues to better improve and enhance system functionality is to develop easily upgradable (flexible) systems; so, a modification in some function of a CEEMS will not imply redesigning the whole system. Current trend is to include programmable components in these devices to enhance their flexibility. In order to make this approach feasible, it is required a high and efficient use of resources. This paper presents HOLAQOS, an architecture of a QoS resource manager that gives support to bulling flexible and open multimedia embedded systems. It is composed of a set of homogenous layers, where each of them manages one of the main system entities: appplications, quality levels, and resource budgets. HOLA-QoS is flexible and composable in order to facilitate experimentation with different types of multimedia applications for CEEMSs and management policies. A prototype of this architecture has been built to test the main concepts in the design.	embedded system;middleware;quality of service	Marisol García-Valls;Alejandro Alonso;José Ruiz;Angel M. Groba	2002		10.1007/3-540-38093-0_3	embedded system;real-time computing;simulation;quality of service;computer science;engineering;resource management;operating system;software engineering;middleware	Embedded	-37.37531044101697	42.303572738690605	170072
db2462944c8cbc899e9694e25d870b79c84977a7	asynchronous-channels and time-domains extending petri nets for gals systems		A specific class of Petri nets was extended with AsynchronousChannels (ACs) and Time-Domains (TDs) to support Globally-Asynchronous Locally-Synchronous (GALS) systems’ modeling, analysis and implementation. This non-autonomous class of Petri nets is targeted to support the development of automation and embedded systems using a model-based development approach. It benefits from a tool chain framework previously developed, covering the whole development flow, from specification to hardware and software deployment. With the extended Petri net class is possible to model GALS systems, and use the specification to generate the corresponding state space supporting the behavior verification and providing valuable information for implementation.	asynchronous circuit;autonomous robot;centralized computing;clock signal;embedded system;globally asynchronous locally synchronous;graphical user interface;interaction;model-driven engineering;petri net;programming paradigm;software deployment;state space;synchronous circuit;toolchain	Filipe Moutinho;Luís Gomes	2012		10.1007/978-3-642-28255-3_16	embedded system;real-time computing;computer science;systems engineering;process architecture;petri net	EDA	-41.36035029721595	32.718595180361916	170331
cec962ca32b53503cd727b9948ea4f6151dbb00f	application of formal methods for system-level verification of network on chip	verification;routing protocols;routing semiconductor process modeling clocks switches protocols system on a chip computational modeling;network on chip;formal languages;verification network on chip routing algorithm model checking;specification language;formal method;chip;formal verification;routing protocols automata theory formal languages formal verification network on chip;model checking;system on chip;system design;routing algorithm;automata theory;communication protocol;wormhole switching;formal language;spin model checker formal method application system level verification network on chip system on chip soc layered communication protocol noc router based communication architecture end to end protocol correctness hermes noc router architecture formal language heterogeneous protocol automata hpa bidirectional port bounded buffer xy routing algorithm priority based arbitration logic wormhole switching request ack handshake protocol promela language	Network on chip (NoC) is a system design methodology that uses on-chip routers for integrating the resources on a system on chip (SoC). Applications on the SoC communicate through a layered communication protocol implemented on the NoC's router-based communication architecture. There is need for a formal system level model of NoC to verify end-to-end protocol correctness in an NoC architecture. In this paper we present a new formal model of the existing Hermes NoC router architecture and its communication scheme using a new formal language called Heterogeneous Protocol Automata (HPA). We model the five bi-directional ports and the bounded buffers at input port of the Hermes Router, including the XY routing algorithm, priority based arbitration logic, wormhole switching and the request-ack handshake protocol of the communication scheme. The automata model is then mapped manually to PROMELA, the specification language of the SPIN model checker for verification, with promising results.	algorithm;automata theory;automaton;communications protocol;correctness (computer science);dspace;end-to-end principle;formal language;formal methods;formal system;formal verification;level design;model checking;network on a chip;promela;router (computing);routing;spin model checker;specification language;system on a chip;systems design;verification and validation;wormhole switching	Vinitha Arakkonam Palaniveloo;Arcot Sowmya	2011	2011 IEEE Computer Society Annual Symposium on VLSI	10.1109/ISVLSI.2011.57	parallel computing;real-time computing;computer science;distributed computing	Embedded	-34.41735659794289	32.57554281267533	170447
02ea8190f63bb5bc9fad53f4f8a4bea421a57779	an automated formal approach to managing dynamic reconfiguration	software maintenance configuration management formal specification object oriented programming program verification software architecture;formal specification;dynamic reconfiguration management;runtime adaptive systems power supplies availability software systems software architecture application software engineering management service oriented architecture power system modeling;dynamic reconfiguration;component based systems;software maintenance;system specification dynamic reconfiguration management run time software changes adaptive systems reconfigurable applications openrec application structural constraints alloy analyzer tool service oriented architecture formal modelling notation;system specification;object oriented programming;program verification;reconfigurable applications;satisfiability;application structural constraints;openrec;software architecture;conference item;adaptive systems;formal modelling notation;adaptive system;component model;run time software changes;alloy analyzer tool;service oriented architecture;configuration management	Dynamic reconfiguration is the process of making changes to software at run-time. The motivation for this is typically to facilitate adaptive systems which change their behavior in response to changes in their operating environment or to allow systems with a requirement for continuous service to evolve uninterrupted. To enable development of reconfigurable applications, we have developed OpenRec, a framework which comprises a reflective component model plus an open and extensible reconfiguration management infrastructure. Recently we have extended OpenRec to verify whether an intended (re)configuration would result in an application's structural constraints being satisfied. Consequently OpenRec can automatically veto proposed changes that would violate configuration constraints. This functionality has been realized by integrating OpenRec with the ALLOY Analyzer tool via a service-oriented architecture. ALLOY is a formal modelling notation which can be used to specify systems and associated constraints. In this paper, we present an overview of the OpenRec framework. In addition, we describe the application of ALLOY to modelling re-configurable component based systems and highlight some interesting experiences with integrating OpenRec and the ALLOY Analyzer	ase;adaptive system;alloy (specification language);alloy analyzer;component-based software engineering;computation;conformance testing;data integrity;distributed computing;facade pattern;fault tolerance;formal verification;operating environment;overhead (computing);quality of service;requirement;scalability;sensor;server (computing);service-oriented architecture;software design pattern;state (computer science);stemming;token reconfiguration;verification and validation;web service	Ian Warren;Jing Sun;Sanjev Krishnamohan;Thiranjith Weerasinghe	2006	21st IEEE/ACM International Conference on Automated Software Engineering (ASE'06)	10.1109/ASE.2006.12	software architecture;computer architecture;real-time computing;computer science;systems engineering;adaptive system;software engineering;service-oriented architecture;system requirements specification;formal specification;component object model;configuration management;programming language;object-oriented programming;software maintenance;satisfiability	SE	-39.80841749156441	38.44678936846082	170491
32c90ca338fef66d78d04e4ddde1e1b012000a2a	a coordination middleware for wireless sensor networks	telecommunication computing wireless sensor networks middleware;region leader coordination middleware wireless sensor networks coordination paradigm tuple channels fifo structures one to many communication many to one communication region sensors;middleware wireless sensor networks programming profession quality of service data structures bridges hardware portable computers interference energy management;telecommunication computing;sensor network;wireless sensor network;middleware;coordination model;wireless sensor networks	Middleware development in the growing and promising field of sensor networks is a major challenge in order to facilitate the programmer task and bridge the gap between the applications and the hardware. This paper presents a new middleware for wireless sensor networks based on the Coordination paradigm. The middleware is thought to support both an operational setting based on a (hierarchical) architecture of sensor regions and a coordination model rested on tuple channels. Tuple channels are FIFO structures that allow one-to-many and many-to-one communication between region sensors and the region leader in a single-hop way. The main components of the middleware architecture are described.	channel (communications);entity;fifo (computing and electronics);java;laptop;middleware;one-to-many (data model);open-source software;operating system;personal digital assistant;programmer;programming language;programming paradigm;prototype;sensor;tinyos	Manuel Díaz;Bartolomé Rubio;José M. Troya	2005	2005 Systems Communications (ICW'05, ICHSN'05, ICMCS'05, SENET'05)	10.1109/ICW.2005.5	embedded system;middleware;real-time computing;computer science;middleware;key distribution in wireless sensor networks;mobile wireless sensor network;computer network	Embedded	-36.5660274777694	45.81180130078281	170514
88d9f5524c90d967bd1ab4e0c1039906b0e8d563	distributed control programming in java - the jakobi system	vertical integration;control application;real time;control engineering computing;real time constraints distributed control programming java jakobi system;java control engineering computing distributed control;distributed control;distributed control java control systems automatic control communication system control runtime object oriented programming industrial control manufacturing automation programmable control;java	Within this paper the design and the implementation of a component based framework for distributed control applications based on Java will be presented. It has been developed over the course of the JAKOBI project. This project targets the applicability of Java in control applications using extensions such as the RTSJ specification. It introduces concepts similar to IEC 61499 allowing the execution of Java based applications within real-time constraints without loosing advantages like dynamic class loading or platform independence. The usage of these concepts opens a wide range of possibilities for future control applications like reconfiguration during runtime or vertical integration without conceptual and technological breaks.	distributed control system;integrated development environment;java classloader;real time java;real-time transcription;runtime system	Michael Heinze;Jörn Peschke	2007	2007 IEEE Conference on Emerging Technologies and Factory Automation (EFTA 2007)	10.1109/EFTA.2007.4416903	vertical integration;real-time computing;jsr 94;java concurrency;computer science;strictfp;embedded java;distributed computing;real time java;real-time control system software;programming language;java	Embedded	-35.018465828813376	38.227273425937625	170623
6e4bda94b8de4a67a515bdc542c93829c57cf7b7	an integrated framework for sensor-based embedded systems	multicast communication;ieee standards;ip multicast;embedded system;embedded systems;pressure measurement;design pattern;sensor based appliances integrated framework sensor based embedded systems networked sensors design pattern smart transducer interface standard ieee 1451 messaging architecture ip multicast communication computer based pressure measurement system communication architecture;computerised instrumentation;ieee standards embedded systems intelligent sensors multicast communication pressure measurement computerised instrumentation;intelligent sensors;embedded system computer architecture intelligent sensors sensor systems and applications transducers communication standards multicast communication internet kernel pressure measurement;virtual interface architecture	7KLV SDSHU SUHVHQWV DQ DSSOLFDWLRQ RI QHWZRUNHG VHQVRUV WKDW RIIHUV D GHVLJQ SDWWHUQ IRU D FODVV RI VHQVRU EDVHG HPEHGGHG V\VWHPV ,W GHDOV ZLWK DQ LQWHJUDWHG IUDPHZRUN EDVHG RQ VPDUW WUDQVGXFHU LQWHUIDFH VWDQGDUG ,((( RQ PHVVDJLQJ DUFKLWHFWXUH &RPSDT ,QWHO 0LFURVRIW V 9LUWXDO ,QWHUIDFH $UFKLWHFWXUH DQG RQ ,3 PXOWLFDVW FRPPXQLFDWLRQ PHGLDWLQJ DQ HIILFLHQW DQG XQLILHG DFFHVV IURP ,QWHUQHW WR VHQVRU EDVHG HPEHGGHG V\VWHPV DQG YLFH YHUVD 7KH NHUQHO RI WKH SDSHU IRFXVHV RQ XWLOL]DWLRQ RI WKH IUDPHZRUN IRU D FRPSXWHU EDVHG SUHVVXUH PHDVXUHPHQW V\VWHP DV D UHDO ZRUOG SURMHFW VWUHVVLQJ LWV FRPPXQLFDWLRQ DUFKLWHFWXUH 7KH SUHVHQWHG FDVH VWXG\ GHPRQVWUDWHV DQ DSSOLFDWLRQ RI D QRYHO GHVLJQ SDWWHUQ DLPHG DW GLVWULEXWHG VHQVRU EDVHG DSSOLDQFHV	data quality;digimon world;double-ended queue;embedded system;rs-232	Miroslav Svéda;Radimír Vrba	2002		10.1109/ECBS.2002.999838	embedded system;real-time computing;multicast;ip multicast;pressure measurement;computer science;engineering;operating system;design pattern;computer network;intelligent sensor	EDA	-35.554559376677055	46.348125942535404	170824
416aab2bac1e84d4a689cf9704f27df81b3f0a2a	metamodels and mda transformations for embedded systems	mda;metamodel;embedded systems;model transformations;embedded system;signal processing;system on chip;hardware architecture	Embedded system design needs to model together application and hardware architecture. For that a huge number of models are available, each one proposing its own abstraction level associated to its own software platform for simulation or synthesis. To produce a co-design framework, we are obviously obliged to support different models among all possible ones. Between these models we should produce automatic transformations. Each time a new model is included in the framework, we should develop a new transformation. To improve transformation engine development, Model Driven Architecture (MDA) techniques are useful. This approach permits to define the transformations at the metamodel level. It guaranties to the framework the reuse of models and unifies the definition of the transformation rules. We present the application of MDA in the context of Intensive Signal Processing (ISP) applications deployed on System on Chip (SoC) platforms. For that purpose, we have developed a new MDA Transformation engine: ModTransf. We apply this engine on UML profiles to generate SystemC Transaction Level Model dedicated to ISP. A particular rule will be presented to illustrate the interest of this approach in a multi model embedded system design environment.	abstraction layer;automatic taxonomy construction;code generation (compiler);code refactoring;embedded system;metamodeling;model-driven architecture;profile (uml);signal processing;simulation;speech synthesis;system on a chip;systemc;systems design;unified modeling language	Lossan Bonde;Cédric Dumoulin;Jean-Luc Dekeyser	2004			system on a chip;embedded system;real-time computing;computer science;operating system;signal processing;hardware architecture	EDA	-41.23139436139189	33.595802189637375	171079
553ce3461ef4b55510333271b081b952876fbf65	the design and implementation of a declarative sensor network system	declarative programming;sensor network;design and implementation;sensor networks	Sensor networks are notoriously difficult to program, given that they encompass the complexities of both distributed and embedded systems. To address this problem, we present the design and implementation of a declarative sensor network platform, DSN: a declarative language, compiler and runtime suitable for programming a broad range of sensornet applications. We demonstrate that our approach is a natural fit for sensor networks by specifying several very different classes of traditional sensor network protocols, services and applications entirely declaratively -- these include tree and geographic routing, link estimation, data collection, event tracking, version coherency, and localization. To our knowledge, this is the first time these disparate sensornet tasks have been addressed by a single high-level programming environment. Moreover, the declarative approach accommodates the desire for architectural flexibility and simple management of limited resources. Our results suggest that the declarative approach is well-suited to sensor networks, and that it can produce concise and flexible code by focusing on what the code is doing, and not on how it is doing it.	communications protocol;compiler;declarative programming;embedded system;geographic routing;high- and low-level;high-level programming language;integrated development environment	David Chu;Lucian Popa;Arsalan Tavakoli;Joseph M. Hellerstein;Philip Levis;Scott Shenker;Ion Stoica	2007		10.1145/1322263.1322281	embedded system;real-time computing;wireless sensor network;computer science;theoretical computer science;distributed computing	Mobile	-36.91432894917539	45.45082032737813	171121
467825802991ecdea40640a580290ff393953c96	a system architecture for pervasive computing	component technology;ubiquitous computing middleware object oriented programming;middleware pervasive computing universal system architecture component technology;universal system architecture;pervasive computing;object oriented programming;computer architecture pervasive computing middleware context aware services communication system control cryptography data security educational institutions communication system security technology management;ubiquitous computing;middleware;service discovery;system architecture	With the development of pervasive computing, the essentiality of universal system architecture for pervasive computing is recognized. At present, there are lots of researches on the related fields in system architecture for pervasive computing. In this paper, a novel system architecture for pervasive computing is presented. The architecture is based on component and middleware technology and contains series of services, such as service discovery, security control, communication management, etc. From the architecture presented, services in pervasive computing environments can be integrated seamlessly. The current state of research is evaluated and the future work agenda in our presented system architecture for pervasive computing is presented, too.	middleware;pervasive informatics;service discovery;systems architecture;ubiquitous computing	Wenshuan Xu;Yunwei Xin;Guizhang Lu	2007	Third International Conference on Natural Computation (ICNC 2007)	10.1109/ICNC.2007.152	enterprise architecture framework;reference architecture;embedded system;middleware;space-based architecture;real-time computing;context-aware pervasive systems;computer science;applications architecture;end-user computing;solution architecture;distributed computing;utility computing;data architecture;autonomic computing	HPC	-40.14625640091127	44.58292596750943	171404
9a2a833f9ad4d9847a1ae28cb75766819d8986b5	service substitutability analysis based on behavior automata	service behavior automata;formal verification;service substitutability;service oriented computing;behavior protocol	Identifying a suitable service to substitute the failed service in Web service composition is a primary means to improve the robustness and dependability of service-oriented computing and cloud computing. Service behavioral substitutability analysis and verification is the main research subject of service-oriented computing. In this paper, based on Finite Automata and characteristics of service-oriented software systems, service behavior automata have been proposed to describe Web service behavior protocols formally; a conceptual hierarchy of service behavioral substitutability has been formally defined to increase service component reuse, and related verification algorithms have been proposed to analyze service behavioral substitutability automatically.	algorithm;automata theory;automaton;cloud computing;computer-aided software engineering;conceptual system;dependability;finite-state machine;parallel computing;plug and play;service composability principle;service-oriented architecture;service-oriented device architecture;service-oriented modeling;service-oriented software engineering;software system;third-party software component;web service	Hongmin Ren;Jin Liu	2012	Innovations in Systems and Software Engineering	10.1007/s11334-012-0190-7	formal verification;computer science;service-oriented architecture;database;distributed computing;data as a service;computer security	SE	-46.523364035226784	39.41052078088463	171449
84081962a3e81446aa0fb0fb225a5ec889a5f1d2	distributing deterministic, accurate time for tightly coordinated network and software applications: ieee 802.1as, the tsn profile of ptp		"""Real-time cooperation among agents requires sharing of certain temporal information. That information might take the form of """"take action X right now!"""" or it might better be achieved in some cases by establishing an a priori agreement by which each action should be taken and when, together with a shared understanding of what time it is. Distributed applications increasingly rely on this latter synchronized time approach rather than explicit """"right now!"""" communication for cooperative sense and control tasks. Such a capability is foundational to the field of cyber physical systems (CPS) where computation and communication interact with the physical world in real time. While multiple historical approaches exist for time-synchronized (and timely) communication among sensing, computing, and actuating devices, the addition of robust temporal performance characteristics to standard Ethernet through the work of the Time Sensitive Networking (TSN) Task Group of IEEE 802.1 is bringing together the benefits of standard IT networking with excellent worst case latency and synchronization performance that was previously available only to these specialized and sometimes proprietary networks. Such advances will be important in next-generation applications as diverse as CPS/real-time distributed control, smart factories, sensor fusion, autonomous vehicles, and even cloud applications [1]. As we show, precision network time synchronization can dramatically enhance the operation of these applications and is a requirement of certain new network latency enhancements as well."""	autonomous robot;best, worst and average case;business logic;byzantine fault tolerance;cloud computing;coexist (image);computation;distributed computing;distributed control system;interoperation;operating system;picture transfer protocol;precision time protocol;real-time clock;real-time transcription;sensor web;testament;time-sensitive networking	Kevin B. Stanton	2018	IEEE Communications Standards Magazine	10.1109/MCOMSTD.2018.1700086	ieee 802;latency (engineering);cyber-physical system;cloud computing;software;sensor fusion;ethernet;synchronization;computer science;distributed computing	Embedded	-37.434048857394885	44.185873750997764	171606
6254f973de4b9cc1881d9b52522855ff1164418b	seamless semantic service provisioning mechanism for ambient assisted living	aal;network selection;service provisioning;ambient assisted living;semantic;semantic web;open service gateway initiative;activity of daily living;service discovery;service provision	As the current technology and usage trends in Ambient Assisted Living (AAL) evolves; more and more services were developed for helping dependent people, especially elderly and people with mild dementia to live independently. These services help them to perform Activities of Daily Living (ADL) easily, safely and in a proper manner. The relevant service is delivered to the user seamlessly through a set of devices. As the user moves around, the devices might also move into a new and sometimes unknown domain. This leads to the need for service discovery and provisioning beyond the current capabilities of Open Services Gateway Initiative (OSGi) or other service platforms. A mechanism for seamless semantic service provisioning using semantic web is further discussed in this paper. The challenge here is to produce a platform that supports not only seamless semantic service provisioning, but also to handle user and device mobility through semantic reasoning. The aim of the system is to ensure users are able to use relevant services at a specific location and time with a set of dynamic context.		Muzaaliff W. Musa;Mounir Mokhtari;Borhanuddin Mohd Ali;Mohd Fadlee A. Rasid;Mahmoud Ghorbel	2010		10.1145/1971519.1971542	activities of daily living;differentiated service;computer science;service delivery framework;operating system;semantic web;service design;service discovery;internet privacy;world wide web;computer network	HCI	-40.69641054552373	45.83970664350924	171648
11d5928d49077ba355bda2265e4f14ef4648aa7d	programming languages for high-assurance autonomous vehicles: extended abstract	programming language design;high assurance	We briefly describe the use of embedded domain-specific languages to improve programmer productivity and increase software assurance in the context of building a fully-featured autopilot for unpiloted aircraft.	autonomous robot;autopilot;domain-specific language;embedded system;microsoft software assurance;programmer;programming productivity	Lee Pike;Patrick C. Hickey;James Bielman;Trevor Elliott;Thomas DuBuisson;John Launchbury	2014		10.1145/2541568.2541570	fourth-generation programming language;real-time computing;simulation;computer science;programming paradigm;fifth-generation programming language;programming language theory;programming language;second-generation programming language	Embedded	-34.328636303660225	36.8407531746431	171705
a501d7ab1898ab661ce7b33eff2b0c60918d7885	deployment aggregates - a generic deployment automation approach for applications operated in the cloud	databases;topology;deployment;provisioning;semantics;unification;devops deployment aggregate topology provisioning operations unification orchestration transformation meta model cloud computing;aggregates topology semantics cloud computing databases automation;aggregates;transformation;operations;cloud computing generic deployment automation approach deployment aggregates generic meta model;devops;meta model;orchestration;cloud computing;automation;aggregate	One of the most essential requirements to make use of the benefits of Cloud computing is fully automated provisioning and deployment of applications including all related resources. This leads to crucial cost reductions when deploying and operating applications in the Cloud because manual processes are slow, error-prone, and thus costly. Both Cloud providers and the open-source community provide a huge variety of tools, APIs, domain-specific languages, and reusable artifacts to implement deployment automation. However, the meta-models behind these approaches are diverse. This diversity makes it challenging to combine different approaches, avoiding vendor lock-in and tooling lock-in. In this work we propose deployment aggregates as a generic means to use and orchestrate different kinds of deployment approaches. We define a generic meta-model and show its relation to existing meta-models in the domain of deployment automation. Moreover, we discuss how existing artifacts can be used as deployment aggregates as a result of transformation and enrichment.	automation;cloud computing;cognitive dimensions of notations;domain-specific language;gene ontology term enrichment;metamodeling;open-source software;orchestration (computing);provisioning;requirement;software deployment;vendor lock-in	Johannes Wettinger;Katharina Görlach;Frank Leymann	2014	2014 IEEE 18th International Enterprise Distributed Object Computing Conference Workshops and Demonstrations	10.1109/EDOCW.2014.34	transformation;metamodeling;aggregate;simulation;cloud computing;deployment diagram;computer science;unification;automation;software engineering;devops;database;distributed computing;semantics;orchestration;software deployment;provisioning	SE	-45.20585223898514	41.26945270789936	171731
209706f604ee0595f76ca72a7aae17e1350ab153	issues and implementation of a urc home service robot	ubiquitous computing computer networks home automation mobile robots protocols resource allocation service robots;protocols;resource allocation;resource manager;service management;service robots;mobile robots;nettoro network based home service robot ubiquitous robotic companion environment urc intelligent home service robot communication protocol resource management;computer networks;pilot project;service robots robot kinematics intelligent robots human robot interaction robot sensing systems resource management motion pictures artificial intelligence computer networks protocols;service robot;communication protocol;ubiquitous computing;home automation	This paper reviews and discusses many issues and implementation details of an intelligent home service robot in a URC (Ubiquitous Robotic Companion) environment. In contrast to standalone service robots, URC service robots provide a variety of functions by the full utilization of network infrastructure. Many challenges are waiting to be faced in front of us-for example, the execution and coordination of services, multiple team support, session and service management, and communication protocol and its architecture, and resource management of a robot. This paper proposes solutions for the above issues and applies the solutions to a network-based home service robot called Nettoro. As an application of the proposed architecture, a pilot project launched December, 2006 is presented and the results are briefly discussed.	communications protocol;home automation;service robot;universal remote console	Seung-Ik Lee;Choulsoo Jang;Sunghoon Kim;Myungchan Roh;Beom-Su Seo	2007	RO-MAN 2007 - The 16th IEEE International Symposium on Robot and Human Interactive Communication	10.1109/ROMAN.2007.4415150	mobile robot;embedded system;communications protocol;simulation;computer science;distributed computing;ubiquitous robot;ubiquitous computing;personal robot	Robotics	-37.8004956755513	43.80861615538788	171803
7d2b534a89b7b00aed57acfc7e0e2e5864aae9b3	design of a component-based simulation framework for component testing using springdm	software;software components component based simulation framework component testing springdm;control systems;object oriented model;computer model;simulation;simulation framework;program testing object oriented programming;testing;object oriented programming;simulation software;control system;computational modeling;testing computational modeling software object oriented modeling control systems computer science discrete event simulation;program testing;software component;computer science;object oriented modeling;simulation environment;testing simulation software component;discrete event simulation	In this paper, we present the design of a simulation framework aimed to support testing of real components in a simulation environment. This enables thorough tests of software components without the need to create their models.	component-based software engineering;simulation	Tomas Potuzak;Richard Lipka;Jaroslav Snajberk;Premek Brada;Pavel Herout	2011	2011 Second Eastern European Regional Conference on the Engineering of Computer Based Systems	10.1109/ECBS-EERC.2011.41	non-regression testing;computer architecture;real-time computing;simulation software;computer science;control system;software reliability testing;component-based software engineering;discrete event simulation;software construction;software testing;object-oriented programming;computational model;computer engineering	Robotics	-46.6211018042921	34.08461688332433	171857
a218fc0bda906af4073d93d42b78b1817b8e5299	failsafe mechanism design of multicopters based on supervisory control theory		In order to handle undesirable failures of a multicopter which occur in either the pre-flight process or the in-flight process, a failsafe mechanism design method based on supervisory control theory is proposed for the semi-autonomous control mode . Failsafe mechanism is a control logic that guides what subsequent actions the multicopter should take, by taking account of real-time information from guidance, attitude control, diagnosis, and other low-level subsystems. In order to design a failsafe mechanism for multicopters, safety issues of multicopters are introduced. Then, user requirements including functional requirements and safety requirements are textually described, where function requirements determine a general multicopter plant, and safety requirements cover the failsafe measures dealing with the presented safety issues. In order to model the user requirements by discrete-event systems, several multicopter modes and events are defined. On this basis, the multicopter plant and control specifications are modeled by automata. Then, a supervisor is synthesized by monolithic supervisory control theory. In addition, we present three examples to demonstrate the potential blocking phenomenon due to inappropriate design of control specifications. Also, we discuss the meaning of correctness and the properties of the obtained supervisor. This makes the failsafe mechanism convincingly correct and effective. Finally, based on Q. Quan, Z. Zhao P. Wang and K.-Y. Cai are with School of Automation Science and Electrical Engineering,Beihang University, Beijing 100191, China (e-mail: qq buaa@buaa.edu.cn, zzy buaa@buaa.edu.cn, wp2204@gmail.com, kycai@buaa.edu.cn). L. Lin and W. M. Wonham are with the Department of Electrical and Computer Engineering, University of Toronto, Toronto, ON M5S 3G4, Canada (e-mail: liyong.lin@utoronto.ca,wonham@control.utoronto.ca). The corresponding author Q. Quan is also with the Department of Electrical and Computer Engineering, University of Toronto as a visiting professor. Most multicopters have two high-level control modes: semi-autonomous control and full-autonomous control. Many open source autopilots support both modes. The semi-autonomous control mode implies that autopilots can be used to stabilize the attitude of multicopters, and also they can help multicopters to hold the altitude and position. Under such a mode, a multicopter will be still under the control of remote pilots. On the other hand, the full-autonomous control mode implies that the multicopter can follow a pre-programmed mission script stored in the autopilot which is made up of navigation commands, and also can take off and land automatically. Under such a mode, remote pilots on the ground only need to schedule the tasks [1]. April 28, 2017 DRAFT	automata theory;automation;autonomous robot;autopilot;blocking (computing);computer engineering;control system;control theory;correctness (computer science);electrical engineering;email;fail-safe;functional requirement;high- and low-level;local interconnect network;open-source software;pdf/a;real-time data;real-time transcription;semiconductor industry;user requirements document	Quan Quan;Zhiyao Zhao;Liyong Lin;Walter Murray Wonham;Kai-Yuan Cai	2017	CoRR		control engineering;reliability engineering;engineering;control theory	Robotics	-44.819377593674275	34.38494163891777	172163
fd4f4400057d613f9d23a5419b5ea14235e47b2f	a hierarchical cooperation model for sensor networks supported cooperative work	sensor systems and applications;intelligent building;groupware;fire monitoring;collaborative work;layered abstract model;multilevel client server architecture;client server systems;telecommunication computing;sensor network;computer networks;intelligent building hierarchical cooperation model multimedia sensor network cscw sensor network supported cooperative work speech action model layered abstract model activity task cooperation multilevel client server architecture fire monitoring;multimedia computing;computer architecture;monitoring;sensor networks;wireless sensor networks client server systems groupware multimedia computing;speech action model;collaborative work intelligent sensors computer architecture computer networks telecommunication computing humans monitoring intelligent networks sensor systems and applications delay;sensor nodes;cscw;humans;intelligent networks;sensor networks hierarchical cooperation model multi level c s architecture cooperative work;activity task cooperation;hierarchical cooperation model;wireless sensor networks;multimedia sensor network;intelligent sensors;multi level c s architecture;cooperative work;sensor network supported cooperative work	Complicated multimedia sensor networks pose several theoretic and technical challenges. These challenges center on cooperative work supported by sensor networks. This paper presents, with the aid of previous works on CSCW, a novel conception - sensor networks supported cooperative work (SNSCW). First, we classify the cooperative work supported by sensor networks into: cooperation between human and sensor nodes, and cooperation among sensor nodes. Then we depict the hierarchical collaboration by speech-action model and layered abstract model (activity-task-cooperation). Moreover, this paper proposes a multi-level C/S architecture for SNSCW system. Finally, we utilize a case $the fire monitoring of intelligent building - to show that our works are effective to cooperative work supported by sensor networks	computer-supported cooperative work;theory	Liang Liu;Huadong Ma;Dan Tao;Dongmei Zhang	2006	2006 10th International Conference on Computer Supported Cooperative Work in Design	10.1109/CSCWD.2006.253143	real-time computing;wireless sensor network;computer science;distributed computing;key distribution in wireless sensor networks;computer network	Robotics	-36.246156297714506	45.86645158090896	172191
16075ed37d1de61af9b5e8e8208072dad39e75e0	a simulation approach for the design of safety-relevant automotive multi-ecu systems	electronic control units;automotive engineering;time division multiple access;safety relevant applications;networked airbag control system safety relevant automotive multi ecu systems electronic control units automotive bus systems networked embedded controllers discrete event simulation unified modeling language automotive in car communication audi;automotive in car communication;networked embedded controllers;system modeling;uml;networked airbag control system;real time;simulation;system of systems;automotive engineering communication system control control systems vehicles telecommunication network reliability employment discrete event simulation unified modeling language real time systems prototypes;automotive;flexray;data communication;safety relevant applications system design uml simulation automotive can flexray;control system;logic gates;can;synchronization;system design;automotive components;unified modeling language;system development;safety relevant automotive multi ecu systems;payloads;electronic control unit;unified modeling language automotive components automotive engineering discrete event simulation safety devices;automotive bus systems;audi;data models;operating systems;discrete event simulation;safety devices	Modern cars comprise tens of electronic control units, interconnected via automotive bus systems towards a specific system-of-systems inside the vehicle. Safety-relevant applications which are realized by these networked embedded controllers require a sophisticated process of system design. The appropriate choice of communication infrastructure and parameters at an early stage of system development significantly influences the overall application performance and reliability. Therefore, we propose the employment of distinct, well-proven system modeling techniques, using discrete event simulation and the Unified Modeling Language with real-time extensions. Our approach allows modeling the relevant aspects of in-car communication even before the first prototype vehicle is built up. Various design alternatives can easily be investigated without time- and manpower-consuming real-world system tests, yielding trustworthy results for a broad variety of aspects of automotive in-car communication. In cooperation with the German car manufacturer Audi, we applied our methodology for design of a networked airbag control system.	control system;embedded system;engine control unit;prototype;real-time locating system;simulation;system of systems;systems design;systems modeling;trustworthy computing;unified modeling language;world-system	Thomas Herpel;Reinhard German	2009	2009 IEEE International Conference on System of Systems Engineering (SoSE)		control engineering;unified modeling language;embedded system;computer science;systems engineering;engineering;control system;automotive engineering	Embedded	-45.10707129242237	35.38350607142848	172390
8f4ea0146dca22378ade3143e56145dcb8f30d0c	dynamically generated multi-modal application interfaces	adaptive method;point of view	This work approaches dynamic multi-modal application interfaces from a new point of view. The ongoing diversification of the user base and technology lays the foundation for the need of an holistic adaption infrastructure. Only designing individual adaption methods is not sufficient anymore. Providing such an infrastructure along with an open reference implementation is the objective of the Generalized Interface ToolKit (GITK) project. The software can generate, adapt and exchange interfaces at runtime. It works on various platforms and comes with several interface renderers. The solution is based on XML technology and defines an own markup language called Generalized Interface Markup Language (GIML). Author	modal logic;web application	Stefan Kost	2006			xml;database;markup language;software;reference implementation;computer science;diversification (marketing strategy)	HCI	-35.25664780223406	43.99597603462977	172478
b58c11b60d6b844013d746b5dbb4780da3b15723	a quantitative verification framework of sysml activity diagrams under time constraints	model checking;pctl;sysml activity diagram;probabilistic timed automata	Time-constrained and probabilistic verification approaches gain a great importance in system behavior validation including avionic, transport risk assessment, automotive systems and industrial process controllers. They enable the evaluation of system behavior according to the design requirements and ensure their correctness before any implementation. Due to the difficulty of analyzing, modeling and verifying these large scale systems, we introduce a novel verification framework based on PRISM probabilistic model checker that takes the SysML activity diagram as input and produce their equivalent timed probabilistic automata that is/are expressed in PRISM language. To check the functional correctness of the system under test, the properties are expressed in PCTL temporal logic. To prove the soundness of our mapping approach, we capture the underlying semantics of both the SysML activity diagrams and their generated PRISM code. We found that the timed probabilistic equivalence relation between both semantics preserve the satisfaction of the system requirements. We present digital camera as case study to illustrate the applicability of the proposed approach and to demonstrate its efficiency by analyzing a performability properties. 2015 Elsevier Ltd. All rights reserved.	activity diagram;automata theory;behavior model;correctness (computer science);digital camera;formal verification;mathematical model;model checking;modeling and analysis of real time and embedded systems;nusmv;prism (surveillance program);probabilistic ctl;probabilistic automaton;reachability;requirement;risk assessment;statistical model;system requirements;system under test;systems modeling language;systems design;temporal logic;timed automaton;turing completeness;uppaal;vhdl;verification and validation	Abdelhakim Baouya;Djamel Bennouar;Otmane Aït Mohamed;Samir Ouchani	2015	Expert Syst. Appl.	10.1016/j.eswa.2015.05.049	model checking;real-time computing;computer science	Logic	-43.26919349523439	32.55649962182808	172481
d7c75853ace3fd7d6103b4c20bb9a2c6f0a142a9	a framework for migrating production snapshots of composite applications to virtualized environments	databases;application migration;generators;virtualization;disk snapshot;virtualized environment;production system;usa councils;data center;real world application;network configuration;production;product configuration migrating production snapshot virtualized environment data center disk snapshot handling network;virtualization application migration disk snapshot;digital storage;virtual environment;generators usa councils databases production;knowledge based systems;handling network;product configuration;migrating production snapshot;knowledge based systems digital storage	Migrating production applications from physical datacenters to a virtualized environment is becoming essential to reduce operational costs. In order to avoid direct access to production systems, migration from disk snapshots is preferable. Model based migration approaches are not suitable for this purpose since they need to perform configuration discovery on production systems. Recent approaches that rely upon an isolated network require special setup and are limited to handling network configurations only. In this paper we present a framework for instantiating an application from disk snapshots in a virtualized environment. Our approach comprises of formally specifying the knowledge about product configurations and compiling the knowledge into a plan. The plan is capable of discovering application configurations in an inconsistent configuration setup. A key feature of our framework is that knowledge is specified once per product and re-used across applications that use the product. We have implemented a prototype of our approach and evaluated it on a real world application. The evaluation demonstrates the feasibility of our approach for migration using disk snapshots.	compiler;component-based software engineering;composite application;data center;formal specification;hypervisor;operating system;plug-in (computing);prototype;random access;spatial variability	Manish Sethi;Narendran Sachindran;Manoj Soni;Manish Gupta;Pratik Gupta	2011	12th IFIP/IEEE International Symposium on Integrated Network Management (IM 2011) and Workshops	10.1109/INM.2011.5990562	embedded system;data center;real-time computing;virtualization;computer science;virtual machine;operating system;knowledge-based systems;distributed computing;production system;computer security;computer network	OS	-38.76713738945462	40.460536038667094	172529
0085eb7132fb63a54873d29e5c27a7cabb44eac2	improving modularity of reflective middleware with aspect-oriented programming	service communities;separation of concern;computational reflection;scaling up;service groups;object oriented;aspect oriented programming;marketplaces;reflective middleware;modular design;middleware;crosscutting concerns	Reflective middleware has been proposed as an effective way to enhance adaptability of component-oriented middleware architectures. To be effectively adaptable, the implementation of reflective middleware needs to be modular. However, some recently emerged applications such as mobile, pervasive, and embedded applications have imposed more stringent modularity requirements to the middleware design. They require support for the conception of a minimal middleware while promoting finegrained modularity of reflective middleware features. The key problem is that fundamental mechanisms for decomposing reflective middleware implementations, such as object-oriented ones, suffer from not providing the proper means to achieve the required level of localizing reflection-specific concerns. This paper presents a systematic investigation on how aspect-oriented programming scales up to improve modularity of typical reflection-specific crosscutting concerns. We have quantitatively compared Java and AspectJ implementations of an OpenORB-compliant reflective middleware using separation of concerns metrics.	aspect-oriented programming;aspectj;cross-cutting concern;embedded system;java;middleware;pervasive informatics;requirement;separation of concerns	Nélio Cacho;Thaís Vasconcelos Batista;Alessandro F. Garcia;Cláudio Sant'Anna;Gordon S. Blair	2006		10.1145/1210525.1210534	middleware;real-time computing;computer science;message oriented middleware;middleware;database;distributed computing	PL	-41.09998796527776	41.433521221043414	172731
3114de8ba23777f52de969b3f35c70d379c52cf3	translation from uml to spn model: a performance modeling framework for managing behavior of multiple collaborative sessions and instances	activity diagram;performance attributes;communication system;performance evaluation;building block;uml;system dynamics;stochastic petri net;continuous time markov chain;performance metric;markov model;spn;performance model;system development life cycle;quality of service	Performance evaluation of distributed system is always an intricate undertaking where system behavior is normally distributed among several components those are physically distributed. Bearing this concept in mind, we delineate a performance modeling framework for a distributed system that proposes a translation process from high level UML notation to SPN model and solves the model for relevant performance metrics. To capture the system dynamics through our proposed framework we outline a specification style that focuses on UML collaboration and activity as reusable specification building blocks. To present the UML specification style we focus on how to coordinate explicitly multiple collaborative sessions occurring at the same time. Design alternatives of system architectures are considered to generate the performance model to show how these design alternatives thus affect the system performance under different work load. The proposed performance modeling framework provides prediction result of a system such as mean response time. The applicability of our proposed framework is demonstrated in the context of performance modeling of a distributed system.	deployment diagram;distributed computing;high-level programming language;mind;performance evaluation;performance prediction;profiling (computer programming);response time (technology);software deployment;substitution-permutation network;system dynamics;type system;unified modeling language	Razib Hayat Khan;Poul E. Heegaard	2010	2010 3rd International Conference on Computer Science and Information Technology	10.1007/978-3-642-13971-0_29	real-time computing;simulation;communication diagram;uml tool;computer science;systems engineering;applications of uml;class diagram	HPC	-43.68550370229769	34.34203171919372	172786
3f9a89b9ba5a9657fbce7626d1584c0c3e541021	reasoning about the reliability of multi-version, diverse real-time systems	epistemic uncertainty;software;diversity;program diagnostics;reliability;software reliability program diagnostics reasoning about programs;uncertainty;two channel system;integrable system;uncertainty timing software reliability real time systems hardware software;aleatory level;reasoning about programs;safety critical system;real time system reliability;failure rate;high integrity system;reliability real time systems high integrity systems safety critical systems diversity;static analysis;high integrity system real time system reliability two channel system static analysis epistemic uncertainty aleatory level;software reliability;high integrity systems;safety critical systems;hardware;real time systems;qa76 computer software;timing	"""This paper is concerned with the development of reliable real-time systems for use in high integrity applications. It advocates the use of diverse replicated channels, but does not require the dependencies between the channels to be evaluated. Rather it develops and extends the approach of Little wood and Rush by (for general systems) by investigating a two channel system in which one channel, A, is produced to a high level of reliability (i.e. has a very low failure rate), while the other, B, employs various forms of static analysis to sustain an argument that it is perfect (i.e. it will never miss a deadline). The first channel is fully functional, the second contains a more restricted computational model and contains only the critical computations. Potential dependencies between the channels (and their verification) are evaluated in terms of aleatory and epistemic uncertainty. At the aleatory level the events ''A fails"""" and ''B is imperfect"""" are independent. Moreover, unlike the general case, independence at the epistemic level is also proposed for common forms of implementation and analysis for real-time systems and their temporal requirements (deadlines). As a result, a systematic approach is advocated that can be applied in a real engineering context to produce highly reliable real-time systems, and to support numerical claims about the level of reliability achieved."""	computation;computational model;failure rate;high-level programming language;numerical analysis;real-time computing;real-time locating system;real-time transcription;requirement;static program analysis	Alan Burns;Bev Littlewood	2010	2010 31st IEEE Real-Time Systems Symposium	10.1109/RTSS.2010.43	embedded system;integrable system;uncertainty quantification;real-time computing;uncertainty;computer science;failure rate;reliability;life-critical system;static analysis;software quality	Embedded	-47.470132284916765	34.92677644578811	172952
32c27cd50f5bf372c8e7e72969616b776182e41e	opc server technology development in the system software integration	component object model;distributed component object model;system integration	The information system of comprehensive automation in enterprise is a complex system. The computer integrated plant automation is based on the realization of integration between control and management in the system. Therefore, the data access mechanism has to be established among devices, databases and application software in high efficiency and universal manner. Because of the variety of the devices and the non-compatibility of the drive programs, it is difficult to realize seamless integration among different systems. This paper made a brief discussion for information interconnection between field devices of control system and supervisory control systems and for key technique of the OPC in openness. © 2011 Springer-Verlag Berlin Heidelberg.	open platform communications;system integration	Yucheng Liu;Yubin Liu	2011		10.1007/978-3-642-23777-5_75	operating system;opc data access;system integration	SE	-35.391319470253265	38.56792728709718	173176
86a624aee8b51c7a74d07e18229be8a5fc057af4	semantic knowledge and service models for energy-aware systems		The energy domain is affected by digitalization like any other domain. Interoperability between the energy-aware devices and grid, and even market actors, are opening a vast amount of use-cases and business models for smart energy services and possibilities to make the systems more efficient. Related standards in the energy domain and neighbouring domains are numerous and knowledge modelling needs to take this already grounded work into account. This research shows how energy-related information and concepts, from weather and energy market information to sensor data, are semantically described and how services using the semantic information can manifest themselves in the same semantic way to be used in a network of energy awareness-related services.	context-aware pervasive systems	Jarmo Kalaoja	2017		10.1007/978-3-319-57186-7_38	natural language processing;semantic interoperability;semantic computing;knowledge integration;semantic search;semantic grid;knowledge management;mathematical knowledge management;knowledge-based systems;social semantic web;semantic web stack;database;semantic technology;semantic analytics	NLP	-43.111253657959224	45.41845562109163	173205
0313b64a2b9ebb03e3b398b2d28b5dd281c022c4	personal pervasive environments: practice and experience	health research;uk clinical guidelines;biological patents;europe pubmed central;pervasive computing;citation search;ami;uk phd theses thesis;life sciences;middleware;uk research reports;medical journals;europe pmc;biomedical research;operating systems;bioinformatics	In this paper we present our experience designing and developing two different systems to enable personal pervasive computing environments, Plan B and the Octopus. These systems were fully implemented and have been used on a daily basis for years. Both are based on synthetic (virtual) file system interfaces and provide mechanisms to adapt to changes in the context and reconfigure the system to support pervasive applications. We also present the main differences between them, focusing on architectural and reconfiguration aspects. Finally, we analyze the pitfalls and successes of both systems and review the lessons we learned while designing, developing, and using them.	abstraction layer;amiodarone;behavioral tic;cache;centralized computing;coda;coherence (physics);computation (action);computer programming;experience;medical device incompatibility problem;octopus, dietary;operating system;peer-to-peer;pervasive development disorder;pervasive informatics;plan 9 from bell labs;randomness;synchronization (computer science);synthetic intelligence;ubiquitous computing;chorioallantoic membrane	Francisco J. Ballesteros;Gorka Guardiola;Enrique Roberto Soriano	2012		10.3390/s120607109	context-aware pervasive systems;human–computer interaction;computer science;bioinformatics;engineering;electrical engineering;data science;middleware;data mining;ubiquitous computing	HCI	-38.72022258326085	41.730353673350145	173335
a9663908b2a2be51844af39caa716a9d01ab96da	toward a new landscape of systems management in an autonomic computing environment	product life cycle;common information model;description logic;system management;autonomic computing	In this paper we present IBM Tivoli Monitoring, a systems management application that displays autonomic behavior at run time, and we focus on extending it in order to encompass the design and the deployment phases of the product life cycle. We review the resource model concept, illustrate it with an example, and discuss its role throughout the product life cycle. Then we introduce basic concepts in ontology and description logics and discuss representing Common Information Model constructs using description logics. Finally, we propose Systems Management Ontology, an approach to enhancing the autonomic properties of IBM Tivoli Monitoring based on an ontology service and the technique of “contextual pulling” applied to the resource model.	autonomic computing;description logic;information model;run time (program lifecycle phase);software deployment;systems management	Giovanni Lanfranchi;Pietro Della Peruta;Antonio Perrone;Diego Calvanese	2003	IBM Systems Journal	10.1147/sj.421.0119	description logic;systems management;simulation;computer science;systems engineering;knowledge management;artificial intelligence;product lifecycle;database;autonomic computing	AI	-42.21314341082887	40.864059600164296	173524
bb81bde801f8dc9ad719e03169c1993168af2912	mirea: component-based middleware for reconfigurable, embedded control applications	control application;software;reconfigurable control;control systems;mirea middleware;nist;embedded control system;ucl;real time control systems library;discovery;theses;conference proceedings;remotely operated vehicles;object oriented programming;intelligent control;real time embedded control systems component based middleware reconfigurable control mirea middleware reusable design hierarchical design complex control systems c third party library national institute of standards and technology nist real time control systems library rcs library u s government driven intelligent control projects autonomous uav helicopters 4d rcs architecture;connectors;control system;autonomous uav helicopters;digital web resources;component based middleware;ucl discovery;complex control systems;open access;reusable design;real time embedded control systems;u s government driven intelligent control projects;real time control system;remotely operated vehicles control engineering computing helicopters intelligent control middleware object oriented programming real time systems;component model;middleware;middleware control systems real time systems unmanned aerial vehicles quality of service connectors software;ucl library;control engineering computing;book chapters;open access repository;rcs library;hierarchical design;quality of service;c;unmanned aerial vehicles;third party library;4d rcs architecture;helicopters;real time systems;ucl research;national institute of standards and technology	This paper presents the MIREA middleware and its support for reusable, reconfigurable and hierarchical design of complex control systems. We review the middleware's component model, key concepts and services, and its support for C++ plus its ability to integrate seamlessly with third-party libraries such as the National Institute of Standards and Technology (NIST)'s Real-Time Control Systems (RCS) library, which has been successfully used in many U.S government-driven intelligent control projects. We also present a case study based on control of our flock of autonomous UAV helicopters. This represents a challenging deployment scenario, but one for which the 4D/RCS architecture is designed and is well suited. Consequently, we discuss our approach to control using a fusion of RCS as a means of architecting a real time control system and MIREA as a means of realising that architecture. Our progress to date suggests that MIREA is indeed well suited as a middleware facilitating the construction of efficient, lightweight, and scalable real-time embedded control systems.	4d-rcs reference model architecture;autonomous robot;c++;component-based software engineering;control system;embedded system;flock;intelligent control;library (computing);middleware;real-time clock;real-time transcription;scalability;software deployment;unmanned aerial vehicle	Jagun Kwon;Stephen Hailes	2010	2010 IEEE International Symposium on Intelligent Control	10.1109/ISIC.2010.5612879	embedded system;real-time computing;simulation;real-time control system;engineering;real-time control system software	Embedded	-42.12023829776863	37.98453402699735	173559
58ae6b01eabbd0e066b8926f376424a565660601	a context-aware model for the management of agent platforms in dynamic networks		A network infrastructure in a mass casualty incident rescue scenario is normally characterized by multiple of working domains scattered over a wide area. For mobile agent systems working in these networks, the management of agent platforms contributes to achieving fault tolerance and reliability. We employ a honey bee inspired approach for imposing a self-organizing mechanism on the colony of mobile agent platforms. This paper presents our approach as well as introduces some preliminary evaluations of the proposed mechanism.	fault tolerance;mobile agent;organizing (structure);overhead (computing);requirement;self-organization;software framework	Phuong T. Nguyen;Volkmar Schau;Wilhelm Rossak	2013		10.1007/978-3-319-05939-6_8	simulation;engineering;operations management;computer security	Metrics	-38.79225398839955	44.6556305975222	173624
43236c451e6881010b5aecf04f1aee96ea0a96a1	a systemc-based modular design and verification framework for c-model reuse in a hw/sw-codesign design flow	hw sw co design;hardware design languages;verification framework;concurrent computing;hardware software codesign;design methodology software systems process design concurrent computing electrical equipment industry industrial control computer science hardware design languages time to market embedded software;system modeling;top down;hardware description languages;software systems;electrical equipment industry;system modelling;hw sw codesign;high level c models;process design;c language;formal verification;levels of abstraction;top down design methodology;model integration;top down design methodology systemc based modular design verification framework hw sw codesign system modeling high level c models c model integration hardware description language;industrial control;modular design;c model integration;time to market;computer science;hardware description language;c language hardware software codesign hardware description languages formal verification;systemc based modular design;embedded software;design methodology	Rising the level of abstraction in system modelling allows early verification of the system functionality, reducing the risk of long redesign cycles. Moving to a new flow introducing systemC as SDL allows the reuse of existing high-level C-models. A framework is presented that allows C-model integration and the connection of modules located at different levels of abstraction without the need to implement the communication or introduce adaptors to translate between the abstraction levels. The focus of the approach lies on high acceptance by the designers coming from a C and HDL based top-down design methodology.	design flow (eda);hardware description language;high- and low-level;modular design;principle of abstraction;systemc;top-down and bottom-up design	Ole Blaurock	2004	24th International Conference on Distributed Computing Systems Workshops, 2004. Proceedings.	10.1109/ICDCSW.2004.1284130	computer architecture;real-time computing;concurrent computing;computer science;hardware description language;programming language	EDA	-41.533939192586246	32.68452001830438	173906
89c09864b11d389b8eb268e013c1219bd941d7ad	the evaluation of high reliability in an autonomous decentralized ic card ticket system	railways;reliability;rail transportation;ic card;autonomous decentralized system;autonomous decentralized algorithm;suica system;autonomous decentralized data consistency technology;functional reliability;reliabilirty;maintenance cost;ic card reliabilirty autonomous decentralized system;customer satisfaction;decentralized system;wireless communication;east japan railway company;wireless communications;smart cards;passenger satisfaction;east japan railway company high reliability autonomous decentralized ic card ticket system automatic fare collection system passenger satisfaction maintenance cost reduction wireless communications autonomous decentralized architecture autonomous decentralized algorithm autonomous decentralized data consistency technology functional reliability suica system;high reliability;travel industry customer satisfaction railways reliability smart cards;maintenance cost reduction;autonomous decentralized architecture;rail transportation maintenance wireless communication automatic frequency control costs computer architecture manuals computer science data communication broadcasting;system development;autonomous decentralized ic card ticket system;automatic fare collection system;data consistency;high performance;travel industry	"""Both high performance and high reliability are necessary for the automatic fare collection system. The IC card ticket system, developed in order to improve the passengers' satisfaction and to reduce the maintenance costs, cannot avoid the requirements, either. However, this new system has a problem; high performance on wireless communications lowers reliability. The solutions are the """"autonomous decentralized architecture,"""" the """"autonomous decentralized algorithm,"""" and the """"autonomous decentralized data consistency technology."""" This paper introduces the """"autonomous decentralized data consistency technology"""" for high reliability and evaluates the effectiveness by the functional reliability, which depends on how many times this technology runs and how many data the IC card contains. The results show the decentralized processes competitive to the centralized processes under the particular conditions. These conditions are made use of the practical """"Suica"""" system at East Japan Railway Company and the system is running satisfactorily, without any fatal errors"""	algorithm;autonomous robot;centralized computing;garbage collection (computer science);requirement;smart card;subscriber identity module	Akio Shiibashi;Takeyuki Yajima;X J David Lu;Kinji Mori	2006	2006 International Symposium on Computer Networks	10.1109/ISCN.2006.1662535	embedded system;simulation;engineering;computer security	Arch	-35.334644235210014	36.888689030436495	174011
de8f016119debaaa80c1476826ac1f294a367171	a rt-maude-based framework for component installation	formal specification;real time installation;component deployment;rewriting logic;real time maude;critical systems	Real-time systems are considered in most cases as critical systems because they must strictly satisfy expected requirements in respect to giving timing constraints. The best way to develop and deploy these complex systems is the component-based software engineering. Traditionally, software components are developed independently and often considered as black boxes. However, they might be dependent from each other at assembly and deployment stages and used by a third party in various environments. In a previous work (Belguidoum et al., 2011), we have proposed a Maude-based framework for safe component installation. In this paper, we extend this work by taking into account real-time constraints for installation operation. This framework is implemented using Real-Time Maude system enabling both the real-time installation execution and its formal analysis using its LTL model checker.	black box;complex systems;component-based software engineering;critical systems thinking;maude system;model checking;real-time clock;real-time computing;real-time transcription;requirement;rewriting;simulation;software deployment;system deployment;user (computing);windows rt	Meriem Belguidoum;Faiza Belala;Fateh Latreche	2014	IJCCBS	10.1504/IJCCBS.2014.059590	embedded system;real-time computing;rewriting;computer science;systems engineering;operating system;formal specification;distributed computing;programming language;computer security	Embedded	-39.365050184689835	36.24596977988365	174027
75d90b0df34e128a25fad7ca9006bdf32c40f88a	verifying high-confidence interactive systems: electronic voting and beyond		Human interaction is central to many computing systems that require a high level of assurance. We term such systems as high-confidence interactive systems . Examples of such systems include aircraft control systems (interacting with a pilot), automobiles with self-driving features (int eracting with a driver), medical devices (interacting with a doctor), and electroni c voting machines (interacting with a voter). A major challenge to verifying the c orrect operation of such systems is that it is difficult to formally specify the hu man user’s view of correct operation and perception of the input/output inter face. In this paper, we describe a promising approach towards addressing this chal lenge that combines formal verification with systematic testing by humans. We de scribe an illustrative application of this approach to electronic voting in the U.S ., and outline directions for future work.	avionics;control system;cynthia dwork;distributed computing;formal verification;high-level programming language;holographic principle;indeterminacy in concurrent computation;input/output;interaction;interactivity;reflow soldering;state space;verification and validation;visual instruction set	Sanjit A. Seshia	2013		10.1007/978-3-642-35668-1_1	embedded system;simulation;computer science;theoretical computer science;data mining;distributed computing;computer security	HCI	-42.876349631087116	34.37625341912331	174304
8e74080d90a8afca8f9a1afbf33b43d452cba0f8	hardware in loop testing of an insulin pump	software;microcontrollers;pumps biomedical electronics biomedical equipment field programmable gate arrays jitter microcontrollers;testing;monitoring;insulin;microcontrollers hardware testing software insulin monitoring field programmable gate arrays;field programmable gate arrays;hardware;jitter hardware in loop testing insulin pump product development cycle safety critical device fault injection data corruption bit flip incorrect signal assertion hil testbed maestro modular architecture event driven operation time driven operation fpga microcontroller	System test plays a very important role in the product development cycle of a safety-critical device, such as an insulin pump. Given the significant risk of this device, fault-injection should be performed to validate dependable implementation under abnormal circumstances, namely: data corruption, bit flips, incorrect signal assertions and more. Clearly, a robust testbed is essential to create the required fault conditions at the system level. In this paper, we consider a Hardware-In-Loop (HIL) testbed to perform system testing of a prototype insulin pump. We compare different hardware and architecture possibilities for implementing the testbed and conclude that a modular architecture (MAESTRO), that combines event-driven and time-driven operations is most optimal. This testbed is implemented on an FPGA, providing better performance and feature sets, especially if systems with multiple microcontrollers are targeted. In particular, MAESTRO allows us to inject faults based on events, as opposed to faults scheduled for specific instants in time, which provided resilience to task jitter and software modifications.	algorithm;device under test;event-driven programming;fault injection;field-programmable gate array;hil bus;hardware-in-the-loop simulation;interaction;interrupt;microcontroller;new product development;processor register;prototype;responsiveness;system testing;testbed	Sriram Karunagaran;Karuna P. Sahoo;Masahiro Fujita	2015	2015 IEEE International Test Conference (ITC)	10.1109/TEST.2015.7342416	microcontroller;embedded system;electronic engineering;real-time computing;computer science;engineering;electrical engineering;operating system;software testing;field-programmable gate array;proinsulin	Embedded	-36.584149676187316	36.80797416813104	174634
eea57ea0a83c564b5323012e30cb68077ca428a2	research on component behavior protocols mismatch detection and limited assembly	software;protocols;formal specification;component interface automata;compounds;detection algorithms;runtime environment;distributed computing;component composition;system monitoring;effective specification method;object oriented programming;program verification;data mining;software engineering;component design;formal definition;component behavior protocol mismatch detection;component assembly;assembly;computerized monitoring;automata;software architecture;time factors;interaction compatibility software architecture component composition interface automata component behavior protocols;interface automata;software reusability;cognition;detection algorithm;runtime monitoring;reuse probability;automata theory;computer science;behavior protocols;interaction compatibility;component behavior protocols;reuse probability component behavior protocol mismatch detection component assembly effective specification method component design component verification method runtime monitoring time sequence constraint component interface automata formal definition;protocols assembly automata software engineering distributed computing computer science runtime environment computerized monitoring time factors detection algorithms;component verification method;system monitoring automata theory formal specification object oriented programming program verification protocols software reusability;time sequence constraint	As an effective specification method of supporting component design, assembly, verification and runtime monitoring, the component behavior protocol describes the time sequence constraints when the component interacts with its external environment dynamically. Using Interface Automata to describe component behavior protocol, the article proposes a formal definition and a detection algorithm thougths for behavior protocols mismatches which would occur when components assembled. Compared with existing research on the compatibility of component interaction, our work has considered control characteristics of component interfaces and different situations of interfaces bindings, therefore the compatible and incompatible parts of composite component behavior protocol can be accurately distinguished. Based on above work, a limited composition approach for components is proposed. Two incompatible components can be assembled as a composite component with limited behavior protocol but reliable and usable, the reuse probability of a component is increased accordingly		Jing-zhou Zhang;Hong-min Ren;Xiao-Kun Ge;Le-Qiu Qian;San-Yuan Zhu	2009		10.1109/SNPD.2009.83	communications protocol;system monitoring;software architecture;real-time computing;cognition;computer science;theoretical computer science;operating system;software engineering;automata theory;formal specification;component;assembly;distributed computing;automaton;programming language;object-oriented programming	Robotics	-40.16940063907217	36.15239931814833	174666
ab61606b7308d761673c73de00e2f217fab23df9	flow sensitive slicing for matlab/simulink models	simulink;analytical models;dependence analysis;public records;websearch;slicing;computational modeling;ikz120000;dependence analysis matlab simulink slicing;unified modeling language;matlab unified modeling language analytical models algorithm design and analysis computational modeling data models;ikz122810;software development flow sensitive slicing algorithm matlab simulink models bus capable blocks bus signals composite signal flow atomic signal flow program dependence graph data dependency relation;software tools mathematics computing modelling program slicing software engineering;algorithm design and analysis;matlab;rwth publications;data models	MATLAB/Simulink is a widespread tool for modelbased software development within the automotive domain. Industrial sized models developed with Simulink often contain more than 20000 blocks connected by complex dependency relations. Those relations are mostly concealed by architectural pattern within the model. Common tools to discover dependencies during model development/maintenance are static analyses and slicing algorithms. In this paper we present a flow sensitive definition of data dependence for Simulink models for the inclusion within such analyses. It is tailored to describe dependencies hidden by the architecture of the model. This includes the distinction of data dependencies of virtual from nonvirtual blocks, the impact of buscapable blocks and bus signals. When integrated into a slicing algorithm, the relation enables accurate tracing of the atomic and composite signal flow of a model via its program dependence graph. We evaluate the created slicing algorithm with models from industrial case studies against another approach from the literature. During the evaluation of the slicing algorithms we could observe a reduction of the average slice sizes by up to 66%, due to the inclusion of the proposed data dependency relation.	algorithm;architectural pattern;data dependency;debugging;dependence analysis;dependency relation;matlab;model viewer;program dependence graph;simulink;software development;stateflow;static program analysis;vii	Thomas Gerlitz;Stefan Kowalewski	2016	2016 13th Working IEEE/IFIP Conference on Software Architecture (WICSA)	10.1109/WICSA.2016.23	unified modeling language;data modeling;algorithm design;program slicing;public records;real-time computing;computer science;theoretical computer science;programming language;computational model;dependence analysis	SE	-40.02180731819601	32.42300787567626	174786
507361f318d4bf6bea050e3f8c69942be366d1fa	distributed and persistent mobile agents for heterogeneous personal communications systems	software portability;application migration;uniform migration wrapper;personal communication networks;portable file systems;application software;mobile agents mobile computing java operating systems application software personal digital assistants distributed computing portable computers computer architecture file systems;network operating systems;mobile agents;distributed computing;mobile computing system;mobile computer;portable file systems persistent mobile agents distributed mobile agents heterogeneous personal communications systems environment heterogeneity interoperability mobile computing platforms heterogeneous languages mobile code distributed mobile computing systems architecture portable environment small operating system pesos distributed persistent personal agents uniform migration wrapper;personal digital assistants;software agents;mobile computing platforms;computer architecture;software layer;heterogeneous personal communications systems;pesos;distributed mobile computing systems;operating system;distributed mobile agents;portable computers;file system;mobile code;heterogeneous languages;persistent mobile agents;personal communications systems;interoperability;mobile agent;mobile computing;open systems;architecture;portable environment small operating system;object oriented languages;personal communication system;object oriented languages open systems personal communication networks software agents network operating systems software portability;file systems;distributed persistent personal agents;environment heterogeneity;operating systems;java;persistent agents	Problems of environment heterogeneity and interoperability between dfferent mobile computing platforms are among the most urgent to address by the research community This paper proposes an environment, which supports migration of mobile code developed using heterogeneous languages. Current developments in the area of mobile code and distributed mobile computing systems are discussed and placed within the context of the proposed system The architecture behind the proposed Portable Environment Small Operating System (PESOS) provides an open platform for distributed persistent personal agents written using a variety of languages. Additionally, PESOS introduces and discusses the concept of a un form migration wrapper consisting of portable file systems (PFS) within which applications and data are em bedded	code mobility;forward secrecy;interoperability;mobile agent;mobile computing;open platform;operating system	Peter Stañski;Arkady B. Zaslavsky	1997		10.1109/ICCCN.1997.623321	software portability;embedded system;interoperability;application software;real-time computing;mobile search;computer science;architecture;operating system;mobile agent;distributed computing;java;mobile computing	OS	-33.84034418769778	44.87951076022986	175348
44ce40212d65ff64d14fc787a6c456b3a0f93c92	achieving interoperability through odp trading function	distributed processing distributed computing;iso standards distributed processing open systems;service provider;iso standards;reference model;distributed processing;distributed computing;policy differences interoperability odp trading function autonomous decentralized systems information service dynamic knowledge trading service open distributed processing reference model meta model heterogeneous distributed processing location transparency federation transparency service type differences;decentralized system;information service;open systems;meta model;open distributed processing	Interoperability between autonomous decentralized systems needs support of an information service that can provide dynamic knowledge about available service providers within the network. In this paper, we describe trading service. Trading is an essential infrastructure function indicated by ODP (Open Distributed Processing) reference model, a metamodel of heterogeneous distributed processing. The purpose of trading is to support location transparency of services: it hides the location of service providers, even if they are located in separate, autonomous domains. Cooperation between trading service providers (traders) supports federation transparency, i.e. hides diierences of technology used in separate domains. In cooperation , the traders have to mediate service type diier-ences, negotiate policy diierences and tolerate technology diierences between domains. Together with other fundamental functions trading ooers a platform for open distributed computing between autonomous subsystems .	autonomous decentralized system;autonomous robot;autonomous system (internet);distributed computing;interoperability;metamodeling;naruto shippuden: clash of ninja revolution 3;rm-odp;reference model;technical standard;trader media east;traders;trading room	Lea Kutvonen	1995		10.1109/ISADS.1995.398956	service provider;metamodeling;reference model;decentralised system;computer science;database;distributed computing;open system;world wide web;computer security;computer network	HPC	-35.211447408525075	44.95267311934004	175475
ed545c68efa1e3d7a8e3045ba3ee184849de85f6	experiences in managing energy with ecosystem	wireless sensor networks energy management systems power consumption operating systems computers battery management systems processor scheduling resource allocation mobile computing;processor scheduling operating system energy management resource management;mobile device;processor scheduling;resource allocation;resource manager;resource management;energy management systems;wireless sensor network;operating system;power management techniques mobile devices wireless sensor networks energy consumption systems design currentcy model energy centric operating system prototype ecosystem;energy consumption;system design;energy management ecosystems energy consumption batteries hardware operating systems power system management portable computers personal digital assistants cellular phones;power management;battery management systems;power consumption;mobile systems;mobile computing;operating systems computers;wireless sensor networks;energy saving;management policy;energy management	"""Mobile devices are becoming increasingly popular, from laptops, PDAs, and cell phones to emerging platforms such as wireless sensor networks. Available battery energy has become a critical mobile-system resource. A mobile device's usefulness is often limited not by its hardware's raw speed but by its battery's energy. Energy consumption is a major systems-design challenge. We designed our ECOSystem (Energy-Centric Operating System) prototype to manage energy consumption at the OS level, complementing existing power-management techniques, such as DVS and application adaptation. It's based on the ideas that energy management should be a system-wide effort, that we should explicitly recognize energy as a resource, and that we should unify energy management across the system. Even managing one hardware device might require coordination with other system components. Without unified management, application-level energy-saving efforts might not result in reduced energy consumption. ECOSystem incorporates the """"currentcy model"""", which lets the operating system manage energy as a first-class resource. It can also express complex energy-related goals and behaviors, leading to more effective, unified management policies."""	dynamic voltage scaling;ecosystem;laptop;mobile device;mobile phone;personal digital assistant;prototype	Heng Zeng;Carla Schlatter Ellis;Alvin R. Lebeck	2005	IEEE Pervasive Computing	10.1109/MPRV.2005.10	embedded system;real-time computing;simulation;wireless sensor network;computer science;resource management;operating system	Embedded	-37.95571672849722	46.01097236180027	175481
1bd4e46213124ec4378d0002a381e4a5b1555644	policy-based architectural adaptation management: robotics domain case studies	adaptive behavior;adaptive management;adaptive system	Robotics is a challenging domain that exhibits a clear need for self-adaptive capabilities, as self-adaptation offers the potential for robots to account for their unstable and unpredictable deployment environments. This paper focuses on two case studies in applying a policyand architecture-based approach to the development of selfadaptive robotic systems. We first describe our domain-independent approach for building self-adaptive systems, discuss two case studies in which we construct self-adaptive Robocode and Mindstorms robots, report on our development experiences, and discuss the challenges we encountered. The paper establishes that it is feasible to apply our approach to the robotics domain, contributes specific examples of supporting novel self-adaptive behavior, offers a discussion of the architectural issues we encountered, and further evaluates our general approach.	adaptive behavior;adaptive system;application domain;component-based software engineering;control system;control theory;np-completeness;nxt;programming game;rich internet application;robot;robotics;simulation;software deployment;software development;testbed	John C. Georgas;Richard N. Taylor	2009		10.1007/978-3-642-02161-9_5	control engineering;simulation;engineering;artificial intelligence	Robotics	-43.41584151664255	38.47184307717802	175531
02cd1a630806bb54b75f086820785db67018f169	simulation based validation of quantitative requirements in service oriented architectures	web services;digital simulation;program verification;software architecture;large service oriented architectures;model based analysis;quantitative requirements;service level agreements;simulation based validation	Large Service Oriented Architectures (SOAs) have to fulfill qualitative and quantitative requirements. Usually Service Level Agreements (SLAs) are defined to fix the maximal load the system can accept and the minimal performance and dependability requirements the system has to provide. In a complex SOA where services use other services and thus performance and dependability of a service depend on the performance and dependability of lower level services, it is hard to give reasonable bounds for quantitative measures without performing experiments with the whole system. Since field experiments are too costly, model based analysis, often using simulation is a reliable alternative. The paper presents an approach to model complex SOAs and the corresponding SLAs hierarchically, map the model on a simulator and analyze the model to validate or disprove the different SLAs.	dependability;experiment;maximal set;requirement;service-level agreement;service-oriented architecture;simulation	Falko Bause;Peter Buchholz;Jan Kriege;Sebastian Vastag	2009	Proceedings of the 2009 Winter Simulation Conference (WSC)		web service;reliability engineering;unified modeling language;data modeling;software architecture;field experiment;quality of service;computer science;systems engineering;software engineering;service-oriented architecture;semantics;particle detector	SE	-47.89369974086924	41.47846385761355	175569
9031a75f907c14fa1f3eb7e60bfa526507464e1b	software security: experiments on the .net common language run-time and the shared source common language infrastructure	developpement logiciel;shared source common language infrastructure;katholieke universiteit leuven;tecnologia electronica telecomunicaciones;common language infrastructure;computacion informatica;university curricula;programming language;securite informatique;net framework;net common language;infrastructure langage commun;partage ressource;software engineering;software engineers;sscli;rotor;computer scientists;computer security;secure software development course;software security;ciencias basicas y experimentales;desarrollo logicial;seguridad informatica;resource sharing;software development;particion recursos;net common language run time;tecnologias;educational courses security of data computer science education programming languages software engineering;katholieke universiteit leuven software security net common language run time university curricula computer scientists software engineers shared source common language infrastructure sscli secure software development course	As more and more software applications are directly or indirectly accessible from the Internet, the importance of the security of these applications grows steadily. Hence, it is important that university curricula for computer scientists and software engineers include courses on secure software development. Such courses should make students familiar with the programming language technology, runtime support and available API’s for security, and they should also teach them how to use these technological means appropriately. The .NET Framework is a good example of the current state-of-the-art support for secure development. The Shared Source Common Language Infrastructure (SSCLI) provides source for some of the security related aspects of the framework. This paper describes how the secure software development course at the Katholieke Universiteit Leuven uses the .NET Framework and the SSCLI. An overview is given of the contents of the course, and a number of example project assignments based on .NET or the SSCLI are presented.	.net framework;application programming interface;application security;common language infrastructure;computer scientist;computer security;experiment;internet;language technology;norm (social);programming language;software development;software engineer	Frank Piessens;Bart Jacobs;Wouter Joosen	2003	IEE Proceedings - Software	10.1049/ip-sen:20030985	software security assurance;shared resource;rotor;computer science;systems engineering;engineering;software framework;software development;operating system;software engineering;programming language	SE	-48.02879416286497	37.495969685217595	175821
796694f45b4aeee3dee2ed40f65c60f64edbd324	a human-centric framework for context-aware flowable services in cloud computing environments	context aware;human centric;flowable services;service integration	Services are expected to be a promising way for people to use information and computing resources in our emerging ubiquitous network society and cloud computing environments. In this study, we propose a metaphoric concept called a flowable service. It is defined as a logical stream that organizes and provides circumjacent services in such a way that they are perceived by individuals to be naturally embedded in their surrounding environments. We present our view on how some of these problems, such as the flexibility, portability and interoperability of services, can be solved using flowable services in order to provide a seamless integration of diverse services in the most intuitive ‘‘flowable’’ way possible, thus achieving maximum satisfaction for both service providers and consumers while decreasing the delivery cost of the services. Recognizing the importance of the awareness of each individual’s context for a smooth and accurate provision of services, we further propose a human-centric framework for context-aware flowable services, which harnesses the users’ contexts to enable a pro-active support of human activities in a flexible and natural way. Owing to context-awareness, this framework can find and integrate circumjacent services that are considered needed by each individual and can create an ambient service environment that is tailored to his/her specific needs, proclivities and characteristics. 2012 Elsevier Inc. All rights reserved.	cloud computing;context awareness;embedded system;interoperability;seamless3d;software portability;ubiquitous computing	Yishui Zhu;Roman Y. Shtykh;Qun Jin	2014	Inf. Sci.	10.1016/j.ins.2012.01.030	simulation;knowledge management;services computing;world wide web	HCI	-41.894725532788755	44.53086826755496	175895
25ac81cede3f07483c3d5776269af9bd8b14882b	reservation-based timing analysis -a practical engineering approach for distributed real-time systems	control systems;timing properties validation;system lifecycle;life cycle;real time;distributed processing;systems engineering;cost control;large scale distributed real time systems;cost control reservation based timing analysis large scale distributed real time systems system lifecycle industrial systems engineering process system development implementation stages in service upgrades timing properties validation incremental validation;systems engineering and theory;implementation stages;computer architecture;distributed real time system;industrial systems engineering process;aerospace electronics;timing analysis;system development;computer science;in service upgrades;reservation based timing analysis;incremental validation;real time systems timing systems engineering distributed processing;timing real time systems costs aerospace electronics large scale systems computer architecture hardware computer science systems engineering and theory control systems;large scale systems;hardware;real time systems;timing	This paper proposes a timing analysis technique that gives practical support to the industrial systems engineering process for large-scale, distributed real-time systems. The technique, known as reservation-based timing analysis (RBA), gives support throughout the lifecycle of the system, from the early stages of system development through to implementation stages and later in-service upgrades. RBA allows the timing properties of the system to be validated incrementally throughout system development and upgrade. This gives greater control over the costs associated with the development and upgrade of the real-time properties of the system.	distributed computing;end-to-end principle;entry sequenced data set;industrial engineering;real-time clock;real-time computing;real-time transcription;requirement;static timing analysis;system requirements;systems engineering	Alan Grigg;Neil C. Audsley	2001		10.1109/ECBS.2001.922411	embedded system;biological life cycle;real-time computing;simulation;computer science;systems engineering;engineering;control system;operating system;static timing analysis;system lifecycle	Embedded	-39.19082579447205	34.63258173431926	175964
0cafb8e739ff971dd1299122dbe4ea97e007a384	extending publish/subscribe mechanisms to soa applications	filtering;temperature sensors;system of systems;quality of service service oriented architecture system of systems temperature sensors monitoring filtering clouds;embedded systems;quality of service publish subscribe mechanisms soa applications arrowhead framework service oriented architecture event handler system arrowhead compliant installation message filtering historical data management;monitoring;conferenceobject;clouds;service oriented architecture embedded automation systems system of systems;quality of service;service oriented architecture;service oriented architecture message passing middleware;event handler systems	The Arrowhead Framework is a European effort that aims to apply Service Oriented Architecture to the embedded systems' world. The Event Handler system is a component that supports the handling of events, and in that sense it enriches service-oriented applications with the capabilities of interacting via the publish/subscribe paradigm. In fact, the Event Handler system is in charge of the notification of events that occur in a given Arrowhead compliant installation, manages producers and consumers of events, allows filtering of messages, and manages historical data regarding events. This latter capability is performed either on local files, on a database, or through another component of the Arrowhead Framework - the Historian system. The net result of the integration of the Event Handler in an Arrowhead Framework simplifies and empowers the communication of its components, as it is demonstrated in the paper with two examples: the management of application faults, and the support to quality of service of orchestrated services.		Michele Albano;Luis Lino Ferreira;Jose Sousa	2016	2016 IEEE World Conference on Factory Communication Systems (WFCS)	10.1109/WFCS.2016.7496528	embedded system;real-time computing;engineering;distributed computing	EDA	-39.24225550874986	41.47090784364053	176059
c519d4835e18b35291599db6c83e4ceba232f583	pipeline leak detection techniques	leak detection;cost effectiveness	Leak detection systems range from simple, visual line walking and checking ones to complex arrangements of hard-ware and software. No one method is universally applicable and operating requirements dictate which method is the most cost effective. The aim of the paper is to review the basic techniques of leak detection that are currently in use. The advantages and disadvantages of each method are discussed and some indications of applicability are outlined.	operating system;requirement;warez	Timur Chis	2009	CoRR		simulation;cost-effectiveness analysis;computer science;engineering;forensic engineering;computer security	SE	-43.15721460092047	35.607133065606185	176135
b049ba7d525b2cd81763a00ed0f62a9f05375e26	mobilescope: a programming language with objective mobility	distributed application;programming language;resource allocation;objective mobility mobilescope programming language channel mobility component based distributed application comet runtime system resource management resource binding;java mobile computing object oriented programming resource allocation;computer languages mobile computing runtime java application software information science resource management distributed computing programming profession;object oriented programming;runtime system;mobile computing;mobile application;java;mobile user	We present a new programming language, MobileScope, developed for the description of component-based distributed applications with extended support for mobility. The language and its underlying runtime system, Comet, support mobility in two flavors: physical mobility of components and virtual mobility of channels. Primarily, physical locations of components may be changed at runtime. We adopt an objective view that allows such moves to be triggered from outside the components. Moreover, the runtime systems support both weak and strong migration. We also introduce a virtual form of mobility for resource management. In MobileScope, resources are explicitly bound through channels on which components are connected dynamically. Resource bindings are thus changeable at runtime. We argue that the combination of these two mobility flavors, we name objective mobility, eases the development of applications with mobile users or devices, among other innovative mobile applications.	apl;component-based software engineering;computation;distributed computing;embedded system;experiment;java virtual machine;language construct;mobile app;operating system;pl/i;performance;programming language;run time (program lifecycle phase);runtime system;uniform resource identifier;π-calculus	Takashi Masuyama;Frédéric Peschanski;Yoshihiro Oyama;Akinori Yonezawa	2004	24th International Conference on Distributed Computing Systems Workshops, 2004. Proceedings.	10.1109/ICDCSW.2004.1284085	real-time computing;resource allocation;computer science;operating system;database;distributed computing;programming language;object-oriented programming;java;mobile computing	HPC	-37.121683407773766	40.5020924699275	176162
67c7f14cebd4418bb69c0e2fd4fd70f4211e113e	a woo based knowledge driven approach for smart home energy efficiency	semantic ontology iot woo virtualization wheems;open systems energy conservation home computing intelligent structures knowledge engineering ontologies artificial intelligence;ontologies energy efficiency knowledge based systems semantics energy consumption monitoring sensors;interoperability woo based knowledge driven approach smart home energy efficiency web of object woo based home energy efficiency management system wheems knowledge synchronization knowledge creation smart distributed applications semantic ontology model information reusability	Web of Object (WoO) based Home Energy Efficiency Management System (WHEEMS) synchronizes and creates knowledge on energy efficiency management through multiple types of objects VO and CVO. They will facilitate a composition and collaboration of smart distributed applications which combines information from different domains in the IoT infrastructure. WHEEMS focuses to support residents' comfort as well as save energy in the real environment. The realization of the smart home with energy efficiency provision, a conceptual semantic ontology model for the information reusability and interoperability among the VOs for creating ubiquitous services and the functional architecture for the WHEEMS have been presented.	distributed computing;home automation;inference engine;interoperability;knowledge base;management system	Muhammad Golam Kibria;Ilyoung Chong	2014	2014 International Conference on Information and Communication Technology Convergence (ICTC)	10.1109/ICTC.2014.6983081	engineering;knowledge management;data mining;world wide web	Robotics	-41.27209443082568	45.079401630942634	176241
da15f2cc1295b76ece75df5ab21fe8ef9f385ba0	a model for an adaptive scheduler	software metrics;pdl environment;adaptive control;system performance;program design languages;operating system;software reusability;design tools;user interaction	This paper reports on the design of a model for an adaptive scheduler of an operating system. The model is based on an adaptive control loop system in which the system's performance quality is evaluated by an index of performance, defined here as the users dissatisfaction time. At each user interaction, the system performs three basic functions: a) select the expected service type of user interaction based on a history of past interactions, b) assign a deadline for the system to respond to the user interaction, and c) modify (adapt) some parameters used in calculating the user's priority (using the system's history of previous services to the user) to reduce the probability of the user being dissatisfied in this interaction. We present here the algorithms necessary to implement this model. Numerical results from a simulation show that our adaptive scheduler is more efficient in minimizing the number of dissatisfied users than any other previously known method.	algorithm;control system;distributed operating system;emoticon;interaction;numerical linear algebra;operating system;requirement;response time (technology);responsiveness;scheduling (computing);simulation	Carlos Gonzalez;Kian Tavakoli	1988		10.1145/322609.322788	user interface design;embedded system;user;real-time computing;simulation;user modeling;adaptive control;computer science;operating system;database;software metric	OS	-43.06888831890728	35.033298777562386	176905
e28a8d4bb23cea52d243c239e2043c493c43ddb8	enhancements of pecos embedded real-time component model for autonomous mobile robot application	turing machines;resource constraint;application software;real time;mobile robots;autonomous mobile robot;wheeled mobile robot;qa75 electronic computers computer science;standards development;component model;predictive models;computer science;mobile robots embedded software application software java real time systems turing machines standards development predictive models laboratories computer science;embedded software;java;real time systems	Recent@, Component-Based Sof iare Enxineering (CBSE) has becoming a poptrlar approach.for developing embedded sofiare. In CBSE, a component model is required to specifY the standards and conventions imposed on developers of components. Indushial cornponent models such as CORBA, CUM and JavaBeans are general!^ not stritable for embedded real-time (ERT) Vstenis. Consequently, a number o f component models slritahle for CBSE ofERT so f iare such 0.7 PBO, Koala, PECOS and ReFIex are introduced. Assessments o f the PECOS component model were conducted to evaltrate the suitabiliw o f PECOS component model for adoption in CRSE o f autonomous mobile-robot (AMR) software. The as.~e.ssments emphasize on three requirentent.y: facilitates predictable real-time performance, support for resource constraint systems, and support plarfonn-independent implementation. Three enhancemenlr were proposed for the PECOS component model. These enhancements were implemented on a real m-wheeled mobile robot. and resul~f show that, the PECOS cornponent model together with the proposed modifications can generate application siritable for resource constrained AMR vstem.r, the new mapping of component behavior to tash process can be used to guarantee the nm-time predictabili(v and perjormance, and the new irnplenientation pamework proposed enable plarform independent development o f AMR sofiare.	adaptive multi-rate audio codec;autonomous robot;code;common object request broker architecture;component-based software engineering;electrical resistivity tomography;embedded system;mobile robot;oryx/pecos;plate boundary observatory;real-time clock;real-time locating system;real-time transcription;requirement;runtime system	Dayang N. A. Jawawi;Safaai Deris;Rosbi Mamat	2006	IEEE International Conference on Computer Systems and Applications, 2006.	10.1109/AICCSA.2006.205192	mobile robot;embedded system;application software;real-time computing;simulation;embedded software;computer science;turing machine;artificial intelligence;operating system;software engineering;component object model;database;predictive modelling;programming language;java;computer security	Robotics	-41.94183278779415	37.891835252562856	177201
4a544ab20ed7c5443e435f4b473c451176f2091f	a middleware for context-aware integration of power system software	context awareness;energy management systems;electric power transmission;middleware	Supervisory computer systems are crucial for electric utilities to monitor the performance of the power system, analyzing equipment safety and reliability, and helping system operators understand what is happening throughout the power network. Some of those systems need to be integrated in order to support the routine operations. In most cases, however, such integration is not automatic, requiring visual access to information displayed on different screens, inference about equipment status, retyping of common data between systems, and others. This study analyzed data from a large electrical power transmission company, and found that a significant number of maintenance requests, for example, are canceled due to typing errors or inconsistencies caused by the lack of context information. This paper presents the architecture of a context-aware middleware and a prototype implementation that allows the integration between a supervisory control and data acquisition system (SCADA), which monitors the power network in real time, and other power-system software applications. It is shown that the use of context awareness has enabled the handling of information in an integrated and flexible manner, helping users make consistent decisions in the planning and supervision of a power system without having to access different screens of the software applications involved.	context awareness;data acquisition;freedom of information laws by country;global variable;middleware;prototype;sysop	Jonysberg P. Quintino;Carlos A. G. Ferraz	2014		10.1145/2590651.2590672	embedded system;middleware;real-time computing;computer science;operating system;software engineering;middleware;database;electric power transmission;world wide web;computer security	OS	-35.60082552668763	38.93154759975959	177256
04fb18e6390487d8d01595ac144e4445b6066b48	robust architectures for embedded wireless network control and actuation	distributed control systems;fault tolerance;distributed systems;wireless sensor networks	Networked cyber-physical systems are fundamentally constrained by the tight coupling and closed-loop control of physical processes. To address actuation in such closed-loop wireless control systems there is a strong need to rethink the communication architectures and protocols for reliability, coordination, and control. We introduce the Embedded Virtual Machine (EVM), a programming abstraction where controller tasks with their control and timing properties are maintained across physical node boundaries and functionality is capable of migrating to the most competent set of physical controllers. In the context of process and discrete control, an EVM is the distributed runtime system that dynamically selects primary-backup sets of controllers given spatial and temporal constraints of the underlying wireless network. EVM-based algorithms allow network control algorithms to operate seamlessly over less reliable wireless networks with topological changes. They introduce new capabilities such as predictable outcomes during sensor/actuator failure, adaptation to mode changes, and runtime optimization of resource consumption. An automated design flow from Simulink to platform-independent domain-specific languages, and subsequently, to platform-dependent code generation is presented. Through case studies in discrete and process control we demonstrate the capabilities of EVM-based wireless network control systems.	algorithm;backup;code generation (compiler);control system;control theory;cyber-physical system;domain-specific language;embedded system;mathematical optimization;runtime system;simulink;virtual machine	Miroslav Pajic;Alexander Chernoguzov;Rahul Mangharam	2012	ACM Trans. Embedded Comput. Syst.	10.1145/2362336.2362349	embedded system;fault tolerance;real-time computing;wireless sensor network;computer science;operating system;distributed computing;distributed control system;key distribution in wireless sensor networks	Embedded	-42.587543288804916	38.2874987147418	177425
e324f1cc03c3430c6f9cd79b4a19938c4fb6bfc9	semantic web based self-management for a pervasive service middleware	owl;instruments;context information;self management context ontologies;ambient intelligence;pervasive computing;real time;open world assumption;ontologies artificial intelligence;pervasive service middleware;rule language pervasive service middleware semantic web based self management ambient intelligence self management context ontologies;semantic web middleware pervasive computing context aware services ambient intelligence ontologies monitoring performance evaluation scalability solids;rule language;semantic web;ubiquitous computing;middleware;ontologies;ubiquitous computing middleware ontologies artificial intelligence semantic web;quality of service;pervasive service middleware self management contect awareness semantic web;semantic web based self management;context modeling;self management;contect awareness	Self-management is one of the challenges for realizing ambient intelligence in pervasive computing. In this paper,we propose and present a semantic Web based self-management approach for a pervasive service middleware where dynamic context information is encoded in a set of self-management context ontologies. The proposed approach is justified from the characteristics of pervasive computing and the open world assumption and reasoning potentials of semantic Web and its rule language. To enable real-time self-management, application level and network level state reporting is employed in our approach. State changes are triggering execution of self-management rules for adaption, monitoring, diagnosis, and so on. Evaluations of self-diagnosis in terms of extensibility, performance,and scalability show that the semantic Web based self-management approach is effective to achieve the self-diagnosis goals, and lay a solid foundation for further self-management work.	ambient intelligence;dependability;extensibility;hydra (chess);iteration;middleware;ontology (information science);open-world assumption;openness;pervasive informatics;quality of service;real-time web;scalability;self-management (computer science);semantic web rule language;ubiquitous computing;web ontology language	Weishan Zhang;Klaus Marius Hansen	2008	2008 Second IEEE International Conference on Self-Adaptive and Self-Organizing Systems	10.1109/SASO.2008.14	semantic computing;context-aware pervasive systems;quality of service;ambient intelligence;open-world assumption;semantic grid;computer science;knowledge management;ontology;artificial intelligence;semantic web;social semantic web;middleware;semantic web stack;database;context model;world wide web;ubiquitous computing;semantic analytics	SE	-41.696628356480275	43.73627139576567	177537
7379cbebfcb425765edebaf791860fb70827fe5a	integration of heterogeneous context resources in ubiquitous environments	user mobility;context aware application;context awareness;protocols;context aware;context information;smart home;rest context awareness sca middleware integration ubiquitous computing heterogeneity;service component architecture;rest;integration;context protocols mobile handsets middleware smart homes context modeling component architectures;software architecture;context aware applications;ubiquitous computing home automation software architecture;smart home scenario heterogeneous context resources integration ubiquitous environments context aware applications user mobility device variability service component architecture representational state transfer;heterogeneous context resources integration;mobile handsets;ubiquitous environments;ubiquitous computing;middleware;sca;context aware systems;smart home scenario;context modeling;representational state transfer;context;heterogeneity;smart homes;home automation;component architectures;device variability	Ubiquitous environments provide families of context-aware applications that are capable of exploiting the user mobility as well as the device variability. Typically, these applications retrieve context information from local and remote providers and react accordingly to the detected variations. However, this must be done by considering the heterogeneity of devices and protocols found in ubiquitous environments. Unfortunately, although the context integration represents a keystone of context-aware systems, existing approaches in the literature fail to integrate the diversity of context sources in a standard and flexible way. Therefore, in this paper, we overcome this challenge by introducing resource-oriented bindings into the SCA (Service Component Architecture) model. This new kind of bindings follows the REpresentational State Transfer (REST) principles and leverages the provision of context as RESTful resources. A smart home scenario that highlights challenges in terms of integration in ubiquitous environments motivates the use of our approach.	context-aware pervasive systems;home automation;keystone effect;representational state transfer;service component architecture;spatial variability	Daniel Romero;Romain Rouvoy;Lionel Seinturier;Frédéric Loiret	2010	2010 36th EUROMICRO Conference on Software Engineering and Advanced Applications	10.1109/SEAA.2010.27	embedded system;home automation;real-time computing;computer science;operating system;software engineering;world wide web;ubiquitous computing	SE	-42.032198410143586	44.24600197123274	177578
c21621d0839162549a83ead0840ae0d4c4132195	open intelligent robot controller based on field-bus and rtos	agent based;mobile robot;real time operating system;distributed architecture	  Robot controller is one of the key facts affecting performance of robot. To meet the requirements of theoretical and application  research, a mobile robot controller based on CAN Bus and Real-time Operating System (RTOS) is presented. In hardware aspect,  a distributed architecture is achieved using CAN Bus and Bluetooth technology. Each module of the controller is integrated  into a multi-agent based architecture, and is implemented in RTOS in software aspect. A comprehensive illustration of ATU-II  mobile robot platform based on the proposed controller is presented and two experiments of ATU-II verify its performance.    	fieldbus;real-time operating system	Zonghai Chen;Haibo Wang	2008		10.1007/978-3-540-74972-1_22	control engineering;mobile robot;embedded system;real-time computing;robot control	Robotics	-34.41155762238964	37.5722497508178	177746
0fab8a9a4a0c87982cdb2975c3ff0d1d3b507721	df*: modeling dynamic process creation and events for interactive multimedia applications	df;specification level;data dependency;exceptions;formal specification;event handling;control flow environment;dynamical processes;resource management;home appliances;resumes;multimedia systems;interactive multimedia;mpeg 4 standard;event handling df dynamic process creation modelling interactive multimedia multimedia systems exceptions data dependency data flow processing control flow environment specification model specification level dynamic task management;media processing;dynamic process creation modelling;streaming media;data dependence;data flow processing;control flow;next generation;data flow computing;dynamic task management;streaming media multimedia systems home appliances laboratories resumes africa resource management hardware mpeg 4 standard context modeling;short period;data flow;task management;specification model;context modeling;africa;formal specification multimedia systems data flow computing;hardware	Modeling the next generation of multi-media systems requires handling non-synchronised event inputs from users, managing task sets that change over a short period of time, significantly larger computational demands that can be met with the available resources and the flexibility of a single hardware platform that can perform multi-media processing and rendering today and adapt to new standards as and when they are implemented. Modeling interrupts, exceptions, data dependency and non-determinism is required in addition to data flow processing which is controlled by a control flow environment. DF* is a specification model that addresses the features required to model all known aspects of multimedia systems at a specification level including events, dynamic task management and non-determinism. This paper explores the dynamic task management and event handling of DF* in the context of a particular application.	direction finding	Sias Mostert;Nathalie Cossement;Rudy Lauwereins;Jef L. van Meerbergen	2001		10.1109/IWRSP.2001.933849	embedded system;data flow diagram;real-time computing;computer science;resource management;operating system;software engineering;formal specification;database;context model;interactive media;programming language;control flow	HCI	-37.09130890086011	41.57927885856886	177877
13afbb21ca9a3c6ea35fad9f9e796b72d87576c8	improving the trustworthiness of service qos information in service-based systems	service composition;service based system;improving trustworthiness;service provider;user feedback;high quality workflow;service qos;quality of service qos;quality of service;service oriented architecture	Service-oriented architecture facilitates rapid development and management of large-scale distributed servicebased systems (SBS), where new workflows are composed of available services. Besides services’ capabilities, the qualities of services (QoS) also need to be considered in service composition in order to have high-quality workflows. The QoS profiles of services provided by their service providers may be inaccurate. In this paper, an approach is presented to improving the trustworthiness of the QoS information of services to facilitate the development of high-quality workflows in SBS. Our approach is based on identifying the deviation between the QoS profiles of the services claimed by their service providers and the QoS profiles determined by monitors and service user feedbacks. An example is given to illustrate the approach.	feedback;quality of service;service composability principle;service-oriented architecture;smart battery system;trust (emotion)	Stephen S. Yau;Jing Huang;Yin Yin	2010		10.1007/978-3-642-16576-4_15	service provider;service level requirement;service level objective;mobile qos;quality of service;service product management;differentiated service;computer science;basic service;service delivery framework;service-oriented architecture;service design;database;service desk;data as a service;customer service assurance;world wide web;computer network;service system	HPC	-47.86965331443038	43.25315791632264	177886
09a52c2601febd44a402195df383b58bb4fb5f24	a compositional approach for constructing connectors	databases;compositional approach;compositional interaction mechanism design;specialized interaction;protocols;independently developed parts;network operating systems;functional properties;kerberized rpc;interaction mechanism design;software systems;bridges;connector construction;client server systems;object oriented programming;component mismatches;mechanical factors;object oriented programming application program interfaces remote procedure calls network operating systems software architecture protocols;connectors;software architecture;generic support;application program interfaces;software reusability;publish subscribe;system developers;system development;connectors costs software systems publish subscribe databases data security bridges mechanical factors software reusability client server systems;remote procedure calls;specialized mechanisms;extra functional properties;data security;kerberized rpc compositional approach connector construction independently developed parts specialized interaction component mismatches extra functional properties interaction mechanism design system developers generic support specialized mechanisms compositional interaction mechanism design publish subscribe	Increasingly, systems are composed from independently developed parts, and mechanisms that allow those parts to interact (connectors). In many situations, specialized forms of interaction are needed to bridge component mismatches or to achieve extra-functional properties (e.g., security, performance, reliability), making the design and implementation of these interaction mechanisms a critical issue. Unfortunately, system developers have few options: they must live with available, but often inadequate, generic support for interaction (such as RPC), or they must handcraft specialized mechanisms at great cost. In this paper we describe a partial solution to this problem, whereby interaction mechanisms are constructed compositionally. Specifically, we describe a set of operators that can transform generic communication mechanisms (such as RPC and publish-subscribe) to incrementally add new capabilities. We show how these transformations can be used to realize complex interactions (such as Kerberized RPC) and to generate implementations of the new connector types at relatively low cost.	authorization;cliff shaw;consortium;dce/rpc;david w. bradley;heart rate variability;interaction;java message service;java remote method invocation;kerberos;prototype;publish–subscribe pattern;remote procedure call;semantics (computer science)	Bridget Spitznagel;David Garlan	2001		10.1109/WICSA.2001.948424	communications protocol;software architecture;real-time computing;computer science;software engineering;database;distributed computing;data security;publish–subscribe pattern;programming language;object-oriented programming;remote procedure call;software system	Networks	-34.83032590072255	41.60205360496697	177903
a85c9629875de9981551dc50cbe8e8ce8e889f6e	towards a verified component platform		This paper describes ongoing work on a new technique for reducing the cost of assurance of large software systems by building on a verified component platform. From a component architecture description, we automatically derive a formal model of the system and a semantics for the runtime behaviour of generated inter-component communication code. We can prove wellformedness properties of the architecture automatically and provide a framework in which users can reason about their component code and its behaviour. By leveraging the isolation properties and communication guarantees of a formally verified platform, correctness arguments for critical components will be able to be derived independently and composed together to reason about system-level correctness.	component-based software engineering;correctness (computer science);formal verification;inter-process communication;mathematical model;software system	Matthew Fernandez;Ihor Kuz;Gerwin Klein;June Andronick	2013		10.1145/2525528.2525535	reliability engineering;real-time computing;computer science;theoretical computer science	SE	-42.23907674419973	33.20847250923248	177984
07723bdb2c3d65005eede6e2ff392a17b6527d4e	on enhancing adaptive random testing for aadl model	analytical models;software;aadl;enhancing art;testing;software engineering;subspace constraints;trusted computing;computer architecture;program testing;unified modeling language;trustworthy computing aadl model complicated software large scale software software system model based software design model based testing enhancing adaptive random testing system architecture;model based testing;testing subspace constraints unified modeling language adaptation models software analytical models computer architecture;trusted computing program testing software engineering;adaptation models;aadl enhancing art model based testing	As the development of the large-scale and complicated software, especially in embedded system, non-functional properties of system, such as timing, reliability, safety and security, have become more and more important on impacting and restricting the behaviors of software system. One of the emerging challenges is how to test these properties in the phase of model-based software design. This paper aims to solve two essential problems in model-based testing: i) how to test model dynamically, ii) how to improve the efficiency of model-based testing. An enhancing adaptive random testing is investigated to generate test cases for AADL model-based testing in order to guarantee the system architecture and computing trustworthy. This methodology makes up the deficiency of adaptive random testing in dealing with the non-numeric data. A case study is presented and illustrates that its efficiency is higher than traditional random testing.	algorithm;angular defect;co-simulation;control system;convergence insufficiency;embedded system;iteration;level of measurement;model-based testing;random testing;simulation;software design;software system;systems architecture;test case;unified modeling language;unmanned aerial vehicle	Bo Sun;Yunwei Dong;Hong Ye	2012	2012 9th International Conference on Ubiquitous Intelligence and Computing and 9th International Conference on Autonomic and Trusted Computing	10.1109/UIC-ATC.2012.77	test strategy;unified modeling language;test data generation;real-time computing;model-based testing;orthogonal array testing;software performance testing;white-box testing;system integration testing;computer science;software reliability testing;operating system;functional testing;software testing;trustworthy computing;system testing;test management approach	SE	-47.42101548811309	32.96969833587655	178009
40c08489703f30c474ec8359247d47b2ba4c11db	global constraint checking at run-time	corba components global constraint checking large scale system self managing system model driven system management autonomous system monitoring distributed system;distributed system;autonomous system monitoring;management system;software management;system monitoring;large scale system;global constraint;program verification;autonomic system;dynamic environment;large scale;constraint handling;corba components;self managing system;system monitoring constraint handling large scale systems program verification software management;runtime unified modeling language control systems concrete large scale systems condition monitoring computerized monitoring fluctuations system testing prototypes;system management;global constraint checking;large scale systems;model driven system management	In large scale and self-managing systems the autonomy of the system has a major impact on the management of such systems. Even if the system can run in a high degree of autonomy a certain level of control over the properties of the system at run-time might be useful, to ensure the system does the right things. In particular, in dynamic environment, where system structure often changes it is desirable to monitor the status of a system to be sure it is still in a normal condition. This paper describes an approach how to use model driven system management for evaluation of global constraints. This allows an automatic or semi-automatic monitoring of autonomous systems, which helps to identify malfunction and wrong self-management of such systems. The approach has been used to check constrains on distributed system realized as CORBA components	autonomous system (internet);autonomy;common object request broker architecture;distributed computing;self-management (computer science);semiconductor industry;systems management	Christian Hein;Tom Ritter	2007	Eighth International Symposium on Autonomous Decentralized Systems (ISADS'07)	10.1109/ISADS.2007.41	system monitoring;real-time computing;systems management;computer science;management system;management	SE	-41.077247643906084	39.1196471802981	178114
58354a5693994539532a2c76945d79f22f3ccdf0	a framework for estimating the impact of a distributed software system's architectural style on its energy consumption	distributed application;distributed system;quality attributes;software systems;pervasive system;satisfiability;architectural styles;software architecture;quality requirement;software architecture energy consumption middleware;energy consumption;component based distributed systems architectural styles energy estimation;energy estimation;software systems energy consumption middleware software architecture application software connectors power engineering and energy energy measurement publish subscribe peer to peer computing;middleware;middleware platform distributed software system energy consumption architectural style mobile systems pervasive systems;component based distributed systems;energy estimate;architectural style	The selection of an architectural style for a given software system is an important factor in satisfying its quality requirements. In battery-powered environments, such as mobile and pervasive systems, efficiency with respect to energy consumption has increasingly been recognized as an important quality attribute. In this paper, we present a framework that (1) facilitates early estimation of the energy consumption induced by an architectural style in a distributed software system, and (2) consequently enables an engineer to use energy consumption estimates along with other quality attributes in determining the most appropriate style for a given distributed application. We have applied the framework on five distributed systems styles to date, and have evaluated it for precision and accuracy using a particular middleware platform that supports the implementation of those styles. In a large number of application scenarios, our framework exhibited excellent precision, in that it was consistently able to correctly rank the five styles and estimate the relative differences in their energy consumptions. Moreover, the framework has also proven to be accurate: its estimates were within 7% of the different style implementations ' actually measured energy consumptions.	distributed computing;list of system quality attributes;middleware;peer-to-peer;publish–subscribe pattern;requirement;software deployment;software system;ubiquitous computing	Chiyoung Seo;George Edwards;Sam Malek;Nenad Medvidovic	2008	Seventh Working IEEE/IFIP Conference on Software Architecture (WICSA 2008)	10.1109/WICSA.2008.28	embedded system;software architecture;real-time computing;computer science;engineering;software engineering;middleware;distributed computing;software system;satisfiability	SE	-40.59390042507613	40.80961019267136	178352
fae278fb95bf02a797e696ad40b459c6f5bfa971	context is key	multiscale resource;fixed set;interaction resource;ever-changing environment;predefined environment	Context is not simply the state of a predefined environment with a fixed set of interaction resources. It's part of a process of interacting with an ever-changing environment composed of reconfigurable, migratory, distributed, and multiscale resources.	interaction;reconfigurable computing	Joëlle Coutaz;James L. Crowley;Simon A. Dobson;David Garlan	2005	Commun. ACM	10.1145/1047671.1047703	real-time computing;computer science;distributed computing	HCI	-40.135072281677445	38.60390311303644	178466
4cfd324884a40d9a44143d6d393c6ef32d312743	designing a new real-time kernel with a hybrid scheduler	hybrid time triggered event triggered cooperative preemptive scheduler;event triggered scheduler;time triggered;kernel;embedded system computer architecture testing jitter kernel adaptation model software architecture;preemptive scheduling;automobiles;preemptive;sinewos;adaptive cruise control system real time kernel hybrid scheduler embedded systems time triggered scheduler event triggered scheduler sinewos lpc2129 hardware in the loop simulator;real time;adaptive control;adaptive cruise control system;automobiles adaptive control;testing;embedded system;real time kernel;cooperative;hybrid scheduler;hybrid;computer architecture;embedded systems;software architecture;adaptation model;adaptive cruise control;scheduler;time triggered scheduler;lpc2129;hardware in the loop simulation;hardware in the loop simulator;jitter;event triggered;high efficiency	Traditional embedded systems employ a time-triggered scheduler or an event-triggered scheduler, however, the truth is that time-triggered scheduling architecture is more dependable but lack of responsiveness to external events and event-triggered scheduling architecture is responsive. In order to get those advantages at the same time, a real-time kernel with a hybrid scheduler, named SinewOS, is developed. In SinewOS time-triggered scheduling and event-triggered scheduling are employed and in order to make this kernel more predictable and high efficient, then cooperative and preemptive scheduling approaches are adopted. The features and the implementation of SinewOS are described in detail. This new kernel has been successfully implemented on LPC2129. And to evaluate the performance of an embedded system employing SinewOS, a testing case is carried out with a simulation, which is a hardware-in-the-loop simulator and based on an adaptive cruise control system (ACCS) platform.	control system;embedded system;hardware-in-the-loop simulation;kernel (operating system);real-time clock;real-time transcription;responsiveness;scheduling (computing)	Qiang Huang;Xiaofeng Liang;Weihua Xu	2008	2008 International Conference on Embedded Software and Systems	10.1109/ICESS.2008.41	cooperative;fair-share scheduling;fixed-priority pre-emptive scheduling;embedded system;software architecture;scheduler activations;kernel;real-time computing;hybrid;jitter;adaptive control;dynamic priority scheduling;computer science;rate-monotonic scheduling;operating system;software engineering;two-level scheduling;software testing;preemption;lottery scheduling;kernel preemption;scheduling	Embedded	-34.2048812888621	37.72633129540134	178630
012cae6eedb6082dc974448eab8aaa73b1e01c21	getex: a tool for testing real-time embedded systems using can applications	out boundary priority;timing constraints;testing clocks timing automata real time systems cost accounting semantics;in boundary priority;getex;can real time embedded systems real time model based testing testing tool;clocks;real time;semantics;controller area networks;system under test;real time embedded system;testing;generation time;real time embedded systems;priority based approach;automata;embedded systems;cost accounting;software tools automata theory controller area networks embedded systems program testing;control area network;program testing;real time embedded system testing;can;priority based testing;boundary priority;boundary priority getex real time embedded system testing can priority based approach uppaal timed automata timing constraints out boundary priority in boundary priority priority based testing testing tool system under test control area network;automata theory;model based testing;uppaal timed automata;real time model based testing;testing tool;software tools;timed automata;real time systems;timing;time constraint	"""Real-Time Embedded Systems (RTES) have an increasing role in controlling the IT that we use on a day-to-day basis. The behaviour of an RTES is not based solely on the interactions it might have with its surrounding environment, but also on the timing requirements it induces. As a result, ensuring that an RTES behaves correctly is non-trivial, especially after adding time as a new dimension to the complexity of the testing process. In previous research, we introduced a 'priority-based' approach which tested the logical and timing behaviour of an RTES modeled formally as UPPAAL Timed Automata (UTA). The 'priority-based' approach was based on producing sets of timed test traces by achieving timing constraints coverage according to three sets of priorities, namely boundary, out-boundary and in-boundary. In this paper, we introduce a new testing tool 'GeTeX' that deploys the """"priority-based"""" testing approach. GeTeX is a complete testing tool which generates timed test-cases from UTA models and executes them on the System Under Test (SUT) to identify faults. In its current version, GeTeX supports Control Area Network (CAN) applications."""	embedded system;interaction;real-time clock;real-time operating system;requirement;system under test;test automation;test-driven development;timed automaton;tracing (software);uppaal	Mohammad Saeed Abou Trab;Steve Counsell;Robert Mark Hierons	2011	2011 18th IEEE International Conference and Workshops on Engineering of Computer-Based Systems	10.1109/ECBS.2011.25	embedded system;real-time computing;model-based testing;can bus;computer science;software engineering;automata theory;distributed computing;semantics;automaton;software testing;system under test;generation time;cost accounting	Embedded	-38.04145749002333	32.42730293037992	178924
658cc17d3b75b74827c12ec50d93a17cb9f067e2	self-adaptive middleware for digital ink based applications	distributed application;self adaptive middleware;adaptive middleware;real time;distributed multimedia;specification language;modeling language;mobile environment;reflective middleware;execution environment;error rate;middleware;quality of service;dynamic adaptation;adaptive architecture;digital ink	Some aspects of the mobile environment, like lower bandwidth and higher error rates, can affect distributed applications that have real-time requirements. In order to maintain the quality of service expected by such applications, a middleware platform can monitor its execution environment and perform dynamic adaptations on its structure and behavior. To do this, the middleware must know which QoS attributes affect the application and act in accordance with policies described in a specific language. In this paper we propose a self-adaptive architecture, based on the Meta-ORB approach, which uses adaptation policies described in the same modeling language used for the definition of middleware configurations. The paper also presents a study on the use of this architecture for applications based on digital ink.	adaptive architecture;bandwidth (signal processing);distributed computing;middleware;modeling language;quality of service;real-time clock;real-time computing;requirement	Lucas Luiz Provensi;Fábio M. Costa;Vagner Jose do Sacramento Rodrigues	2008		10.1145/1462716.1462721	embedded system;middleware;real-time computing;computer science;message oriented middleware;middleware;distributed computing	Embedded	-40.1668752592986	40.706112624582644	178990
95eba858ce9be745534df6825cf467a2a0378a53	adaptive and reflective middleware for qos-enabled ccm applications	configuration decision;qos-enabled ccm applications;qos property;corba messaging;applications flexibly;conventional ccm implementations focus;corba component model;reflective middleware;dre application;real-time corba;adaptive qos;qos requirement	Existing middleware specifications, such as Real-Time CORBA and CORBA Messaging, address many quality-of-service (QoS) properties by defining policies that control connection multiplexing, request priority, queuing order, routing, and dependability. They do not, however, define strategies for configuring these QoS properties into applications flexibly, transparently, and adaptively. Application developers must therefore make these configuration decisions manually. This process is tedious and error-prone, and suboptimal for complex distributed realtime and embedded (DRE) systems. Although the recently adopted CORBA Component Model (CCM) defines a standard configuration framework for packaging and deployingsoftware components, conventional CCM implementations focus on functionality rather than adaptive QoS, which makes the CCM currently unsuitable for DRE applications withdemanding QoS requirements.	middleware;quality of service	Nanbor Wang;Douglas C. Schmidt;Michael Kircher;Kirthika Parameswaran	2001	IEEE Distributed Systems Online	10.1109/MDSO.2001.4	world wide web;implementation;computer science;quality of service;real-time computing;adaptive quality of service multi-hop routing;distributed computing;common object request broker architecture;dependability;middleware;multiplexing	Embedded	-40.303984776211735	40.772481371508796	179077
88bcd73df2cdb2ecb77e87faa1036c6c0dfd2615	y distributed application platform	distributed application;distributed computing;y;applications platform;infrastructure	Motto: Q: Why is it called Y? A: Y not?#R##N##R##N#The main rationales and design concepts for the ‘Y’ system, which is currently under development are presented. Y provides a platform for the development of distributed applications in a cooperative, heterogenous, open environment. This environment can be characterized as a ‘service market’ where different service providers offer different services in different locations at different costs and qualities. In the Y architecture, four planes are identified, and the solutions adopted for each plane are outlined.		Radu Popescu-Zeletin;Volker Tschammer;Michael Tschichholz	1991	Computer Communications	10.1016/0140-3664(91)90062-6	real-time computing;simulation;computer science;distributed computing;close front rounded vowel	Mobile	-35.596876573201314	43.680004745783364	179136
0fb7e2e92c354ac3cefd3995121d6c9658207717	safety-oriented design of component assemblies using safety interfaces	front end;scade;automotive industry;component based systems;safety properties;automatic generation;safety interfaces;engineering and technology;component based system development;teknik och teknologier;process support;safety;safety critical system;fault modes;datavetenskap datalogi;model based development;component model;computer science;formal analysis;component assemblies;adaptive cruise controller;compositional reasoning	This paper promotes compositional reasoning in the context of safety-critical systems, and demonstrates a safety-oriented component model using an application from the automotive industry: an Adaptive Cruise Controller (ACC). The application consists of four components for which a set of 18 fault modes have been identified. We show the impact of all single faults and double faults selected from this set, on a safety property associated with the ACC assembly. Analysis related to each fault mode is performed using compositional rules and derived safety interfaces for each component. The derivation of safety interfaces for the ACC components has been supported by implementation of two extensions to the SCADE tool set: (1) a front end that iteratively and automatically builds the environment in which the component is resilient in presence of a given fault, (2) fault mode libraries that can be reused for modeling several classes of faults affecting the input of a component. The result of the study is the illustration of system level safety in presence of certain single and double faults, based on compositional reasoning and the automatically generated interfaces. The component model uses reactive modules as the formal notation. The instantiation of the model in terms of modules specified in SCADE provides a link between formal analysis of components in safety-critical systems and the traditional engineering processes supported by model-based development.	assembly language;component-based software engineering;fault tolerance;integrated development environment;lars bak (computer programmer);library (computing);model-driven engineering;reactive programming;refinement (computing);shortest seek first;universal instantiation	Jonas Elmqvist;Simin Nadjm-Tehrani	2007	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2006.09.031	real-time computing;simulation;computer science;automotive industry;front and back ends;component object model;model-based design	SE	-43.010103102410646	32.88467939189126	179384
4e3fbdf94d4681686149a752ed6c4e392ced8ab0	modeling and verification of train safety comprehensive monitoring system using temporal petri nets	concurrent system train safety comprehensive monitoring system temporal petri net temporal logic;temporal logic;monitoring system;concurrent systems;temporal logic railway safety petri nets;railway safety petri nets logic rail transportation condition monitoring computers computerized monitoring information analysis infrared detectors information security;railway safety;petri nets;petri net	Petri nets and temporal logic are efficient tools to study concurrent systems, but each has their own shortages. Thus, we introduce temporal Petri nets to model, analyze and verify train safety comprehensive monitoring system. On one hand, we describe frameworks of this system using Petri nets. On the other hand, we use temporal logic to describe temporal relationships of system states. Then, we analyze and verify the properties of model and conclude that the system is reliable and effective.	petri net	Yanhua Du;Lifeng Ai;Chunhuang Liu	2005		10.1109/GRC.2005.1547327	real-time computing;simulation;computer science;artificial intelligence;process architecture;petri net	SE	-45.67625182158835	33.98993549369647	179529
003cf8e77e20028eeaf022d8183f10f764cf45cc	challenges in the formal verification of complete state-of-the-art processors	hardware verification;formal verification process design hardware visualization microprocessors computer science productivity automation digital systems scalability;formal verification microprocessor chips;formal method;formal verification;development methodology;vampexplorer formal hardware verification processor designs vamp design complexities;microprocessor chips	Research on formal hardware verification has made steady progress in developing methodologies and tools that try to cope with the growing complexities of systems. Despite of case studies that demonstrate the applicability of formal methods to selected contemporary processor designs, the current state in formal hardware verification is far from being considered practical for systems of the complexity of complete contemporary processor designs. It is our goal to improve the practicality of current formal verification methods for complete state-of-the-art processor designs. The recent success in the complete formal verification of the VAMP can be considered pioneering for reaching design complexities close to this range. We dissect the VAMP verification effort in detail with the goal to identify the main technical and organizational challenges and the major productivity bottlenecks of the verification process. This is done in particular to search for opportunities of increased levels of automation. As part of our efforts we are developing the VAMPExplorer, a tool that provides an intuitive interface to the specification, the implementation and the verification of the VAMP. The VAMPExplorer visualizes the general implementation and verification structure and improves accessibility to expert and non-expert users.	accessibility;benchmark (computing);central processing unit;electronic design automation;formal methods;formal verification;graphical user interface;processor design;reference design;schematic;vamp	Nathaniel Ayewah;Nikhil Kikkeri;Peter-Michael Seidel	2005	2005 International Conference on Computer Design	10.1109/ICCD.2005.37	computer architecture;verification;formal methods;formal verification;software verification;computer science;theoretical computer science;formal specification;formal equivalence checking;high-level verification;runtime verification;programming language;intelligent verification;functional verification;computer engineering	EDA	-36.78019526947165	33.12518371503309	179595
dd9d49444f1efc88c3bf4d118557ba54ddabdf22	qos mechanism composition at design-time and runtime	message passing middleware distributed object management specification languages quality of service network operating systems;network operating systems;specification languages;distributed object management;qos management;message passing;net qos mechanisms runtime adaptation message passing middleware uml;on the fly;middleware;runtime quality of service middleware reflection unified modeling language sections fault tolerance computer architecture availability process design;quality of service	In this paper we present a model-driven approach to the composition of QoS mechanisms. The support of multiple QoS categories as well as runtime adaptation requires the ability to change the message path of a middleware on the fly. This leads to a new set of problems regarding the composition of individual mechanisms to a functioning message path. Especially the order in which messages are passed through the QoS mechanisms is of great importance. We show how QoS mechanisms and their composition constraints can be modeled using the UML. Furthermore, a mapping from these UML models to our .NET Remoting based QoS management framework DotQoS is presented.	.net remoting;adaptive system;distributed computing;microsoft outlook for mac;middleware;model-driven architecture;model-driven engineering;on the fly;platform-independent model;platform-specific model;quality of service;unified modeling language	Andreas Ulbrich;Torben Weis;Kurt Geihs	2003		10.1109/ICDCSW.2003.1203542	message passing;real-time computing;mobile qos;quality of service;computer science;operating system;middleware;database;distributed computing;programming language;computer network	Embedded	-37.9476676598739	39.825950306845115	179866
53217ba8aa579dce468b3e2b3750a55769e4752e	"""""""self-healing"""": softening precision to avoid brittleness: position paper for woss '02: workshop on self-healing systems"""	sufficient correctness;self healing systems;environmental change;software utility theory;software homeostasis;utility theory	Modern practical computing systems are much more complex than the simple programs on which we developed our models of dependability. These dependability models depend on precise specifications, but it is often impractical to obtain precise specifications of practical software-intensive systems. Furthermore, the criteria for acceptable behavior vary from time to time and from one user to another. When development methods are based on the classic models that assume precise specifications, the resulting systems are often brittle --- they are vulnerable to unexpected conditions and hard to tune to changing expectations. Practical systems would be better served by development models that recognize the variability and unpredictability of the environment in which the systems are used. Such development methods should pursue not the absolute criterion of correctness, but rather the goal of fitness for the intended task, or sufficient correctness. They should accommodate environmental unpredictability not only by reactive mechanisms, but also by design that produces resilience to environmental change, or homeostasis. In many cases, this resilience may be achievable by relaxing tolerances in the specifications, thereby enlarging the envelope of acceptable operation.	correctness (computer science);dependability;heart rate variability;homeostasis;softening	Mary Shaw	2002		10.1145/582128.582152	reliability engineering;systems engineering;engineering;operations management	SE	-44.17616775777408	38.37329115910791	179884
829975fe0dabf79869ae142aedc36d5352de400a	component-based workspace awareness support for composite web applications	mashups;workspace awareness;widgets;collaboration	Universal Composition is a promising way to support the long tail of user needs. While most mashup platforms only support single-user scenarios, CRUISE enables the reconfiguration of multi-user mashups during runtime. A major requirement for tool-supported collaboration is the provision of workspace awareness, e. g., about all participants' current activities or rights. With respect to the synchronization of black-box components from different vendors, detecting and representing state changes is far from trivial. To provide adequate workspace awareness, we present an architecture and a widget-based presentation concept. It supports application independent detection of state changes, reusability in different application contexts and flexible reconfigurability during runtime. Thereby, semantic annotations are used to enable component state change replication in case of different underlying DOM representations and provide awareness support in form of semantic activities instead of technical descriptions. The practicability of our prototype, including six widgets, is validated by a user acceptance test.	acceptance testing;black box;long tail;mashup (web application hybrid);multi-user;prototype;reconfigurability;scenario (computing);sensor;web application;workspace	Gregor Blichmann;Carsten Radeck;Sergej Hahn;Klaus Meißner	2015		10.1145/2837185.2837219	simulation;computer science;multimedia;world wide web;engineering support	HCI	-41.212976912879995	41.578826620847565	179922
05ca42c2103e88829b8dfde92b4d32ee633a8c50	evaluation of embedded system energy usage with extended uml models		Energy consumption as an increasingly important decision criterion has to be included in the search for good architectural and design alternatives to make an embedded system as energy-efficient as possible. The proposed method describes a system with dedicated extended UML models for applications and hardware components and evaluates the energy use via a transformation into an analyzable stochastic Petri net.	embedded system;stochastic petri net;unified modeling language	Dmitriy Shorin;Armin Zimmermann	2013	Softwaretechnik-Trends		reliability engineering;embedded system;uml tool;systems engineering;applications of uml	EDA	-41.54583937450496	33.91765713288229	180141
75c1a827bba894ab143a7a62087453e7e39a5b0a	dynamic adaptation of service compositions with variability models	verification;models at runtime;articulo;web service composition;constraint programming;dynamic software product line;variability;dynamic adaptation;autonomic computing	Web services run in complex contexts where arising events may compromise the quality of the whole system. Thus, it is desirable to count on autonomic mechanisms to guide the self-adaptation of service compositions according to changes in the computing infrastructure. One way to achieve this goal is by implementing variability constructs at the language level. However, this approach may become tedious, difficult to manage, and error-prone. In this paper, we propose a solution based on a semantically rich variability model to support the dynamic adaptation of service compositions. When a problematic event arises in the context, this model is leveraged for decision-making. The activation and deactivation of features in the variability model result in changes in a composition model that abstracts the underlying service composition. These changes are reflected into the service composition by adding or removing fragments of Business Process Execution Language (WS-BPEL) code, which can be deployed at runtime. In order to reach optimum adaptations, the variability model and its possible configurations are verified at design time using Constraint Programming. An evaluation demonstrates several benefits of our approach, both at design time and at runtime.	autonomic computing;business process execution language;cognitive dimensions of notations;constraint programming;heart rate variability;run time (program lifecycle phase);service composability principle;spatial variability;web service	Germán H. Alférez;Vicente Pelechano;Raúl Mazo;Camille Salinesi;Daniel Diaz	2014	Journal of Systems and Software	10.1016/j.jss.2013.06.034	constraint programming;real-time computing;verification;simulation;computer science;operating system;database;programming language;autonomic computing	SE	-41.18753352774959	38.381323104026166	180171
ea97f23dc2addf5d4c4580ed161b2f399873306c	discrete event simulation as a means of validating jsd design specifications	simulation;environmental parameter;embedded system;embedded systems;cost effectiveness;validation;discrete event simulation	It is difficult to visualize the behaviour of an embedded system in its operational environment from a specification of the system alone. However, it is unacceptable to wait for system completion before validating its behaviour. Discrete event simulation is an effective technique for making quantitative predictions about system behaviour, provided that the model is derived carefully from the system specification. We summarize the steps involved in deriving an Ada** simulation program from a JSD function step specification, using a lift system as an illustration. Having used this technique, we conclude that while it is time-consuming and not amenable to automation in the near future, it is cost-effective because it helps to elucidate counter-intuitive interactions between system functions and environmental parameters.	ada;embedded system;interaction;jackson system development;simulation	Colin Potts;A. Bartlett;B. H. Cherrie;Roy MacLean	1985			real-time computing;simulation;cost-effectiveness analysis;computer science;systems engineering;discrete event simulation	SE	-43.08773142010598	35.28316990056814	180182
a678d912d2e57a469888bf82ba1c89641f384f80	transparent shaping of existing software to support pervasive and autonomic computing	generic model;adaptive middleware;program families;separation of concern;adaptive behavior;dynamic environment;aspect oriented programming;adaptive applications;software development;middleware;development time;dynamic adaptation;autonomic computing;component based design;generic programming	The need for adaptability in software is growing, driven in part by the emergence of pervasive and autonomic computing. In many cases, it is desirable to enhance existing programs with adaptive behavior, enabling them to execute effectively in dynamic environments. In this paper, we propose a general programming model called  transparent shaping  to enable dynamic adaptation in existing programs. We describe an approach to implementing transparent shaping that combines four key software development techniques: aspect-oriented programming to realize separation of concerns at development time, behavioral reflection to support software reconfiguration at run time, component-based design to facilitate independent development and deployment of adaptive code, and adaptive middleware to encapsulate the adaptive functionality. After presenting the general model, we discuss two specific realizations of transparent shaping that we have developed and used to create adaptable applications from existing programs.	autonomic computing;noise shaping;pervasive informatics	Seyed Masoud Sadjadi;Philip K. McKinley;Betty H. C. Cheng	2005	ACM SIGSOFT Software Engineering Notes	10.1145/1082983.1083086	real-time computing;simulation;aspect-oriented programming;separation of concerns;computer science;component-based software engineering;software development;adaptive behavior;middleware;distributed computing;programming language;generic programming;autonomic computing	SE	-40.772353006242646	40.04452775984953	180432
d092ac948edb76957643d261a6ad17cc0f2c2be4	improving maintenance processes with distributed monitoring systems	production facilities cloud computing condition monitoring cyber physical systems maintenance engineering production engineering computing;computer architecture;condition monitoring;monitoring;production facilities;condition monitoring monitoring automation computer architecture production facilities;centralized distributed system maintenance processes distributed monitoring systems industrial production systems process control condition monitoring industry 4 0 cyber physical systems modular web based framework production facilities decentralized distributed system standardized communication protocols semantic information models node js opc ua protocol cloud based services;automation	Industrial production systems meet strict requirements regarding availability, process control and condition monitoring. As a key enabler of Industry 4.0, cyber-physical systems form the core of a modular, web-based framework, which delivers more efficient condition monitoring mechanisms for maintenance staff in production facilities. The present approach illustrates the potential of a decentralized and centralized, distributed system by using standardized communication protocols and semantic information models. The use of web-based platforms like node.js and protocols such as OPC UA offers the ability to automate transferring information about anomalies, root causes and nominal data directly between cloud-based services and condition monitoring systems on the shop floor. To conclude, a validation is accomplished within a case study on a flexible handling unit.	centralized computing;cloud computing;complex event processing;cyber-physical system;distributed computing;industry 4.0;information model;level of measurement;node.js;opc unified architecture;open platform communications;requirement;software system;user agent;user interface;web application	Hans Fleischmann;Johannes Kohl;Jörg Franke;Andreas Reidt;Markus Duchon;Helmut Krcmar	2016	2016 IEEE 14th International Conference on Industrial Informatics (INDIN)	10.1109/INDIN.2016.7819189	reliability engineering;real-time computing;systems engineering;engineering	SE	-35.678858082458284	39.13261182757208	180552
98b53a136898f5339dcdf7beb2c33901279d1cf1	platform for security-aware design of human-on-the-loop cyber-physical systems		Cyber-Physical Systems (CPS) are commonly supervisory control systems where a human-on-the-loop (HOL) supervises one or more autonomous systems, while embedded autonomy allows the operators to intermittently attend to the system and other tasks. Thus, it is imperative that the design of any security-aware CPS considers the impact of the human interaction with the system on security guarantees. Yet, there has been very little work on design of Human-CPS that promotes human situational awareness for enhanced system performance, particularly in terms of cyber-physical security and real-time defense against attacks. One of the main obstacles to the rapid advancement of this field is the scarcity of testbeds for evaluating security-aware Human-CPS interactions. We present RESCHU-SA, an extendable virtual platform that facilitates studying the impact that HOL has on security of CPS with varying levels of autonomy. It allows users to analyze how inductive reasoning and ability to provide context, particularly during an attack, affects the overall CPS security guarantees. The proposed platform is an extension of the Research Environment for Supervisory Control of Heterogeneous Unmanned Vehicles (RESCHU) simulation environment, previously used in various applications including studies focused on supervising Unmanned Aerial Vehicles (UAVs) missions and evaluation of interface usability.	cyber-physical system	Mahmoud Elfar;Haibei Zhu;Adithya Raghunathan;Yi Y. Tay;Jeffrey Wubbenhorst;Mary L. Cummings;Miroslav Pajic	2017			embedded system;simulation;engineering;cyber-physical system;computer security	EDA	-45.24362670266353	38.027460695262015	180603
4107220dc5ea02dc81f16e85675a8ec70817898d	a robot software middleware based on the opros and the rtx	engines real time systems middleware service robots semantics;opros robot middleware realtime rtx;semantics;service robots;engines;middleware;robots control engineering computing middleware operating systems computers;realtime robot application robot software middleware opros intervalzero rtx open platform for robotic services robot software platform hardware device components software algorithm components ms windows general purpose operating system realtime operating system;real time systems	The OPRoS(Open Platform for Robotic Services) is a robot software platform to operate hardware device components and software algorithm components in order to perform given tasks effectively. But, the OPRoS cannot support hard real time in the MS Windows due to limit of general purpose operating system that aims at efficiency of overall processes. IntervalZero's RTX transforms Windows into a real time operating system. This paper introduces a robot software middleware that support to develop real-time robot application using OPRoS component model on the RTX.	algorithm;component-based software engineering;microsoft windows;middleware;open platform for robotic services;rtx, rtx64;real-time computing;real-time operating system;real-time transcription;robot software	Byoungyoul Song;Choulsoo Jang;Sunghoon Kim;Hoon Choi	2014	2014 11th International Conference on Ubiquitous Robots and Ambient Intelligence (URAI)	10.1109/URAI.2014.7057459	embedded system;middleware;real-time computing;computer science;operating system;middleware;semantics	Robotics	-33.73628513212074	38.28964187041339	180606
97c2378077f6d378d3e1cca015deef4171332c24	context constraints for compositional reachability analysis	state space reduction;distributed system;labeled transition system;computer model;context constraints;labeled transition systems;concurrency;client server;compositional techniques;validation;state explosion;distributed systems;static analysis;behavior analysis;reachability analysis	Behavior analysis of complex distributed systems has led to the search for enhanced reachability analysis techniques which support modularity and which control the state explosion problem. While modularity has been achieved, state explosion in still a problem. Indeed, this problem may even be exacerbated, as a locally minimized subsystem may contain many states and transitions forbidden by its environment or context. Context constraints, specified as interface processes, are restrictions imposed by the environment on subsystem behavior. Recent research has suggested that the state explosion problem can be effectively controlled if context constraints are incorporated in compositional reachability analysis (CRA). Although theoretically very promising, the approach has rarely been used in practice because it generally requires a more complex computational model and does not contain a mechanism to derive context constraints automatically. This article presents a technique to automate the approach while using a similar computational model to that of CRA. Context constraints are derived automatically, based on a set of sufficient conditions for these constraints to be transparently included when building reachability graphs. As a result, the global reachability graph generated using the derived constraints is shown to be observationally equivalent to that generated by CRA without the inclusion of context constraints. Constraints can also be specified explicitly by users, based on their application knowledge. Erroneous constraints which contravene transparency can be identified together with an indication of the error sources. User-specified constraints can be combined with those generated automatically. The technique is illustrated using a clients/server system and other examples.	client (computing);computation;computational model;credit bureau;distributed computing;observational equivalence;reachability;server (computing)	Shing-Chi Cheung;Jeff Kramer	1996	ACM Trans. Softw. Eng. Methodol.	10.1145/235321.235323	computer simulation;real-time computing;concurrency;computer science;theoretical computer science;distributed computing;static analysis;client–server model	SE	-35.28906581662048	33.76951780010146	180835
20da8dc9e9e849ec829ce34283472e719d8be660	pairwise testing of dynamic composite services	random sampling;software systems;web service;qos;sampling technique;pairwise testing;service oriented computing;web services;data quality;crisis management;model composition;dynamic behavior	Online services encapsulate enterprises, people, software systems and often operate in poorly understood environments. Using such services in tandem to predictably orchestrate a complex task is one of the principal challenges of service-oriented computing. A composite service orchestration soliciting multiple atomic services is plagued by a number of sources of variation. For instance, availability of an atomic service and its response time are two important sources of variation. Moreover, the number of possible variations in a composite service increases exponentially with increase in the number of atomic services. Testing such a composite service presents a crucial challenge as its often very expensive to exhaustively examine the variation space. Can we effectively test the dynamic behavior of a composite service using only a subset of these variations? This is the question that intrigues us. In this paper, we first model composite service variability as a feature diagram (FD) that captures all valid configurations of its orchestration. Second, we apply pairwise testing to sample the set of all possible configurations to obtain a concise subset. Finally, we test the composite service for selected pairwise configurations for a variety of QoS metrics such as response time, data quality, and availability. Using two case studies, Car crash crisis management and eHealth management, we demonstrate that pairwise generation effectively samples the full range of QoS variations in a dynamic orchestration. The pairwise sampling technique eliminates over 99% redundancy in configurations, while still calling all atomic services at least once. We rigorously evaluate pairwise testing for the criteria such as: a) ability to sample the extreme QoS metrics of the service b) stable behavior of the extracted configurations c) compact set of configurations that can help evaluate QoS tradeoffs and d) comparison with random sampling.	data quality;diagram;emoticon;list of code lyoko episodes;online and offline;orchestration (computing);procedural generation;quality of service;response time (technology);sampling (signal processing);service-oriented device architecture;service-oriented modeling;software system;spatial variability	Ajay Kattepur;Sagar Sen;Benoit Baudry;Albert Benveniste;Claude Jard	2011		10.1145/1988008.1988028	real-time computing;computer science;data mining;world wide web	Web+IR	-45.88558865000403	40.80756471660189	181228
b9f24efcaea3e523fcb6932131dd3bf9f0364862	reliability properties assessment at system level: a co-design framework	hw sw co design;hardware software co design;system specification;partitioning;hardware fault detection;design framework;fault detection;design methodology	This paper introduces an enhanced hardware/software co-design framework allowing the designer to introduce hardware fault detection properties in the system under consideration. By considering reliability requirements at system level, within a hw/sw co-design flow, it is possible to evaluate overheads and benefits of different solutions. System specification, hardware and software concurrent fault detection design methodologies and hw/sw partitioning are the three key factors taken into account. The paper discusses these aspects providing a complete overview of the reliability co-design project.		Cristiana Bolchini;Luigi Pomante;Fabio Salice;Donatella Sciuto	2002	J. Electronic Testing	10.1023/A:1015047524985	embedded system;computer architecture;real-time computing;design methods;computer science;engineering;system requirements specification;fault detection and isolation;software fault tolerance	SE	-42.209457570785595	34.87218941248234	181871
e874ebbffd3107f68076228b1ac0ed6902b75e10	tool-supported refinement of high-level requirements and constraints into low-level policies	model design;policy enforcement;formal specification;management system;model based management;policy;tool support;system modeling;refinement;ambient assisted living;formal verification;healthcare system;model based management policy refinement;software component;graphical model;event condition action;constraint handling;mobasec tool supported refinement high level requirements low level policies automated technical management distributed ambient assisted living healthcare systems low footprint management system software components three layered system model service infrastructure policy enforcement policy refinement graphical modeling tool;point of view;service oriented architecture;use case;management policy;service oriented architecture constraint handling formal specification formal verification health care;health care;unified modeling language software training object oriented modeling concrete runtime process control	In the context of the automated technical management of distributed ambient-assisted-living healthcare systems, we employ high-level policies which describe the abstract requirements of the system from the use cases point of view. At runtime, an efficient low-footprint management system is used which executes low-level management rules of the event-condition-action type. The rules represent the low-level management policies. They monitor the status variables of the software components and change the settings of their configuration variables in order to enforce the high-level requirements. We report on the automated, tool-supported refinement of these policies which is based on a three-layered system model. The top layer reflects the use cases, the middle layer the service infrastructure, and the bottom layer the actual software and hardware components. The automated refinement exploits the model and its refinement relations which associate system elements with all those elements representing them on the next lower model layer. Moreover, the automated refinement is controlled by refinement, evaluation, and control pattern instances introduced by the model designer in order to supply the policy refinement and the policy enforcement with ``ideas'' to be applied. The paper outlines our management approach and the graphical modeling tool MoBaSeC. The focus is set on the policy refinement functions and on the utilization of refinement, evaluation, and control patterns.	byte;component-based software engineering;configuration management;control flow;declarative programming;event condition action;exploit (computer security);graphical user interface;high- and low-level;imperative programming;java bytecode;layered system;mbm (file format);point of view (computer hardware company);principle of abstraction;refinement (computing);requirement;run time (program lifecycle phase);service-level agreement	Oliver Dohndorf;Jan Krüger;Heiko Krumm;Christoph Fiehe;Anna Litvina;Ingo Lück;Franz-Josef Stewing	2011	2011 IEEE International Symposium on Policies for Distributed Systems and Networks	10.1109/POLICY.2011.32	reliability engineering;computer science;systems engineering;database	Embedded	-45.75077054523114	42.555227478336164	181924
f942537c446c9a53296031d9c77a70bd420bf72d	executable test sequence for the protocol data flow property	executable test sequence;protocol data flow property;data flow	Bluetooth test solutions all in one – from development to conformance testing R&S PTW60 applications ◆ Integral component in the development of protocol layers, profiles and applications ◆ Transparent integration of Bluetooth components ◆ Approved reference for protocol and profile conformance tests Main functions ◆ Reference implementation of baseband, LM, L2CAP in master and slave mode ◆ Simulation of a Bluetooth pico-network ◆ Automatic generation of executable test cases from official test vectors issued in TTCN by Bluetooth Special Interest Group (SIG) ◆ Support of official conformance tests for baseband, LM, L2CAP, GAP, SDP and SPP ◆ Powerful test script package for easy analysis of implementation under test (IUT) ◆ Comprehensive choice of problem-oriented analysis tools (PCOs, MSCs, TTCN traces) ◆ Flexible internal and external programming interfaces for adaptation to special measurement tasks	algorithm;baseband;bluetooth;conformance testing;dataflow architecture;directed graph;executable;integer programming;linear programming;microsoft cluster server;reference implementation;route inspection problem;self-propelled particles;simulation;test case;test script;tracing (software);verification and validation	Wen-Huei Chen	2001			data flow diagram;real-time computing;computer science;database;programming language	SE	-36.11971187159584	34.660518779862734	181933
bbc5dafe09c67ea4a07b6573021f4d36acf2a895	managing infinite variability in mobile terminal software	variability management;mobile terminal software;product family architecture;mobile terminal	ly speaking, most of the problems analyzed in the previous sections have one common solution: separating behavior from appearance or, in other words, enabling the decoupling of components from their environment. In our case we have several layers of decoupling. An example of a small system is shown in Figure 5, which illustrates the concepts we have been discussing so far, and indicates some of the variability points and how they impact on the rest of the software. As a client application runs, the current variation set determines its functionality. In practice, the client implements the behavior of a feature. A typical client interacts with the user by means of the display server, which manages the placement of the various UI components in the display. The client utilizes a set of display components to show its data. Such components implement the appearance of the feature. In practice, we decouple the client from the physical input and output (keypad and display). This way, changes in the appearance do not reflect into the behavior, and vice versa. Abstractly speaking, the behavior defines the datamanipulation functionality, while the appearance represents the data visualization. This design pattern is also known as the observer pattern [9,10]. Copyright c © 2005 John Wiley & Sons, Ltd. Softw. Pract. Exper. 2005; 35:513–537 528 A. MACCARI AND A. HEIE	client (computing);cocktail shaker sort;complexity;coupling (computer programming);data visualization;display server;heart rate variability;input/output;interaction;john d. wiley;mobile phone;mutual exclusion;observer pattern;overhead (computing);ripple effect;server (computing);software architecture;software design pattern;software system;spatial variability;systems architecture;terminal emulator;user interface	Alessandro Maccari;Anders Heie	2005	Softw., Pract. Exper.	10.1002/spe.645	mobile search;simulation;computer science;engineering	SE	-34.365243226059185	41.120568241749126	182167
3b5f1951d74b819cac783a9f12b90ccac08d7f5c	ease standard compliance by technical means via mils		You have to develop an embedded system? You need to show its conformance to a safety standard (e.g. IEC 61508, ISO 26262, DO-178) or a security standard (e.g. IEC 62443, Common Criteria)? How does your life get easier by using a MILS design? Using an embedded operating system can help with modularization. Moreover, a *MILS* embedded operating system isolates processes and their resources from each other. Resource management and information flow control enable separation in time and separation in space. In this paper we show standard compliance work units that MILS helps achieving by	a* search algorithm;common criteria;conformance testing;embedded operating system;embedded system;multiple independent levels of security;non-interference (security);standards-compliant	Sven Nordhoff;Holger Blasum	2017		10.5281/zenodo.571175		Security	-47.455475576854795	37.60998007909035	182318
2282ffbf8070d011d4591638c98d216b2897b875	a component framework for document-centric network processing	document handling;component development language software components document centric network processing content based network processing mobile agent technology application specific network processing gui manipulations java;mobile agents;object oriented programming;graphical user interfaces;component framework;agent technology;java distributed computing mobile agents protocols electronic mail computer networks workflow management software informatics assembly graphical user interfaces;object oriented programming document handling graphical user interfaces java mobile agents;java	A component framework for defining content-based network processing is presented. It is unique among other existing approaches because it enables contents to naturally define their own processing and end-users to easily define network processing. By using it, we can dynamically make an enriched document as a nested composition of software components corresponding to various content, e.g., text, images, and windows. It enables each component or document to migrate over a network under its own control by using mobile agent technology. Moreover, it introduces components as carriers or forwarders because it enables them to carry or transmit other components as first class objects to other locations. It offers several basic operations for network processing, e.g., forwarding, duplication, and synchronization. It allows end-users to easily define their own content-based or application-specific network processing by assembling these components in through GUI manipulations. This paper describes the framework and its implementation, which currently uses Java as the implementation language as well as a component development language, and then illustrates several interesting applications that demonstrate its utility and flexibility	component-based software engineering;first-class function;graphical user interface;java;microsoft windows;mobile agent;network processor;object language	Ichiro Satoh	2007	2007 International Symposium on Applications and the Internet	10.1109/SAINT.2007.5	real-time computing;computer science;operating system;graphical user interface;database;programming language;object-oriented programming;java;world wide web	OS	-35.85337196976405	42.445664929801545	182371
11d66f7de6c6ad5ef5940ff521e6b49f9a058f46	a flexible run-time support for distributed dependable hard real-time applications	runtime application software fault tolerance timing real time systems rockets aerospace control power generation stock markets automotive engineering;off the shelf hardware;automotive engineering;flexible run time support;operating system kernels distributed processing fault tolerant computing real time systems;fault tolerant;application software;rockets;transparent provision;real time;real time kernels;distributed processing;runtime;stock markets;fault tolerant computing;application domain;aerospace control;strict timing constraints;application domains;fault tolerance;specialized hardware;power generation;fault tolerant mechanisms;run time support;distributed dependable hard real time applications;operating system kernels;alternative approach;off the shelf;real time kernels flexible run time support distributed dependable hard real time applications application domain non reusable solutions specialized hardware alternative approach flexible run time support off the shelf hardware strict timing constraints fault tolerance transparent provision fault tolerant mechanisms run time support application domains;non reusable solutions;hard real time;real time systems;timing	Typically, most distributed, dependable, real-time systems designed in the past can only meet the particular requirements of the application domain to which they were targeted. This approach led to specific, non-flexible, dedicated and non-reusable solutions, often based on specialized hardware. This paper presents an alternative approach where a flexible run-time support for distributed dependable hard real-time applications is built on top of off-theshelf hardware. This support has been designed by considering three fundamental and complementary aspects: realtime, to support applications that exhibit strict timing constraints;fault-tolerance, to provide a high degree of reliability through the transparent provision of fault tolerant mechanisms; andflexibility , to allow the modifications of components of the run-time support without having to rewrite it entirely, and to support a large range of application domains, real-time kernels and hardware.	atm turbo;application domain;central processing unit;dependability;differential analyser;dynamical system;fault model;fault tolerance;multicast;prototype;real-time clock;real-time computing;real-time operating system;real-time transcription;replication (computing);requirement;rewrite (programming);run time (program lifecycle phase);scheduling (computing);worst-case execution time	Emmanuelle Anceaume;Gilbert Cabillic;Pascal Chevochot;Isabelle Puaut	1999		10.1109/ISORC.1999.776398	embedded system;fault tolerance;real-time computing;computer science;operating system;distributed computing;programming language	Embedded	-35.1042470141113	38.19570006517086	182442
054c12ea8f230f8eb3bc35f4cbe049e22df23640	scheduler for automatic management of maintenance jobs in large-size systems: a case study applied to smart city		Maintenance of systems such as infrastructure, services and equipment on city context requires a complex management process in order to provide quality services, comply with regulations and extend lifespan of urban equipment and infrastructure without neglecting the proper use of resources to execute maintenance jobs. Cities can generate hundreds or thousands of maintenance jobs during a particular time period. These jobs can be generated automatically by equipment or can be reported by citizens/users. This work introduces a scheduling architecture for automatic management of maintenance jobs. The proposal is able to handle preventive and corrective maintenance jobs looking for available human and instrumental resources during the common time period required by the job to be executed. The scheduler uses intelligent strategies to satisfy constraints of each job in order to get a scheduling according to the criterion of the manager of maintenance. A case study is applied to smart city.	scheduling (computing);smart city	Rafael Jesús Valdivieso Sarabia;Oscar Marín-Alonso;Fernando G. Guerrero-Gómez;Francisco Javier Ferrández Pastor;Jerónimo Mora Pascual;Juan Manuel García Chamizo	2017		10.1007/978-3-319-67585-5_6	smart city;architecture;computer science;real-time computing;scheduling (computing);corrective maintenance;management process	Logic	-42.262667561986916	41.30730437646402	182564
97189189d9ee0a4620c76551ed5bdfa50322bd52	concurrency in a decentralized automatic regression test selection framework for web services	software testing;regression testing;service provider;software agent;web service;web services;safe regression test selection;service oriented architecture;distributed algorithm;business process;fault location	Business processes can be realized by utilizing many different Web services directly or indirectly in workflows which may be internal or external to the enterprise. Since service-oriented architecture allows service providers to modify the underlying implementation of a service at any time, a new set of challenges arise in software testing, especially regression testing. In this work, a framework which automates a key tenet of regression testing, safe regression test selection, for Web services in a decentralized, end-to-end manner using service monitoring will be presented. Any such system must be capable of handling multiple concurrent modifications and the main contribution of this work is defining and resolving those challenges related to concurrency in a framework for automating a decentralized, end-to-end, safe regression testing technique being applied to Web services. The challenges which will be discussed include coverage conflict, fault locatability, test inconsistency, and communication errors. A solution in the form of software agents following a predetermined distributed algorithm will also be presented.	concurrency (computer science);distributed algorithm;end-to-end principle;regression testing;service-oriented architecture;service-oriented infrastructure;software agent;software testing;web service	Michael Ruth	2008		10.1145/1341811.1341820	web service;reliability engineering;system integration testing;computer science;service delivery framework;software reliability testing;cloud testing;data mining;database	SE	-46.66467426931429	41.02756249052836	182758
f93462075deefa7e2f7997d4a424cb680354a598	armiscom: self-healing service composition		In the domain of the service composition, the failure of a service generates error propagation in the other services, and therefore, it can generate the failure of the entire system. Usually, these failures cannot be detected and corrected only with local information. Normally, it is required the development of architectures that enable the diagnosis and correction of faults, both locally (elementary service) as well as globally (service composition). This paper presents a reflexive middleware architecture based on autonomic computing, which allows the distributed diagnosis of faults in the service composition, called ARMISCOM. This middleware has not a central diagnoser, instead the diagnosis of failures is carried out through the interaction of local diagnosers present in each service of the composition. These local diagnoses use a distributed chronicle approach proposed in previous works, which allows the recognition of fully distributed patterns of the classic failures in the SOA systems. In addition, the repair strategies are defined through consensus of the repairers, equally distributed between the services of the composition. The repair strategies use the concept of “equivalent regions” defined in this paper, for the fault correction in a SOA application.	autonomic computing;middleware;propagation of uncertainty;service composability principle;service-oriented architecture;software propagation	Juan Vizcarrondo;José Aguilar;Ernesto Exposito;Audine Subias	2017	Service Oriented Computing and Applications	10.1007/s11761-017-0217-x	autonomic computing;self-healing;real-time computing;distributed computing;fault tolerance;computer science;architecture;composition (visual arts);autonomous system (internet);middleware	HPC	-44.006674273258064	42.24191355110768	182953
0504d31acb21286a14a6d0075f2ce9861db29034	compositional timing analysis	timed systems;compositional generation;abstraction;timing analysis;component model;timed automata;reachability analysis	We develop and implement a methodology for automatic abstraction of systems defined as networks of timed components modeled by timed automata. The abstraction technique yields an abstract model with much less clocks and states which over-approximate the timed behavior of the concrete system. Using this technique we can analyze timed system of size beyond the capabilities of contemporary analysis tools for timed automata.	approximation algorithm;automata theory;static timing analysis;timed automaton;timed event system;type system	Ramzi Ben Salah;Marius Bozga;Oded Maler	2009		10.1145/1629335.1629342	real-time computing;computer science;component object model;distributed computing;abstraction;timed automaton;static timing analysis;algorithm	Embedded	-38.74400024532643	32.63051915669823	182973
1debda86580f2471e69cfbc733eac3e7d185a4a4	mapping aadl models to a repository of multiple schedulability analysis techniques	analytical models;architectures materielles;aadl models mapping mosart model temporal analysis semantic sensitivity analysis worst case response time schedulability analysis temporal requirements architecture analysis and design language scheduling analysis real time systems modeling;job shop scheduling;biological system modeling;computer architecture;specification languages formal specification real time systems scheduling software architecture;analytical models real time systems biological system modeling computer architecture timing job shop scheduling;real time systems;timing	To fill the gap between the modeling of real-time systems and the scheduling analysis, we propose a framework that supports seamlessly the two aspects: (1) modeling a system using a methodology, in our case study, the Architecture Analysis and Design Language (AADL), and (2) helping to easily check temporal requirements (schedulability analysis, worst-case response time, sensitivity analysis, etc.). We introduce the usefulness of an intermediate framework called MoSaRT, which supports a rich semantic concerning temporal analysis. We show with a case study how the input model is transformed into a MoSaRT model, and how our framework is able to generate the proper models as inputs to several classic temporal analysis tools.	architecture analysis & design language;best, worst and average case;mosart;real-time clock;real-time computing;real-time transcription;requirement;requirements analysis;response time (technology);scheduling (computing);scheduling analysis real-time systems;semantics (computer science)	Yassine Ouhammou;Emmanuel Grolleau;Jérôme Hugues	2013	16th IEEE International Symposium on Object/component/service-oriented Real-time distributed Computing (ISORC 2013)	10.1109/ISORC.2013.6913214	embedded system;job shop scheduling;parallel computing;real-time computing;simulation;computer science;operating system;distributed computing;programming language	Embedded	-39.73999582948796	33.16280025394109	183409
3c72d5ac87ecce412f3422fed834f2fd384fddb6	a framework for cps modeling and verification based on dl		With the development of sensor network and embedded system, CPS integrating computation, communication and control is becoming the focus of attention gradually. Obvious problems have emerged when CPS applying to various industries. It is crucial that the designed CPS can work as expect. A growing number of researchers are concerned about the property verification of CPS since verification technique has played a key role in improving the security and reliability of systems. It is a commonly used method that transforming generic model to formal model for verification. A formal method of theorem proving has well applied to verify CPS based on differential dynamic logic which operating model named Hybrid Program proposed by A. Platzer. This paper introduced HybridUML to model CPS, presented a method based on model transformation which mapped from HybridUML to Hybrid Program, and verified a case study with the resulting model finally.	automated theorem proving;computation;embedded system;expect;formal language;formal methods;key;model transformation;operating model;systems design;unified model;unified modeling language	Ying Zhou;Xufang Gong;Bixin Li;Min Zhu	2018	2018 IEEE/ACIS 17th International Conference on Computer and Information Science (ICIS)	10.1109/ICIS.2018.8466460	wireless sensor network;operating model;unified modeling language;computation;automated theorem proving;theoretical computer science;formal methods;model transformation;computer science;dynamic logic (digital electronics)	EDA	-44.18309331386729	35.5899723274398	183503
87fd696010b0216176e322be4183dea5fa76b8a0	early safety analysis	fmea;agile development;safety analysis	In this paper, we discuss how to use available information to get an early start on safety analysis in an agile setting, based on the early, high level requirements and early system sketches. We suggest that this can be done by using existing generic failure modes for FMEA, domain specific fault trees and hazard lists plus generic architectural patterns. The paper gives a short presentation of the methods and some examples from the analysis of a fire alarm system.	agile software development;architectural pattern;byzantine fault tolerance;failure cause;failure mode and effects analysis;fault tree analysis;hazard (computer architecture);high-level programming language;requirement	Tor Stålhane;Thor Myklebust	2016		10.1145/2962695.2962714	reliability engineering;systems engineering;engineering;operations management	SE	-46.96450629741747	32.409486913008614	183674
32c4d6f2a726fa5e767cb7cb5e47ca53407f6de4	a protocol based approach to specifying interoperability between objects	legacy software;components interoperability;protocols software systems computer architecture software reusability software maintenance computer science object oriented modeling operating systems nasa contracts;formal specification;interfaces;software maintainability protocol based approach object interoperability software modules legacy software software reuse software components specification object oriented systems function level signature matching data encapsulation procedural programming interoperable component model software reusability;signature matching;software maintenance object oriented programming formal specification software reusability open systems data encapsulation;software maintenance;software systems;object oriented programming;data encapsulation;behavior specification;object oriented systems;software reusability;software development;software component;component model;open systems;protocol compatibility;object oriented paradigm	Interoperability is the ability of two or more software modules to communicate and cooperate with each other. The interoperability problem arises when software developers want to reuse legacy software systems, or when software systems are componentized and these components need to be connected in order to work together. Software modules can be functions, objects, or components which consist of multiple functions or objects. We focus on the specification of software components in object oriented systems. Traditionally, interoperability checking is performed by signature matching between an invoking function and a function being invoked. Function level signature matching techniques are not sufficient for software components in object oriented systems since an object encapsulates a set of data and functions, and a component may contain more than one object. We first describe the interoperability problems of software modules both in the procedural and object oriented paradigms, and then review current approaches and compare them. Based on the review, we propose a new interoperable component model (ICM) that enhances software reusability and maintainability.	interoperability	Il-Hyung Cho;John D. McGregor;Lee Krause	1998		10.1109/TOOLS.1998.711005	software distribution;connascence;semantic interoperability;reusability;software sizing;computer science;backporting;software design;software framework;component-based software engineering;software development;software design description;object-oriented design;software engineering;software construction;database;programming language;resource-oriented architecture;artificial intelligence systems integration;software system	Robotics	-34.59530137348823	41.691750173077146	183727
04b4c266529fabd6eac4d72b863a507cac4ee750	representing hierarchical mobility in software architectures	object oriented methods;object oriented architectural style;queuing system;connection software architecture;innovative software architecture;software topologies;hierarchical mobility;hierarchical component;hierarchical software construction;software architecture;object oriented technology;software architecture object oriented methods;software architecture topology computer architecture object oriented modeling filters runtime software engineering protocols operating systems informatics;software architectures;hierarchical model;queuing system hierarchical mobility software architectures software topologies hierarchical component connection software architecture hierarchical software construction object oriented architectural style innovative software architecture object oriented technology;architectural style	The ability to move components from one hierarchical model to another becomes necessary to support arbitrary changes in software topologies. Mobility allows the access to the hidden interface of a hierarchical component without breaking encapsulation, keeping the architecture modular. Mobility permits also the introduction of new functionally in the application without requiring changes in the architecture, enabling its adaptation to dynamic requirements. To illustrate hierarchical mobility we employ the Connecton software architecture (CSA). CSA combines a modular and hierarchical software construction with the objectoriented architectural style to achieve an innovative software architecture that eliminates the limitations of the classical object-oriented technology in supporting modular components. The simulation of a queuing system whose clients are represented by mobile components is provided.	encapsulation (networking);hierarchical database model;requirement;simulation;software architecture;software construction	Fernando J. Barros	2007	International Workshop on Software Engineering for Adaptive and Self-Managing Systems (SEAMS '07)	10.1109/SEAMS.2007.16	reference architecture;software architecture;computer architecture;real-time computing;computer science;software engineering;queue management system;resource-oriented architecture;hierarchical database model;computer engineering	SE	-35.84685376468906	42.05528111020582	183875
243ad69bad3b03fc428428f35392a5bc9c03e177	automatic transformation of abstract autosar architectures to timed automata	uml modeling;design exploration;code generation;synthesis	The AUTomotive Open System ARchitecture (AUTOSAR) is the emerging standard for the development of real-time embedded automotive systems. Several tools exist that support the development as well as the analysis of AUTOSAR systems. Simulation environments use models or generated source code for testing and scenario-based simulation purposes. Unfortunately, there is a lack of methods and tools supporting the early timing analysis of AUTOSAR systems. In this work, we show how to automatically transform a given AUTOSAR architecture to an interconnected set of timed automata that represents the state-based timing behavior of the system. The derived timed automata models are used for analyzing the timing behavior in an early development stage. Furthermore, we show how to analyze the resulting timing behavior supporting abstract and incomplete AUTOSAR systems using the tool UPPAAL.	autosar;automata theory;embedded system;gray box testing;mathematical model;real-time clock;simulation;software release life cycle;static timing analysis;systemc;timed automaton;uppaal;worst-case execution time	Stefan Neumann;Norman Kluge;Sebastian Wätzoldt	2012		10.1145/2432631.2432641	embedded system;computer architecture;real-time computing;computer science;east-adl	Embedded	-40.851776745155455	32.75160088266468	183921
072fd6273a089054fb279e456c57e5d82f5cc099	service-oriented computing: key concepts and principles	developpement logiciel;internet open systems software engineering standards service oriented computing;standards;open environments service oriented computing software development case tools;componente logicial;bepress selected works;service web;composant logiciel;service oriented architectures;soa;web service;software engineering;calcul oriente service;standards internet open systems software engineering;internet;desarrollo logicial;service oriented computing;software development;case tool;web services;architecture orientee service;software component;soc;application software surgery web services hospitals buildings computer architecture government programming computer aided software engineering software tools;service oriented architecture;open systems;soa web services service oriented architectures service oriented computing soc;servicio web	ions for SOC We can view SOC in terms of several different cross-cutting levels of abstractions, ranging from those that concern services within an application to those that concern service applications interacting across enterprises. Let’s consider a typical surgery division in a large hospital. One challenge in such a setting would be to make the payroll, scheduling, and billing systems interoperate. Each system is quite complex, with its own user interfaces and databases, perhaps running on different operating systems. For obvious reasons, these systems must work together. Scheduling employees and operating rooms for surgery is complicated, for example, because schedules require frequent updating. A scheduling system must balance staff and equipment availability with unpredictable levels of surgical urgency and advance notice. The mechanisms for payroll are similarly complex — the payroll system must consider various kinds of overtime rules for different categories of labor, such as nurses, residents, consulting physicians, senior surgeons, radiologists, and so on — and rely to some extent on data from the scheduling system. Likewise, the billing system must also incorporate scheduling information. It is used not only to bill customers, but also to deal with medical insurance companies and government agencies (such as those for children, the elderly, retired government employees, and veterans). Agencies typically impose complex rules for valid billing and penalties for violations of these rules. Across the US, for example, different rules apply regarding how hospitals can bill for anesthesiologists’ efforts during surgeries. In some states, a senior anesthesiologist can supervise up to four junior (resident) anesthesiologists. This senior person thus time-shares his or her effort among four concurrent surgeries, whereas each junior person is dedicated to one. If an emergency arises, the law allows a fifth surgical procedure under the same senior anesthesiologist’s supervision, but the billing rate is severely reduced. Hospital systems provide services within an enterprise, exemplifying the abstraction level of intraenterprise interoperation. Similar examples can exist among enterprises, among software components, and between the application level of a system and its infrastructure level, as the following sections describe. Intraenterprise Abstraction Level If we look at just the interoperation aspects in our hospital example, we quickly see several hurdles to overcome. The first is connectivity among the applications, which protocols such as HTTP can readily ensure. The second is the ability of the various components to understand each other. XML, particularly XML Schema, can handle communication formatting, but it cannot decipher the meaning behind a given message. Meaning usually is not encoded explicitly; rather, it depends on how various systems process information, which means system integrators and developers must uncover and reconcile the interacting components’ intent. This reconciliation presupposes that accurate declarative information models exist. In practice, however, such models are often poorly maintained or simply do not exist. Developers must thus construct (or reconstruct) them at integration time. This process is further complicated by the fact that information models for different systems might describe different abstraction levels. Services can encapsulate component behavior at many levels, but still describe it in the same way, thus easing composition of the components. Because our hospital setting deals with legacy and other systems and applications that operate within the enterprise, various enterprise policies must readily authenticate and authorize the parties involved in different interactions. A service-oriented architecture (SOA), by requiring that policies be made explicit, can organizationally enforce compliance with these policies, thus simplifying the system’s management. 76 JANUARY • FEBRUARY 2005 www.computer.org/internet/ IEEE INTERNET COMPUTING Service-Oriented Computing Track Figure 1. Web services architectural model. As a basis for a service-oriented architecture, Web services models incorporate how Web services are advertised, discovered, selected, and used. Bind	abstraction layer;authentication;component-based software engineering;database;electronic billing;hypertext transfer protocol;information model;interaction;internet;interoperability;interoperation;operating system;radiology;schedule (project management);scheduling (computing);service-oriented architecture;service-oriented device architecture;user interface;web service;xml schema	Michael N. Huhns;Munindar P. Singh	2005	IEEE Internet Computing	10.1109/MIC.2005.21	computer science;operating system;service-oriented architecture;database;distributed computing;law;world wide web	DB	-44.72830474009307	42.987396545474134	183987
02ee605b724a0640a55f76802c30047da7c6f91c	design of dynamically reconfigurable real-time software using port-based objects	libraries;reconfiguration;object based design;port based object abstraction;sistema operativo;robot sensing systems;automatic;control systems;software portability;targets;code templates;concurrent processes;reconfiguracion;distributed memory systems;object oriented methods;variables;dynamique;selected works;dynamic reconfiguration;programming paradigm;application software;mando numerico;reutilizacion;control engineers;real time;evolutionary design;domain specific units;real time operating system;actuators;control engineering;robotics;commande numerique;object oriented programming;time;communication system software;robot programming software reusability software portability real time systems object oriented methods operating systems computers synchronisation shared memory systems distributed memory systems;software engineering;integration;reuse;software abstraction;software components;conception evolutive;port automaton theory;programming model;port based objects;synchronisation;software architecture;shared memory systems;operating system;guidelines;dynamics;configurations;synchronization;temps reel;software reusability;robotic applications;software component;genie logiciel;tiempo real;bepress;systeme exploitation;digital control systems;robotique;tools;digital control;software reuse dynamically reconfigurable real time software port based objects software abstraction programming model domain specific units control engineers software components port based object abstraction port automaton algebraic model concurrent processes chimera real time operating system robotic applications synchronization distributed shared memory code templates;software design;chimera;programmation orientee objet;distributed shared memory;concurrent process;software reuse;component based design;operating systems computers;global;domain specificity;port automaton algebraic model;reutilisation;dynamically reconfigurable real time software;robot programming;subroutines;operating systems;jobs	The port-based object is a new software abstraction for designing and implementing dynamically reconfigurable real-time software. It forms the basis of a programming model that uses domain-specific elemental units to provide specific, yet flexible, guidelines to control engineers for creating and integrating software components. We use a port-based object abstraction, based on combining the notion of an object with the port-automaton algebraic model of concurrent processes. It is supported by an implementation using domain-specific communication mechanisms and templates that have been incorporated into the Chimera Real-Time Operating System and applied to several robotic applications. This paper describes the port-based object abstraction, provides a detailed analysis of communication and synchronization based on distributed shared memory, and describes a programming paradigm based on a framework process and code templates for quickly implementing applications. Index Terms —Dynamic reconfiguration, real-time operating system, software architecture, object-based design, port-automaton theory, reusable software, component-based design, evolutionary design, digital control systems, robotics. —————————— ✦ ——————————	automata theory;automaton;chimera;component-based software engineering;continuous design;control system;distributed shared memory;elemental;object-based language;programming model;programming paradigm;real-time computing;real-time operating system;real-time transcription;reconfigurability;reconfigurable computing;robot;robotics;software architecture;token reconfiguration	David B. Stewart;Richard Volpe;Pradeep K. Khosla	1997	IEEE Trans. Software Eng.	10.1109/32.637390	embedded system;synchronization;method;real-time computing;digital control;computer science;software framework;component-based software engineering;software development;operating system;object-oriented design;software engineering;distributed computing;programming paradigm;robotics;programming language	Embedded	-33.82585546903753	34.405299134931326	184416
8dfba6fb1509657945e6c7638607f4dcfc364039	performance modeling and prediction of enterprise javabeans with layered queuing network templates	software profiling;application server;layered queueing network;software component;template	Component technologies, such as Enterprise Java Beans (EJB) and .NET, are used in enterprise servers with requirements for high performance and scalability. This work considers performance prediction from the design of an EJB system, based on the modular structure of an application server and the application components. It uses layered queueing models, which are naturally structured around the software components. This paper describes a framework for constructing such models, based on layered queue templates for EJBs, and for their inclusion in the server. The resulting model is calibrated and validated by comparison with an actual system.	application server;calibration (statistics);central processing unit;component-based software engineering;enterprise javabeans;informatics;layered queueing network;middleware;performance prediction;predictive modelling;queueing theory;requirement;scalability;server (computing)	Jing Xu;Alexandre Oufimtsev;C. Murray Woodside;Liam Murphy	2006	ACM SIGSOFT Software Engineering Notes	10.1145/1118537.1123064	template;real-time computing;computer science;component-based software engineering;operating system;layered queueing network;database;profiling;programming language;application server	SE	-37.67195489559325	36.62048717919067	184709
bc50df91d1f180457b61004d477b039af949e503	quality-driven architectural patterns for self-aware cloud-based software	self awareness quality qos architecture architecture pattern architectural tactic cloud;cloud;architecture pattern;software architecture cloud computing object oriented methods quality of service;qos;cloud autoscaling architecture self aware cloud based software architecture based self adaptation autonomic system design self manageable architectures dynamicity level compliance level self expression self aware architecture patterns qos run time requirements architecture quality management quality driven architectural patterns qos tactics quantitative evaluation;quality;self awareness;architectural tactic;computer architecture quality of service monitoring cloud computing context engines;architecture	Architecture-based self-adaptation has been recognised as one of the prominent ways to design autonomic systems, where self-manageable architectures tend to achieve the required level of dynamicity and compliance with the continual changing in QoS requirements during run-time. Self-awareness and self-expression have recently emerged as promising architectural concepts in the field of self-adaptive software. Self-aware architecture patterns are envisioned as enabler for self-adaptation, but they tend to provide limited support for the QoS run-time requirements. While the research community has developed in architecture quality management, patterns and tactics, addressing quality attributes in self-aware architectures has not been tackled yet. In this paper, we aim to provide quality-driven architectural patterns for emerging class of architecture enabled by the principles of self-awareness. We report on the feasibility of correlating QoS tactics with self-aware capabilities to better respond to QoS run-time requirements and trade-offs. We describe novel extensions which make the correlation between QoS tactics and self-awareness explicit. We quantitatively evaluate the feasibility, generality and fitness of the proposed approach, as well as its potential applicability to self-aware architectures. Though the proposed extensions can potentially benefit architectures which leverage on self-awareness, we use the case of cloud auto-scaling architecture.	architectural pattern;autonomic computing;autoscaling;cloud computing;image scaling;list of system quality attributes;quality of service;requirement;self-awareness;self-management (computer science)	Maria Salama;Rami Bahsoon	2015	2015 IEEE 8th International Conference on Cloud Computing	10.1109/CLOUD.2015.116	enterprise architecture framework;reference architecture;software architecture;space-based architecture;website architecture;real-time computing;simulation;database-centric architecture;architectural pattern;computer science;applications architecture;architecture;operating system;service-oriented modeling;enterprise architecture management;solution architecture;software architecture description;view model;data architecture	SE	-44.653996712326084	41.64964849623655	184715
93b23a23863ff3cb15b06fd6206f199149e86d4a	interoperability in open heterogeneous multirobot systems	information technology;multirobot systems;open system;service oriented architecture	An approach to the problem of interoperability in open and heterogeneous multirobot systems is presented. It is based on the paradigm of Service Oriented Architecture (SOA), and a generic representation of the environment. Robot, and generally device, is seen as a collection of its capabilities exposed as services. The representation of environment is used to define tasks, and service interfaces. Several protocols are proposed to enable interoperability among the services in order to publish, discover, compose services, and execute the composite services. The representation, language for task definition, and language for service interface definition, as well as the protocols constitute together an information technology for automatic task accomplishment in open system consisting of heterogeneous devices (robots).	interoperability;programming paradigm;robot;service-oriented architecture	Stanislaw Ambroszkiewicz;Waldemar Bartyna;Marek Faderewski;Grzegorz Terlikowski;Krzysztof Cetnarowicz	2007			computer science;knowledge management;database;distributed computing	Robotics	-38.42193629156727	42.55048972525517	185234
fa28a5474d7dae86fb45b074ed9b7542cb284fb5	extending web service offerings infrastructure (wsoi) for management of mobile/embedded xml web services	extensible markup language;web service management tools web service offerings infrastructure xml web services mobile extensible markup language web services embedded extensible markup language web services management infrastructure context sensitivity quality of service intermittent connectivity high level architecture;xml web services;prototypes;web service management tools;resource management;web services xml environmental management resource management context aware services quality of service monitoring quality management service oriented architecture prototypes;service management;mobile extensible markup language web services;web service;xml embedded systems formal verification mobile computing quality of service web services;embedded systems;formal verification;intermittent connectivity;monitoring;web services;xml;embedded extensible markup language web services;web service offerings infrastructure;quality of service;service oriented architecture;mobile computing;environmental management;high level architecture;context sensitivity;quality management;management infrastructure;context aware services	Management of extensible markup language (XML) Web services executing in mobile and/or embedded environments poses new challenges coming from limited available resources and from the need for characteristic management activities, such as handling context sensitivity. We determined management requirements, studied relevant tradeoffs, and designed a management infrastructure for monitoring of mobile/embedded XML Web services. The infrastructure enables that some or all management activities are executed on a non-mobile/non-embedded gateway instead of a mobile/embedded provider Web service. Further, it contains support for managing context-sensitivity and for handling disruptions in quality of service (QoS) and intermittent connectivity. While our high-level architecture can be implemented upon several existing Web service management tools, we chose to develop a new version of our Web service offerings infrastructure (WSOI). The suggested solutions are being verified using the new WSOI prototype and validated on case studies, such as emulation of track-tracking Web services	apache axis;archive;cpu cache;e-commerce;e-services;embedded system;emulator;high- and low-level;high-level architecture;lookup table;management information system;markup language;mobile device;presence information;prototype;proxy server;quality of service;requirement;resource description framework;soap;verification and validation;web service;xml	Vladimir Tosic;Hanan Lutfiyya;Yazhe Tang	2006	The 8th IEEE International Conference on E-Commerce Technology and The 3rd IEEE International Conference on Enterprise Computing, E-Commerce, and E-Services (CEC/EEE'06)	10.1109/CEC-EEE.2006.49	web service;web application security;quality management;web development;web modeling;xml;mobile web;web mapping;web design;web standards;computer science;knowledge management;resource management;web api;ws-policy;web navigation;ws-addressing;database;mobile computing;web 2.0;world wide web	DB	-48.18345852657036	44.98668976808324	185299
23602e5b57fb6d934177584c46946effc1cfbab5	where event processing grand challenge meets real-time web: play event marketplace	intelligent complex event processing;service system;real time;distributed computing;spectrum;real time data;complex event processing;open standard	The Grand Challenge in Event Processing serves as a common goal and mechanism for coordinating research across the spectrum of people working on event processing. The Grand Challenge is a single, though broad, challenge that impacts society which the community can use as a basis for measuring progress in research and application.  In this paper we will present an analysis of the recent development in the realization of the Grand Challenge and elaborate on its implementation using the current development in the so called Real-time Web - a decentralized, global, Internet-like infrastructure, built upon widely-accepted open standards.  We present a particular solution that has been developed in the scope of the EU project PLAY (www.play-project.eu), that is aiming to develop an elastic and reliable platform for dynamic complex event-driven interaction in large highly distributed and heterogeneous federated service systems. The main outcome is an Event Marketplace Platform which offers and consumes real-time data of all sorts and across the whole Web.  We explain the theoretical principles behind the Event Marketplace, discuss the research and technological challenges required for its efficient development, present the implementation and evaluation details and demonstrate several applications that have been built on the top of the Platform so far.	complex event processing;darpa grand challenge;event-driven programming;grand challenges;play;real-time data;real-time web	Nenad Stojanovic;Roland Stühmer;Françoise Baude;Philippe Gibert	2012		10.1145/2335484.2335521	spectrum;real-time data;simulation;open standard;computer science;complex event processing;operating system;data mining;database;distributed computing;world wide web;service system	Mobile	-44.861159795451385	44.89588245754331	185362
849dee94f2b5cb03e409a43c26f7e6696d480cfa	self-configuration, monitoring and control of physical entities via sensor and actuator networks. (auto-configuration, supervision et contrôle d'entités physiques par l'intermédiaire de réseaux de capteurs et actionneurs)		The physical entities which are taken into account by Machine to Machine (M2M) telecom applications are more and more heterogeneous. This is due to the increased turnover and multiplication of digital connected devices, and also to the need to integrate non-networked or even non-digital ”legacy” equipment in these applications. In addition, space entities such as rooms may also be taken into account in the same environments. The challenge addressed by our research is the automatic integration and configuration of all these types of physical entities in M2M systems, with a homogeneous solution that generalizes self-configuration approaches used for networked digital devices. This thesis presents a general theoretical framework and basic mechanisms for the identification and configuration of such physical entity models in distributed embedded information systems. Our approach deals jointly with equipment and space entities encompassing the ”Internet of Things” (IoT) and ”interactive environment” viewpoints in a renewed interpretation of ambient intelligence. This work has been motivated initially by home energy management applications, trying to integrate into the Home Area Network all home entities (e.g. domestic appliances and rooms) that play a role in energy management, but do not have a networked interface of their own. This corresponds to a qualitative extension of the perimeter of the Home Area Network. This integration is achieved in a way similar to what is done for state of the art digital devices, through a spontaneous discovery and configuration mechanism, with the following stages: • Detection of the presence of a physical entity by analyzing the coincidence of significant events detected by sensors; • Selection of the first generic model corresponding to the detected physical entity from a reference ontology, on the basis of received sensors data; • Creation of a software component representing the detected physical entity, based on the selected model, associated with relevant sensors and actuators; • Provision of application interface for monitoring and control of the target entity through this intermediate software component; • Iterative update of the identified entity model on the basis of data from associated sensors. The proposed approach has been validated and implemented in home environments, but it is intended to be generalized and expanded to environments such as buildings or cities, offering a similarly shared infrastructure for all M2M applications in these environments.		Zheng Hu	2014				AI	-43.75943373580835	45.471294691499075	185599
5f4cbf868aa114bc18cfe927bd580983247f409c	towards runtime optimization of software quality based on feedback control theory	quality attributes;double layer;software systems;self adaptation;optimal control;dynamic environment;runtime reconfiguration;web based system;quality optimization;control;feedback control;software quality;throughput	The increasingly complex environments in which software systems are running today have made runtime software quality unstable and hardly in an optimal state, especially for those systems in open and dynamic environments, e.g. Internetware. In this paper, we explore the effectiveness of software cybernetics and feedback control theory in runtime software quality optimization. We propose a method of runtime quality optimization by using feedback control theory. Specially, we consider the problem of runtime optimization for a specific quality attribute, namely throughput, for Web-based systems. We design a double-layer feedback control model for the problem and implement the runtime optimization control method. In the method, runtime feedbacks are collected and used by the control model to adjust related control parameters. The experimental study has demonstrated the effectiveness of software cybernetics and feedback control theory in runtime quality optimization.	control theory;cybernetics;experiment;feedback;mathematical optimization;software quality;software system;throughput	Bihuan Chen;Xin Peng;Wenyun Zhao	2009		10.1145/1640206.1640216	control engineering;real-time computing;profile-guided optimization;computer science;distributed computing;runtime verification	SE	-44.69548596429745	39.165313513757376	185683
dfd50dacba0d76cd86f7b07f98cba23fc177684e	midshm: a flexible middleware for shm application based on service-oriented architecture	wireless sensor networks condition monitoring middleware service oriented architecture structural engineering computing;wireless sensor networks service oriented architecture monitoring computer architecture hardware quality of service;structural health monitoring middleware service oriented architecture wireless sensor network;wireless sensor network;soa midshm flexible middleware shm application service oriented architecture wireless sensor network wsn structural health monitoring;middleware;structural health monitoring;service oriented architecture	Wireless Sensor Network (WSN) is often used for developing Structural Health Monitoring (SHM) application by civil researchers but they do not have much expertise on hardware and network related issues. By providing programming abstractions and hiding low level network issues middleware layer makes it easier to develop an efficient WSN-based SHM application. Service-oriented architecture (SOA) is a popular approach for designing middleware for WSN as it provides flexibility in developing WSN applications by using loosely coupled services. SOA can overcome issues like adaptation, reliability which are usually difficult to deal using other middleware approaches applied for WSN. This paper surveys various middleware approaches for WSN focusing mainly on SOA-based approach. It discusses drawbacks in various middleware approaches and points out design issues that not completely addressed by existing middleware architectures designed for SHM application. An easy-to-use SOA-based middleware, named MidSHM, has been proposed to deal with various SHM application issues such as resource optimization, in-network processing, quality of service, and fault tolerance. Two different application examples enabled by MidSHM are also shown to illustrate its flexibility and usability.	abstraction layer;fault tolerance;loose coupling;mathematical optimization;middleware;network processor;quality of service;service-oriented architecture;service-oriented device architecture;software release life cycle;super high material cd;usability	Yuvraj Sahni;Jiannong Cao;Xuefeng Liu	2016	2016 IEEE Symposium on Service-Oriented System Engineering (SOSE)	10.1109/SOSE.2016.43	embedded system;middleware;real-time computing;wireless sensor network;computer science;engineering;message oriented middleware;operating system;service-oriented architecture;middleware;computer network	Embedded	-44.33510909331282	45.953284694028966	185726
33aa619bbb2a84a6668728e9916a81e15256fa4d	towards context-aware testing for semantic interoperability on pvc environments	software testing;pervasive computing switches context modeling mathematics software testing assembly systems information analysis runtime proposals logic;user needs;context aware;pervasive computing;contextual information;object oriented programming;component based software;semantic interoperability;semantic information;program testing;ubiquitous computing;temporal model context aware testing semantic interoperability pvc environments software testing pervasive computing systems component based software transparent interconnection dynamic assembly contextual information dynamic interaction;open systems;open systems program testing ubiquitous computing object oriented programming	New challenges in software testing arise from evaluating pervasive computing systems, which are a special type of component-based software. Transparent interconnection of components becomes highly important when users need to switch between operative contexts. Dynamic assembly requires evaluating components to ensure they conform to the updated system's requirements, and components semantical information could be analysed with a proper ontology. Thus, our focus is set on semantic interoperability. We present an abstract model of an infrastructure integrated with an evaluation process, by applying testing strategies based on contextual information of components and user tasks. A typical case study is used to present both static and dynamic aspects of participating components. To improve this description we show the components' dynamic interaction by a temporal model from which testing strategies could be more precisely defined and applied.	component-based software engineering;interconnection;requirement;semantic interoperability;software testing;ubiquitous computing	Andres Flores;Juan Carlos Augusto;Macario Polo;Mauricio Varea	2004	2004 IEEE International Conference on Systems, Man and Cybernetics (IEEE Cat. No.04CH37583)	10.1109/ICSMC.2004.1399775	semantic interoperability;semantic computing;software performance testing;system integration testing;computer science;theoretical computer science;software development;software construction;cloud testing;database;distributed computing;software testing;open system;object-oriented programming;ubiquitous computing	SE	-40.05706791480388	38.909044080398765	185812
1af3e3a50ddafce248698e5d44ac4f261f453871	towards a flexible global sensing infrastructure	service provider;environmental conditions;wireless sensor network;software architecture;ip networks;resource availability;service provision	Wireless sensor networks can potentially become larger, more prevalent, and interconnected via the Internet, forming a global sensing infrastructure that serves many users. In order to realize this and maximize its utility, it is necessary to develop a software architecture that enables new components to be integrated, multiple applications to share the same sensing substrate, and the integration of sensor and IP networks. We propose one such architecture that encodes applications as malleable, platform-independent, high-level mobile scripts. Multiple users are supported by allowing these scripts to execute concurrently, while flexibility is achieved by having them invoke platform-specific services. Services provide reusable functional capabilities that may vary across platforms and environmental conditions. They are platform-specific and may be discovered and redeployed on-demand at runtime. Service provision allows applications to exploit whatever computational capabilities are available, and new services to be added in response to changing application needs, resource availability, or environmental conditions. Our approach allows applications to function in diverse settings by employing dynamic rebinding of mobile scripts to different services as they execute over extended intervals across different types of networks.	concurrent computing;functional programming;high- and low-level;internet;platform-specific model;run time (program lifecycle phase);software architecture	Chien-Liang Fok;Gruia-Catalin Roman;Chenyang Lu	2007	SIGBED Review	10.1145/1317103.1317104	service provider;embedded system;software architecture;real-time computing;wireless sensor network;computer science;operating system;distributed computing;computer security;computer network	Mobile	-38.06859171977224	45.415759429423765	185845
a31e9a566d0489f3aa212192078ef18e386b105e	integrated network management amsterdam: control approach and test results	amsterdam netherlands;traffic control monitoring aerospace electronics computer architecture coordinate measuring machines electric breakdown abstracts;integrated corridor management;field tests;road traffic control;computer architecture;algorithms;demonstration projects;highway traffic control;hierarchal control approach control approach test results praktijkproef amsterdam project field operational test integrated network management amsterdam fot testing coordinated traffic management network wide deployment proof of concept	The Praktijkproef Amsterdam (Field Operational Test Integrated Network Management Amsterdam) is one of the first large-scale FoTs testing coordinated network wide deployment of traffic management in practice. After a successful Proof-of-Concept (PoC) in 2009, in 2013 the first parts of the concept approach will be tested in the field, working towards a full deployment from 2014 onwards. This paper describes the hierarchal control approach that has been developed in order to operationalise the control paradigm developed during the PoC. The paper explains this control framework, the functional architecture, and the main control algorithms. The paper also shows the first results of the application of the control approach in a simple test network.	algorithm;full scale;functional testing;network model;programming paradigm;prototype;real life;software deployment;test case;vissim	Serge P. Hoogendoorn;Ramon L. Landman;Jaap van Kooten;Marco Schreuder	2013	16th International IEEE Conference on Intelligent Transportation Systems (ITSC 2013)	10.1109/ITSC.2013.6728276	simulation;engineering;operations management;operations research	Robotics	-37.164455513118334	34.60997202214523	186114
16226221b4912f1b3884b3cf15d43067ce6150c8	towards separation of concerns in flow-based programming	flow based programming;aspect oriented;separation of concerns	Flow-Based Programming (FBP) is a programming paradigm that models software systems as a directed graph of predefined processes which run asynchronously and exchange data through input and output ports. FBP decomposes software systems into a network of processes. However there are concerns in software systems which do not fit this dominant decomposition. In this paper, we address the cross-cutting-concerns in FBP by using some examples and propose an aspect-oriented extension to FBP.	aspect-oriented software development;aspectj;cross-cutting concern;dataflow;directed graph;flow-based programming;input/output;java;join point;mathematical optimization;pointcut;programming language;programming paradigm;prototype;scheduling (computing);separation of concerns;software system;type signature;type system	Bahram Zarrin;Hubert Baumeister	2015		10.1145/2735386.2736752	simulation;computer science;theoretical computer science;programming language	SE	-37.340993405593935	38.453500885281215	186199
2c03d259509909000c0799a98ad9745d4488aef7	feature analysis for service-oriented reengineering	software engineering;internet;service identification feature analysis service oriented architectures soa distributed computing web services technology legacy system function oriented middleware;middleware;software engineering internet middleware open systems;open systems;service oriented architecture web services software engineering software systems packaging internet application software distributed computing programming middleware	Web services together with service-oriented architectures (SOA) are playing an important role in the future of distributed computing, significantly impacting software development and evolution. With the adoption to Web services technology, more and more existing non-service-oriented software systems turn to be legacy systems. They require a service-oriented reengineering process in order to survive in service-oriented computing environment. If the reengineering goal is to expose the services of a single object or any underlying function-oriented middleware, many problems will arise including semantic mismatches, service granularity issues and state management. Attempting to masquerade software assets from a lower level of abstraction can often cause significant mismatch and exposure problems. In this paper, by using feature analysis, an approach to supporting service-oriented reengineering is presented. Service identification and packaging process are performed and resulted into a service delegation.	code refactoring;distributed computing;legacy system;middleware;problem domain;service-oriented architecture;service-oriented device architecture;service-oriented software engineering;software as a service;software development;software system;state management;web service	Feng Chen;Shaoyun Li;William C. Chu	2005	12th Asia-Pacific Software Engineering Conference (APSEC'05)	10.1109/APSEC.2005.67	middleware;computing;the internet;computer science;social software engineering;component-based software engineering;message oriented middleware;software development;operating system;software engineering;service-oriented architecture;middleware;software construction;software as a service;database;open system;world wide web;software system	SE	-38.13633935052183	41.157027850912165	186356
00132b54f7e7ea67a22158007ee47c4be08bd459	compositional schedulability analysis of an avionics system using uppaal		We propose a compositional framework for analyzing the schedulability of hierarchical scheduling systems. The framework is realized using Parameterized Stopwatch Automata to describe tasks, whereas the schedulability analysis is performed using UPPAAL. The concrete behavior of each periodic preemptive task is given as a list of timed actions to which resources are assigned by SIRAP protocol. Our framework is reconfigurable in which the hierarchical structure, the scheduling policies, the concrete task behavior and the shared resources can all be reconfigured. Finally, we use our framework to analyze the schedulability of a real-time avionics system. Keywords-Hierarchical scheduling systems, Parameterized stopwatch automata, Compositional analysis, Uppaal.	automata theory;automaton;avionics;model checking;preemption (computing);reachability;real-time clock;real-time computing;scheduling (computing);scheduling analysis real-time systems;simulation;uppaal	Abdeldjalil Boudjadar;Jin Hyun Kim;Kim G. Larsen;Ulrik Nyman	2014			embedded system;parallel computing;real-time computing;computer science	Embedded	-33.89637966663879	33.65378484524245	186390
b95a383fd5a5652d77e5f560d8e3e1c7f7953665	distributed software maintenance using an autonomic system management approach based on the viable system model	metadata binding;control systems;cybernetics;information model;metadata binding distributed software maintenance autonomic system management viable system model system stability;system modeling;software maintenance;software systems;holistic approach;autonomic system management;autonomic system;stability;evolution biology;computer architecture;system stability;software maintenance software systems cybernetics stability system testing open systems concrete computer architecture evolution biology control systems;open system;system testing;distributed software maintenance;software maintenance open systems;open systems;viable system model;system management;concrete	Most current software management solutions are missing a systematic and holistic approach for global system management, and apply only to specific system components. This limits the system's extensibility, and does not meet interoperability requirements from the growing heterogeneity of the operating environment. This paper discusses an alternative approach to common management of evolving distributed software, inspired by the research in the field of open systems and cybernetic models. The approach involves adapting Stanford Seer's viable system model (VSM) to the concrete needs of distributed software, supporting evolutionary integration of new functionality, while preserving system stability. We introduce meta-data bindings to existing information models as a basis for management of hierarchical and recursive software elements, and an architecture for composition of interacting components with verification of their capabilities during deployment and runtime. The architecture is designed to satisfy criteria of the viable system model and to assure conditions necessary for autonomic behavior	autonomic computing;computer-integrated manufacturing;cybernetics;distributed computing;extensibility;holism;information model;interaction;interoperability;open system (computing);operating environment;recursion;requirement;seer-sem;self-reference;software deployment;software maintenance;software project management;software system;systems management;viable system model	Emil A. Stoyanov;Asa MacWilliams;Markus Alexander Wischy;Dieter Roller	2006	International Conference on Autonomic and Autonomous Systems (ICAS'06)	10.1109/ICAS.2006.22	verification and validation;cybernetics;computer science;control system;artificial intelligence;component-based software engineering;operating system;software construction;database;real-time control system software;open system;application lifecycle management;resource-oriented architecture;software deployment;software system;viable system model	SE	-41.60612295594546	39.47311007744311	186563
fb67158591dcce8d1af3735829c1e09f003fffe3	a broker-based approach for improving web services reliability	reliability engineering;high availability;electronic commerce;e business;fault tolerant;service oriented middleware;availability;service orientation;broker based approach;software fault tolerance;web service;computer networks;software architecture;internet;mediation;mission critical applications;fault tolerance;web services;web services message bus;fault tolerant web services;supply chain management system;message passing;middleware;fault tolerant web services broker based approach web services reliability mission critical applications e business quality of service service delivery web services message bus service oriented middleware supply chain management system;web services service oriented architecture availability fault tolerance quality of service mediation supply chain management buildings computer networks reliability engineering;quality of service;service oriented architecture;web services reliability;software reliability;supply chain management software reliability software fault tolerance middleware internet quality of service electronic commerce message passing software quality software architecture;software quality;buildings;supply chain management;service delivery	As Web services start to be deployed for mission-critical applications and for e-business scenarios, higher quality of service (QoS) and continuous service delivery become a critical issue to ensure high availability and reliability in spite of the failure or unavailability of the participating services or networks. These challenges call for vast improvements in the Web services containers and the mediation infrastructure. To address these requirements, we propose Web services message bus (wsBus), a lightweight service-oriented middleware for reliable and fault tolerant Web services interactions. This paper first discusses wsBus architecture and features and then it reports some experimental results to illustrate the effectiveness of wsBus in adding reliable and uninterrupted services to a supply chain management system.	electronic business;fault tolerance;high availability;itil;interaction;message-oriented middleware;mission critical;quality of service;requirement;service-oriented device architecture;service-oriented middleware;unavailability;web service;world wide web	Abdelkarim Erradi;Piyush Maheshwari	2005	IEEE International Conference on Web Services (ICWS'05)	10.1109/ICWS.2005.3	web service;web application security;fault tolerance;supply chain management;web standards;computer science;ws-policy;service-oriented architecture;ws-addressing;database;services computing;web engineering;ws-i basic profile;law;world wide web;software quality;computer network	HPC	-43.41308933132633	41.603754610307895	186890
bdea1b229b31ab87cf999294c52c7576bccada0a	detection of spatial events in commonsens	real time;functional properties;automated homecare;probability of error;multimodality;complex event processing;false positive	The aim of our complex event processing system, CommonSens, is to simplify the application programmers' tasks by abstracting away from any particular sensor installation.  Queries only need to refer to capabilities and locations of interest. In order to detect spatial events, CommonSens identifies the sensors that cover the specific locations where the spatial events should occur. This requires calculating how the coverage areas of sensors are affected by the environment. CommonSens promotes the use of heterogeneous multimodal sensors to reduce the probability of errors. It calculates the probability of false positives related to locations of interest and assists the application programmer with placing sensors in the environment effectively. We demonstrate through a series of experiments the functional properties of CommonSens related to these spatial issues. Furthermore, our experiments show that our non-optimised prototype is able to process all sensor readings and detect complex events in real-time.	complex event processing;experiment;multimodal interaction;programmer;prototype;real-time clock;sensor	Jarle Søberg;Vera Goebel;Thomas Plagemann	2010		10.1145/1877937.1877952	real-time computing;simulation;computer science;data mining	HCI	-39.043540255599616	41.442270197725435	187397
80ddaac65c104fe5ec21abc73862085459a4482e	towards multi-design of situated service-oriented systems	time dependent;service orientation;pervasive computing;multiuser;situated systems;user centric design;system development;service discovery;software design;conflict resolution	This paper discusses ongoing changes to the boundaries and roles of design and run time in the software lifecycle. Specifically, it focuses on changes caused by the emergence of situated systems in open pervasive computing environments. Clearly, such changes have a direct repercussion on the roles and tasks of system developers, stakeholders, and users.  The paper proposes extensions to current software design notations, concerning (a) service discovery and ways to scope it to user-defined physical locations, and (b) the ability to incorporate and shed features and behaviors at run time, depending on which users are present and on their goals, and including the ability to resolve conflicts between such goals. Five small but illustrative example systems demonstrate the benefits of these extensions.	emergence;emoticon;run time (program lifecycle phase);service discovery;service-oriented device architecture;situated;software design;software development process;ubiquitous computing	João Pedro Sousa;Zeynep Zengin;Sam Malek	2010		10.1145/1808885.1808897	simulation;systems engineering;engineering;knowledge management	HCI	-41.951544915460225	38.99191502976062	187445
ce41a84e419ae08a5efd2e2899f8391db73d6090	scalable model-checking for precise end-to-end latency computation	state space methods;automobiles;sensors;actuators;precision engineering;embedded systems;joseph pandya equation scalable model checking precise end to end latency computation automotive embedded control systems sensors actuators worst case end to end latency system architectures model checking based techniques exhaustive state space exploration state space explosion small sized systems medium sized systems abstract system model model checking based latency computation on the fly generation abstract models task activations;time factors computational modeling mathematical model equations abstracts calendars control systems;state space methods actuators automobiles embedded systems precision engineering sensors	Correct functionality of automotive embedded control systems often requires that the end-to-end latencies of data items traversing through specified task/message chains from sensors to actuators are within specified bounds. Hence, accurate estimation of the worst-case end-to-end latency has significant impact on the design of system architectures. Model-checking based techniques can provide accurate estimates of worst-case end-to-end latency, as they are based on exhaustive state-space exploration. However, state-space explosion may limit their applicability to small and medium sized systems. In this paper, we present an abstract system model that can be used for model-checking based latency computation, leading to a major increase in scalability. This is achieved by on-the-fly generation of abstract models for task activations, based on a proposed variant of the Joseph-Pandya equation.	best, worst and average case;computation;control system;embedded system;end-to-end principle;model checking;scalability;sensor;state space	Swarup Mohalik;Devesh B. Chokshi;Manoj G. Dixit;A. C. Rajeev;S. Ramesh	2013	2013 IEEE Conference on Computer Aided Control System Design (CACSD)	10.1109/CACSD.2013.6663476	embedded system;real-time computing;computer science;theoretical computer science	Embedded	-38.96398474554497	34.67029390517637	187462
05d146f09979573bb152f606038891c16202dc91	type-safe updating for modular wsn software	random access memory;event based programming abstraction;kernel;dynamic software updating;compile time verification;telecommunication computing;runtime;safety properties;wireless sensor network;computer architecture;large scale;formal verification;safety kernel runtime wireless sensor networks computer architecture random access memory;modular wsn software;safety;wireless sensor net work;modular design;composition time verification;software updating approach;software composition modular wsn software wireless sensor network software updating approach event based programming abstraction compile time verification composition time verification interoperability lorien modular operating environment;interoperability;open systems;high efficiency;wireless sensor networks;lorien modular operating environment;wireless sensor networks formal verification open systems telecommunication computing;dynamic loading;software composition	Modular software, in which strongly-separated units of functionality can be independently added to and removed from a node's running software, offers a promising approach to effective dynamic software updating in Wireless Sensor Networks (WSNs). Modular software updating approaches offer high efficiency, in terms of both network costs and update installation at nodes, as well as low disruption, allowing existing software to continue to operate during updates. Existing approaches however critically lack safety, relying on weakly-typed event-based programming abstractions for inter-module interaction. This precludes compile-time or composition-time verification of interoperability between dynamically loaded modules and therefore presents major risks for future large-scale production-class deployments. In this paper we present Lorien: a component-based modular operating environment that employs interface-based inter-component interaction to support completely type-safe software composition, while still supporting high update efficiency and low disruption. Our approach also has very wide scope, allowing almost 90% of software to be remotely updated on common sensor platforms such as the TelosB. We compare Lorien against existing modular designs, finding that the safety properties of Lorien are offered with near equal efficiency.	compile time;compiler;component-based software engineering;correctness (computer science);denial-of-service attack;event-driven programming;function composition (computer science);high- and low-level;interoperability;low-power broadcasting;modular programming;operating environment;patch (computing);strong and weak typing;tinyos;type safety	Barry Porter;Utz Roedig;Geoff Coulson	2011	2011 International Conference on Distributed Computing in Sensor Systems and Workshops (DCOSS)	10.1109/DCOSS.2011.5982140	embedded system;real-time computing;wireless sensor network;computer science;software development;operating system;software construction;distributed computing;computer network	SE	-40.3137432505625	39.35936822206673	187492
6c4ed55e0fb1ae1019056349e2d1ba4ef58c497e	systems-theoretic view of component-based software development	hierarchical control;supervisory control theory;formal method;controller synthesis;systems theory;component model;component based software development	This paper investigates component-based software development in the perspective of systems theory. In the proposed systems-theoretic view, a complex system is organized hierarchically from horizontal and vertical aggregations of components, but more important is the explicit control at each level of the hierarchy. Control actions are then determined by controllers that enforce constraints imposed on components and their interaction, and thus reduce their degree of autonomy. Not only the system behavior is restrained but nonfunctional properties emerge at each level. The finer the exercised control, the richer emergent properties should be. Therefore, achieving nonfunctional properties, such as liveness, predictability, safety and security, corresponds to solving control problems. The supervisory control theory initiated in the early and mid eighties is a mathematical apparatus that helps to accomplish this task in a rigorous way.	component-based software engineering;software development	Daniel Côté;Michel Embe Jiague;Richard St.-Denis	2010		10.1007/978-3-642-27269-1_10	control engineering;real-time computing;simulation;engineering	SE	-42.53748183133893	36.71106745410964	187720
8332a06a83b537bc9ef36196f4d073ef41c2d9aa	prediction intelligence in context-aware applications	context aware application;level of service;context awareness;context aware;context prediction;spatial prediction;context model;qa75 electronic computers computer science;context proactivity;adaptive applications;mobile application	Mobile applications are required to operate in ubiquitous environments of dynamic nature. Specifically, the availability of resources and services may vary significantly during a typical session of system operation. As a consequence, mobile applications need to be capable of adapting to these changes to ensure the best possible level of service to the user. Therefore, such adaptive applications may have pre-evaluated the appropriate knowledge of their environment to act efficiently. Such knowledge is not known a priori, so information prediction and proactivity should enhance and extend the functionality of such applications in order to be adaptable to the future changes of their underlying computational environment. In this paper, we discuss and evaluate such a context prediction algorithm.	algorithm;information;mobile app	Christos Anagnostopoulos;Panagiotis Mpougiouris;Stathes Hadjiefthymiades	2005		10.1145/1071246.1071266	simulation;computer science;knowledge management;data mining;context model;level of service	Web+IR	-41.84002091742169	42.77313931136036	187797
17de56c97748e4dbe7d2c3b110ca7688c654c155	performance evaluation of distributed track-to-track fusion systems	target tracking system performance analysis of variance missiles;statistical testing design of experiments distributed sensors performance evaluation sensor fusion;information matrix fusion fusion performance evaluation design of experiments covariance intersection;sensitivity analysis performance evaluation distributed track to track fusion systems network centric consideration track information distributed sources heterogeneous sources multisensor tracking system distributed active sensor passive sensor network centric operation design space design of experiments approach doe approach statistical analysis techniques anova tukey hsd test key system design variable distributed t2t fusion system performance	Implications of network-centric considerations provide additional challenges for fusing track information from distributed and heterogeneous sources. In this paper a multisensor tracking system that consists of distributed active and passive sensors is used to describe a distributed Track-to-Track (T2T) fusion system. Network-centric operations manifest an extended design space for the distributed T2T fusion systems. This paper describes a Design of Experiments (DoE) approach to comprehend the extended design space of the distributed T2T fusion systems. Using statistical analysis techniques, ANOVA and Tukey HSD tests, we quantify the impact of key system design variables on the distributed T2T fusion system performance. The sensitivity analysis, based on statistical results, establishes the significance of interactions between system design variables and emphasizes the need for design and evaluation of the distributed T2T fusion systems in a system of systems context.	design of experiments;interaction;key;monolithic application;performance evaluation;sensor;system of systems;systems architecture;systems design;tracking system;von neumann architecture	Ali K. Raz;Daniel DeLaurentis	2014	2014 IEEE International Conference on Systems, Man, and Cybernetics (SMC)	10.1109/SMC.2014.6974142	real-time computing;simulation	Robotics	-42.22424503145367	35.856508345317316	188132
76e1e0771d1016519ece8de58e427d840346f7b0	simulation of neutron multiplicity measurements using geant4 - open source software for nuclear arms control		"""Nuclear arms control, including nuclear safeguards and verification technologies for nuclear disarmament typically use software as part of many different technological applications. This thesis proposes to use three open source criteria for such software, allowing users and developers to have free access to a program, have access to the full source code and be able to publish modifications for the program.#R##N#This proposition is presented and analyzed in detail, together with the description of the development of """"Open Neutron Multiplicity Simulation"""", an open source software tool to simulate neutron multiplicity measurements. The description includes physical background of the method, details of the developed program and a comprehensive set of validation calculations."""	coat of arms;geant4;open-source software;simulation	Moritz Kütt	2016			real-time computing;simulation;computer science;computer security	SE	-46.85237520333049	36.70407059221679	188159
e21d56251bb1ae13f144a18f4a55c3b9ea2df947	software architecture for adaptive distributive multimedia systems	explicit binding;distributed multimedia system;continuous media;corba;multimedia application;open bindings;software architecture;mobile environment;open implementation;video on demand;distributed object management;adaptive distributed multimedia systems;middleware;adaptive continuous media interaction;mobile environments;adaptive video on demand software architecture adaptive distributed multimedia systems mobile environments middleware open implementation corba explicit binding open bindings adaptive continuous media interaction;adaptive video on demand	To support multimedia applications in mobile environments, it will be necessary for applications to be aware of the underlying network conditions and also to be able to adapt their behaviour and that of the underlying platform. This paper focuses on the role of middleware in supporting such adaptation. In particular, we investigate the role of open implementation and reflection in the design of middleware platforms such as CORBA. The paper initially extends CORBA with the concept of explicit binding, where path of communication between objects is represented as first class objects. We then introduce the concept of open bindings which support inspection and adaptation of the path of communications. An implementation of open bindings for adaptive continuous-media interaction is described using the example of adaptive video-on-demand for mobile environments.	software architecture	Tom Fitzpatrick;Gordon S. Blair;Geoff Coulson;Nigel Davies;Philippe Robin	1998	IEE Proceedings - Software	10.1049/ip-sen:19982299	software architecture;real-time computing;computer science;operating system;software engineering;common object request broker architecture;middleware;distributed computing	HPC	-36.929445574399764	41.78579048741065	188214
9bb55aa904a3ccf63aae50e6a96cb94acb7d011d	towards dependable grid and web services	web service	1 Grid and Web Services Remote method invocations have been used in distributed systems for quite some time. Frameworks such as CORBA from the Object Management Group (OMG) [1] have had schemes in place to facilitate invocations on remote objects for more than a decade. There also has been support for remote invocations in programming languages, a case in point being the Java Remote Method Invocation (RMI) Framework [2]. In these cases we could think of the remote object as providing a service comprising a set of functions. The provider exposes the service’s capability through an appropriate description language, which comprises the function names, the number and type arguments that a given service function takes and finally the return type that would be returned upon completion of the invocation.	common object request broker architecture;distributed computing;interaction;java remote method invocation;open-source software;programming language;return type;sms language;substrate (electronics);web service	Geoffrey C. Fox;Shrideep Pallickara;Marlon E. Pierce;David W. Walker	2003	Ubiquity	10.1145/941402.941405	web service;web application security;web development;data web;web analytics;web standards;computer science;ws-policy;web navigation;ws-addressing;web intelligence;ws-i basic profile;web 2.0;law;world wide web	PL	-34.050305624482384	43.50870065898008	188385
1adb00467131d134268c4da16974440485355795	architecting dynamic cyber-physical spaces	verification;static and dynamic semantics;etc;68n30 mathematical aspects of software engineering specification;metrics;building information modeling;cyber physical systems;self adaptation;requirements;formal verification;cyber physical spaces	We increasingly live in cyber-physical spaces: spaces that are both physical and digital, and where the two aspects are intertwined. Cyber-physical spaces may exhibit a range of behaviors, from smart control of heating, ventilation, and light to visionary multi-functional living spaces that can be spatially re-organized in a dynamic way. In contrast to traditional physical environments, cyber-physical spaces often exhibit dynamic behaviors: they can change over time and react to changes occurring in space. Current design of spaces, however, does not normally accommodate the cyber aspects of modern spatial environments and does not capture their dynamic behavior. Spatial design, although done with CAD tools and following certain international processes and standards, such as Building Information Modelling (BIM), largely produces syntactic descriptions of spaces which lack dynamic semantics. As a consequence, designs cannot be automatically (and formally) analyzed with respect to various requirements emerging from dynamic cyber-physical spaces; safety, security or reliability requirements being typical examples of this. This paper will show an avenue for research which can be characterized as rethinking the design of spatial environments, i.e., dynamic cyber-physical spaces, from a software engineering perspective. We outline our approach where formally analyzable models may be automatically extracted from BIM depending on the analysis required, and then checked against formally specified requirements, both regarding static and dynamic properties of the design, prior to the construction phase (at design time). To realize automated operational management, these models can also be used during operation to continuously check satisfaction of the requirements when changes occur, and possibly enforce their satisfaction through self-adaptive strategies (at run-time).	action potential;adaptive system;architectural pattern;architecture domain;bim;building information modeling;computer security;computer-aided design;countermeasure (computer);entity;experiment;formal verification;holism;information model;interaction;logic programming;microsoft outlook for mac;mission critical;model checking;physical symbol system;programming language;requirement;run time (program lifecycle phase);software engineering;way to go	Christos Tsigkanos;Timo Kehrer;Carlo Ghezzi	2016	Computing	10.1007/s00607-016-0509-6	building information modeling;requirements analysis;verification;simulation;formal verification;computer science;theoretical computer science;cyber-physical system;metrics	SE	-42.81921407401912	38.41174601769393	188554
659646810aa73195916363f726ff4f8b27a070b8	an open generic corba-programmable videoconferencing platform	videoconferencing;multimedia streaming;corba;technology and engineering;design and implementation;software component;tina;middleware;h 323;multimedia services	In this paper we address the design and implementation of a generic terminal architecture for videoconferencing based on the principle of programmable protocol stacks. In this architecture, there exist two types of software components. A first type are the multimedia engines, which are responsible for handling the multimedia stream (execution layer). Secondly, the managing components handle the multimedia engines' lifecycles and provide a set of network- and codec-independent CORBA-IDL interfaces which make building the desired protocol stack straightforward (middleware based control layer). As a result, the developed platform can be easily integrated in existing multimedia control frameworks such as the TINA architecture or the H.323 terminal framework.	common object request broker architecture	Brecht Vermeulen;Filip Vandermeulen;Piet Demeester	2005	Electronic Commerce Research	10.1007/s10660-005-1181-7	embedded system;real-time computing;computer science;component-based software engineering;operating system;common object request broker architecture;middleware;videoconferencing;h.323;world wide web	DB	-36.60375421318127	41.87918435513795	188568
d45d5e209b916663f1cbcf2795ce4be19c3fa4db	building a case for fipa compliant multiagent approaches for wireless sensor networks	multiagent system;fipa;agent based;wireless sensor network;for intelligent physical agents;middleware;structural health monitoring;fipa compliance;wireless sensor networks;multiagent systems	There have been some efforts to apply agent based approaches in Wireless Sensor Networks (WSNs) for different application scenarios in recent past. These efforts have met with varying levels of success so far. However, the efforts to assess the suitability of Foundation for Intelligent Physical Agents (FIPA) compliant multiagent solutions for WSNs are almost non-existent. In this paper we present a scenario from an industrial domain and asses the suitability of a FIPA compliant multiagent based solution for it. The scenario is based on a WSN deployment in an underground mine where it could be put to use for several purposes like hazardous gas plume detection and tracking, mine lighting control, Proximate Environment Monitoring (PEM), structural health monitoring of mine structure, to name a few. However, we only consider the PEM usage scenario in this paper.	agent-based model;lighting control system;plume (fluid dynamics);requirement;software deployment	Khalid Nawaz;Alejandro P. Buchmann	2008		10.4108/ICST.AMBISYS2008.2906	embedded system;simulation;engineering;computer security	AI	-38.806563955121085	44.63819521712413	188632
bf51a17af2ec2bfa3fd3cfbdfbeebfc0d3723f99	adaptable pervasive flows - an emerging technology for pervasive adaptation	pervasive computing humans application software computer vision embedded computing mobile communication conferences wireless sensor networks software systems hardware;probability density function;pervasive computing;airports;data mining;human behavior;emerging technology;adaptation model;pervasive adaptation;logic gates;workflows;adaptation;adaptable pervasive flows;ubiquitous computing;pervasive computing adaptable pervasive flows pervasive adaptation;workflows adaptation pervasive applications;context;pervasive applications	The era of pervasive computing brings with it a grand challenge: Pervasive applications must adapt to the dynamics entailed in human behavior and constantly changing computing environments. In this paper, we propose adaptable pervasive flows as a novel technology that goes far beyond existing approaches for adapting pervasive computing systems. APFs model applications in a fashion similar to classical workflows while being situated in the real world. The notable advantage of this is that applications as well as their environment can be adapted proactively based on knowledge about future tasks. We introduce the visions, concepts, and challenges of this emerging approach.	coherence (physics);grand challenges;pervasive psql;pervasive informatics;programming paradigm;seamless3d;sentient computing;situated;ubiquitous computing;user interface	Klaus Herrmann;Kurt Rothermel;Gerd Kortuem;Naranker Dulay	2008	2008 Second IEEE International Conference on Self-Adaptive and Self-Organizing Systems Workshops	10.1109/SASOW.2008.25	workflow;probability density function;real-time computing;context-aware pervasive systems;simulation;logic gate;computer science;distributed computing;emerging technologies;ubiquitous computing;adaptation	Robotics	-44.068851324625534	44.97281825128574	189016
61f04641dcefc086464a69dccfd613ac7898570c	generic support for distributed applications	distributed application;distributed system;distributed programming client server systems open systems multimedia computing mobile computing;client server systems;multimedia computing;application software middleware educational institutions software design distributed computing explosions multimedia systems mobile computing large scale systems information systems;distributed programming;middleware;software design;mobile computing;distributed software approach middleware platforms distributed computing system distributed processing requirements multimedia systems mobile users mobile computers timely asynchronous event response secure interoperability independent services large scale widely distributed systems information systems cross domain interaction flexible scalable approach;open systems;object model	I n the late 1980s, software designers introduced middleware platforms to support distributed computing systems. Since then, the rapid evolution of technology has caused an explosion of distributed-processing requirements. Application developers now routinely expect to support multimedia systems and mobile users and computers. Timely response to asynchronous events is crucial to such applications, but current platforms do not adequately meet this need. Another need of existing and emerging applications is the secure interoperability of independent services in large-scale, widely distributed systems. Information systems serving organizations such as universities, hospitals, and government agencies require cross-domain interaction. These systems must handle large numbers of users and must be easy to use, internally efficient, secure, reliable, and robust. Moreover, independently developed services must work together with minimal extensions to their basic software. At the University of Cambridge, in the Computer Laboratory’s Opera Research Group, we have developed middleware extensions to address these problems: the Cambridge Event Architecture for asynchronous operation and Oasis, an open architecture for secure interoperating services. Our work is wide in scope, with applicability to many multiservice information systems.	computer;distributed computing;information system;interoperability;middleware;open architecture;requirement;robustness (computer science)	Jean Bacon;Ken Moody;John Bates;Richard Hayton;Chaoying Ma;Andrew McNeil;Oliver Seidel;Mark D. Spiteri	2000	IEEE Computer	10.1109/2.825698	distributed algorithm;dce/rpc;middleware;real-time computing;global information system;object model;computer science;object request broker;software design;message oriented middleware;operating system;middleware;database;distributed computing;distributed object;distributed design patterns;open system;mobile computing;replication;autonomic computing	OS	-33.733424415906356	44.80846643109925	189042
4c50476f36b8ffb811f39323081124ba32a04c61	on resource-sensitive timed component connectors	constraint automata;formal model;simulation;resource sensitive timed;coordination language;semantic model;compositional reasoning;coordination;time constraint	In this paper we introduce a formal model for reasoning about resource sensitive timed component connectors. We extended the constraint automata model, which is used as the semantic model for the exogenous channelbased coordination language Reo, through integrating both resource and time information. This model allows to specify both the interactions that take time to be performed and timeouts. Moreover, the model reflects resource issues, such as bandwidth or allocated memory, that may affect the time needed for interactions when specifying the timed behavior of connectors. The time duration that an interaction takes is represented by a function on the available resources. In addition to the formalism, we also discuss compositional reasoning and present two notions of simulation to relate different connectors from functional and resourcesensitive temporal perspectives respectively.	automata theory;bandwidth (signal processing);constraint automaton;fits;formal language;interaction;principal component analysis;scheduling (computing);semantics (computer science);simulation	Sun Meng;Farhad Arbab	2007		10.1007/978-3-540-72952-5_19	semantic data model;real-time computing;simulation;computer science;algorithm	AI	-34.87615426747193	34.28095054727792	189068
e42d4c50247a006b7e9dd156cc569092a4e076b1	task level specification and communication		Abstract   To translate a system specification into a hardware and software implementation, several translations and decisions have to be made. Task Level Behavioral VHDL focuses on the specification of an embedded system without muddling with implementation details. The specification uses tasks specifying the data processing, communication and synchronization. A specification of a task consists of a PORT, CONTEXT, DECLARATION and DATA PROCESSING section. The contex simplifies the system specification by specifying task interruption and communication protocols used on the channels between tasks.		L. P. M. Benders;M. P. J. Stevens	1992	Microprocessing and Microprogramming	10.1016/0165-6074(92)90338-8	embedded system;parallel computing;real-time computing;computer science;operating system;system requirements specification;programming language;language of temporal ordering specification	EDA	-34.303639410220015	33.327930008613954	189326
3ee985d2fd62e3ff39458d448822fd15f6f2d27c	automatic client-server partitioning of data-driven web applications	application development;application server;sampling;programming model;client server;approximate query answering;course management system	Current application development tools provide completely different programming models for the application server (e.g., Java and J2EE) and the client web browser (e.g., JavaScript and HTML). Consequently, the application developer is forced to partition the application code between the server and client at the time of writing the application. However, the partitioning of the code between the client and server may have to be changed during the evolution of the application for performance reasons (it may be better to push more functionality to the client), for correctness reasons (data that conflicts with multiple clients cannot always be pushed to clients), and for supporting clients with different computing power (browsers on desktops vs. PDAs). Since the client and server use different programming models, moving application code from client to server (and vice versa) reduces programmer productivity and also has the potential to introduce concurrency bugs. In this demonstration, we advocate an alternative solution to this problem: we propose developing applications using a unified declarative high-level language called Hilda, and show how a Hilda compiler can automatically (and correctly) partition Hilda code between the client and the server using a real Course Management System application. We illustrate our techniques using two clients: a powerful laptop machine and a less powerful PDA.	application server;client–server model;compiler;concurrency (computer science);correctness (computer science);html;high- and low-level;high-level programming language;java platform, enterprise edition;javascript;laptop;management system;mathematical optimization;personal digital assistant;programmer;programming productivity;programming tool;server (computing);software bug;web application	Nicholas Gerner;Fan Yang;Alan J. Demers;Johannes Gehrke;Mirek Riedewald;Jayavel Shanmugasundaram	2006		10.1145/1142473.1142580	client;smart client;sampling;computer science;web api;operating system;database;fat client;programming paradigm;programming language;rapid application development;world wide web;application server;client–server model;remote evaluation	OS	-34.30541432808601	40.14717571883069	189426
3f1d2245ea159d89c0132b618fe17ef0528234fe	tackling variety in event-based systems	coupling;semantics;internet of things;thingsonomy;event processing systems	Event-based systems follow an interaction model based on three decoupling dimensions: space, time, and synchronization. However, event producers and consumers are tightly coupled by event semantics: types, attributes, and values. That limits scalability in large-scale heterogeneous environments with significant variety such as the Internet of Things (IoT) due to difficulties in establishing semantic agreements at such scales. This paper studies this problem and investigates the suitability of different traditional and emerging approaches for tackling the issue.	coupling (computer programming);internet of things;scalability;synchronization (computer science)	Souleiman Hasan;Edward Curry	2015		10.1145/2675743.2774215	real-time computing;computer science;complex event processing;data mining;database;distributed computing;semantics;coupling;internet of things	DB	-43.20544631740424	42.679124151370765	190028
54bdbf6672c35c4225c22e63998fb6f7c682063b	ontology for mobile phone operating systems		This ongoing study deals with an important part of a line of research that constitutes a challenging burden. It is an initial investigation into the development of a Holistic Framework for Cellular Communication (HFCC). The main purpose is to establish mechanisms by which existing wireless cellular communication components and models can work holistically together. It demonstrates that establishing a mathematical framework that allows existing cellular communication technologies (and tools supporting those technologies) to seamlessly interact is technically feasible. The longer-term future goals are to actually improve the interoperability, the efficiency of mobile communication, calls quality, and reliability by applying the framework to specific development efforts.	android;domain analysis;extensibility;feature model;holism;interoperability;mobile phone;ontology (information science);operating system;symbian;unified modeling language	Hasni Neji;Ridha Bouallegue	2012	CoRR	10.5121/ijwmn.2012.4311	simulation;management science	Mobile	-43.9798153219145	44.34919481093354	190099
44acacc7a442b12f6bc83fcca0b7c49644a2e5da	an overview of s-ogsa: a reference semantic grid architecture	informatica;design principle;virtual community;semantics;spectrum;open grid service architecture;grid;explicit metadata;architecture;semantic grid;reference architecture;grid system	Architecture Oscar Corcho, Pinar Alper, Ioannis Kotsiopoulos, Paolo Missier, Sean Bechhofer and Carole Goble School of Computer Science The University of Manchester, Manchester, UK <ocorcho, penpecip, ioannis, pmissier, seanb, carole>@cs.man.ac.uk Abstract The Grid's vision, of sharing diverse resources in a flexible, coordinated and secure manner through dynamic formation and disbanding of virtual communities, strongly depends on metadata. Currently, Grid metadata is generated and used in an ad hoc fashion, much of it buried in the Grid middleware’s code libraries and database schemas. This ad hoc expression and use of metadata causes chronic dependency on human intervention during the operation of Grid machinery, leading to systems which are brittle when faced with frequent syntactic changes in resource coordination and sharing protocols.	automated reasoning;capability maturity model;coexist (image);computer science;database schema;downstream (software development);entity;feedback;grid computing;hoc (programming language);library (computing);middleware;norm (social);oscar;ontology (information science);open grid services architecture;overhead (computing);provisioning;scalability;semantic web;semantic grid;semantic network;virtual community	Óscar Corcho;Pinar Alper;Ioannis Kotsiopoulos;Paolo Missier;Sean Bechhofer;Carole A. Goble	2006	J. Web Sem.	10.1016/j.websem.2006.03.001	reference architecture;spectrum;semantic grid;computer science;architecture;data grid;database;distributed computing;semantics;grid;world wide web;drmaa;grid computing	HPC	-36.662234393591525	42.98170326757997	190499
1b25ea55a0e17a0a98356a5f57d762d564795ed1	enriching the internet by acting and reacting		A recent trend in application development for the web is a move towards rich internet applications (RIAs). As more and more of the application logic is moved to the client, RIAs can benefit from concurrency in order to increase overall performance as well as responsiveness of the application. Additionally, RIAs are often written in an event-driven style of programming to react to incoming events of a multitude of services that are integrated within the application. In this paper we argue that, while individual technologies exist to tackle both concerns, these technologies cannot easily be integrated in an ad hoc way. To increase the modularisability and composability of RIAs we propose a new programming model based on actors and reactors that encapsulate different parts of the application. We show that our model is able to exploit some of the available concurrency while reducing the required amount of event-driven code. Both actors and reactors are modular components that can be glued together via a unified communication mechanism. We evaluate our approach by means of a motivating example of a collaborative code editor.	business logic;code reuse;composability;computation;concurrency (computer science);control flow;event-driven programming;graphical user interface;hoc (programming language);javascript;programming model;publish–subscribe pattern;responsiveness;rich internet application;separation of concerns;server (computing);source lines of code;web application	Sam Van den Vonder;Florian Myter;Joeri De Koster;Wolfgang De Meuter	2017		10.1145/3079368.3079407	rich internet application;the internet;programming paradigm;javascript;composability;reactive programming;concurrency;unified communications;distributed computing;computer science	HCI	-36.03147524043946	41.150026221463094	190569
a1196fa5e14b40ad57a724b672220ae7f48157a7	cloud#: a specification language for modeling cloud	trust;virtual machining computational modeling argon virtual machine monitors cloud computing resource management monitoring;fair scheduling;trust cloud computing cloud model;specification language;cloud modeling specification language cloud internal organisation cloud services business critical application cloud computing resource visualization fair scheduling trusted cloud services;specification languages;cloud model;specification languages cloud computing security of data;security of data;cloud computing	We present a specification language Cloud# for modeling the internal organisation of cloud. By reasoning about cloud models, clients understand more on how services are delivered inside cloud. In this sense, cloud models make cloud services more transparent to clients. The transparency of cloud services are expected to increase the confidence of clients to move their business-critical applications to cloud. The expressiveness of Cloud# is evaluated by giving four cloud models, which demonstrate basic features of cloud computing, such as resource virtualization and air scheduling. We describe an application of Cloud# by building an architecture, in which Cloud# models are combined with remote attestation to deliver trusted services.	client (computing);cloud computing;fair-share scheduling;scheduling (computing);specification language;trusted computing;x86 virtualization	Dongxi Liu;John Zic	2011	2011 IEEE 4th International Conference on Cloud Computing	10.1109/CLOUD.2011.18	cloud computing security;real-time computing;specification language;cloud computing;computer science;operating system;cloud testing;distributed computing;trustworthy computing;world wide web	Visualization	-46.57253055735039	43.36547851510902	190582
617428c5ba59eb8ee0e9cbbf197d9cd8f6698a34	volatile sets: event-driven collections for mobile ad-hoc applications		In mobile peer-to-peer applications, a common pattern is to maintain a collection of remotely-hosted objects. Traditional approaches require programmers to manually track the connectivity state of these remote objects and add them or remove them from local collections on a per-object basis. Because this happens concurrently with the rest of the application code, it hinders the composability of such collections and leads to subtle and hard to find bugs. In this paper, we propose an abstraction called volatile sets that allows the contents of the set to be specified intensionally. Additionally, volatile sets offer an event-driven API that signals when remote objects appear, disappear or change. Finally, volatile sets can be easily and efficiently composed through traditional set operations. We show how volatile sets ease the development of a collaborative peer-to-peer drawing application.	algorithm;application programming interface;composability;consistency model;event-driven programming;fuzzy set;hoc (programming language);network traffic control;peer-to-peer;programmer;rough set;software bug;volatile memory	Dries Harnie;Elisa Gonzalez Boix;Andoni Lombide Carreton;Christophe Scholliers;Wolfgang De Meuter	2011	ECEASST	10.14279/tuj.eceasst.43.585	computer science;theoretical computer science;database;distributed computing	HCI	-35.46821958098076	40.7978138380595	190718
d3c43e2af4959c32ad775a57e42119dc1ccd1801	algon: from interchangeable distributed algorithms to interchangeable middleware	distributed algorithms;distributed system;components;interchangeability;separation of concern;component middleware;mutual exclusion;distributed environment;complex system;system design;middleware independence;middleware;separation of concerns;distributed algorithm;software composition;programming framework	Programming in a distributed environment is a complex activity. Programmers need to be aware of issues unrelated to their domain of expertise, and are often unprepared for the challenges that distribution brings. Chief among these are the choice and application of different distributed algorithms, and the adaptation to evolving and emerging middleware systems. We have tackled both these problems by adopting the technique of separation of concerns. We have developed a framework called Algon which enables any of a range of complex distributed algorithms (for example, for mutual exclusion and deadlock) to be incorporated into existing or new distributed systems based on quantitative comparisons supported by a performance visualisation tool. Since middleware can have a considerable impact on the performance of a distributed system, it is highly desirable to be able to test one against the other. We propose that the principles applied in providing for interchangeable algorithms can also been extended to interchangeable middleware, and we have completed the redesign of the Algon system accordingly. In this paper we explain how the Algon framework operates, how the programmer can use it to interchange and compare algorithms, and how this concept can be extended so that the existing Java-RMI middleware can be dynamically replaced by Corba. We envisage a C# version of Algon in which Corba can be interchanged with .NET or any other future middleware system. The lessons learnt through this research include practical aspects of software composition, the impact of language features on system design and issues associated with evaluating complex systems at runtime.	common object request broker architecture;complex systems;deadlock;distributed algorithm;distributed computing;function composition (computer science);java remote method invocation;middleware;mutual exclusion;programmer;run time (program lifecycle phase);separation of concerns;systems design	Karen Renaud;Judith Bishop;Johnny Li-Chang Lo;Basil Worrall	2005	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2004.02.064	distributed algorithm;real-time computing;separation of concerns;computer science;database;distributed computing;programming language	PL	-38.53870676941664	36.9460955214209	190748
8a5815cf00e3c72ef8c3bf1d8d996f45184f58af	opc ua supporting the automated engineering of production monitoring and control systems	manufacturing systems;software;synchronization production monitoring systems production control systems production plants manufacturing systems standardized communication method opc ua framework;control systems;servers monitoring production control systems computer architecture process control software;opc ua framework;production control systems;standard exchange format;production engineering computing;synchronisation computerised monitoring manufacturing systems production control production engineering computing;synchronisation;computer architecture;control system;servers;production control;monitoring;synchronization;production plants;standardized communication method;process control;production;production monitoring systems;computerised monitoring;manufacturing system;monitoring and control	Control systems monitor and control production plants and manufacturing systems. Before they can be taken into operation, they have to be configured. To automate this process, which is called engineering, a standardized exchange format is required that forms the basis of the work of all those who are involved in the project and that is understood by anyone involved. In addition, the contents to be exchanged have to be transmitted on the basis of a standardized communication mechanism with maximum efficiency. This article will present a standardized communication method capable of fulfilling these requirements. On the basis of an OPC UA framework acting as a communication, synchronization and processing mechanism, the opportunities of the unified architecture and its application in the automated engineering of control systems will be evaluated.	address space;control system;correctness (computer science);microsoft outlook for mac;opc unified architecture;open platform communications;requirement;server (computing);software development kit;user agent	Miriam Schleipen	2008	2008 IEEE International Conference on Emerging Technologies and Factory Automation	10.1109/ETFA.2008.4638464	synchronization;real-time computing;telecommunications;computer science;systems engineering;engineering;control system;instrumentation and control engineering;control theory	SE	-35.395954338427565	38.96390633119975	190946
026256aa220d2c9381499d514c9872d0b834b341	on impact-oriented automatic resolution of pervasive context inconsistency	pervasive computing;inconsistency resolution	Context-awareness is a capability that allows applications in pervasive computing to adapt themselves continuously to changing contexts of their environments. However, contexts from physical environments may be inconsistent. It affects the correctness of these applications. Existing resolution strategies for context inconsistency have diverse adverse impacts on the context-awareness of applications, such as feeding different amounts of contexts to the applications. In this paper, we examine the impacts of inconsistency resolution and study the extent to which their effects on context-awareness can be reduced. We conduct simulation experiments of two pervasive computing applications. The experimental results show that existing inconsistency resolution strategies adversely affect the context-awareness of applications. This motivates the importance of deploying an impact-oriented approach to respect context-awareness in inconsistency resolution.	context awareness;correctness (computer science);experiment;pervasive informatics;simulation;ubiquitous computing	Chang Xu;Shing-Chi Cheung;Wing Kwong Chan;Chunyang Ye	2007		10.1145/1295014.1295043	simulation;computer experiment;computer science;data mining;computer security;ubiquitous computing	HCI	-42.11079865978821	42.73789723706063	191204
20ea6296babd27f22f121f96efb61757ced21b92	model-based construction and verification of cyber-physical systems		By combining communication, computation, and control (3C), Cyber-Physical Systems (CPS)0tightly couple the physical world with the cyber-world, to enable more applications, enhance performance, increase dependability and etc. Among these goals, as CPS are widely used in the safety-critical area, guaranteeing the basic dependability/safety is after all the prerequisite and often the top concern.  However, the behavior of CPS is extremely complex. First of all, due to the existence of both discrete control modes transition and continuous real-time behavior in CPS, the behavior of CPS is a complex hybrid state space, which is difficult to understand and handle. Secondly, most CPS applications are working in the open environment and acquiring real-time data from the environment intensively to adjust their own behavior. The dynamic environment makes the behavior space more complex to reason.  When a system is too complex to analyze directly, building an abstract model of the system and then conducting analysis on the model to answer questions about the original system is an important and widely-used method. Meanwhile, a reasonable model also plays important roles in the phase of specification, design, development, testing, monitoring and so on. Therefore, it is an important topic of investigating how model-based methods can be applied in the context of CPS to increase the quality and dependability of the system.  During the past decade, our research group at Nanjing University has devoted a lot of efforts into this mission. We conducted comprehensive research in a wide spectrum of CPS including model-driven design, verification, control, monitoring, and testing. In this paper, we will make a general review of the progress we made on these directions recently.		Lei Bu;Tian Zhang;Xin Chen;Linzhang Wang;Jianhua Zhao;Xuandong Li	2018	ACM SIGSOFT Software Engineering Notes	10.1145/3229783.3229793	software engineering;systems engineering;computation;state space;cyber-physical system;computer science;dependability	SE	-45.34916992543012	36.1497416423211	191288
6a07cdcc8c53253995bb7ebc42c392ac4b62296a	compositional verification of a medical device system	large software system;complex system;different subsystems;simulink design verifier;aadl language;verification tool;osate aadl environment;compositional verification;system level property;medical device system;design language;cyber physical systems	Complex systems are by necessity hierarchically organized. Decomposition into subsystems allows for intellectual control, as well as enabling different subsystems to be created by distinct teams. This decomposition affects both requirements and architecture. The architecture describes the structure and this affects how requirements ``flow down'' to each subsystem. Moreover, discoveries in the design process may affect the requirements. Demonstrating that a complex system satisfies its requirements when the subsystems are composed is a challenging problem.  In this paper, we present a medical device case example where we apply an iterative approach to architecture and verification based on software architectural models. We represent the hierarchical composition of the system in the Architecture Analysis and Design Language (AADL), and use an extension to the AADL language to describe the requirements at different levels of abstraction for compositional verification. The component-level behavior for the model is described in Simulink/Stateflow. We assemble proofs of system level properties by using the Simulink Design Verifier to establish component-level properties and an open-source plug-in for the OSATE AADL environment to perform the compositional verification of the architecture. This combination of verification tools allows us to iteratively explore design and verification of detailed behavioral models, and to scale formal analysis to large software systems.	architecture analysis & design language;complex system;complex systems;iterative method;open-source software;plug-in (computing);principle of abstraction;requirement;simulink;software system;stateflow	Anitha Murugesan;Michael W. Whalen;Sanjai Rayadurgam;Mats Per Erik Heimdahl	2013		10.1145/2527269.2527272	real-time computing;verification;simulation;software verification;computer science;high-level verification;runtime verification;programming language;cyber-physical system;functional verification	SE	-42.274724130203815	33.025329672280634	191350
96e05341647eb234f28ea4309a85192aa52f9aa8	software performance models from system scenarios	layered queueing networks;user requirements notation;uml;software systems;use case map;software performance;message sequence chart;unified modeling language;use case maps;performance model;layered queueing network;scenarios;use case;sequence diagram;software quality;software evaluation	The earliest definition of a software system may be in the form of Use Cases, which may be elaborated as scenarios. In this work performance models are created from scenarios, to permit the earliest possible analysis of potential performance issues. Suitable forms of scenario models include UML Activity or Sequence Diagrams, and Use Case Maps from the URN standard. They capture the causal flow of intended execution, and the operations, activities or responsibilities which may be allocated to components, with their expected resource demands. The SPT algorithm described here automatically transforms scenario models into performance models, and the LQNGenerator tool implements SPT to convert UCM scenario models into Layered Queueing performance models. SPT can in principle also be applied to other scenario models, including Message Sequence Charts, UML Activity Graphs (or Collaboration Diagrams, or Sequence Diagrams).	algorithm;causal filter;hall-effect thruster;message sequence chart;performance engineering;rational clearcase ucm;sequence diagram;software system;unified modeling language	Dorin Bogdan Petriu;C. Murray Woodside	2005	Perform. Eval.	10.1016/j.peva.2004.09.005	unified modeling language;real-time computing;computer science	SE	-43.810044827875124	33.87371335853655	191799
6a3d3a2bd367dfddad3c4a01b1f2603ae97010cf	requirements and tools for the debugging of multi-agent systems	debugging;virtual machine;toolset;multi agent system;three dimensions;requirements;multi agent systems;mulan;reference architecture;message logging	Debugging of multi-agent systems (MAS) is hard due to their distributed, concurrent, adaptive, highly interactive, flexible, mobile and heterogeneous nature.We identify three dimensions (activities, scale, and coupling) that span the area of debugging and derive general requirements for a debugging toolset in the multi-agent context. An implementation of a toolset w.r.t. the requirements given for the MAS reference architecture Mulan is presented. This toolset comprises general low level debugging possibilities that are included in the virtual machine (execution engine Renew), specialized Mulan-dependent debugging facilities that enable debugging on higher (agent concepts and independent debugging aspects that rely on publicly available information - i.e. message logs - together with advanced techniques, such as visualization and mining.	debugging;multi-agent system	Lawrence Cabac;Till Dörges;Michael Duvigneau;Daniel Moldt	2009		10.1007/978-3-642-04143-3_26	reference architecture;three-dimensional space;requirements analysis;computer architecture;real-time computing;computer science;virtual machine;artificial intelligence;operating system;multi-agent system;algorithmic program debugging;background debug mode interface;debugging;nexus	Robotics	-40.52162585795675	36.296172041757984	191919
99739fc60a27ac8576e7ab44a8c14cf14f09b709	bridging the requirements/design gap in dynamic systems with use case maps (ucms)	design model;incremental development;uml;use cases;dynamic system;use case map;architectural reasoning;software engineering;ucm styles;requirements;model derivation;test case generation;software development;performance analysis;time use;design;scenarios;high level architecture;use case;urn	Two important aspects of future software engineering techniques will be the ability to seamlessly move from analysis models to design models and the ability to model dynamic systems where scenarios and structures may change at run-time. Use Case Maps (UCMs) are used as a visual notation for describing causal relationships between responsibilities of one or more use cases. UCMs are a scenario-based software engineering technique most useful at the early stages of software development. The notation is applicable to use case capturing and elicitation, use case validation, as well as high-level architectural design and test case generation. UCMs provide a behavioural framework for evaluating and making architectural decisions at a high level of design. Architectural decisions may be based on performance analysis of UCMs. UCMs bridge the gap between requirements and design by combining behaviour and structure in one view and by flexibly allocating scenario responsibilities to architectural components. They also provide dynamic (run-time) refinement capability for variations of scenarios and structure and they allow incremental development and integration of complex scenarios. Therefore, UCMs address the issues mentioned above.	bridging (networking);causality;dynamical system;high- and low-level;high-level programming language;iterative and incremental development;map;profiling (computer programming);refinement (computing);requirement;requirements elicitation;run time (program lifecycle phase);software development;software engineering;test case	Daniel Amyot;Gunter Mussbacher	2001			use case;reliability engineering;simulation;systems engineering;engineering;software engineering	SE	-43.68163502354896	33.587088899248116	191922
0f30e141e635d7e1eb5076cd80c42a93b101d703	corbaweb: a generic object navigator	object oriented design;heterogeneous environment;information space;corba;web service;distributed objects;client server;object oriented;object orientation;world wide web;interoperability;object oriented technology;point of view;generic object navigator;scripting language;information system development	Abstract   The World Wide Web and Distributed Object-Oriented Systems (e.g. CORBA) provide future infrastructures for distributed client/server computing. This paper presents our work to provide the integration of CORBA objects into the Web: first, to describe Web services using object-oriented technologies and second to access any Information System developed with CORBA from the Web. We present a new Shared Information Space model with the following issues:  Object Orientation Design, Distributed and Heterogeneous Environment, Users' Point of View, Object Invocation and Navigation .  Navigation over SIS is supported by  CorbaWeb , a Generic Object Navigator, composed of metascripts allowing the access, the representation and the invocation of any CORBA object from the Web. These operations are achieved by scripts written in  CorbaScript , an interpreted scripting language which can dynamically invoke any CORBA objects.		Philippe Merle;Christophe Gransart;Jean-Marc Geib	1996	Computer Networks	10.1016/0169-7552(96)00071-2	web service;distributed objects everywhere;interoperability;interoperable object reference;computer science;object;object-oriented design;dynamic invocation interface;common object request broker architecture;web page;database;distributed computing;scripting language;distributed object;programming language;object-oriented programming;object-orientation;law;world wide web;client–server model	Vision	-34.79521293553315	43.13170881311017	192156
63eeec2bd9cdf512e35a894d8cbe66f4452fa3a9	coordinating spatially-situated pervasive service ecosystems		Technology evolution is providing new pervasive service scenarios characterised by a huge number of distributed and dynamic devices. Accordingly, a new generation of services and infrastructures are emerging which support situatedness, adaptivity and diversity. In this paper we model the overall world of services, data and devices, as a distributed computational ecosystem. Each entity will be modelled as an autonomous, spatially-situated individual of the ecosystem, whose existence is reified by an LSA (Live Semantic Annotation). Ecosystem’s behaviour is controlled by coordination rules called eco-laws, which are sort of chemical-like reactions evolving the population of LSAs. We describe an architecture supporting this vision, a formal model of eco-laws, and finally show their usefulness in a scenario of crowd steering through pervasive displays.	augmented reality;autonomous robot;crowdsourcing;ecosystem;independent set (graph theory);mathematical model;ontology (information science);pervasive informatics;proactive parallel suite;real-time locating system;reification (computer science);self-organization;situated;tuple space;ubiquitous computing;web ontology language	Mirko Viroli;Elena Nardini;Gabriella Castelli;Marco Mamei;Franco Zambonelli	2011			ecosystem;data science;situated;architecture;sort;technological evolution;population;annotation;computer science	HCI	-41.93323315153044	45.85221778404099	192194
7097690fd504996e6ac0edd88293aca62eb52e45	modeling functional and non-functional properties of systems based on a multi-view approach. (une approche multi-vue pour la modélisation système de propriétés fonctionnelles et non-fonctionnelles)		At the system-level, experts specify functional and non-functional properties by employing their own theoretical models, tools and environments. Such experts attempt to use the most adequate formalisms to verify the defined system properties in a specific domain. Nevertheless, each one of these experts’ views is supported on a common base and impacts directly or indirectly the models described by the other experts. As a consequence, it is essential to keep a semantic coherence among the different points of view and also to be able to reconcile and to include all the points of view before undertaking the different phases of the analysis. This thesis proposes a specific domain model named PRISMSYS. This model is based on a model-driven multi-view approach where the concepts, and the relationships between them, are described for each expert’s domain. Moreover, these concepts maintain a relation with a backbone model. PRISMSYS allows keeping a semantic coherence among the different views by means of the manipulation of events and logical clocks. PRISMSYS is represented in a uml profile, supported as much as possible by SysML, devoted to the systems engineering, and marte, dedicated to the design of real-time embedded systems. The semantic model, which preserves the view coherence, is specified by using ccsl, a declarative formal language for the specification of causal and temporal relationships between events of different views. The approach is illustrated taking as case study an electronic system, where the main domain analysis is power consumption. The system model incorporates various views: a functional model, a power model, a time performance model and a thermal model. In turn, these views are divided in three parts: control, structural, and equational. These parts interact with each other to characterize the temperature and power consumption of the system. The environment proposed by PRISMSYS allows the co-simulation of the model and its analysis. The simulation is supported by TimeSquare, for the event aspects and correlated to the control, and by SciLab, for taking into account the nonfunctional properties (temperature and power consumption). The analysis is conduced by transforming the multi-view model in the internal format accepted by Aceplorer, an expert tool dedicated to power consumption analysis.		Carlos Ernesto Gómez Cárdenas	2013				SE	-40.378308171347044	33.00002816440112	192487
4a10fb04d4290ccd0ce46c25ff685461f84b7ab3	simualtion-based debugging of active databases	formal specification;active database;rule based;formal specification program debugging deductive databases system monitoring software reliability;system monitoring;program debugging;debugging databases discrete event simulation scheduling application software event detection information systems clustering algorithms production planning software engineering;software reliability;user interactions active databases simulation based debugging adl activity description language simulated event schedules asynchronous simulator aide architecture extended debugging mapping algorithm;deductive databases	Active databases allow the rule-based specification of activities using languages like ADL (Activity Description Language) for the definition of complex, applicationspecific events and reactions thereof. Although a number of such languages for active databases have been published in the last years, there is an obvious lack of suitable mechanisms to examine whether the described active behaviour designed for an application corresponds to the intended one. As a possible solution for this problem we suggest the concept of debugging active databases with simulated event schedules. In particular,we map the events of the activity description into different event schedules for an asynchronous simulator. We briefly introduce the AIDE architecture, the activity description language ADL and motivate the necessity of a simulation tool. Then we focus on the description of extended debugging with simulation especially on a mapping algorithm and a simulation execution mechanism supported by user interactions.	active database;advanced intrusion detection environment;algorithm;architecture description language;compiler;debugger;debugging;error message;interaction;logic programming;oracle database;prototype;runtime system;schedule (computer science);simulation;software bug;software propagation	Helge Behrends	1994		10.1109/RIDE.1994.282839	real-time computing;computer science;database;algorithmic program debugging;programming language	AI	-34.631366317530194	35.09348620677456	192754
6e3d765e21be70552f720999cd3e2452eedbf6c0	reliability analysis of complex systems with repair	complex system;reliability analysis		complex systems;reliability engineering	Peter Franken;Bernd-Michael Kirstein;Arnfried Streller	1984	Elektronische Informationsverarbeitung und Kybernetik		complex system;discrete mathematics;complex system;theoretical computer science;mathematics;reliability engineering	Logic	-46.99453182903868	32.457677077177046	193488
5addba2287cd1aa2b61fbb821ee297d30178dd54	a discrete-event simulator for early validation of avionics systems		The paper discusses problems arising in development of avionics systems and considers how discrete-event simulation on the base of architecture models at the early stages of avionics design can help to mitigate some of them. A tool for simulation of AADL architecture models augmented by behavioural specifications is presented and its main design decisions are discussed.	architecture analysis & design language;avionics;behavior model;simulation;transition system	Denis Buzdalov;Alexey A. Khoroshilov	2014			avionics;architecture;computer architecture;computer science	SE	-43.27603264923857	32.90964527029701	193530
6a2d4ccdacbd29586faa01401da9607a50c55a8c	automatic mediation between incompatible component interaction styles	mediation object oriented modeling concrete java context aware services programming assembly systems sorting computer languages;legacy software;interaction style;object oriented programming;automatic programming;ejb 2 0 automatic mediation component interaction styles incompatibility interoperability off the shelf components legacy software aid heterogeneous interaction styles invocation pipe and filter abstract interface description dataflow mediation mediation code invocation based interaction mismatching push pull modes event based interaction corba notification service enterprise java beans message driven beans;software reusability;distributed object management;message passing;component model;open systems;off the shelf;remote procedure calls;software reusability distributed object management object oriented programming remote procedure calls automatic programming message passing java open systems;enterprise java bean;java	Incompatibility of component interaction styles is identified as a major obstacle to interoperability when using off-the-shelf components or dealing with legacy software in compositional development. It is argued that a language for defining abstract interfaces – AID – can serve as a basis for accommodating heterogeneous interaction styles. AID is independent of any concrete style, such as invocation, pipe-and-filter, event-based or others. An AID text just specifies elementary input and output events which happen at the boundary of a component. Code that mediates between different styles can then be generated automatically from an abstract interface description. The focus of this paper is on mediating between dataflow and invocation interaction. The design of the mediation code for invocation-based interaction with mismatching push/pull modes is described in some detail. How to accommodate event-based interaction is shown in the context of the CORBA Notification Service. Enterprise Java Beans are taken as an example of a complex component model, and the problems of accommodating the message-driven beans of EJB 2.0 are analyzed.	.net framework;abstraction layer;common object request broker architecture;component-based software engineering;dataflow;elementary;enterprise javabeans;input/output;interoperability;java platform, enterprise edition;legacy system;notification service;osgi;piaget's theory of cognitive development;pipeline (software);production system (computer science);programming language;software incompatibility;tagged union;type system	Klaus-Peter Löhr	2003		10.1109/HICSS.2003.1174884	message passing;real-time computing;computer science;operating system;software engineering;component object model;database;distributed computing;open system;programming language;object-oriented programming;java;remote procedure call;world wide web;legacy system	SE	-34.37807988317134	41.9960594665663	193593
75361e96a3da50ce626c9651f659c3c36ad533ea	software engineering challenges for mutable agent systems	heterogeneous computing;agent oriented software engineering;software engineering;agent systems	"""In this paper we address mutability, an important feature of agent societies operating in heterogeneous computing environments. We present the Bond system, a FIPA compliant agent framework, with support for mutability. We propose a set of extensions to the Gaia agent-oriented design and analysis methodology. These extensions allow the methodology to handle certain important classes of mutable systems. 1. MUTABILITY Mutation is a term used in genetic algorithms and evolutionary computing to indicate random changes of the chromosomes. Throughout this paper we use the term mutation to indicate controllable and well specified changes of a program at runtime. The executable of a mutable program could be self-modifiable or could be modified by an external entity. As early as 1975, the Microsoft Basic interpreter for Altair contained self-modifying code, to fit into the limited address space available. Reconfigurable and mutable systems are an increasingly frequent occurrence in today’s computing landscape. The ubiquitous web browser consists of a basic framework with multiple API’s allowing the user to configure and extend the browser. Extensions such as plugins, codecs, drivers, applets, controls, and themes change the functionality of the browser, e.g., allow the user to view new media formats. Extensions are installed and uninstalled dynamically during the lifetime of the application. Extensions are usually developed by a third party. In addition to the desired changes of functionality, an extension may have undesirable side effects. For example, it may contain spyware. Spyware is code built into an extension to report back to some external entity usage statistics and/or private user data. Occasionally, viruses and worms make use of the very same extension API’s to penetrate a system. While web browsers are the quintessential user driven applications, reconfiguration and mutability are even more important for autonomous agents. Several agent systems supporting mutability emerged recently. Varela and Agha [9] proposed the SALSA language based on the actor programming paradigm. The SALSA language is compiled to Java and targets dynamically reconfigurable Internet and mobile computing applications. The SmartApps approach proposed by Rauchwerger [8] takes an approach of ”measure, compare, and adapt if beneficial” for scientific applications. Restructuring occurs during various stages from the selection of the algorithm to compiler parameter tuning. The Bond agent system [3, 11] was one of the first Java based agent systems with support for strong mutability. A series of primitive operations performed on a multi-plane state machine supports reconfigurability of Bond agents. This mutation technique is called agent surgery [1]. Reconfigurability presents both an opportunity for developing more powerful software systems but can be also a Pandora’s box. One way to study the effects of a reconfiguration is to identify and enforce invariants which are maintained during an operation. One such invariant is that a successful run in the original agent should also be successful in the modified agent. Other invariants can cover resource management, error handling, and security aspects. Reconfigurable and mutable agents have a special appeal for highly heterogeneous systems where mutation and mobility are strongly coupled with one another. For instance, the resources available on a laptop and on a cell-phone differ so widely that agents cannot migrate from one to the other without being significantly reconfigured. The solution is to migrate only part of an agent to the new location and replace some of its components with ones compatible with the new environment. Of course, the systems must support a common environment, e.g., Java. The remainder of this article is organized as follows. The Bond agent system, a FIPA compliant agent system with support for mutation is presented in Section 2. In Section 3, we discuss how one of the popular agent design methodologies, Gaia, can be extended to support mutable agents. A summary is presented Section 4. 2. THE BOND AGENT SYSTEM The Bond agent system (currently at version 3) is a FIPA compliant agent development environment. It is built on top of the Java Agent Development Environment (JADE) framework and extends its functionality in several ways including: ease of development using a declarative approach, better introspection capabilities, and support for mutability through agent surgery. The other important component of an agent is its knowledgebase which contains the agents knowledge about the world and about itself, including its agenda. Bond knowledgebase is implemented using the the Protégé-2000 ontology editor. All Bond agents share a basic core ontology. Individual agents can also use custom domain-specific and agent-specific ontologies. The salient features of Bond system are: • Support for development of behaviours (called strategies) for multi-plane state machine • Support for creating and modifying the multiplane state machine using a declarative approach using the Python based Blueprint agent definition language . • Graphical User interface for monitoring state machine’s current status • Support for Belief, Desire, Intention (BDI) model A high level architecture of the Bond system is shown in Figure 1. The input provided to the Bond system the description of the agent in the Blueprint agent description language. Each state of this state machine has associated a strategy from strategy database. To enable automatic runtime assembly or mutability, Bond strategies extend the Jade behaviors with meta information concerning their roles, resource utilization, preand post-conditions, and other data. The Bond strategy database is an indexed and machine searchable collection of strategies. The multi-plane state machine of the individual agent is assembled from strategies pre-existent in the strategy database based on a description in Blueprint. 2.1 The Blueprint agent description language A Blueprint specification is a set of declarative statements that describe the internal structure of the agent, i.e. its knowledgebase, set of planes, set of states within each plane and the transitions between these states etc. Besides describing the initial multi plane state machine configuration of the agent, it can also be used to specify surgical operations on the agent by adding or removing states/transitions from the state machine by modifying the blue print description. An sample Blueprint description for a component of a task engine is presented below. The structure of the multi plane state machine constructed based upon this specification is shown in Figure 2. includeKnowledgeBase(""""TaskComputation"""") createPlane(""""ApplicationScheduler"""") s = bond.strategydb.GreedyApplicationScheduler (agent,’Computation’) addFirstState(s, ’scheduler’) s = bond.strategydb.DummyStrategy(agent)"""	actor model;address space;applet;application programming interface;autonomous agent;autonomous robot;bond;belief–desire–intention software model;blueprint;codec;compiler;core ontology;data flow diagram;declarative programming;device driver;evolutionary computation;exception handling;executable;finite-state machine;francisco varela;gaia hypothesis;genetic algorithm;graphical user interface;heterogeneous computing;high-level architecture;immutable object;internet;introspection;invariant (computer science);jade;java;knowledge base;laptop;microsoft basic;mobile computing;mobile phone;new media;ontology (information science);plug-in (computing);programming paradigm;python;reconfigurability;run time (program lifecycle phase);salsa;self-modifying code;side effect (computer science);software engineering;software system;spyware;theme (computing)	Ladislau Bölöni;Majid Ali Khan;Xin Bai;Guoqiang Wang;Yongchang Ji;Dan C. Marinescu	2003		10.1007/978-3-540-24625-1_9	computing;information engineering;system of systems engineering;systems engineering;software design;social software engineering;component-based software engineering;software development;feature-oriented domain analysis;software engineering;software construction;resource-oriented architecture;software deployment;software system;computer engineering	AI	-35.31143950747563	41.54222963934709	193616
102e5e0581b84da057effae163b329d4bb176d36	a framework for enabling trust requirements in social cloud applications	trust and reputation requirements;social cloud;architecture;framework	Cloud applications entail the provision of a huge amount of heterogeneous, geographically distributed resources managed and shared by many different stakeholders who often do not know each other beforehand. This raises numerous security concerns that, if not addressed carefully, might hinder the adoption of this promising computational model. Appropriately dealing with these threats gains special relevance in the social cloud context, where computational resources are provided by the users themselves. We argue that taking trust and reputation requirements into account can leverage security in these scenarios by incorporating the notions of trust relationships and reputation into them. For this reason, we propose a development framework onto which developers can implement trust-aware social cloud applications. Developers can also adapt the framework in order to accommodate their application-specific needs.	cloud computing;computation;computational model;computational resource;norm (social);relevance;requirement	Francisco Moyano;M. Carmen Fernández Gago;Javier López	2013	Requirements Engineering	10.1007/s00766-013-0171-x	public relations;computer science;engineering;knowledge management;environmental resource management;architecture;programming language;computational trust	Security	-45.50653940624536	44.32434752166303	193843
070b937964824ff1011bf1d31b1a29d985e05ed3	validation of service oriented computing devs simulation models	soa complaint devs;verification validation;co design;service based software system;soc devs	In the simulation based design and development of Service Based Software Systems (SBS), it is important to analyze the models for correctness and improve confidence in the validity of the model. Of particular interest is the SBS simulation where models are used towards evaluation of time dependent QoS metrics (e.g., service delay, throughput etc.). In this paper, an experiment based validation of Service Based Software Systems using SOC-DEVS (i.e. Service Oriented Computing DEVS) framework is presented. As formal basis towards validation, the real system under consideration is abstracted as a DEVS I/O System model and experiments are developed to observe its time-based I/O trajectories. An exemplar Voice Communication System is simulated and results are analyzed towards model validation w.r.t. a real system prototype.	devs;service-oriented architecture;simulation	Hessam S. Sarjoughian;Mohammed A. Muqsith;Dazhi Huang;Stephen S. Yau	2012			co-design;embedded system;real-time computing;verification and validation;simulation;computer science	HPC	-40.64873660304036	33.51762334489647	194029
3922d3138147a595e8ee7540b5ce405f1b831268	infrastructure for web-based administration of embedded systems	document structure;web based administration;web pages;document structure web based administration embedded systems network interfaces web based management dynamically generated pages web developer;system monitoring;layout;embedded system;html;embedded systems;network interfaces;servers;dynamically generated pages;web developer;internet;web based management;web server;network interface;embedded system java html web server writing read only memory web pages operating systems read write memory network interfaces;web development;system monitoring embedded systems internet network interfaces;java	Today, many embedded systems are equipped with network interfaces. Thus, web based management and administration are often required in such embedded systems. General approaches, which are widely available, fail to work on those resource constrained devices. Yet, there exists a necessity to support rapid development for dynamically generated pages. In this contribution we present a framework that will be usable on many embedded systems and also helps the web developer to simplify the document structure.	ajax (programming);dynamic web page;embedded system;high-level programming language;kerbal space program;web application;web content;web developer;windows update	Christian Hochberger;Christian Meusel	2008	2008 International Symposium on Industrial Embedded Systems	10.1109/SIES.2008.4577682	embedded operating system;web modeling;computer science;network interface;operating system;database;world wide web	Embedded	-34.17723992465964	39.99843170530438	194298
6c35ff65b17288b04014b95b11053dfb4004c778	beyond physical mashups: autonomous systems for the web of things		By abstracting devices to Web resources, the Web of Things (WoT) fosters innovation and rapid prototyping in the Internet of Things (IoT): it enables developers to use standard Web technologies for creating mashups of Web services that perceive and act on the physical world (a.k.a. physical mashups). In recent years, however, it has become apparent that current programming paradigms for Web development have important shortcomings when it comes to engineering IoT systems: static Web mashups cannot adapt to dynamic IoT environments, and manually mashing-up the IoT does not scale. To address these limitations, WoT researchers started to look for means to engineer WoT systems that are more autonomous in pursuit of their design objectives. The engineering of autonomous systems has already been explored to a large extent in the scientific literature on artificial intelligence. In this position paper, we distill that large body of research into a coherent set of abstractions for engineering autonomous WoT systems.	artificial intelligence;autonomous robot;autonomous system (internet);coherence (physics);html;internet of things;mashup (web application hybrid);programming paradigm;rapid prototyping;scalability;scientific literature;web development;web of things;web resource;web service;world wide web	Andrei Ciortea;Olivier Boissier;Alessandro Ricci	2017		10.1145/3199919.3199924	autonomous agent;web development;position paper;mashup;web service;human–computer interaction;web of things;web resource;multi-agent system;computer science	AI	-44.171721890980436	45.3611667011124	194344
7570a37b337c7e2631d9ca81ef4f82ed865a37e0	incorporation of matlab into a distributed behavioral robotics architecture	control engineering computing mathematics computing robots distributed processing java;mathematics computing;distributed processing;remote computer workstation matlab distributed behavioral robotics architecture java jini platform irobot atrv jr;distributed objects;control architecture;matlab computer architecture robot control robot sensing systems java workstations robotics and automation testing computer errors automatic control;remote method invocation;robots;control engineering computing;autonomous robot;distributed architecture;java	This paper presents a method that integrates MATLAB into a distributed behavioral robotics architecture. The architecture is written in Java and uses the Jini platform for distributed object registration, lookup and remote method invocation. The method described here can be used to integrate MATLAB into any Java-based behavioral architecture. The form of the integration allows a running MATLAB workspace to be accessed as a distributed object within the larger Java/Jini-based architecture. This is beneficial because MATLAB scripts and functions may be called in interpreted form and can make full use of MATLAB tool boxes and have access to the MATLAB workspace environment. This is not possible when MATLAB scripts are compiled into stand-alone C++, Java or p-code. The use of the architecture is demonstrated on an iRobot ATRV-JR robot and remote computer workstation. Experiments have been conducted to quantify GPS and odometry errors in outdoor environments using automated methods supported by the distributed architecture.	c++;compiler;distributed computing;distributed object;experiment;global positioning system;ibm pcjr;java remote method invocation;lookup table;matlab;microsoft p-code;mobile robot;odometry;p-code machine;programming paradigm;remote computer;robot;robot control;robotics;sfx (software);subroutine;workspace;workstation;jini	Andrew L. Nelson;Lefteris Doitsidis;Matthew T. Long;Kimon P. Valavanis;Robin R. Murphy	2004	2004 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (IEEE Cat. No.04CH37566)	10.1109/IROS.2004.1389696	robot;embedded system;real-time computing;computer science;distributed computing;distributed object;java	Robotics	-33.93495917572967	39.18467528622913	194422
37da8ce91cb5cd0256748f5c0a430f380fabc6ba	integrating smart devices as business process resources - concept and software prototype		The foundation of the Internet of Things (IoT) consists of ubiquitous smart devices, equipped with sensors, actuators and tags, that are connected to the Internet and able to communicate with one another. It is seen as a great opportunity for organizations to improve, innovate, and reinvent their business processes. However, existing Business Process Management (BPM) tools and systems are not fully capable of integrating and utilizing smart devices as business process resources and, thus, are unable to unlock the high joint potential of BPM and the IoT. In this paper, we propose a concept for a service-oriented BPM system architecture which aims at the modeling, implementation, and execution of IoT-aware business processes. Furthermore, we introduce a first software prototype of the architecture as a proof of concept.	business process;prototype;smart device;software prototyping	Robert Wehlitz;Ingo Rößner;Bogdan Franczyk	2017		10.1007/978-3-319-91764-1_20	computer engineering;business process;proof of concept;real-time computing;systems architecture;computer science;the internet;software;architecture;business process management;service-oriented architecture	HCI	-42.9118873865741	46.06297705508021	194460
8a74a63b2410667544ebe805417dd2c37486a55e	design suite for deeply embedded cyber physical systems	design process;real time;cyber physical systems;community computing;levels of abstraction;system design	Many emerging applications are deployed in harsh environments and must operate dependably, efficiently and in real-time. This makes it essential to develop robust system designs before deployment. Thus, there is a tremendous need for a complete design suite for deeply embedded cyber physical systems that will enable the designers to model these systems to the desired level of abstraction, analyze the models and validate them. The main challenges involved in the design process are due to the complex interactions between communication, computing and the physical components in cyber physical systems. We discuss the problems faced in developing such a design suite and possible solutions to overcome them.	cyber-physical system;embedded system;interaction;real-time clock;software deployment	Vibha Prasad;Sang Hyuk Son	2008	SIGBED Review	10.1145/1366283.1366285	embedded system;real-time computing;simulation;design process;computer science;operating system;cyber-physical system;systems design	EDA	-45.502531248116256	38.10141887566951	194676
0f150ad16a6dfaf1eca4ee382eb7e15eccf72701	interaction and coordination for distributed grid computing	distributed application;distributed coordination;distributed programming grid computing java application program interfaces distributed object management;grid applications;e commerce;remote procedure call;programming model;current distribution;client server;distributed grid programming distributed grid computing middleware corba java rmi remote procedure call api multiparty interaction;distributed programming;remote method invocation;application program interfaces;distributed object management;message passing;middleware;web browsing;machine model;grid computing;grid computing programming profession pervasive computing distributed computing protocols java physics computing computer science middleware application software;parallel applications;java	The programming model of the current distributed systems such as middleware CORBA or JAVA RMI is based on remote procedure call. Without the support of high-level API for coordination, developing real-world distributed grid applications in this model is difficult. We present an algorithm for multiparty interaction, a key abstraction of distributed coordination for the future distributed grid programming.	algorithm;application programming interface;common object request broker architecture;distributed computing;grid computing;high- and low-level;java remote method invocation;middleware;programming model;remote procedure call;subroutine	Peiyi Tang;James Sinnamon	2004	IEEE International Conference onServices Computing, 2004. (SCC 2004). Proceedings. 2004	10.1109/SCC.2004.1358028	distributed algorithm;real-time computing;computer science;database;distributed computing;distributed object;distributed design patterns;drmaa;grid computing	HPC	-33.80877576388812	43.753969593227865	194908
36af63144f30b1165d123dd8191158fc3d34b3b9	managing non-functional uncertainty via model-driven adaptivity	adaptive systems;finite state machines;mobile computing;probability;program interpreters;program verification;uncertainty handling;adaptive systems;distributed mobile application;finite state automaton;interpreter;model-driven adaptivity;nonfunctional uncertainty management;probabilities;software systems;system ability maximization	Modern software systems are often characterized by uncertainty and changes in the environment in which they are embedded. Hence, they must be designed as adaptive systems. We propose a framework that supports adaptation to non-functional manifestations of uncertainty. Our framework allows engineers to derive, from an initial model of the system, a finite state automaton augmented with probabilities. The system is then executed by an interpreter that navigates the automaton and invokes the component implementations associated to the states it traverses. The interpreter adapts the execution by choosing among alternative possible paths of the automaton in order to maximize the system's ability to meet its non-functional requirements. To demonstrate the adaptation capabilities of the proposed approach we implemented an adaptive application inspired by an existing worldwide distributed mobile application and we discussed several adaptation scenarios.	activity diagram;adaptive system;automaton;embedded system;experiment;finite-state machine;functional requirement;interpreter (computing);mobile app;model-driven security;non-functional requirement;open-source software;overhead (computing);parallel computing;scalability;simulation;software system	Carlo Ghezzi;Leandro Sales Pinto;Paola Spoletini;Giordano Tamburrelli	2013	2013 35th International Conference on Software Engineering (ICSE)		unified modeling language;real-time computing;simulation;uncertainty;usability;computer science;theoretical computer science;operating system;software engineering;probability;automaton;programming language;mobile computing;measurement;statistics	SE	-42.828228433529326	37.65808580257649	195138
499546db4ff185c981dbf8afd6a2c42b85cd7a8f	autonomic pervasive computing based on planning	distributed processing;formal specification;planning (artificial intelligence);software fault tolerance;ubiquitous computing;gaia;strips-based planning;autonomic computing;autonomic systems;fault-tolerance;goal specification;pervasive computing;prototype planning;self-managing systems;system usability;user interaction	Pervasive computing envisions a world with users interacting naturally with device-rich environments to perform various kinds of tasks. These environments must, thus, be self-managing and autonomic systems, receiving only high-level guidance from users. However, these environments are also highly dynamic $the context and resources available in these environments can change rapidly. They are also prone to failures - one or more entities can fail due to variety of reasons. The dynamic and fault-prone nature of these environments poses major challenges to their autonomic operation. In this paper we present a paradigm for the operation of pervasive computing environments that is based on goal specification and STRIPS-based planning. Users as well as application developers can describe tasks to be performed in terms of abstract goals and a planning framework decides how these goals are to be achieved. This paradigm helps improve the fault-tolerance, adaptability, ease of programming and usability of these environments. We have developed and used a prototype planning system within our pervasive computing system, Gaia.	automated planning and scheduling;autonomic computing;autonomic networking;entity;fault tolerance;gaia hypothesis;high- and low-level;interaction;programming paradigm;prototype;strips;self-management (computer science);ubiquitous computing;usability	Anand Ranganathan;Roy H. Campbell	2004	International Conference on Autonomic Computing, 2004. Proceedings.	10.1109/ICAC.2004.17	fault tolerance;real-time computing;context-aware pervasive systems;simulation;computer science;operating system;database;distributed computing;computer security;ubiquitous computing;autonomic computing	Robotics	-41.345906319083575	39.768470027867075	195194
f4e0fa11e1b7eaeabf59a26780269c46920c1140	development of a fail-safe microprocessor lsi with self-diagnosis mechanism depending on an m-sequence code signature	railways;signalling;cost reduction;chip;fault tolerant computing;large scale integration;microprocessors large scale integration software safety costs computer errors rail transportation computer architecture control systems hardware circuits;microprocessor chips fault tolerant computing fault diagnosis railways signalling large scale integration;fail safe computer fail safe microprocessor lsi self diagnosis mechanism m sequence code signature bus level synchronized computer system railway signaling japan manufacturing cost reduction bus level synchronized fs computer lsi chip cost reduction performance enhancement economical fs one chip computer lsi technology fail safety fault diagnosis mechanism;fault diagnosis;microprocessor chips	A bus-level synchronized computer system is widely utilized in the jield of railway signaling of Japan. It may be recognized that there is a problem of disadvantage in a manufacturing cost reduction. We intend to integrate a bus-level synchronized FS computer into an LSI chip in expectation of cost reduction and pegormance enhancement. An economical FS one-chip computer by utilizing system LSI technology is realized, It assures fail-safe0 by means of new fault diagnosis mechanism depending on an M-sequence code signature. In this papel; these contents and techniques are reported in detail.	computer;fail-safe;microcontroller;microprocessor	Sei Takahashi;Munehisa Taira;Hidetaka Saegusa;Takehiko Hoshino;Hideo Nakamura	2001		10.1109/PRDC.2001.992697	chip;embedded system;signalling;electronic engineering;real-time computing;telecommunications;engineering;operating system;computer security	Arch	-35.32486365962101	36.69978044819219	195249
5d5e67cf896e173f6704e2c7bca18e758ec76255	toward open-world software: issue and challenges	developpement logiciel;autonomic framework open world software development ubiquitous computing pervasive computing software change software self organizing capability software self adapting capability dynamic heterogeneous system open system programming programming language features software introspection mechanism software reflective mechanism service oriented technology publish subscribe middleware system grid infrastructure;ubiquitous and pervasive computing;software reflective mechanism;computer languages;heterogeneous systems;programming language;open system programming;application software;service orientation;pervasive computing;prototypes;service oriented technology;open world software development;web service;open world assumption;runtime;software engineering;ubiquitous computing grid computing message passing middleware open systems software engineering;standards publication;publish subscribe middleware system;software self organizing capability;dynamic heterogeneous system;autonomic computing software engineering open world software polymorphism middleware systems web services grid computing;programming language features;industrial production;desarrollo logicial;polymorphism;software introspection mechanism;logiciel libre;publish subscribe;software development;web services;autonomic framework;grid infrastructure;message passing;open system;autoorganizacion;software libre;ubiquitous computing;self organization;middleware;software self adapting capability;open systems;closed world assumption;grid computing;programming;autonomic computing;middleware systems;autoorganisation;software change;open world software;open source software;programming pervasive computing application software open systems computer languages runtime standards publication prototypes middleware	Traditional software development is based on the closed-world assumption that the boundary between system and environment is known and unchanging. However, this assumption no longer works within today's unpredictable open-world settings, especially in ubiquitous and pervasive computing settings, which demand techniques that let software react to changes by self-organizing its structure and self-adapting its behavior. The more we move toward dynamic and heterogeneous systems, and the more we stress their self-healing and self-adapting capabilities, the more we need new approaches to develop these applications and new ways to structure and program them. Programming open systems requires new programming language features. Two features that bear investigation are introspection mechanisms to get runtime information about newly encountered services and reflective mechanisms to adapt client applications dynamically. Some existing standards, industrial products, and research prototypes that support, to a certain extent, the open-world assumptions are service-oriented technologies, publish/subscribe middleware systems, grid infrastructures, autonomic frameworks	open world	Luciano Baresi;Elisabetta Di Nitto;Carlo Ghezzi	2006	IEEE Computer	10.1109/MC.2006.362	web service;computer science;software development;operating system;software engineering;database;distributed computing;open system;programming language;ubiquitous computing	Visualization	-38.0894287299603	41.74707884458395	195428
66093bfd47c0fb9d7535a334f2267f5e9e46abc3	a dynamic and flexible sensor network platform	virtual machine;r osgi;user interface;swissqm;query optimization;sensor network;sensor networks;sensor nodes;query machine;osgi	SwissQM is a novel sensor network platform for acquiring data from the real world. Instead of statically hand-crafted programs, SwissQM is a virtual machine capable of executing bytecode programs on the sensor nodes. By using a central and intelligent gateway, it is possible to either push aggregation and other operations into the network, or to execute them on the gateway. Since the gateway is built in an entirely modular style, it can be dynamically extended with new functionality such as user interfaces, user defined functions, or additional query optimizations. The goal of this demonstration is to show the flexibility and the unique features of SwissQM.	user interface;virtual machine	René Müller;Jan S. Rellermeyer;Michael Duller;Gustavo Alonso;Donald Kossmann	2007		10.1145/1247480.1247615	embedded system;real-time computing;wireless sensor network;computer science;operating system;database;key distribution in wireless sensor networks;visual sensor network	Mobile	-37.2098036198443	45.63840421796884	195741
d98c9935335a483efea8a8e12e600de4051e4ff1	monitoring networks through multiparty session types	session types;runtime verification;dynamic monitoring;bisimulation;the π calculus	In large-scale distributed infrastructures, applications are realised through communications among distributed components. The need for methods for assuring safe interactions in such environments is recognized, however the existing frameworks, relying on centralised verification or restricted specification methods, have limited applicability. This paper proposes a new theory of monitored π-calculus with dynamic usage of multiparty session types (MPST), offering a rigorous foundation for safety assurance of distributed components which asynchronously communicate through multiparty sessions. Our theory establishes a framework for semantically precise decentralised run-time enforcement and provides reasoning principles over monitored distributed applications, which complement existing static analysis techniques. We introduce asynchrony through the means of explicit routers and global queues, and propose novel equivalences between networks, that capture the notion of interface equivalence, i.e. equating networks offering the same services to a user. We illustrate our static-dynamic analysis system with an ATM protocol as a running example and justify our theory with results: satisfaction equivalence, local/global safety and transparency, and session fidelity.	asynchronous i/o;communication endpoint;correctness (computer science);cyberinfrastructure;distributed computing;enterprise architecture framework;hypertext transfer protocol;interaction;ocean observatories initiative;real-time clock;software verification;text simplification;timer;well-formed document;wildfly	Laura Bocchi;Tzu-Chun Chen;Romain Demangeon;Kohei Honda;Nobuko Yoshida	2017	Theor. Comput. Sci.	10.1016/j.tcs.2017.02.009	real-time computing;computer science;bisimulation;theoretical computer science;distributed computing;runtime verification;programming language;algorithm	Logic	-37.86043982616234	35.669936338763094	196522
0f7177bee4fa205ac33e98496fcccffc6efca5b5	qos-uniframe: a petri net-based modeling approach to assure qos requirements of distributed real-time and embedded systems	quality assurance;domain specific scripting language;evolutionary computation;formal specification;real time;distributed processing;null;software engineering;design space;embedded system;formal specification embedded systems distributed processing evolutionary computation quality of service petri nets specification languages;symposia;embedded systems;statistical distributions;qos requirements;formal specification quality of service qos requirements distributed real time system embedded system evolutionary algorithm domain specific scripting language petri net specification languages;distributed real time system;specification languages;manufacturing;aerospace electronics;assembly systems;algorithms;evolutionary algorithm;petri nets;quality of service;petri net;distributed data processing;security;article;algorithm design and analysis;real time systems embedded system quality of service aerospace electronics assembly systems security evolutionary computation algorithm design and analysis statistical distributions manufacturing;domain specificity;scripting language;real time systems;real time and embedded systems	Assuring quality of service (QoS) requirements is critical when assembling a distributed real-time and embedded (DRE) system from a repository of existing components. This paper presents a two-level approach for assuring satisfaction of QoS requirements in the context of a reduced design space for DRE systems. A dynamic and parallel approach is introduced to prune off the infeasible design spaces at the first level. Evolutionary algorithms cooperating with a domain-specific scripting language then discard less probable design spaces using statistics. These techniques fulfill the collective objectives of pruning and assuring the design space at system assembly time.	assembly language;embedded system;evolutionary algorithm;petri net;quality of service;real-time clock;requirement;scripting language	Shih-Hsi Liu;Barrett R. Bryant;Jeffrey G. Gray;Rajeev R. Raje;Andrew M. Olson;Mikhail Auguston	2005	12th IEEE International Conference and Workshops on the Engineering of Computer-Based Systems (ECBS'05)	10.1109/ECBS.2005.57	quality assurance;embedded system;real-time computing;computer science;theoretical computer science;operating system;software engineering;evolutionary algorithm;distributed computing;programming language;petri net;evolutionary computation	Embedded	-40.1709565626284	36.79289310015704	196685
542e4884deb4d8538b3d716b96883fe8bd340d3d	smart reifier: model-driven development of service-oriented scada applications from models of sensor and actuator networks		This paper aims at presenting SMART REIFIER a tool for designing networks of sensors and actuators and for generating a set of web services for supervisory control and data acquisition. Such a code generation is achieved by the means of model-driven engineering: a specific meta-model for sensor and actuator networks is designed as well as a model-to-model mapping into a web service meta-model that enables source code generation of JEE applications.	as-interface;automatic programming;code generation (compiler);component-based software engineering;data acquisition;java platform, enterprise edition;metamodeling;model transformation;model-driven architecture;model-driven engineering;model-driven integration;network security;refinement (computing);sensor;service-oriented device architecture;smart card;top-down and bottom-up design;web service	Jérôme Rocheteau;Clémentine Geslin;Margaux Bosshardt	2017		10.5220/0006198201250136	control engineering;embedded system	Robotics	-39.25272816090906	41.8723988865647	196705
5ce3c599c28941afa4163ed259e1cf99e2e4b140	"""reliability analysis and functional design using bayesian networks generated automatically by an """"idea algebra"""" framework"""			bayesian network;functional design;reliability engineering	Andas Amrin;Vasileios Zarikas;Christos Spitas	2018	Rel. Eng. & Sys. Safety	10.1016/j.ress.2018.07.020		Robotics	-46.98635567466785	32.42033822782539	196842
03197b19559f73e4f37efeca2f7cd574b353a35d	management and coordination framework for aerial-terrestrial smart drone networks	sensors;wireless communications;smart objects;drones collaboration	According to the paradigm of Internet of Mobile Things, the paper proposes and investigates a novel framework to support the management and the collaboration of Mobile Smart Objects (MSOs) considered as terrestrial and aerial drones (i.e., UAVs, UGVs) with embedded sensors and/or actuators that can move autonomously remaining always connected, accessible and controllable. The proposed framework allows (i) the network setup and maintenance of smart drones (ii) the mission assignment to a group of smart drones, (iii) the task/role assignment to the different drones involved into a particular mission and (iv) the task/role rearrangement according to specific executive parameters and system conditions (i.e., residual energy, computational power, abilities offered by specific on board sensors). To evaluate the effectiveness and the reliability of the proposed framework, a real testbed was realized using drones commonly available on the market.	aerial photography;computation;embedded system;programming paradigm;sensor;smart objects;terrestrial television;testbed;unmanned aerial vehicle	Pasquale Pace;Gianluca Aloi;Giuseppe Caliciuri;Giancarlo Fortino	2015		10.1145/2797044.2797047	embedded system;simulation;engineering;computer security	Mobile	-38.58433224572214	44.95161870398666	196846
81c86d52f6aa60c9d1596b143bcd962883cd14aa	test harness environment for embedded java applications	personal computer;smart phone;client server;software development;set top box;embedded software	There are many devices with java embedded platform that allow executing generic Java applications. Some of the examples are  smart phones, PDAs, set-top boxes, etc. Developers can create and users can download such applications to their devices. The  number of embedded applications increases each year and developers should adapt efficient software development techniques  in order to move their products to market in time and with high reliability level. There are currently so many software development  frameworks and techniques for standalone or server applications that embedded software developers often miss out on them.  One of the most important to follow practice is testing. The authors have developed several products for PC in Java where  testing was formally defined and automated with JUnit. That experience demonstrated a value of regular test runs for product  reliability and development stability.    This paper is devoted to the testing process of embedded Java application on target devices using JUnit based test cases.  The test process described in this article includes test cases creation on personal computer and their execution on target  platform via client-server interconnection using special techniques developed specifically for this purpose.      	embedded java;test harness	Olga Korolyova;Andrey Pakhomov	2008		10.1007/978-1-4020-8739-4_69	smart client;embedded system;real-time computing;computer science;software development;operating system;embedded java;test harness	EDA	-35.32017595270248	40.35881426505827	196918
aa4cd0330f97a90edc6e0002170ecf40c945ac74	physicloud: a cloud-computing framework for programming cyber-physical systems	information dependencies cloud computing inspired framework deployed cyber physical system programming physicloud low power mobile systems network failures controls application developer;monitoring robots sensors kernel mobile communication computational modeling global positioning system;mobile computing cloud computing	This paper presents a cloud-computing inspired framework that facilitates the programming of a deployed cyber-physical system. This framework, PhysiCloud, uses a novel combination of abstractions that hide the implementation details of the underlying cyber-physical system. Additionally, the framework is designed to operate on low-power, mobile systems with resiliency to network failures. Using this system, a controls application developer can focus on their algorithm development and its information dependencies, rather than issues of low level scheduling and communication.	algorithm;application programming interface;clojure;cloud computing;compiler;cyber-physical system;experiment;high- and low-level;high-level programming language;low-power broadcasting;object language;scheduling (computing);specification language;system programming	Paul Glotfelter;Travis Eichelberger;Patrick J. Martin	2014	2014 IEEE Conference on Control Applications (CCA)	10.1109/CCA.2014.6981542	embedded system;real-time computing;computer science;distributed computing;mobile computing	Embedded	-37.776553148444755	45.4888980608512	196965
20e49a953ee7d4363723813a8235d698cdc4ce5d	a resource description language with vagueness support for multi-provider cloud networks	cloudnet prototype architecture flexible resource description language multiprovider cloud network cloud resources federated environment interprovider communication customized virtual environment economic benefits rdl requirement topology requirement communication business scenario flerd multiprovider virtual network architecture;topology;virtual enterprises;prototypes;software architecture;specification languages;virtual enterprises cloud computing software architecture specification languages;business;bandwidth;substrates;context;substrates business topology prototypes context bandwidth;cloud computing	The concept of CloudNets, virtual networks connecting cloud resources, has recently attracted much interest from both academic as well as business sides. CloudNets can realize the vision of affordable customized infrastructures. In particular, such networks are expected to be offered even in federated environments with multiple providers. Inter-provider communication about requirements or provisioning of truly customized virtual environments however require a powerful flexible resource description language (RDL). While extensibility and expressiveness seem to be natural requirements for such a language, we identify another less intuitive requirement affecting all actors (or stakeholders) in their economic benefits: the possibility to omit arbitrary specification details and to remain vague while at the same time describing real world scenarios. Not only may a description language ignoring this constraint easily become too bulky to use, it is also likely to force players to focus on details they are not interested in or lack the knowledge to map their actual requirements to. This paper identifies detailed requirements for an RDL to allow for topology and requirement communication in business scenarios. Furthermore, we present the FleRD flexible resource description language for multi-provider virtual network architectures. FleRD is fully incorporated in our own CloudNet prototype architecture.	cloud computing;extensibility;prototype;provisioning;report definition language;requirement;vagueness;virtual reality	Gregor Schaffrath;Stefan Schmid;Ishan Vaishnavi;Ashiq Khan;Anja Feldmann	2012	2012 21st International Conference on Computer Communications and Networks (ICCCN)	10.1109/ICCCN.2012.6289187	software architecture;simulation;cloud computing;computer science;operating system;prototype;world wide web;bandwidth;computer network	Visualization	-47.795209890571044	45.33504088656478	197119
5e58feadd69850cb31b1e3ed12a0c9f2a9b986d2	achieving reusability through interoperability	reusability interoperability programming language net language java language;computer languages;reusability;programming language;net language;network operating systems;virtual machining;bridges;software reusability java network operating systems open systems;runtime;java bridges costs merging computer languages communication system control virtual machining runtime simple object access protocol conferences;software reusability;merging;interoperability;communication system control;simple object access protocol;open systems;conferences;java language;java;new products	The scope of this paper is how we can achieve reusability by merging two different programming languages. The two entirely different languages, .Net and Java can be merged together to achieve huge benefits of reusability. It is basically achieved by combining an existing system of any language (.Net or Java) with the other language to give you a new product without changing your existing systems	.net framework;interoperability;java;programming language	Haroon Saleem Khan	2006	13th Annual IEEE International Symposium and Workshop on Engineering of Computer-Based Systems (ECBS'06)	10.1109/ECBS.2006.19	interoperability;reusability;real-time computing;computer science;operating system;software engineering;soap;database;open system;programming language;java	Arch	-34.00870839962115	42.39829730884329	197169
4fde667c90c885a20ecc6edb7544ca00b6af26ec	an autonomic context management system for pervasive computing	pervasive computing context management system context manager autonomic system;context aware application;context awareness;context information gathering;context information;fault tolerant;pervasive computing;autonomic system;ubiquitous computing fault tolerant computing open systems;context manager;fault tolerant computing;interoperability model based autonomic context management system pervasive computing context information gathering context information preprocessing functionality fault tolerant provision;context management;ubiquitous computing;interoperability;context aware systems;open systems;fault tolerant provision;pervasive computing context modeling resource management sensor systems fault tolerant systems technology management australia redundancy runtime conference management;autonomic computing;model based autonomic context management system;context information preprocessing functionality;context management system;dynamic configuration	Context-aware applications adapt to changing computing environments or changing user circumstances/tasks. Context information that supports such adaptations is provided by the underlying infrastructure, which gathers, pre-processes and provisions context information from a variety of context information sources. Such an infrastructure is prone to failures and disconnections that negatively impact on the ability of context-aware applications to adapt (and therefore dramatically impact on their usability). This paper describes a model-based autonomic context management system (ACoMS) that can dynamically configure and reconfigure its context information gathering and pre-processing functionality in order to provide fault tolerant provisioning of context information. The approach uses standards based descriptions of context information sources to increase openness, interoperability and scalability of context-aware systems.	autonomic computing;context-aware pervasive systems;fault tolerance;interoperability;management system;openness;preprocessor;provisioning;scalability;ubiquitous computing;usability	Peizhao Hu;Jadwiga Indulska;Ricky Robinson	2008	2008 Sixth Annual IEEE International Conference on Pervasive Computing and Communications (PerCom)	10.1109/PERCOM.2008.56	interoperability;fault tolerance;real-time computing;human–computer interaction;computer science;database;distributed computing;open system;ubiquitous computing	HPC	-42.94436610555978	42.62381199203691	197586
1854211205bd48342b5c6f5de4ef6431e7fa3135	power consumption analysis using multi-view modeling	real time systems integrated circuit modelling power aware computing power consumption power integrated circuits;power analysis;power consumption analysis sysml concepts uml profile specialized tools real time systems nonfunctional properties multiview modeling;unified modeling language analytical models power demand hardware clocks computer architecture real time systems;uml;multi view modeling;power aware computing;mde;integrated circuit modelling;power analysis multi view modeling mde uml marte sysml;marte;power consumption;power integrated circuits;sysml;real time systems	Non-functional properties take an important place in real-time systems. Power consumption, time performance and temperature are non-functional properties that are individually analyzed using specialized tools. Nevertheless, non-functional properties are interrelated, and changes on one property may affect the other ones, but also may impact the system function itself. In this work, we propose a multi-view system model to combine different property domains without depending on the proprietary formats defined by specialized tools. We start by the definition of a multi-view model and explain how the different views are connected. Then we focus on the analysis of our multiview model by picking out a tool dedicated to power analysis, Aceplorer. This multi-view system model is implemented in a uml profile, where the marte and SysML concepts are used in the profile definition.	modeling and analysis of real time and embedded systems;multi-agent system;profile (uml);real-time clock;real-time computing;real-time locating system;systems modeling language;unified modeling language;view model	Carlos Gomez;Julien DeAntoni;Frédéric Mallet	2013	2013 23rd International Workshop on Power and Timing Modeling, Optimization and Simulation (PATMOS)	10.1109/PATMOS.2013.6662180	unified modeling language;embedded system;real-time computing;power analysis;systems modeling language;computer science;systems engineering;engineering;operating system;applications of uml;statistics	SE	-40.47098638935998	33.252441446552965	197705
026b514e5214d8be0610ec6a024e49d738175c29	complex event processing with t-rex	information processing;complex event processing;distributed systems;event middleware	Several application domains involve detecting complex situations and reacting to them. This asks for a Complex Event Processing (CEP) middleware specifically designed to timely process large amounts of event notifications as they flow from the peripheral to the center of the system, to identify the composite events relevant for the application. To answer this need we designed T-Rex, a new CEP middleware that combines expressiveness and efficiency. On the one hand, it adopts a language (TESLA) explicitly conceived to easily and naturally describe composite events. On the other hand, it provides an efficient event detection algorithm based on automata to interpret TESLA rules. Our evaluation shows that the T-Rex engine can process a large number of complex rules with a reduced overhead, even in the presence of challenging workloads.	algorithm;application domain;automata theory;complex event processing;middleware;overhead (computing);peripheral;rexx;sensor	Gianpaolo Cugola;Alessandro Margara	2012	Journal of Systems and Software	10.1016/j.jss.2012.03.056	embedded system;real-time computing;information processing;computer science;complex event processing;operating system;distributed computing	OS	-40.05341115069639	42.31789791447686	197752
2855d7c68f6ddaccd87356ab14e05556912a3c87	reflective authorization systems	computational reflection;object oriented;authoring system	A reflective approach for modeling and implementing authorization systems is presented. The advantages of the combined use of computational reflection and authorization mechanisms are discussed, and three reflective architectures are examined for pointing out the corresponding merits and defects.	authorization;computation;reflection (computer programming)	Massimo Ancona;Walter Cazzola;Eduardo B. Fernández	1998		10.1007/3-540-49255-0_62	computer vision;simulation;computer science;multimedia;programming language;object-oriented programming	Security	-34.79158081960025	42.852002650825284	197808
c623a9a51cd9d0717283513cad55e234b6e9cf9a	model checking implicit-invocation systems	attractive alternative;delivery policy;reusable run-time infrastructure;good engineering property;event-based communication;alternative run-time mechanism;model-checking problem;implicit invocation;reusable portion;particular implicit invocation system;model checking implicit-invocation systems;software architecture;computer science;software systems;publish subscribe;model checking;system testing;formal verification;machinery	While implicit invocation (publish-subscribe) systems have good engineering properties, they are difficult to reason about and to test. Model checking such systems is an attractive alternative. However, it is not clear what kinds of state models are best suited for this. In this paper, we propose a structural approach, which factors the model-checking problem into two parts: behavior specific to a particular implicit invocation system, and reusable run-time infrastructure that handles event-based communication and delivery policies. The reusable portion is itself structured so that alternative run-time mechanisms may be experimented with.	finite-state machine;implicit invocation;model checking;publish–subscribe pattern;run-time infrastructure (simulation)	David Garlan;Serge Khersonsky	2000			implicit invocation;real-time computing;computer science;database;distributed computing	SE	-39.63836494586692	38.32418927778876	197821
57f2349214ad851ada9c51ee5d46c627f053dac9	adaptivity in dynamic service-based systems	service-oriented architecture;ubiquitous computing;fbk soa unit;context-aware adaptation;cross-layer adaptation;dynamic service-based systems;multilayer adaptation;s-cube network;service paradigm;user-centric adaptation;context-aware services;multi-layer adaptation;sbs adaptation and monitoring;user-centric systems	Adaptivity for service-based systems is one of the most challenging research problems to fully exploit the dinamicity promised by the service paradigm. In this paper we present the research results achieved by the FBK SOA unit within the S-Cube Network, aiming at addressing key challenges in this area: context-aware adaptation, user-centric adaptation, cross- and multi-layer adaptation.	cube;layer (electronics);programming paradigm	Antonio Bucchiarone;Raman Kazhamiakin;Annapaola Marconi;Marco Pistore	2012	2012 First International Workshop on European Software Services and Systems Research - Results and Challenges (S-Cube)		real-time computing;computer science;knowledge management;world wide web	Arch	-42.99088020522669	44.00787133269637	197880
4708227b95a65438b8b4a210232a2dd0ad2cf0ed	selective focus as a means of improving geographically distributed embedded system co-simulation	software engineering;embedded system;high level synthesis;level of detail;levels of abstraction;cosimulation embedded system co simulation selective focus geographically distributed hardware software co simulation internet communication primitives java based tool inter module communications;embedded system hardware internet field programmable gate arrays computer science computational modeling java medical simulation application software automotive engineering;simulation model;geographic distribution;digital simulation;digital simulation real time systems high level synthesis software engineering;dynamic optimization;real time systems	When dealing with communication-intensive systems, hardware/sof%ware co-simulation usually either requres the communication t o be simulated with a uniformly low level of detail or it performs poorly. This prohlem manifests itself even more strongly when considering geographically distributed co-simulation where designers take advantage of proprietary component siviulation models that are made available over the Internet. In such systems, much of the communication can potentially occur over the Internet, with even more ezpensive and slower communication primitives. This paper presents a technique, called ”selective focus”, and a Java based tool which allow communication to be represented at various levels of abstraction thus giving the designer the ability to dynamically optimize inter-module communications and improve the performance of the cosimulation.	co-simulation;embedded system;high- and low-level;internet;java;level of detail;principle of abstraction;simulation	Ken Hines;Gaetano Borriello	1997		10.1109/IWRSP.1997.618825	embedded system;real-time computing;computer science;operating system;software engineering;logic simulation;level of detail;simulation modeling;high-level synthesis;programming language;computer engineering	PL	-36.84522130995747	35.32247858075744	198003
1fd57efc1dc5c619b58d5a94d4437897d839c149	the virtual splitter: refactoring web applications for themultiscreen environment	application distribution;multiscreen;web application;authoring	Creating web applications for the multiscreen environment is still a challenge. One approach is to transform existing single-screen applications but this has not been done yet automatically or generically. This paper proposes a refactoring system. It consists of a generic and extensible mapping phase that automatically analyzes the application content based on a semantic or a visual criterion determined by the author or the user, and prepares it for the splitting process. The system then splits the application and as a result delivers two instrumented applications ready for distribution across devices. During runtime, the system uses a mirroring phase to maintain the functionality of the distributed application and to support a dynamic splitting process. Developed as a Chrome extension, our approach is validated on several web applications, including a YouTube page and a video application from Mozilla.	code refactoring;demultiplexer (media file);disk mirroring;distributed computing;multi-screen video;web application	Mira Sarkis;Cyril Concolato;Jean-Claude Dufourd	2014		10.1145/2644866.2644893	embedded system;web application;simulation;computer science;operating system;programming language;world wide web	SE	-35.656846157505406	41.696275784683685	198296
d089800f091c7a53fd1e6e831a3a384c44041260	reputation-based semantic service discovery	service oriented computing;service discovery;semantic grid;trust and reputation	Semantic grids need to support dynamic service discovery - to enable users to look for services based on their properties. Such properties generally include the interface provided by a service (such as message types supported) - but may also include other nonfunctional properties - such as service performance and cost. This requires the provision and recording of metadata about a service that is not supported by current registry services such as UDDI. A framework to facilitate reputation-based service selection in semantic grids is presented. The proposed framework has two key features that distinguish it from other work in this area. First, an adaptive reputation-aware service discovery algorithm is provided. Second, a service-oriented distributed reputation assessment algorithm is presented. The main components of the framework are described.	algorithm;composer;interaction;requirement;semantic web;service discovery;service-oriented device architecture;service-oriented software engineering;uptime	Ali Shaikh Ali;Shalil Majithia;Omer F. Rana;David W. Walker	2004	13th IEEE International Workshops on Enabling Technologies: Infrastructure for Collaborative Enterprises	10.1002/cpe.977	semantic grid;computer science;operating system;service-oriented architecture;database;service discovery;internet privacy;world wide web	HPC	-45.870877519375604	43.04733154402762	198420
663b67e607ad11a09e40e2dd9f263d3f696f1f41	event loop coordination using meta-programming		Event-based programming is used in different domains, ranging from user interface development to various distributed systems. Combining different event-based subsystems into one system forces the developer to manually coordinate the different event loops of these subsystems. This leads to a lot of excessive code and, in addition, some event loops are prey to lifecycle state changes. On mobile applications, for example, event loops can be shut down when memory runs low on the device. Current approaches take care of the communication problems between the different types of event loops, but become complex when trying to deal with lifecycle state changes. We propose a new coordination model, Elector, that allows two event loops to run separately, and introduce a novel kind of reference, called undead references. These references do not only allow communication between the event loops, but also handle lifecycle state changes in such a way that they do not influence other event loops.	care-of address;distributed computing;event loop;library (computing);metaprogramming;mobile app;prey;user interface	Laure Philips;Dries Harnie;Kevin Pinte;Wolfgang De Meuter	2013		10.1007/978-3-642-38493-6_14	real-time computing;simulation;computer science;distributed computing;event;event tree analysis	SE	-38.495794769954756	40.7753317636386	198826
5a6643e827e650582ead548099fa4be062ff3d93	from (incomplete) tosca specifications to running applications, with docker		Cloud applications typically consist of multiple interacting components, each requiring a virtualised runtime environment providing the needed software support (e.g., operating system, libraries). In this paper, we show how TOSCA and Docker can be effectively exploited to orchestrate multi-component applications, even if their (runtime) specification is incomplete. More precisely, we first propose a TOSCA-based representation for multi-component applications, and we show how to use it to specify only the components forming an application. We then present a way to automatically complete TOSCA application specifications, by discovering Docker-based runtime environments that provide the software support needed by the application components. We also discuss how the obtained specifications can be automatically orchestrated by existing TOSCA engines.	docker	Antonio Brogi;Davide Neri;Luca Rinaldi;Jacopo Soldani	2017		10.1007/978-3-319-74781-1_33	real-time computing;cloud computing;computer science;software	OS	-39.96715676083425	38.17052032567384	198850
2545e8460b8e0afb33e5371ed4edfd2cb8423500	multi-view power modeling based on uml, marte and sysml	sysml multi view modeling power reduction techniques uml marte;ieee standards;power reduction techniques;clocks;soc multiview power modeling uml marte sysml embedded systems functional aspects behavioral aspects structural aspects system on chip;uml;multi view modeling;unified modeling language power aware computing system on chip;unified modeling language mathematical model clocks equations power demand ieee standards hardware;power aware computing;system on chip;unified modeling language;mathematical model;marte;power demand;sysml;hardware	In embedded systems, non-functional and functional aspects are closely related and cannot be considered independently. However, the high complexity of systems requires a large domain of competencies and experts in various domains have to work concurrently on different aspects of the same systems. This is why we propose a multi-view model where each view represents a specific domain. The different views are connected to each other by explicit associations that maintain consistency. The whole system is the sum of all the aspects of elements in all the views. This multi-view approach is implemented in a dedicated UML profile based on MARTE and SysML. This article specifically focuses on the power view and its relationship to other functional or non-functional, structural or behavioral aspects.	co-simulation;embedded system;federated identity;modeling and analysis of real time and embedded systems;profile (uml);simulation;systems modeling language;unified modeling language;view model	Carlos Gomez;Julien DeAntoni;Frédéric Mallet	2012	2012 38th Euromicro Conference on Software Engineering and Advanced Applications	10.1109/SEAA.2012.66	unified modeling language;embedded system;real-time computing;computer science;systems engineering;operating system;applications of uml;east-adl	SE	-40.44620844323766	33.273495339991015	198979
9b2169634785312741257b1b0735398e41883bfe	industrial data acquisition and control systems	control system;data acquisition	Industrial process control requires acquisition of data, calculation of the appropriate control action and output of a signal to effect that control action. The advent of microcomputers has resulted in a trend towards distributed, rather than centralized, control. This trend is in part due to the development of interfaces for industrial input and output. After an introduction to the requirements for data acquisition and control, the development of microcomputer systems is traced, illustrated by consideration of particular units.	centralized computing;control system;data acquisition;input/output;microcomputer;requirement	Joe Gallacher	1979	Microprocessors and Microsystems - Embedded Hardware Design	10.1016/0141-9331(79)90139-X	real-time computing;computer science;control system;data acquisition	Robotics	-35.44805238316545	38.45046488014662	199163
783cf5b33cf610157c489f34d78be672e3867918	exploiting code mobility in decentralized and flexible network management	code mobility;network management;mobile agent	Network management is gaining increasing importance due to the pervasiveness of computer networks. Nevertheless, mainstream approaches to network management are presently limited by centralized management strategies and poor exibility|a consequence of their rigid client-server architecture. In this paper we analyze how to overcome these problems by new design paradigms and technologies encompassing the capability to relocate dynamically the components of a distributed application. We evaluate the opportunities ooered by this approach and provide feasibility considerations, also discussing a few interim architectural solutions adopted in our ongoing implementation work.	centralized computing;client–server model;code mobility;distributed computing;object language;programming paradigm;server (computing);tcl	Mario Baldi;Silvano Gai;Gian Pietro Picco	1997		10.1007/3-540-62803-7_20	element management system;network management station;mobile agent;distributed computing;network management application;mobility model;computer security;computer network	Networks	-36.301752506714294	43.944387858288195	199360
e8a90a5cba9b750b7f331ca955000f5fc0388839	efficiency and robustness using trusted communities in a trusted desktop grid	agent architecture adaptation cooperative systems trust organic computing grid computing desktop grid multi agent system;trust;trust based adaptivity algorithms trusted communities trusted desktop grid social systems system to system level efficiency improvement robustness improvement self organising complex systems malicious nodes desktop grid and volunteer computing system dgvcs trust adaptive agents;multi agent system;computer model;organic computing;social system;software agents;computer architecture;adaptive algorithm;multi agent systems;computational modeling;cooperative systems;community computing;adaptive systems;complex system;adaptation;adaptive system;robustness;agent architecture;communities;software agents grid computing multi agent systems security of data;adaptation models;grid computing;security of data;robustness communities computer architecture adaptive systems adaptation models computational modeling grid computing;desktop grid	Bringing forward trust from social systems to system-to-system level can lead to efficiency and robustness improvements in self-organising complex systems. In this paper, we show how trust can enhance the matchmaking and robustness regarding malicious nodes in a Desktop Grid and Volunteer Computing System (DGVCS). We give the agent a suited degree of autonomy to continuously adapt to their environment in both worker and submitter role. In this paper, we introduce adaptivity in submitter and worker role for our trust-adaptive agents. The evaluation shows that using trust based adaptivity algorithms in a DGVCS leads to efficiency improvements and robustness regarding malicious nodes.	agent architecture;algorithm;autonomy;complex systems;computational trust;malware;period-doubling bifurcation;self-organization;social system;vii;volunteer computing	Yvonne Bernard;Lukas Klejnowski;Emre Cakar;Jörg Hähner;Christian Müller-Schloer	2011	2011 Fifth IEEE Conference on Self-Adaptive and Self-Organizing Systems Workshops	10.1109/SASOW.2011.28	agent architecture;computer science;artificial intelligence;theoretical computer science;adaptive system;software agent;multi-agent system;social system;distributed computing;trustworthy computing;computational model;world wide web;grid computing;robustness;adaptation	Robotics	-43.95976438720834	40.29973845867886	199438
9144b83a9fb4442a3d93e12b0657b1de75fa78f2	business process assignment and execution in mobile environments	mobile communication engines mobile handsets business performance evaluation algorithm design and analysis computational modeling;mobile computing business data processing;mobile assisted health care project business process assignment business process execution mobile environments mobile devices mobile applications business process management technologies service composition service coupling business logic process assignment algorithm business process deployment graphical process designer android based process engine;context aware application business process mobile environment assignment	Mobile devices are emerging as working equipment. Developing and maintaining mobile applications for evolving business is costly. Business Process Management technologies enable loose-coupling and composition of services to support the evolving business logic. Business Process Management becomes pervasive and more powerful when it interweaves mobile devices. However, traditional Business Process execution is inefficient in mobile environments: the computational capabilities on mobile devices are various; the movement of devices changes their connectivity. In this paper, we propose a model of mobile computational capability and connectivity. Based on that, we define the constraints of mobile environments and the requirements to execute a business process. A process assignment algorithm and its optimized version considering the cost are designed. Our approach enables more flexible and efficient business process deployment in mobile environments. Preliminary results including a graphical process designer and Android based process engine are tested in a mobile-assisted healthcare project.	algorithm;android;business logic;business process;business requirements;graphical user interface;interconnection;loose coupling;metamodeling;mobile app;mobile device;pervasive informatics;process (computing);requirement;software deployment	Tao Peng;Chi-Hung Chi;Annamaria Chiasera;Giampaolo Armellin;Marco Ronchetti;Cristina Matteotti;Cristhian Parra;Aleksey Oleksiy Kashytsa;Alessio Varalta	2014	2014 International Conference on Collaboration Technologies and Systems (CTS)	10.1109/CTS.2014.6867574	real-time computing;mobile search;mobile web;artifact-centric business process model;business process management;mobile technology;process modeling;distributed computing;mobile business development;process mining;business process discovery;mobile computing;business process modeling;business activity monitoring;business architecture	HCI	-43.00232900321367	43.2573268104084	199605
95692c8d941e1f59f8eb07530c888132cab55268	automated design of communication protocols using esterel	verification;automated design;specification;development process;rapid evolution;protocol implementation;protocol tailoring;communication protocol;communication protocols;real time systems	"""The rapid evolution of networking and the multiplication of new applications re-emphasizes the importance of the efficient communication supports. Implementations must be able to take maximal advantage of the details of application-specific semantics and of specific networking environments. In other words, the application needs to have more control over data transmission. Such control can be obtained by tailoring the communication facilities (or protocols) to the application characteritics, and by integrating the communication control to the application. Because such a task is too complex to be realized manually, we propose to automate the protocol development process using a formal approach. This paper presents our approach to the automated design and the implementation of application-specific communication protocols based on information provided by the application. Starting from the formal description of an application, our approach is based on a tool called """"Protocol Compiler"""" that will automatically produce the implementation of a communication protocol tailored to the application. The formalism we use is ESTEREL, a synchronous reactive language dedicated to the description of Real-Time systems. Protocol description and verification using ESTEREL are described, as well as protocol implementation principles."""	communications protocol;compiler;esterel;maximal set;real-time computing;real-time transcription;semantics (computer science)	Christophe Diot;Robert de Simone;Christian Huitema	1996	J. High Speed Networks	10.3233/JHS-1996-5202	communications protocol;computer architecture;real-time computing;computer science;distributed computing;computer network	Embedded	-34.702128858085736	32.60060230877562	199744
a081347dd0dca3bf645494764e59d05cbb008016	research of reliability technology in heterogeneous autonomous decentralized assurance systems	financial data processing;reliability;data integrity;system modeling;autonomous decentralized data consistency technology;functional reliability;centralized system model;autonomous decentralized data consistency technology reliability technology automatic fare collection system railway autonomous decentralized assurance systems functional reliability autonomous decentralized systems ic card ticket system centralized system model;autonomous decentralized assurance systems;decentralized system;smart cards data integrity financial data processing reliability;railway;smart cards;reliability technology;automatic fare collection system;broadcasting rail transportation concrete wireless communication local area networks automatic frequency control smart cards writing;ic card ticket system;autonomous decentralized systems	Reliability, the conventional measure, is defined as whether a system can continue the operation without failure. It indicates 0 or 1 and is not suitable for systems with functions gradually increasing and decreasing. Functional reliability, on the other hand, scales a system as integration of functions by subsystems. So it can reflect how the system is changing. autonomous decentralized systems, for example, can continue the operation even when some of the subsystems fail. In this case, functional reliability is more appropriate to grasp the state of the system. This paper introduces functional reliability to evaluate the IC card ticket system, one of the autonomous decentralized assurance systems. Two models of the centralized system model and the decentralized system model are prepared, simulated, and compared. According to the results, the decentralized system model shows higher functional reliability. In reality, the IC card ticket system is operating very well without any fatal errors, which proves the usefulness of functional reliability	autonomous decentralized system;autonomous robot;centralized computing;decentralised system;reliability engineering;simulation;smart card;subscriber identity module	Akio Shiibashi;Takashi Kuroda;Motoharu Yamana;Kinji Mori	2007	Eighth International Symposium on Autonomous Decentralized Systems (ISADS'07)	10.1109/ISADS.2007.64	embedded system;smart card;real-time computing;systems modeling;decentralised system;computer science;artificial intelligence;data integrity;reliability;database;computer security	Embedded	-35.37516751736671	37.04893896562413	199767
97936f0c313a16d45f4ef2e9c4059f44862821a7	mas-based self-adaptive architecture for controlling and monitoring cloud platforms		The theory of agents and multiagent systems can provide a new model for managing Cloud Computing systems based on the distribution of responsibilities, flexibility and autonomy. Managing the functions of the nucleus of a CC system through an agent-based model allows the resulting platforms to be much more efficient, scalable and adaptable than they currently are. This article presents an architecture to model the control and monitoring system of a Cloud Computing platform by using a Virtual Organization of intelligent agents that self-adapt and reorganize according to the needs of the surrounding environment.	adaptive architecture	Fernando de la Prieta;Javier Bajo;Sara Rodríguez;Juan Manuel Corchado	2017	J. Ambient Intelligence and Humanized Computing	10.1007/s12652-016-0434-8	embedded system;real-time computing;cloud computing;distributed computing	HPC	-38.68801022883829	44.028404593857616	199787
354dcf00fa95a93b140b2c4fae96c313e3730450	virtual platforms for model-based design of dependable cyber-physical system software	computational modeling iron data models unified modeling language abstracts testing time varying systems;simulink virtual platforms model based design cyber physical system software discrete continuous application physical environment in the loop sw under test systemc based framework automotive case study fault tolerant fuel injection control system;time varying systems;iron;testing;computational modeling;abstracts;unified modeling language;virtualisation automotive engineering c language fault tolerance program testing simulation;data models	In this article, we present a virtual platform driven methodology for model-based design of dependable SW targeting cyber-physical systems. Our methodology covers an eight levels spanning flow for smooth refinement of discrete/continuous application models towards the implementation of distributed SW stacks providing flexibility w.r.t. early integration of object/binary code. For this, we propose multiple virtual platform abstraction levels supporting SW synthesis from high level MoCs. By continuous interfacing with a model of the physical environment in-the-loop we enable to holistically consider mutual impacts of the SW and its environment. In order to assess and improve SW dependability we investigate the injection of faults and their effects into both the environment model and the SW under test. We present a mapping of the proposed methodology to a completely SystemC-based framework by employing several SystemC extensions, such as AMS/TDF, QEMU, and abstract models of RTOS, HAL and middleware. Finally, we present experimental results from an automotive case study: a fault- tolerant fuel injection control system for which we consider two fault injection use cases: (i) robustness/stress testing and (ii) mutation testing. Our results were derived by prototypic integration of our SystemC framework with a commercial Simulink- based tool chain for AUTOSAR-compliant SW development and deployment.	autosar;application server;binary code;control system;cyber-physical system;dependability;fault injection;file spanning;hal;high-level programming language;holism;microsoft outlook for mac;middleware;mutation testing;refinement (computing);robustness testing;shattered world;simulink;software deployment;stress testing;systemc;toolchain;trusted data format;vhdl-ams;virtual machine	Markus Becker;Christoph Kuznik;Wolfgang Mueller	2014	2014 17th Euromicro Conference on Digital System Design	10.1109/DSD.2014.107	unified modeling language;embedded system;real-time computing;computer science;operating system;iron	EDA	-42.668581774441925	32.7906078526806	199812
41d8fc0a51d308e0901d9541b640f7ee4a05659b	eflux: simple automatic adaptation for environmentally powered devices	environmentally powered devices;adaptation algorithms;biology computing;global positioning system batteries energy management animals jacobian matrices computer science mobile computing algorithm design and analysis biological system modeling wildlife;adaptation algorithms eflux environmentally powered devices energy management mobile computing environmental source energy high level data flow oriented coordination language;object oriented programming biology computing environmental science computing low power electronics mobile computing;high level data flow oriented coordination language;mobile computing system;eflux;coordination language;object oriented programming;environmental science computing;adaptive algorithm;system design;environmental source energy;low power electronics;performance prediction;runtime system;data flow;mobile computing;energy source;energy management	Energy management is a critical problem in designing mobile computing systems, especially when those systems depend on harvesting energy from environmental sources, such as solar or wind. Environmental sources are highly variable and difficult to predict, which is often complicated further by device mobility. In this demo, we present a simple approach for developing energy-aware applications using a high-level data flow oriented coordination language. This language, eFlux, is an extension of the Flux (Burns et al., 2006) coordination language, which provides a simple interface for specifying an energy adaptation policy, which can then be implemented automatically by the underlying runtime system. This approach allows a system designer to change the underlying adaptation algorithms (e.g. energy source prediction) without modifying the application. Also, the data flow programming style of Flux simplifies program profiling and performance prediction. In this demo, we will present our experience, to date, using eFlux, including both working system and simulation results. We will also demonstrate an energy-aware GPS tracking device for tracking threatened Wood Turtles in Western Massachusetts	algorithm;dataflow;gps tracking unit;global positioning system;high- and low-level;mobile computing;performance prediction;programming style;runtime system;simulation;systems design;tracking system;word lists by frequency	Jacob Sorber;Alexander Kostadinov;Matthew Brennan;Mark D. Corner;Emery D. Berger	2006	Seventh IEEE Workshop on Mobile Computing Systems & Applications (WMCSA'06 Supplement)	10.1109/WMCSA.2006.8	real-time computing;simulation;computer science;theoretical computer science	Mobile	-41.49461618394397	35.464091490027634	199849
a4ef0b5cb74de85bde41b0297412c5c1a947d51f	designing an sla protocol with renegotiation to maximize revenues for the cmac platform		The emerging transformation from a product oriented economy to a service oriented economy based on Cloud environments envisions new scenarios where actual QoS mechanisms need to be redesigned. In such scenarios new models to negotiate and manage Service Level Agreements (SLAs) are necessary. An SLA is a formal contract which defines acceptable service levels to be provided by the Service Provider to its customers in measurable terms. This is meant to guarantee that consumers’ service quality expectation can be achieved. In fact, the level of customer satisfaction is crucial in Cloud environments, making SLAs one of the most important and active research topics. The aim of this paper is to explore the possibility of integrating an SLA approach for Cloud services based on the CMAC (Condition Monitoring on A Cloud) platform which offers condition monitoring services in cloud computing environments to detect events on assets as well as data storage services.	one-key mac;service-level agreement	Adriano Galati;Karim Djemame;Martyn Fletcher;Mark Jessop;Michael Weeks;Simon J. Hickinbotham;John McAvoy	2012		10.1007/978-3-642-38333-5_12	condition monitoring;service provider;process management;quality of service;cloud computing;business;customer satisfaction;revenue;service quality;service level	Crypto	-47.74246269774259	43.322199176595596	199883
128ef43b18eb69ecf2c68933aaf150cf567741ec	a component-based meta-model for context-aware, distributed adaptation graphs	component platform component based meta model context aware graph distributed adaptation graph component based modeling pipeline based processing adaptive data processing mobile environment pervasive environment parametrizable component application data processing contextual information adaptation control adaptation mechanism modeling adaptive software system platform independent model;context aware;adaptive control;software systems;data processing;contextual information;pipeline processing graphs mobile computing;graphs;application software software systems unified modeling language computer networks data processing connectors adaptive systems context modeling computer science mediation;platform independent model;mobile computing;meta model;pipeline processing	In this paper we present a component-based modeling approach for distributed adaptation graphs at architectural level. The graph structure reflects the pipeline-based processing of applications typical for adaptive data processing and transfer in mobile and pervasive environments. Parametrizable components and connectors represent mechanisms for processing application data as well as its mediation between components. Further elements represent contextual information and its mapping to component and connector parameters allowing an explicit definition of adaptation control. Thus, the model enables the explicit modeling of adaptation mechanisms as well as of reconfigurations inform of alternative paths, both controlled by parameter changes. The meta-model provides a certain view and abstraction on adaptive software systems which can be combined with other views to create comprehensive system descriptions. It represents a platform independent model (PIM) not tied to a certain component platform and can be mapped to existing component platforms like J2EE or Microsoft .NET using an MDA-approach	.net framework;component-based software engineering;eclipse;email;enterprise javabeans;explicit modeling;java platform, enterprise edition;metamodeling;mobile device;osgi;pervasive informatics;pipeline (computing);platform-independent model;qvt;software system	Thomas Springer	2006	International Conference on Autonomic and Autonomous Systems (ICAS'06)	10.1109/ICAS.2006.2	metamodeling;real-time computing;data processing;adaptive control;computer science;theoretical computer science;operating system;component;database;distributed computing;graph;mobile computing;software system	SE	-39.4601560110621	39.39925048342154	199929
