id	title	keywords	abstract	entities	authors	year	journal	doi	fos	area	x	y	ix
33dd6a9a015e3a940bc793ec421a1c02d337ffb1	a complete rule for equifair termination	lenguaje de programacion;competition;planificacion integral;programmation;programming language;plenitud;integrated planning;systeme non deterministe;programacion;non deterministic system;quarded command;construction cone;program termination;commande gardee;langage programmation;sistema no determinista;completeness;cone construction;completude;programming;ordonnancement;terminaison programme;competencia	Abstract   The notion of  equifairness , strengthening the familiar notion of  fairness , is introduced as a scheduling policy of nondeterminism and concurrency. Under this notion, it is infinitely often the case that the number of selections of each of a family of infinitely often jointly enabled processes is equal. A proof rule for proving  equifair termination  is introduced and proved to be semantically complete.		Orna Grumberg;Nissim Francez;Shmuel Katz	1986	J. Comput. Syst. Sci.	10.1016/0022-0000(86)90056-5	programming;competition;completeness;artificial intelligence;mathematics;integrated business planning;algorithm	Theory	-8.056404597750728	20.06061387232615	155165
75f9c11b7b34a1e07a213872ecc7b722ed4d584f	permutative rewriting and unification	e unification;permutation group;algorithme unification;ordered set;68q42;68t15;estrategia;ensemble ordonne;definicion;68wxx;probleme decision;probleme np;strategy;decision problem;unification;definition;theorie algorithme;algorithm theory;permutation groups;informatique theorique;reecriture;06axx;decision;equational theories;cardinalite;rewriting;term rewriting;strategie;deduccion;unificacion;reescritura;conjunto ordenado;computer theory;informatica teorica;deduction	Permutative rewriting provides a way of analyzing deduction modulo a theory defined by leaf-permutative equations. Our analysis naturally leads to the definition of the class of unify-stable axiom sets, in order to enforce a simple reduction strategy. We then give a uniform unification algorithm modulo theories E axiomatized this way. We prove that it computes complete sets of unifiers of simply exponential cardinality, and that the E-unification decision problem belongs to NP.	rewriting;unification (computer science)	Thierry Boy de la Tour;Mnacho Echenim	2007	Inf. Comput.	10.1016/j.ic.2006.11.001	discrete mathematics;computer science;mathematics;permutation group;programming language;algorithm;algebra	Logic	-7.912987930436221	19.356338069475004	155780
29da7c51f6a3836e4a75d3c25ec1e1d7ad275072	compositional reasoning using intervals and time reversal	68q55;03b44;interval temporal logic;symmetry;mutual exclusion;time reversal;formal verification;03b70;68q85;compositional reasoning;68q60;peterson s algorithm	Interval Temporal Logic (ITL) is an established formalism for reasoning about time periods. We investigate some simple kinds of ITL formulas which have application to compositional reasoning and furthermore are closed under conjunction and the conventional temporal operator known both as “box” and “always”. Such closures help us modularly construct formulas from simple building blocks in a way which preserves useful compositional properties. The most important class considered here is called the 2-to-1 formulas. They offer an attractive framework for analysing sequential composition in ITL and provide the formal basis for most of the subsequent presentation. A key contribution of this work concerns a useful and apparently new and quite elementary mathematical theorem that 2-to-1 formulas are closed under “box”. We also use a natural form of time symmetry with 2-to-1 formulas. This extends known facts about such formulas by looking at them in reverse. An important example involves showing that 2-to-1 formulas are also closed under a variant of “box” for prefix subintervals rather than suffix ones. We then apply the compositional formulas obtained with time symmetry to analyse concurrent behaviour involving mutual exclusion in both Peterson’s algorithm and a new and more abstract one. At present, our study of mutual exclusion mainly serves as a kind of experimental “proof of concept” and research tool to develop and illustrate some of the logical framework’s promising features. We also discuss how time symmetry sometimes assists in reducing reasoning in ITL to conventional linear-time temporal logic.	benchmark (computing);computational complexity theory;concurrency (computer science);decision problem;elementary;forward error correction;hoare logic;interval temporal logic;linear temporal logic;logical framework;mutual exclusion;pass transistor logic;peterson's algorithm;process calculus;qualitative comparative analysis;semantics (computer science);sven jaschan;t-symmetry;time complexity;weitao yang	Ben C. Moszkowski	2011	2011 Eighteenth International Symposium on Temporal Representation and Reasoning	10.1007/s10472-013-9356-8	discrete mathematics;mutual exclusion;formal verification;interval temporal logic;computer science;artificial intelligence;peterson's algorithm;machine learning;mathematics;symmetry;programming language;t-symmetry;algorithm	Logic	-10.799073729201682	21.327578180203936	155871
80600d061ce0526823a463c8eed3ce5ed2e6593b	approximation for the path complexity of binary search tree		The complexity of an algorithm is an important parameter to determine its efficiency. They are of different types viz. Time complexity, Space complexity, etc. However, none of them consider the execution path as a complexity measure. Ashok et al, firstly proposed the notion of the Path Complexity of a program/algorithm, which defined based on the number of execution paths as a function of the input size. However, the notion of path complexity of the program, cannot apply to the objectoriented environment. Therefore, Anupam et al, has extended the notion of path complexity to the class as follows. The notion of the state of the class is defined based on structural representation (aka state) of the class. The class contains data members and data operations. It considers only those data operations that change the state of the class. The path complexity of the class is defined to be the number of valid input sequences, each of them containing valid data operations. Anupam et al, had applied this notion to the class Stack. However, the stack is basic and simple data structures. Therefore, in this research we have used a more complex class to understand the path complexity behavior in the object oriented environment. Binary Search Tree (BST) is one of the well known (and more complex too) data structure, which is useful in sorting, searching, Traffic Engineering and many more applications. We have analyzed the path complexity of the class BST based on the algorithms for insert and delete operations. Additionally, we have modified the delete operation to minimize the path complexity for the class BST.	algorithm;approximation;blum axioms;computational complexity theory;dspace;data structure;information;search tree;sorting;stack (abstract data type);state (computer science);time complexity;viz: the computer game;whole earth 'lectronic link	Nishant Doshi	2013	CoRR		co-np;complete;time complexity;complexity class;discrete mathematics;complexity;fp;average-case complexity;ph;theoretical computer science;structural complexity theory;sparse language;worst-case complexity;complexity index;mathematics;up;game complexity;algorithm;descriptive complexity theory	Theory	-5.044074380935897	23.449441773343295	155942
7d7f8a7b216a6ee45cd88731a8c24e76fb9df9bc	synthesizing optimally resilient controllers		Recently, Dallal, Neider, and Tabuada studied a generalization of the classical game-theoretic model used in program synthesis, which additionally accounts for unmodeled intermittent disturbances. In this extended framework, one is interested in computing optimally resilient strategies, i.e., strategies that are resilient against as many disturbances as possible. Dallal, Neider, and Tabuada showed how to compute such strategies for safety specifications. In this work, we compute optimally resilient strategies for a much wider range of winning conditions and show that they do not require more memory than winning strategies in the classical model. Our algorithms only have a polynomial overhead in comparison to the ones computing winning strategies. In particular, for parity conditions optimally resilient strategies are positional and can be computed in quasipolynomial time. 2012 ACM Subject Classification Theory of computation → Automata over infinite objects	algorithm;automata theory;computer memory;game theory;overhead (computing);polynomial;program synthesis;quasi-polynomial;theory of computation	Daniel Neider;Alexander Weinert;Martin Zimmermann	2018		10.4230/LIPIcs.CSL.2018.34	mathematical optimization;program synthesis;computer science;polynomial	Logic	-5.631359120719985	24.3183089314837	156182
bd87f1826a84d2bb30a3ce7e67f5d569677997d4	on the undecidability of implications between embedded multivalued database dependencies	abelian group;mathematical morphology;base donnee;relation equivalence;grupo abeliano;language theory;database;base dato;dependance multivaluee;word problem;teoria lenguaje;isomorphism;homomorphism;permutation;theorem proving;isomorfismo;congruencia;dependencia multivaluada;demonstration theoreme;equivalence relation;multivalued dependency;decision procedure;dependance fonctionnelle;permutacion;homomorphisme;equivalence classes;isomorphisme;dependencia funcional;algebre relationnelle;homomorfismo;groupe abelien;coordinatization;relational algebra;theorie langage;congruence;functional dependence;unsolvability;morphologie mathematique	The implication and finite implication problems for embedded multivalued database dependencies are both shown to be algorithmically undecidable. The proof is by an interpretation of semigroup word problems via systems of permuting equivalence relations into database dependencies. In contrast, it is shown that for each fixed premise H one has a decision procedure for implications H ? F.	multivalue;undecidable problem	Christian Herrmann	1995	Inf. Comput.	10.1006/inco.1995.1148	equivalence class;homomorphism;word problem;combinatorics;discrete mathematics;mathematical morphology;dependency theory;relational algebra;philosophy of language;congruence;mathematics;permutation;abelian group;automated theorem proving;isomorphism;equivalence relation;fourth normal form;algorithm;multivalued dependency;algebra	DB	-4.599979278683045	19.89598504791592	156988
6b814034fcaab2040c3c5395e428e0279e1615c8	on reachability and spatial reachability in fragments of bioambients	reachability;computer model;decision problem;biological systems;term rewriting;petri net;power modeling;associative commutative	BioAmbients is a powerful model for representing various aspects of living cells. The model provides a rich set of operations for the movement and interaction of molecules. The richness of the language motivates the study of dialects of the full model and the comparison with other computational models. In this paper we investigate the limit between decidability and undecidability of two decision problems, namely reachability and spatial reachability, for semantic and syntactic fragments of BioAmbients providing movement capabilities and merge. Our results illustrate the power of merge with respect to the other movement operations of BA for properties like reachability. Furthermore, they establish an interesting connection between BioAmbients and other computational models like associative-commutative term rewriting and Petri nets with transfer arcs.	biological system;business architecture;computation;computational model;decision problem;elan;executable;maude system;petri net;reachability;rewriting;turing completeness;turned a;undecidable problem	Giorgio Delzanno;Roberto Montagna	2007	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2007.05.008	computer simulation;discrete mathematics;computer science;theoretical computer science;decision problem;mathematics;reachability;petri net;algorithm	Logic	-9.074124592053575	22.57646462072275	157025
767a7ed9036ac4000c9f7922031ac617ed3d5885	algebraic characterization of petri net pomset semantics	algebraic semantic;red petri;semantica algebraica;informatique theorique;linear time;semantique algebrique;petri net;reseau petri;computer theory;informatica teorica	Sets of pomsets are frequently used as a true-concurrency, linear-time semantics of Petri nets. For a Petri net N, let P(N), a set of pomsets, denote the pomset behaviour of N, and let P:= {P(N) IN is a Petri nett denote the class of pomset behaviours of Petri nets, a generalization of C, the class of all Petri net languages. We present here an algebraic characterization for P, similar to the known algebraic characterizations for C.	petri net	Harro Wimmel;Lutz Priese	1997		10.1007/3-540-63141-0_28	time complexity;discrete mathematics;computer science;theoretical computer science;petri net;algorithm	Logic	-5.114996551819442	21.321332090944953	157508
192935e55e96b79f5f3d8a36fb8f3f04cfe1bd39	mell in the calculus of structures	logique lineaire;automated deduction;teoria demonstracion;theorie preuve;decomposition;eliminacion;cut elimination;proof theory;propiedad;calculus of structures;sistema;estructura;time;logica lineal;sequent calculus;proof net;temps;contexto;system;natural deduction;contexte;propriete;calcul structure;classical logic;systeme;elimination;descomposicion;properties;linear logic;structure calculus;elimination coupe;deduccion;structure;context;fragmento;tiempo;fragment;deduction	Gentzen’s sequent calculus is a tool to study properties of logics independently of semantics. The main property is cut-elimination which entails the subformula property and consistency. It is also the basis of methods of automated deduction. Although the sequent calculus is very appropriate for classical logic, it raises some concerns in dealing with more refined logics like linear logic. An example is the global behaviour of the promotion rule. The calculus of structures is a recent development that is able to overcome those difficulties without losing the ability of performing a cut-elimination proof. Moreover, the cut rule can be reduced to its atomic form in the same way as the identity axiom can. In this paper I will carry out the exercise of describing the multiplicative exponential fragment of linear logic in the calculus of structures. We get the following advantages over the sequent calculus representation: no non-deterministic splitting of the context in the times rule, a local rule for promotion, a modular proof for the cut-elimination theorem, and a decomposition theorem for derivations and proofs.	automated theorem proving;calculus of structures;cut rule;formal system;linear logic;logical connective;natural deduction;sequent calculus;the times;time complexity;undecidable problem;well-formed formula	Lutz Straßburger	2003	Theor. Comput. Sci.	10.1016/S0304-3975(03)00240-8	structure;fluent calculus;linear logic;process calculus;discrete mathematics;classical logic;cut-elimination theorem;geometry of interaction;computer science;analytic proof;time-scale calculus;proof theory;system;mathematics;proof calculus;noncommutative logic;property;curry–howard correspondence;decomposition;programming language;sequent calculus;natural deduction;structural proof theory;algorithm;elimination	Logic	-10.519369792531677	19.2122772273322	157833
072cb63284cd1bda24b5c4617eed576ed6fdc4b5	on the complexity of ltlmodel-checking of recursive state machines	state machine;model checking;computational complexity	Recursive state machines (rsms) are models for programs with recursive procedural calls. While Ltl model-checking is Exptimecomplete on such models, on finite-state machines, it is Pspace-complete in general and becomes Np-complete for interesting fragments. In this paper, we systematically study the computational complexity of modelchecking rsms against several syntactic fragments of Ltl. Our main result shows that if in the specification we disallow next and until, and retain only the box and diamond operators, model-checking is in Np. Thus, differently from the full logic, for this fragment the abstract complexity of model-checking does not change moving from finite-state machines to rsms. Our results on the other studied fragments confirm this trend, in the sense that, moving from finite-state machines to rsms, the complexity of model-checking either rises from Pspace-complete to Exptimecomplete, or stays within Np.	computational complexity theory;finite-state machine;model checking;np (complexity);np-completeness;pspace-complete;recursion (computer science);thinking outside the box	Salvatore La Torre;Gennaro Parlato	2007		10.1007/978-3-540-73420-8_80	model checking;discrete mathematics;computer science;theoretical computer science;mathematics;finite-state machine;computational complexity theory;algorithm	Logic	-10.72106840442277	23.068360697109107	158797
13209553d5ca49053587c7d55b786a19b2615edd	on the complexity of consistency and complete state coding for signal transition graphs	polynomial consistency checking;complete state coding;polynomials;asynchronous circuit;formal verification;computational complexity;np complete complete state coding signal transition graph asynchronous circuits polynomial consistency checking;signal transition graph;np complete;asynchronous circuits;petri nets;petri net;polynomials computer science asynchronous circuits petri nets cybernetics encoding computational complexity linear programming runtime sufficient conditions;polynomials asynchronous circuits computational complexity formal verification petri nets	Signal transition graphs (STGs) are a popular formalism for the specification of asynchronous circuits. A necessary condition for the implementability of an STG is the existence of a consistent and complete state encoding. For an important subclass of STGs, the marked graph STGs, we show that checking consistency is polynomial, but checking the existence of a complete state coding is co-NP-complete. In fact, co-NP-completeness already holds for acyclic and 1-bounded marked graph STGs and for live and 1-bounded marked graph STGs. We add some relevant results for free-choice, bounded, and general STGs	asynchronous circuit;co-np;co-np-complete;directed acyclic graph;marked graph;np-completeness;polynomial;semantics (computer science);signal transition;star trek generations	Javier Esparza;Petr Jancar;Alexander Miller	2006	Sixth International Conference on Application of Concurrency to System Design (ACSD'06)	10.1109/ACSD.2006.17	computer science;theoretical computer science;programming language;petri net;algorithm	EDA	-9.386905808363101	24.24420140400563	158897
c25cdaee4a854d330878a646a7d2a3dfd4f78e82	membership problems for regular and context-free trace languages	settore inf 01 informatica;time complexity;programacion paralela;language theory;context free language;appartenance;context free;regular language;parallel programming;concurrent program;teoria lenguaje;lenguaje racional;lenguaje cf;trace language;complexite temps;informatique theorique;programa competidor;langage rationnel;pertenencia;complejidad tiempo;langage trace;membership;theorie langage;langage cf;programme concurrent;programmation parallele;computer theory;informatica teorica	Abstract   Trace languages have been introduced in order to describe the behaviour of concurrent systems in the same way as usual formal languages do for sequential system. They can be defined as subsets of a free partially commutative monoid and a theory of trace languages can be developed, generalizing the usual formal languages theory. In this paper, the time complexity of membership problems for regular and context-free trace languages is investigated. It is proved that the membership problem for context free trace languages can be solved in time  O ( BM ( n   α  )), where α is the dimension of the greatest clique of the concurrency relation  C  and  BM ( n ) is the time required for multiplying two arbitrary  n  ×  n  boolean matrices. For regular trace languages, our method gives an algorithm which requires  O ( n   α  ) time. Finally, the uniform membership problem is shown to be NP-complete.		Alberto Bertoni;Giancarlo Mauri;Nicoletta Sabadini	1989	Inf. Comput.	10.1016/0890-5401(89)90051-5	arithmetic;time complexity;formal language;pumping lemma for regular languages;regular language;computer science;philosophy of language;mathematics;context-free language;cone;trace theory;algorithm	Logic	-4.811739486611421	21.1348715315439	159121
6696593dd1fcdd7214402aab789f8a487c95b958	a calculus of computational fields		A number of recent works have investigated the notion of “computational fields” as a means of coordinating systems in distributed, dense and mobile environments such as pervasive computing, sensor networks, and robot swarms. We introduce a minimal core calculus meant to capture the key ingredients of languages that make use of computational fields: functional composition of fields, functions over fields, evolution of fields over time, construction of fields of values from neighbours, and restriction of a field computation to a sub-region of the network. This calculus can act as a core for actual implementation of coordination languages and models, as well as pave the way towards formal analysis of properties concerning expressiveness, self-stabilisation, topology independence, and relationships with the continuous space-time semantics of spatial computations.	aggregate data;ambient calculus;booting;computation;distributed computing;electronic component;emergence;hood method;linda (coordination language);operational semantics;parallel computing;recursion (computer science);self-organization;self-stabilization;type system;ubiquitous computing;well-formed formula	Mirko Viroli;Ferruccio Damiani;Jacob Beal	2013		10.1007/978-3-642-45364-9_11	computer science;artificial intelligence;theoretical computer science;algorithm	PL	-11.381664823491226	19.809063414082473	159358
51c9e3d6a25f6533e5fb96f9ddc525670768f989	decidability and complexity of petri nets with unordered data	decision problem;expressive power;transition systems;petri net	We prove several decidability and undecidability results for ν-PN, an extension of P/T nets with pure name creation and name management. We give a simple proof of undecidability of reachability, by reducing reachability in nets with inhibitor arcs to it. Thus, the expressive power of ν-PN strictly surpasses that of P/T nets. We encode ν-PN into Petri Data Nets, so that coverability, termination and boundedness are decidable. Moreover, we obtain Ackermann-hardness results for all our decidable decision problems. Then we consider two properties, width-boundedness and depth-boundedness, that factorize boundedness. Width-boundedness has already been proven to be decidable. Here we prove that its complexity is also non primitive recursive. Then we prove undecidability of depth-boundedness. Finally, we prove that the corresponding “place version” of all the boundedness problems are undecidable for ν-PN. These results carry over to Petri Data Nets.	ackermann function;clique-width;concurrency (computer science);decision problem;encode;expressive power (computer science);petri net;primitive recursive function;reachability;recursion;simulation;undecidable problem	Fernando Rosa-Velardo;David de Frutos-Escrig	2011	Theor. Comput. Sci.	10.1016/j.tcs.2011.05.007	combinatorics;discrete mathematics;computer science;decision problem;mathematics;programming language;petri net;expressive power;algorithm	Logic	-6.149997967253242	21.989504278448358	159762
082381c1a52c773d5d1c4b2c01e606b30849a721	exploiting structure in quantified formulas	probleme satisfiabilite;dynamic programming;quantified formulas;tree decompositions;programacion dinamica;monoid;satisfiability problems;sum of products;channelwidth;generic algorithm;formule quantifiee;complexite calcul;quantifier;structure arborescente;non serial dynamic programming;dynamic program;satisfiability;algoritmo genetico;constraint satisfaction problems;constraint satisfaction;monoide;satisfaction contrainte;complejidad computacion;finite domain;generic algorithms;estructura arborescente;computational complexity;problema satisfactibilidad;quantificateur;tree structure;programmation dynamique;algorithme genetique;genetic algorithm;tree decomposition;treewidth;constraint satisfaction problem;satisfaccion restriccion;cuantificador;data structure;satisfiability problem;structure trees	We study the computational problem “find the value of the quantified formula obtained by quantifying the variables in a sum of terms.” The “sum” can be based on any commutative monoid, the “quantifiers” need only satisfy two simple conditions, and the variables can have any finite domain. This problem is a generalization of the problem “given a sum-of-products of terms, find the value of the sum” studied in [R.E. Stearns and H.B. Hunt III, SIAM J. Comput. 25 (1996) 448–476]. A data structure called a “structure tree” is defined which displays information about “subproblems” that can be solved independently during the process of evaluating the formula. Some formulas have “good” structure trees which enable certain generic algorithms to evaluate the formulas in significantly less time than by brute force evaluation. By “generic algorithm,” we mean an algorithm constructed from uninterpreted function symbols, quantifier symbols, and monoid operations. The algebraic nature of the model facilitates a formal treatment of “local reductions” based on the “local replacement” of terms. Such local reductions “preserve formula structure” in the sense that structure trees with nice properties transform into structure trees with similar properties. These local reductions can also be used to transform hierarchical specified problems with useful structure into hierarchically specified problems having similar structure.  2002 Elsevier Science (USA). All rights reserved.	algorithm;brute-force search;computational problem;data structure;generic programming;linear algebra;quantifier (logic);uninterpreted function	Richard Edwin Stearns;Harry B. Hunt	2002	J. Algorithms	10.1016/S0196-6774(02)00002-0	partial word;mathematical optimization;function composition;combinatorics;discrete mathematics;analysis of flows;genetic algorithm;data structure;generic property;computer science;property testing;reduct;mathematics;incidence;constraint satisfaction problem;algorithm;conditional event algebra;decision matrix	Theory	-7.155078093752691	18.85722843345278	160681
de5bcd310235f68713a2197ae91f564f6a427084	alternating-time temporal logic with finite-memory strategies		Model-checking the alternating-time temporal logics ATL andATL∗ with incomplete information is undecidable for perfect recall semantics. However, when restricting to memoryless strategies the model-checking problem becomes decidable. In this paper we consider two other types of semantics based on finite-memory strategies. One where the memory size allowed is bounded and one where the memory size is unbounded (but must be finite). This is moti vated by the high complexity of model-checking with perfect recall semantics and the sever e limitations of memoryless strategies. We show that both types of semantics introduced are differen t f om perfect recall and memoryless semantics and next focus on the decidability and complexity of model-checking in both complete and incomplete information games for ATL/ATL∗. In particular, we show that the complexity of model-checking with bounded-memory semantics is ∆ 2-complete forATL andPSPACE-complete for ATL∗ in incomplete information games just as in the memoryless ca e. We also present a proof thatATL andATL∗ model-checking is undecidable for n≥ 3 players with finite-memory semantics in incomplete information games.	alternating-time temporal logic;memory semantics (computing);model checking;undecidable problem	Steen Vester	2013		10.4204/EPTCS.119.17	discrete mathematics;mathematics;algorithm	Logic	-7.1362609522163	22.686898126743042	160934
4dd8d319da3b7639cdbcceb6be4d48c941b65a06	relating axiomatic and operational semantics of place/transition nets: from process terms to partial orders	operational semantics;partial order	Abstract   In this paper we define partial orders associated to process terms of place/transition nets. Further, we construct a set of partial orders from a given set of process terms. For place/transition nets without loops we prove the following result:  The set of minimal partial orders constructed from process terms is in a one-to-one correspondence with the set of minimal partial orders defined by processes of the given net.	operational semantics	Jörg Desel;Gabriel Juhás;Robert Lorenz	2003	Electr. Notes Theor. Comput. Sci.	10.1016/S1571-0661(04)80746-1	partially ordered set;combinatorics;discrete mathematics;computer science;complete partial order;mathematics;programming language;operational semantics;algorithm	Logic	-9.709446720869217	20.799200184303565	161538
a896e13c4ce3f78ff1c66568d4e41ab46a66ffbd	pushdown multi-agent system verification		In this paper we investigate the model-checking problem of pushdown multi-agent systems for ATL specifications. To this aim, we introduce pushdown game structures over which ATL formulas are interpreted. We show an algorithm that solves the addressed model-checking problem in 3EXPTIME. We also provide a 2EXPSPACE lower bound by showing a reduction from the word acceptance problem for deterministic Turing machines with doubly exponential space.	algorithm;model checking;multi-agent system;stack (abstract data type);time complexity;turing machine	Aniello Murano;Giuseppe Perelli	2015			deterministic context-free language;deterministic pushdown automaton;discrete mathematics;theoretical computer science;mathematics;pushdown automaton;embedded pushdown automaton;algorithm	AI	-6.711585093272046	23.451170725113137	161800
6a5cadac463118121a083fe4360887c42b4fee6a	familial monads and structural operational semantics		We propose a categorical framework for structural operational semantics, in which we prove that under suitable hypotheses bisimilarity is a congruence. We then refine the framework to prove soundness of bisimulation up to context, an efficient method for reducing the size of bisimulation relations. Finally, we demonstrate the flexibility of our approach by reproving known results in three variants of the π-calculus.		Tom Hirschowitz	2019	PACMPL	10.1145/3290334	theoretical computer science;programming language;computer science;operational semantics;monad (functional programming)	PL	-10.67749662189885	21.194680329479528	162511
5e381a46e050a1454eae9dfbeb0686acdef156cf	some results on parametric temporal logic	parametric specifications;temporal logic;formal methods;formal languages;specification language;formal method;decision procedure;linear temporal logic;specification languages;formal language	Parametric Temporal Logic extends linear temporal logic by allowing the temporal operators to additionally specify quantitative and parametric bounds on event occurrences. In this paper, we revisit and provide improved solutions to the four important problems of emptiness, universality, finiteness and construction considered in the literature for this logic.	linear logic;temporal logic;universality probability	Manoj G. Dixit;S. Ramesh;Pallab Dasgupta	2011	Inf. Process. Lett.	10.1016/j.ipl.2011.07.002	dynamic logic;formal language;discrete mathematics;linear temporal logic;description logic;formal methods;horn clause;object language;formal verification;interval temporal logic;computation tree logic;computer science;theoretical computer science;formal semantics;mathematics;signature;ontology language;programming language;multimodal logic;algorithm;language of temporal ordering specification;temporal logic of actions;autoepistemic logic	Vision	-11.761081051928636	22.720854538743016	162672
5171c707e3d38f29cf1f49aa387fd701239080b3	on the essence of parallel independence for the double-pushout and sesqui-pushout approaches		Parallel independence between transformation steps is a basic notion in the algebraic approaches to graph transformation, which is at the core of some static analysis techniques like Critical Pair Analysis. We propose a new categorical condition of parallel independence and show its equivalence with two other conditions proposed in the literature, for both left-linear and non-left-linear rules. Next we present some preliminary experimental results aimed at comparing the three conditions with respect to computational efficiency. To this aim, we implemented the three conditions, for left-linear rules only, in the Verigraph system, and used them to check parallel independence of pairs of overlapping redexes generated from some sample graph transformation systems over categories of typed graphs.		Andrea Corradini;Dominique Duval;Michael Löwe;Leila Ribeiro;Rodrigo Machado;Andrei Costa;Guilherme Grochau Azzi;Jonas Santos Bezerra;Leonardo Marques Rodrigues	2018		10.1007/978-3-319-75396-6_1	pushout;equivalence (measure theory);discrete mathematics;algebraic number;critical pair;categorical variable;static analysis;graph rewriting;graph;mathematics	Logic	-10.442391121613095	20.780269135893402	162721
305012484b13b46d32a4f279a398078e8c8cb251	undecidability of weak bisimulation equivalence for 1-counter processes	red petri;1 counter nets;bisimulation;1 counter machines;petri net;reseau petri	We show that checking weak bisimulation equivalence of 1-counter nets (Petri nets with only one unbounded place) is undecidable. This implies the undecidability of weak bisimulation equivalence for 1-counter machines. The undecidability result carries over to normed 1-counter nets/machines.	bisimulation;turing completeness;undecidable problem	Richard Mayr	2003		10.1007/3-540-45061-0_46	combinatorics;discrete mathematics;computer science;bisimulation;mathematics;programming language;petri net;algorithm	Logic	-5.752964686551248	21.681072927380157	163055
3d89fc31ff98744e1435ae01961adc81a7df116a	enriched µ-calculus pushdown module checking	decision problem;model checking;tree automata;open system;lower bound	The model checking problem for open systems (called module checking) has been intensively studied in the literature, both for finite–state and infinite–state systems. In this paper, we focus on pushdown module checking with respect to decidable fragments of the fully enriched μ–calculus. We recall that finite–state module checking with respect to fully enriched μ–calculus is undecidable and hence the extension of this problem to pushdown systems remains undecidable as well. On the contrary, for the fragments of the fully enriched μ–calculus we consider here, we show that pushdown module checking is decidable and solvable in double–exponential time in the size of the formula and in exponential time in the size of the system. This result is obtained by exploiting a classical automata–theoretic approach via pushdown nondeterministic parity tree automata. In particular, we reduce in exponential time our problem to the emptiness problem for these automata, which is known to be decidable in Exptime. As a key step of our algorithm, we show an exponential improvement of the construction of a nondeterministic parity tree automaton accepting all models of a formula of the considered logic. This result, does not only allow our algorithm to match the known lower bound, but also to investigate decision problems related to the fragments of the enriched μ-calculus in a greatly simplified manner.	algorithm;decision problem;exptime;finite-state machine;modal μ-calculus;model checking;stack (abstract data type);tree automaton;undecidable problem	Alessandro Ferrante;Aniello Murano;Mimmo Parente	2007		10.1007/978-3-540-75560-9_32	model checking;computer science;decision problem;open system;upper and lower bounds;algorithm	Logic	-6.846770804227724	22.56871337512866	163068
b0d37eb3748f481d9f610da067f6fc81fe67b5ea	order structures for subclasses of generalised traces	professor maciej koutny;eprints newcastle university;open access;dr lukasz mikulski	Traces are equivalence classes of action sequences which can be represented by partial orders capturing the causality in the behaviour of a concurrent system. Generalised traces, on the other hand, are equivalence classes of step sequences. They are represented by order structures that can describe non-simultaneity and weak causality, phenomena which cannot be expressed by partial orders alone. In this paper, we provide a systematic classification of different subclasses of generalised traces in terms of the order structures representing them. We also show how the original trace model fits into the overall framework. © 2014 Newcastle University. Printed and published by Newcastle University, Computing Science, Claremont Tower, Claremont Road, Newcastle upon Tyne, NE1 7RU, England. Bibliographical details JANICKI, R., KLEIJN, J., KOUTNY, M., AND MIKULSKI, L. Order Structures for Subclasses of Generalised Traces [By] R. Janicki, J. Kleijn, M. Koutny and L. Mikulski Newcastle upon Tyne: Newcastle University: Computing Science, 2014. (Newcastle University, Computing Science, Technical Report Series, No. CS-TR-1437)	cs games;causality;computer science;concurrency (computer science);digital footprint;fits;operational semantics;silk road;trace (psycholinguistics);tower of hanoi;tracing (software);turing completeness	Ryszard Janicki;Jetty Kleijn;Maciej Koutny;Lukasz Mikulski	2015		10.1007/978-3-319-15579-1_54	combinatorics;mathematics;algorithm	Logic	-7.656725162935097	21.464130847027842	163651
3e6f890735b29774886bf92a42f1396a0a50a256	a theory of retractable and speculative contracts		Behavioral contracts are abstract descriptions of expected communication patterns followed by either clients or servers during their interaction. Behavioral contracts come naturally equipped with a notion of compliance: when a client and a server follow compliant contracts, their interaction is guaranteed to progress or successfully complete. We study two extensions of behavioral contracts, retractable contracts dealing with backtracking and speculative contracts dealing with speculative execution. We show that the two extensions give rise to the same notion of compliance. As a consequence, they also give rise to the same subcontract relation, which determines when one server can be replaced by another preserving compliance. Moreover, compliance and subcontract relation are both decidable in quadratic time. Finally, we study the relationship between retractable contracts and calculi for reversible computing.	speculative execution	Franco Barbanera;Ivan Lanese;Ugo de'Liguoro	2018	Sci. Comput. Program.	10.1016/j.scico.2018.06.005	backtracking;theoretical computer science;real-time computing;time complexity;speculative execution;decidability;server;computer science;reversible computing	Logic	-10.99575263443422	22.71040677442219	164297
48fce10490da797c30deb0123f9776d175f611d5	decision procedures for modal logics of actions, resources and concurrency. (procédures de décision pour des logiques modales d'actions, de ressources et de concurrence)		The concepts of action and resource are ubiquitous in computer science. The main characteristic of an action is to change the current state of the modeled system. An action may be the execution of an instruction in a program, the learning of a new fact, a concrete act of an autonomous agent, a spoken word or a planned task. The main characteristic of resources is to be divisible, for instance in order to be shared. Resources may be memory cells in a computer, performing agents, different meanings of a phrase, time intervals or access rights. Together, actions and resources often constitute the temporal and spatial dimensions of a modeled system. Consider for instance the instructions of a computer executed at memory cells or a set of cooperating agents. We observe that in these cases, an interesting modeling of concurrency arises from the combination of actions and resources: concurrent actions are actions performed simultaneously on disjoint parts of the available resources. Modal logics have been successful in modeling both concepts of actions and resources. The relational semantics of a unary modality is a binary relation which allows to access another state from the current state. Hence, unary modalities are convenient to model actions. Similarly, the relational semantics of a binary modality is a ternary relation which allows to access two states from the current state. By interpreting these two states as substates of the current state, binary modalities allow to divide states. Hence, binary modalities are convenient to model resources. In this thesis, we study modal logics used to reason about actions, resources and concurrency. Specifically, we analyze the decidability and complexity of the satisfiability problem of these logics. These problems consist in deciding whether a given formula can be true in any model. We provide decision procedures to prove the decidability and state the complexity of these problems. Namely, we study modal logics with a binary modality used to reason about resources. We are particularly interested in the associativity property of the binary modality. This property is desirable since the separation of resources is usually associative too. But the associativity of a binary modality generally makes the logic undecidable. We propose in this thesis to constrain the valuation of propositional variables to make modal logics with an associative binary modality decidable. The main part of the thesis is devoted to the study of variants of the Propositional Dynamic Logic (PDL). These logics features an infinite set of unary modalities representing actions, structured by some operators like sequential composition, iteration and non-deterministic choice. We first study branching time variants of PDL and prove that the satisfiability problems of these logics have the same complexity as the corresponding branching-time temporal logics. Then we thoroughly study extensions of PDL with an operator for parallel composition of actions called separating parallel composition and based on the semantics of binary modalities. This operator allows to reason about resources, in addition to actions. Moreover, the combination of actions and resources provides a convenient expression of concurrency. In particular, these logics can express situations of cooperation where some actions can be executed only in parallel with some other actions. Finally, our main contribution is to prove that the complexity of the satisfiability problem of a practically useful variant of PDL with separating parallel composition is the same as the satisfiability problem of plain PDL. Résumé Les concepts d’action et de ressource sont omniprésents en informatique. La caractéristique principale d’une action est de changer l’état actuel du système modélisé. Une action peut ainsi être l’exécution d’une instruction dans un programme, l’apprentissage d’un fait nouveau, l’acte concret d’un agent autonome, l’énoncé d’un mot ou encore une tâche planifiée. La caractéristique principale d’une ressource est de pouvoir être divisée, par exemple pour être partagée. Il peut s’agir des cases de la mémoire d’un ordinateur, d’un ensemble d’agents, des différent sens d’une expression, d’intervalles de temps ou de droits d’accès. Actions et ressources correspondent souvent aux dimensions temporelles et spatiales du système modélisé. C’est le cas par exemple de l’exécution d’une instruction sur une case de la mémoire ou d’un groupe d’agents qui coopèrent. Dans ces cas, il est possible de modéliser les actions parallèles comme étant des actions opérant sur des parties disjointes des ressources disponibles. Les logiques modales permettent de modéliser les concepts d’action et de ressource. La sémantique relationnelle d’une modalité unaire est une relation binaire permettant d’accéder à un nouvel état depuis l’état courant. Ainsi une modalité unaire correspond à une action. De même, la sémantique d’une modalité binaire est une relation ternaire permettant d’accéder à deux états. En considérant ces deux états comme des sous-états de l’état courant, une modalité binaire modélise la séparation de ressources. Dans cette thèse, nous étudions des logiques modales utilisées pour raisonner sur les actions, les ressources et la concurrence. Précisément, nous analysons la décidabilité et la complexité du problème de satisfaisabilité de ces logiques. Ces problèmes consistent à savoir si une formule donnée peut être vraie. Pour obtenir ces résultats de décidabilité et de complexité, nous proposons des procédures de décision. Ainsi, nous étudions les logiques modales avec des modalités binaires, utilisées notamment pour raisonner sur les ressources. Nous nous intéressons particulièrement à l’associativité. Alors qu’il est généralement souhaitable que la modalité binaire soit associative, puisque la séparation de ressources l’est, cette propriété rend la plupart des logiques indécidables. Nous proposons de contraindre la valuation des variables propositionnelles afin d’obtenir des logiques décidables ayant une modalité binaire associative. Mais la majeure partie de cette thèse est consacrée à des variantes de la logique dynamique propositionnelle (PDL). Cette logiques possède une infinité de modalités unaires structurée par des opérateurs comme la composition séquentielle, l’itération et le choix non déterministe. Nous étudions tout d’abord des variantes de PDL comparables aux logiques temporelle avec branchement. Nous montrons que les problèmes de satisfaisabilité de ces variantes ont la même complexité que ceux des logiques temporelles correspondantes. Nous étudions ensuite en détails des variantes de PDL ayant un opérateur de composition parallèle de programmes inspiré des logiques de ressources. Cet opérateur permet d’exprimer la séparation de ressources et une notion intéressante d’actions parallèle est obtenue par la combinaison des notions d’actions et de séparation. En particulier, il est possible de décrire dans ces logiques des situations de coopération dans lesquelles une action ne peut être exécutée que simultanément avec une autre. Enfin, la contribution principale de cette thèse est de montrer que, dans certains cas intéressants en pratique, le problème de satisfaisabilité de ces logiques a la même complexité que PDL.	autonomous agent;autonomous robot;bibliothèque de l'école des chartes;boolean satisfiability problem;computer science;concurrency (computer science);courant–friedrichs–lewy condition;decision problem;dynamic logic (modal logic);estdomains;iteration;kripke semantics;large eddy simulation;linear algebra;memory cell (binary);modal logic;modality (human–computer interaction);operator associativity;process calculus;propositional variable;secam;triple des;unary operation;undecidable problem;value (ethics);nouveau	Joseph Boudou	2016				Logic	-7.937641041118817	20.00414534738125	164541
86f2ac0883ed4338b5ec483d14fee22358e46285	coverability synthesis in parametric petri nets		We study Parametric Petri Nets (PPNs), i.e., Petri nets for which some arc weights can be parameters. In that setting, we address a problem of parameter synthesis, which consists in computing the exact set of values for the parameters such that a given marking is coverable in the instantiated net. Since the emptiness of that solution set is already undecidable for general PPNs, we address a special case where parameters are used only as input weights (preT-PPNs), and consequently for which the solution set is downward-closed. To this end, we invoke a result for the representation of upward closed set from Valk and Jantzen. To use this procedure, we show we need to decide universal coverability, that is decide if some marking is coverable for every possible values of the parameters. We therefore provide a proof of its ExpSpace-completeness, thus settling the previously open problem of its decidability. We also propose an adaptation of this reasoning to the case of parameters used only as output weights (postT-PPNs). In this case, the condition to use this procedure can be reduced to the decidability of the existential coverability, that is decide if there exists values of the parameters making a given marking coverable. This problem is known decidable but we provide here a cleaner proof, providing its ExpSpace-completeness, by reduction to ω-Petri Nets. 1998 ACM Subject Classification F.1.1 Models of Computation	computation;item unique identification;np-completeness;petri net;rüdiger valk;undecidable problem	Nicolas David;Claude Jard;Didier Lime;Olivier H. Roux	2017		10.4230/LIPIcs.CONCUR.2017.14	computer science;theoretical computer science;discrete mathematics;petri net;parametric statistics	Logic	-11.376269380427111	23.64936015790456	165361
0bc3395a0c2883ba26103d52edebb6643744aaaa	a robust specification theory for modal event-clock automata		In a series of recent work, we have introduced a general framework for quantitative reasoning in specification theories. The contribution of this paper is to show how this framework can be applied to yield a robust specification theory for timed specifications.	theory;timed automaton	Ulrich Fahrenberg;Axel Legay	2012		10.4204/EPTCS.87.2	quantum finite automata;automata theory	Logic	-11.574300013171175	22.55520629135791	166208
b33dbc4c1db582bd0f2c24a48bbf05eb4c02422f	a simple characterization of stuttering bisimulation	logica temporal;temporal logic;concurrent program;logical programming;program verification;ranking function;verificacion programa;programmation logique;state space;programa competidor;verification programme;programacion logica;logique temporelle;programme concurrent	"""Abs t r ac t . Showing equivalence of two systems at different levels of abstraction often entails mapping a single step in one system to a sequence of steps in the other, where the relevant state information does not change until the last step. In [BCG 88,dNV 90], bisimulations that take into account such """"stuttering"""" are formulated. These definitions are, however, difficult to use in proofs of bisimulation, as they often require one to exhibit a finite, but unbounded sequence of transitions to match a single transition; thus introducing a large number of proof obligations. We present an alternative formulation of bisimulation under stuttering, in terms of a ranking function over a well-founded set. It has the desirable property, shared with strong bisimulation [Mil 90], that it requires matching 8ingle transitions only, which considerably reduces the number of proof obligations. This makes proofs of bisimulation short, and easier to demonstrate and understand. We show that the new formulation is equivalent to the original one, and illustrate its use with non-trivial examples that have infinite state spaces and exhibit unbounded stuttering."""	bisimulation;principle of abstraction;ranking (information retrieval);turing completeness;unbounded nondeterminism	Kedar S. Namjoshi	1997		10.1007/BFb0058037	discrete mathematics;temporal logic;computer science;state space;artificial intelligence;mathematics;algorithm	Logic	-9.737130132241017	22.207167030687433	166557
c0d9b88f28abc0a7f545d4374633ae6f018df95f	a flattening approach for attributed type graphs with inheritance in algebraic graph transformation		The algebraic graph transformation approach was initiated in 1973 and supports the rule-based modification of graphs based on pushout constructions. The vertex and edge types used within the rules (or productions) as well as possible inheritance relationships defined between them are specified in the type graph. However, the termination proof can only be accomplished for graph transformation systems without inheritance relationships. Thus, all graph transformation systems with inheritance relationships in the type graph must be flattened. To this end, the algebraic graph transformation approach provides a formal description for how to flatten the type graph as well as a definition of abstract and concrete productions. In this paper, we will extend the definitions to also consider vertices in negative application conditions with finer node types and positive application conditions. Furthermore, we will prove the semantic equivalence of the original and the flattened graph transformation system. The whole flattening algorithm is then implemented in a prototype which supports an abstract or concrete flattening of a given graph transformation system. The prototype is finally evaluated within a case study.	algorithm;graph rewriting;linear algebra;logic programming;prototype;termination analysis;turing completeness	Christine Natschläger;Klaus-Dieter Schewe	2012	ECEASST	10.14279/tuj.eceasst.47.716	graph power;null graph;graph property;regular graph;clique-width;distance-regular graph;simplex graph;cubic graph;symmetric graph;voltage graph;distance-hereditary graph;graph;butterfly graph;quartic graph;complement graph;line graph;string graph;strength of a graph;coxeter graph;graph rewriting	PL	-10.04573107535115	19.411330592885058	167179
8b8c813d2bdcaa18d3b955cd5430c53f56f398b3	modeling non-iterated system behavior with chu spaces	system behavior modeling;key-words:;concurrency;n-type dependencies;chu spaces;behavior modeling	We present an algorithm for generating Chu space models of the behaviors of arbitrarily complex non-iterated systems including those with N-type dependencies. The generated Chu space can be used for verification of system properties. The application of the model generation algorithm is illustrated with a few examples. Key-Words: concurrency, Chu spaces, system behavior modeling, N-type dependencies	algorithm;behavior model;concurrency (computer science);iterated function;iteration;spaces	Lubomir Ivanov	2008			iterated function;discrete mathematics;concurrency;chu space;mathematics	Logic	-9.011487986647921	23.168415398319787	167197
0a92c4c30a0a6ea83e97cbaa944d61345c66b2eb	preservation of dynamic behaviours in a hierarchical event structure		Event structure is a method of modelling and verification for concurrent system, and action refinement is the core operation in event structure. This paper researches on what conditions action refinement must satisfy, such that some structural properties and dynamic properties of contour model, such as connectivity, liveness, fairness and regression, can also be preserved in its detailed model. In researching on the dynamic properties of event structure, it is difficult to apply event structure model to represent infinite events, this is because each action can be executed infinite times, thus it will produce infinite events. There has been little research on the problem. Therefore, we propose the concept of action structure model. The differences between the action structure model and event structure model include: (1)The events in event structure model are replaced by actions, and the same actions are merged into one action; (2) The inheritance of causality and the inheritance of conflict relation are no longer preserved; (3) When an action is executed even times, it will not appear in the configuration; and when an action is executed odd times, it will appear in the configuration. The use of action structure model can easily solve the difficult problem of representation of infinite events which encountered in the event structure model. This paper gives an example to demonstrate the application of action structure model.	causality;concurrency (computer science);fairness measure;information processing;liveness;modeling language;refinement (computing)	Weidong Tang;Jinzhao Wu;Meiling Liu	2016	JSW	10.17706/jsw.11.8.712-732	computer science;distributed computing;machine learning;artificial intelligence;event structure	AI	-9.571314980155803	23.957808454601416	167807
4dbe15219603d054af5080ec4c751e9fb1ee2fa2	a framework to synergize partial order reduction with state interpolation		We address the problem of reasoning about interleavings in safety verification of concurrent programs. In the literature, there are two prominent techniques for pruning the search space. First, there are wellinvestigated trace-based methods, collectively known as “Partial Order Reduction (POR)”, which operate by weakening the concept of a trace by abstracting the total order of its transitions into a partial order. Second, there is state-based interpolation where a collection of formulas can be generalized by taking into account the property to be verified. Our main contribution is a framework that synergistically combines POR with state interpolation so that the sum is more than its parts.	interpolation;partial order reduction;search algorithm;synergy	Duc-Hiep Chu;Joxan Jaffar	2014		10.1007/978-3-319-13338-6_14	mathematical optimization;discrete mathematics;artificial intelligence;mathematics;algorithm	Logic	-11.417806746109987	22.724092991543777	167815
09f377bd03ccb255054e00c3badb006b9f8156c7	transition systems, metric spaces and ready sets in the semantics of uniform concurrency	metric space;transition systems	Abstract   Transition systems as proposed by Hennessy and Plotkin are defined for a series of three languages featuring concurrency. The first has shuffle and local nondeterminacy, the second synchronization merge and local nondeterminacy, and the third synchronization merge and global nondeterminacy. The languages are all uniform in the sense that the elementary actions are uninterpreted. Throughout, infinite behaviour is taken into account and modelled with infinitary languages in the sense of Nivat. A comparison with denotational semantics is provided. For the first two languages, a linear time model suffices; for the third language a branching time model with processes in the sense of de Bakker and Zucker is described. In the comparison an important role is played by an intermediate semantics in the style of Hoare and Olderog's specification oriented semantics. A variant on the notion of ready set is employed here. Precise statements are given relating the various semantics terms of a number of abstraction operators.	denotational semantics;spaces	J. W. de Bakker;John-Jules Ch. Meyer;Ernst-Rüdiger Olderog;Jeffery I. Zucker	1988	J. Comput. Syst. Sci.	10.1016/0022-0000(88)90026-8	combinatorics;discrete mathematics;metric space;computer science;theoretical computer science;mathematics;programming language;operational semantics;denotational semantics;algorithm	Theory	-11.038830226857016	20.00945177273938	168373
7ccb0032f92d1c8ca8424efbe215d11e83f67add	alternative developments of cyclic-permutation algorithms	systeme cyclique;programmation;algorithm analysis;program derivation;sistema informatico;program transformation;computer system;cyclic system;transformation programme;tableau;permutation;programacion;transformacion programa;permutacion;sistema ciclico;array;analyse algorithme;systeme informatique;programming;analisis algoritmo	Whaley, T., Alternative developments of cyclic-permutation algorithms, Information Processing Letters 41 (1992) 239-241. Feijen, van Gasteren, and Gries (1987) give a formal development of an algorithm to invert a cyclic permutation stored in an array, and Xue and Gries (1988) give such a development for an algorithm to cube a cyclic permutation. These derivations are first done with an alternative representation of the permutation; then a coordinate transformation is used to express the algorithm in terms of the array representation. Here, we develop the algorithms in terms of the original array, using the standard strategies Keyword: Program derivation 1. Cubing a cyclic permutation We adopt the context of Xue and Gries [5]. P is a cyclic permutation and Ii’ is an array containing P. The problem is to develop a constant-space algorithm with precondition Q and postcondition R given by	algorithm;array data structure;cyclic permutation;david gries;formal methods;information processing letters;postcondition;precondition;program derivation	Tom Whaley	1992	Inf. Process. Lett.	10.1016/0020-0190(92)90166-S	programming;computer science;calculus;permutation graph;mathematics;permutation;bit-reversal permutation;programming language;program derivation;algorithm	DB	-5.837297330143174	20.263934322621	168402
f6d2310937c102c8bf560ef146a5e898c6a2d2bc	an abstract machine theory for formal language parsers	information system;operating system;data structure;communication network;information theory	The usual data necessary for any abstract machine theory is given in categorical terminology. In these terms, an abstract machine theory for formal language parsers is developed, exposing the essential nature of any left-to-right parsing scheme. A weak classification of all parsers for a given language is developed and the usual notions of initial machine, reachable machine and minimal machine apply. Minimality is an extremely weak notion in this theory, although it is equivalent to a simple form of immediate error detection for parsers. Remarks on the construction of parsing procedures are given.	abstract machine;formal language;parsing	David B. Benson	1974		10.1007/3-540-07142-3_68	natural language processing;formal language;error detection and correction;top-down parsing language;computer science;abstract machine;formal grammar;programming language;algorithm;lr parser	NLP	-6.2409041654286	20.807468522298873	168830
0e143ab3e86da4d9642d9a412aeaa1e495ea49ad	decidable integration graphs	graph theory;equation differentielle;teoria grafo;reachability;right hand side;computer model;continuous variable;differential equation;finitary timed automaton;integration graph;theorie graphe;constant slope hybrid system;ecuacion diferencial;fta;cshs;right handed;automate hybride lineaire;asequibilidad;hybrid system;atteignabilite;linear hybrid automaton;decidibilidad;decidabilite;decidability;graphe integration	Integration graphs are a computational model developed in the attempt to identify simple hybrid systems with decidable analysis problems. We start with the class of constant slope hybrid systems (CSHS), in which the right-hand side of all differential equations is an integer constant. We refer to continuous variables whose right-hand side constants are always 1 as timers. All other continuous variables are called integrators. The first result shown in the paper is that simple questions such as reachability of a given state are undecidable for even this simple class of systems. To restrict the model even further, we impose the requirement that no test that refers to integrators may appear within a loop in the graph. This restricted class of CSHS is called integration graphs. The main results of the paper are that the reachability problem of integration graphs is decidable for two special cases: the case of a single timer and the case of a single test involving integrators. The expressive power of the integration-graphs formalism is demonstrated by showing that some typical problems studied within the context of the calculus of durations and timed statecharts can be formulated as reachability problems for restricted integration graphs, and a high fraction of these fall into the subclasses of a single timer or a single test involving integrators. 1999 Academic Press Article ID inco.1998.2774, available online at http: www.idealibrary.com on	computational model;hybrid system;hypertext transfer protocol;id-wsf;reachability problem;semantics (computer science);timer;undecidable problem	Yonit Kesten;Amir Pnueli;Joseph Sifakis;Sergio Yovine	1999	Inf. Comput.	10.1006/inco.1998.2774	decidability;combinatorics;discrete mathematics;computer science;graph theory;mathematics;reachability;differential equation;algorithm;hybrid system;algebra	Theory	-5.227904751331138	22.222351389396042	169417
bd0f311075e3f1f73ea9dc21c57b53030e08e210	on p-transitive graphs and applications	model checking;polynomial time;logic in computer science;transitive graph	We introduce a new class of graphs which we call P-transitive graphs, lying between transitive and 3-transitive graphs. First we show that the analogue of de Jo ngh-Sambin Theorem is false for wellfoundedP-transitive graphs; then we show that the μ-calculus fixpoint hierarchy is infinite for Ptransitive graphs. Both results contrast with the case of tr ansitive graphs. We give also an undecidability result for an enrichedμ-calculus onP-transitive graphs. Finally, we consider a polynomial time reduction from the model checking problem on arbitrary graphs to the model checking problem onP-transitive graphs. All these results carry over to 3-trans itive graphs.	bisimulation;first-order logic;fixed point (mathematics);modal logic;model checking;ork;polynomial;polynomial-time reduction;random graph;strongly connected component;theory;transitive closure;undecidable problem	Giacomo Lenzi	2011		10.4204/EPTCS.54.16	strong perfect graph theorem;1-planar graph;time complexity;model checking;pathwidth;combinatorics;discrete mathematics;robertson–seymour theorem;cograph;graph product;longest path problem;dense graph;computer science;clique problem;metric dimension;lévy family of graphs;clique-sum;trapezoid graph;mathematics;odd graph;maximal independent set;modular decomposition;treewidth;partial k-tree;chordal graph;indifference graph;algorithm;algebra	Theory	-5.194253283592851	20.975474213773197	170441
02d30b0fc0adb79491556b747fffb4a6719b1db1	an axiomatisation of duplication equivalence in the petri box calculus	proceso secuencial comunicante;modelizacion;semantica operacional;semantica denotacional;red petri;communicating sequential process;operational semantics;modelisation;semantique operationnelle;processus sequentiel communicant;concurrent systems;algebra proceso;denotational semantics;algebre processus;process algebra;petri net;modeling;structural similarity;semantique denotationnelle;reseau petri	The Petri Box Calculus (PBC) consists of an algebra of box expressions, and a corresponding algebra of boxes (a class of labelled Petri nets). A compositional semantics provides a translation from box expressions to boxes. There are several alternative ways of defining an equivalence notion for boxes, the strongest one being net isomorphism. In this paper we consider slightly weaker notion of equivalence, called duplication equivalence, which still can be argued to capture a very close structural similarity of concurrent systems represented by boxes. We transfer the notion of duplication equivalence to the domain of box expressions and investigate the relationship between duplication equivalent boxes and box expressions. The main result of this investigation is a sound and complete axiomatisation of duplication equivalence for a fragment of recursion-free PBC.	axiomatic system;petri net;turing completeness	Martin Hesketh;Maciej Koutny	1998		10.1007/3-540-69108-1_10	combinatorics;process calculus;discrete mathematics;systems modeling;computer science;structural similarity;mathematics;programming language;operational semantics;petri net;denotational semantics;algorithm	Logic	-8.753031513050278	21.5704172465509	170610
60f45c0861bef497fbd3eaa645e4e83d97313200	security protocols: from linear to classical logic by abstract interpretation	logique lineaire;procesamiento informacion;algorithm analysis;multiensemble;cryptographic protocols;metodo formal;logique classique;methode formelle;horn clauses;formal methods;cryptographic protocol;interpretacion abstracta;logica lineal;formal method;protocole cryptographique;informatique theorique;reecriture;information processing;clause horn;analyse algorithme;classical logic;interpretation abstraite;rewriting;abstract interpretation;traitement information;linear logic;logique horn;analisis algoritmo;reescritura;security protocol;computer theory;protocole securite;informatica teorica	We relate two models of security protocols, namely the linear logic or multiset rewriting model, and the classical logic, Horn clause representation of protocols. More specifically, we show that the latter model is an abstraction of the former, in which the number of repetitions of each fact is forgotten. This result formally characterizes the approximations made by the classical logic model.	abstract interpretation	Bruno Blanchet	2005	Inf. Process. Lett.	10.1016/j.ipl.2005.05.011	predicate logic;dynamic logic;abstract model theory;discrete mathematics;classical logic;linear temporal logic;description logic;formal methods;higher-order logic;horn clause;many-valued logic;intuitionistic logic;computer science;intermediate logic;cryptographic protocol;mathematics;minimal logic;programming language;substructural logic;multimodal logic;algorithm	Logic	-7.735151770918341	20.57449842128162	170713
ac16d080dce3c0c53fad4f0757b30d6cd54da4ef	refinement of actions for real-time concurrent systems with causal ambiguity	systeme temps reel;hierarchical system;concurrent;partial order semantics;concepcion sistema;comportement systeme;bisimulacion;real time;branching;temps lineaire;systeme hierarchise;bisimulation;ordre partiel;tiempo lineal;congruencia;sistema jerarquizado;semantique ordre partiel;concurrent systems;simultaneo;system design;informatique theorique;ramificacion;linear time;systeme concurrent;ramification;simultane;real time system;equivalence bisimulation;sistema tiempo real;hierarchical design;structure evenement;bisimulation equivalence;conception systeme;event structures;congruence;computer theory;informatica teorica	Refinement of actions is a core operation in the hierarchical design methodology for concurrent systems. In this paper, we develop an approach of action refinement for concurrent systems with not only the notation of real-time but also with causal ambiguity, which often exists and appears in real application areas. The systems are modeled in terms of a timed extension of bundle event structures with causal ambiguity. Under a certain partial order semantics, the behavior of the refined system can be inferred compositionally from the behavior of the original system and from the behavior of the systems used to refine actions with explicitly represented start points. A variant of a linear-time equivalence termed pomset trace equivalence and a variant of a branching-time equivalence termed history preserving bisimulation equivalence based on the partial order semantics are both congruences under the refinement. The refinement operation behaves thus well and meets the commonly expected properties.	bisimulation;causal filter;concurrency (computer science);real-time locating system;refinement (computing);time complexity;turing completeness	Mila E. Majster-Cederbaum;Jinzhao Wu;Houguang Yue	2005	Acta Informatica	10.1007/s00236-005-0172-4	time complexity;discrete mathematics;real-time operating system;branching;computer science;bisimulation;congruence;mathematics;ramification;hierarchical control system;algorithm;systems design	Logic	-8.697021716939432	23.81698993176334	170797
bff63728be985cd59fa7d926ee95590081fbd375	proving nets correct via cause-effect structures (an experiment)	specification;correctness;cause effect structures;petri nets;petri net;model theory	Proving safety and liveness of parallel systems is of unquestionable importance in system construction activity. A proof method for systems represented by nets (cause-effect structures and Petri nets) is proposed. Its outline is the following. (1) Let a problem specification as a formal theory i.e. a language system with specific relation symbols (operations, in particular), axioms and first-order inference rules be given. For each symbol introduce a class of atomic c-e structures (counterpart of Petri net transitions) to be the symbol's operational representative. (2) Using algebraic calculus of cause-effect structures, construct - from the atoms - a c-e structure and equivalent net intended to behave in accordance with the axioms (a mechanical step); (3) From the cause-effect structure just constructed, infer an algebraic structure and prove it to be a model (in terms of model theory) of the axiomatic system specifying the problem.		Ludwik Czaja	2003	Fundam. Inform.		combinatorics;discrete mathematics;stochastic petri net;computer science;mathematics;process architecture;programming language;petri net;algorithm;algebra	Logic	-9.844968132315767	21.564586224913658	170811
1604bdf9a49a98a39218f909ee766a913c7a4721	graph invariants as necessary conditions for global constraints	graph theory;programmation logique avec contrainte;base donnee;teoria grafo;condicion necesaria;base donnee graphe invariant;prolog;representation basee graphe;database;programacion logica con restriccion;base dato;global constraint;theorie graphe;necessary condition;contrainte globale;constraint logic programming;condition necessaire	This report presents a database of about graph invariants for deriving systematically necessary conditions from the graph properties based representation of global constraints. This scheme is based on invariants on the graph characteristics used in the description of a global constraint. A SICStus Prolog implementation based on arithmetic and logical constraints as well as on indexicals is available.	algorithm;automaton;computation;experiment;graph property;invariant (computer science);sicstus prolog;scott continuity	Nicolas Beldiceanu;Mats Carlsson;Jean-Xavier Rampon;Charlotte Truchet	2005		10.1007/11564751_10	constraint logic programming;combinatorics;extremal graph theory;discrete mathematics;topology;null graph;graph property;computer science;constraint graph;clique-width;graph theory;algebraic graph theory;mathematics;voltage graph;graph;programming language;prolog;intersection graph	DB	-5.080751112458067	20.498838405919205	170854
ac9d10f3fffb9e6c7af6c134d84cc80c2ce08ca0	ccs + time = an interleaving model for real time systems	real time;time delay;real time systems	This paper shows how to put time into Milner’s CCS to model real time systems. In particular, we will develop an expansion theorem for real time concurrency, which is an extension of the expansion theorem of CCS. The essential step made in this work is that a more general form of action prefix, @t:P is introduced, where t is a time variable. Intuitively, @t:P is an agent which may perform and become P [d=t] in doing so, where t is replaced by d, the time delay before is actually performed. The original form :P of action prefix of CCS is just a simple case of @t:P when t does not occur free in P P does not depend on the time at which is performed.	broadcast delay;calculus of communicating systems;concurrency (computer science);forward error correction;intelligent agent	Wang Yi	1991		10.1007/3-540-54233-7_136	computer science	Theory	-10.947374102972864	25.14326525433952	170953
7908abc1ac40f32e0fc051fa7aaff9c27291ed1c	verifying balanced trees	satisfiability;search trees;first order;presburger arithmetic;data structure	Balanced search trees provide guaranteed worst-case time performance and hence they form a very important class of data structures. However, the self-balancing ability comes at a price; balanced trees are more complex than their unbalanced counterparts both in terms of data structure themselves and related manipulation operations. In this paper we present a framework to model balanced trees in decidable first-order theories of term algebras with Presburger arithmetic. In this framework, a theory of term algebras (i.e., a theory of finite trees) is extended with Presburger arithmetic and with certain connecting functions that map terms (trees) to integers. Our framework is flexible in the sense that we can obtain a variety of decidable theories by tuning the connecting functions. By adding maximal path and minimal path functions, we obtain a theory of red-black trees in which the transition relation of tree self-balancing (rotation) operations is expressible. We then show how to reduce the verification problem of the red-black tree algorithm to constraint satisfiability problems in the extended theory.	algorithm;best, worst and average case;data structure;decision problem;first-order logic;first-order predicate;list of algorithms;maximal set;performance tuning;presburger arithmetic;red–black tree;self-balancing binary search tree;theory;unbalanced circuit;undecidable problem	Zohar Manna;Henny B. Sipma;Ting Zhang	2007		10.1007/978-3-540-72734-7_26	combinatorics;discrete mathematics;data structure;computer science;presburger arithmetic;first-order logic;mathematics;weight-balanced tree;ternary search tree;programming language;algorithm;algebra;satisfiability	Logic	-5.418320895188294	20.244884877752376	171160
697619101a0a289633c4e71489275c378e5b2f25	on observational equivalence and algebraic specification	algebraic specification;observational equivalence	The properties of a simple and natural notion of observational equivalence of algebras and the corresponding specification-building operation are studied. We begin with a defmition of observational equivalence which is adequate to handle reachable algebras only, and show how to extend it to cope with unreachable algebras and also how it may be generalised to make sense under an arbitrary institution. Behavioural equivalence is treated as an important special case of observational equivalence, and its central role in program development is shown by means of an example.	algebraic specification;observational equivalence;turing completeness	Donald Sannella;Andrzej Tarlecki	1987	J. Comput. Syst. Sci.	10.1016/0022-0000(87)90023-7	logical equivalence;equivalence;combinatorics;discrete mathematics;adequate equivalence relation;computer science;mathematics;equivalence relation	Theory	-11.422993229764415	18.892913924968777	171953
60255a70c8c4175885a8b955edf1a023464579f6	time bounded rewrite systems and termination proofs by generalized embedding	term rewrite system;rewrite systems	It is shown that term rewriting systems with primitive recursively bounded derivation heights can be simulated by rewriting systems that have termination proofs using generalized embedding, a very restricted class of simplification orderings. As a corollary we obtain a characterization of the class of relations computable by rewrite systems having primitive recursively bounded derivation heights using recent results on termination proofs by multiset path orderings.		Dieter Hofbauer	1991		10.1007/3-540-53904-2_86	discrete mathematics;computer science;theoretical computer science;normalization property;mathematics;algorithm;rippling	Logic	-4.613359304962875	20.64266831423484	173059
7b9f461a90b75ba764cd1aae3c4b14a8a15d6107	some results on the pi-calculus		The z-calculus [MPW1,2] is a calculus of mobile processes in which one can naturally express systems which have changing structure. [MPWl] contains an introduction to the calculus through a sequence of examples, while in [MPW2] the algebraic theory of the calculus is developed. The present paper contains two further contributions to the theory. The first is a modal characterization of the relation of strong ground bisimilarity on agents of the z-cMculus. This result is analogous to the well-known modal characterization of bisimilarity on labelled transition systems [HM]. The second contribution concerns the expressive power of the z-calculus. In [MPW1] this power is illustrated through discussion of the encoding of the passing of processes as parameters, of combinator graph reduction and the A-calculus, and of data values and data structures. Here we use the encodings of data values and data structures to encode a version of CCS with value passing in the z-calculus, and establish certain properties of the translation, principal among them being that the translation induces a simulation of an agent by its translation, and that a converse simulation obtains for translations of a restricted class of 'type-safe' agents.	bisimulation;data structure;encode;graph reduction;left 4 dead 2;linear algebra;mobile agent;modal logic;simulation;type safety;whole earth 'lectronic link;π-calculus	David Walker	1989		10.1007/3-540-53932-8_42	discrete mathematics;computer science;pi	Logic	-11.155556405761553	18.89490875762495	173249
075374e8a86bf018ccde012a2e6a228fcef02848	census techniques collapse space classes	complexite calcul;prise decision;theorem proving;demonstration theoreme;complejidad computacion;computational complexity;demostracion teorema;toma decision	Recent results have focused the attention of research in structural complexity theory to the development and applications of census techniques. In this paper we will develop several new techniques with which we can show the equality of SPACE(s) NTIME(t)  classes in the sense of Ladner and Lynch (1976) to known classes		Edith Hemaspaandra	1994	Inf. Process. Lett.	10.1016/0020-0190(94)00059-X	computer science;pure mathematics;mathematics;automated theorem proving;computational complexity theory;algorithm	DB	-6.3489656842295785	19.33484309728496	173322
e874555d7733049e7a14e34170dbdb571dfd5215	first-order aspects of tree paths	tree paths;postprint article;first order logic	Tree paths are investigated using first-order logic. The following results are obtained: (i) every definable path can be defined by a firstorder formula using at most one parameter chosen from the path itself; (ii) a canonical representation of the formulas that define definable paths is obtained; and (iii) every tree that has only finitely many paths that are not definable is n-equivalent to a tree of which all paths are definable. Moreover, a certain property that might be expected to hold, involving the transfer of n-equivalence between trees, is shown not to be true.	first-order logic;first-order predicate;turing completeness	Ruaan Kellerman	2015	Logic Journal of the IGPL	10.1093/jigpal/jzv026	computer science;theoretical computer science;machine learning;first-order logic;mathematics;tree;programming language;tree traversal;algorithm	Logic	-5.6797698465984885	20.041342657474015	173635
077bd3d795b618f5b321b5719612a16ffc2233d6	bounded synthesis of register transducers		Reactive synthesis aims at automatic construction of systems from their behavioural specifications. The research mostly focuses on synthesis of systems dealing with Boolean signals. But real-life systems are often described using bit-vectors, integers, etc. Bit-blasting would make such systems unreadable, hit synthesis scalability, and is not possible for infinite data-domains. One step closer to real-life systems are register transducers [12]: they can store data-input into registers and later output the content of a register, but they do not directly depend on the datainput, only on its comparison with the registers. Previously [6] it was proven that synthesis of register transducers from register automata is undecidable, but there the authors considered transducers equipped with the unbounded queue of registers. First, we prove the problem becomes decidable if bound the number of registers in transducers, by reducing the problem to standard synthesis of Boolean systems. Second, we show how to use quantified temporal logic, instead of automata, for specifications.	automata theory;automaton;finite-state machine;orna berry;parity bit;real life;rewriting;scalability;temporal logic;transducer;undecidable problem	Ayrat Khalimov;Benedikt Maderbacher;Roderick Bloem	2018		10.1007/978-3-030-01090-4_29	discrete mathematics;theoretical computer science;scalability;undecidable problem;bounded function;decidability;mathematics;temporal logic;transducer;integer;queue	Logic	-11.141226038813324	24.488620625714713	174162
15a8749a48ce97ee2fbbb757d3bc1d1fed371e9d	ctl-like fragments of a temporal logic of robustness	pair roctl;transient failure;robustness temporal logic;ctl;complexity theory;branching time temporal logic;temporal logic;computability;logic;semantics;roctl ctl robustness logic state roctl pair roctl;satisfiability;strontium;temporal logic computability;cost accounting;data packet loss;decision procedure;syntactics;robustness;logic roctl;satisfiability preserving translation logic roctl robustness temporal logic branching time temporal logic transient failure data packet loss state roctl pair roctl;robustness semantics complexity theory syntactics australia strontium cost accounting;roctl;state roctl;australia;satisfiability preserving translation	The logic RoCTL* is an extension of the branching time temporal logic CTL* to represent robustness of systems to transient failures such as loss of data packets. New operators are introduced dealing with obligation (where no failures occur) and robustness (where at most one additional failure occurs). The only known decision procedures for the temporal logic of robustness RoCTL* are non-elementary. Here we propose two CTL-like restrictions of RoCTL*, Pair-RoCTL and State-RoCTL. We investigate whether it is possible to translate these fragments into CTL showing whilst this is not in general possible for Pair-RoCTL it is for State-RoCTL. We obtain a satisfiability preserving translation for State-RoCTL into CTL showing that the complexity of satisfiability of State-RoCTL is EXPTIME-complete. We also show that these fragments of RoCTL* are useful in specifying systems.	ctl*;exptime;karp's 21 np-complete problems;network packet;robustness (computer science);temporal logic;while	John Christopher McCabe-Dansted;Clare Dixon	2010	2010 17th International Symposium on Temporal Representation and Reasoning	10.1109/TIME.2010.7	discrete mathematics;linear temporal logic;computation tree logic;theoretical computer science;mathematics;algorithm	Logic	-11.775953006120725	24.4762684055187	174307
26e7effcd7440a13610275a317dc430da995dc53	on control of systems modelled as deterministic rabin automata	supervisory control;system modelling;modal logic;decision procedure;finite automata;reactive system;control synthesis	Recent results on the control of infinite behaviour of finite automata are extended to allow Rabin acceptance conditions as modelling assumptions as well as specifications. The key result is a fixpoint characterization of the automaton'scontrollability subset—the set of states from which it can be controlled to the satisfaction of its associated specification. The fixpoint characterization allows for straightforward computation of the subset and for effective synthesis of controllers. the results have potential applications to supervisory control synthesis, the synthesis of reactive systems, and decision procedures for modal logics.	automata theory;ω-automaton	John G. Thistle	1995	Discrete Event Dynamic Systems	10.1007/BF01439153	modal logic;control engineering;discrete mathematics;reactive system;computer science;supervisory control;finite-state machine;algorithm	Logic	-9.876577364775953	24.46487133479581	174366
4346e52032c49582459b039e622eaf7405d71a74	linear-time model-checking for multithreaded programs under scope-bounding	datavetenskap datalogi;computer science	We address the model checking problem of omega-regular linear-time properties for shared memory concurrent programs modeled as multi-pushdown systems. We consider here boolean programs with a finite number of threads and recursive procedures. It is well-known that the model checking problem is undecidable for this class of programs. In this paper, we investigate the decidability and the complexity of this problem under the assumption of scope-boundedness defined recently by La Torre and Napoli in [24]. A computation is scope-bounded if each pair of call and return events of a procedure executed by some thread must be separated by a bounded number of context-switches of that thread. The concept of scope-bounding generalizes the one of contextbounding [31] since it allows an unbounded number of context switches. Moreover, while context-bounding is adequate for reasoning about safety properties, scope-bounding is more suitable for reasoning about liveness properties that must be checked over infinite computations. It has been shown in [24] that the reachability problem for multi-pushdown systems under scope-bounding is PSPACE-complete. We prove in this paper that model-checking linear-time properties under scope-bounding is also decidable and is EXPTIME-complete.	algorithm;automata theory;büchi automaton;chaitin's constant;computation;context switch;exptime;linear algebra;liveness;modal μ-calculus;model checking;network switch;pspace;pspace-complete;persistence (computer science);reachability problem;recursion;shared memory;stack (abstract data type);thread (computing);time complexity;undecidable problem	Mohamed Faouzi Atig;Ahmed Bouajjani;K. Narayan Kumar;Prakash Saivasan	2012		10.1007/978-3-642-33386-6_13	discrete mathematics;computer science;theoretical computer science;mathematics;programming language;algorithm	Logic	-11.778357551017134	24.30492683607806	174398
6ee05a1b5fd1b382cc4674a9fec12c625db65c81	an algebra-based method to associate rewards with empa terms	performance measure;ease of use;modal logic;algebra proceso;stochastic process algebra;informatique theorique;systeme concurrent;algebre processus;process algebra;computer theory;informatica teorica	We present a simple method to associate rewards with terms of the stochastic process algebra EMPA in order to make the specification and the computation of performance measures easier. The basic idea behind this method is to specify rewards within actions of EMPA terms, so it substantially differs from methods based on modal logic. The main motivations of this method are its ease of use as well as the possibility of defining a notion of equivalence which relates terms having the same reward, thus allowing for simplification without altering the performance index. We prove that such an equivalence is a congruence finer than the strong extended Markovian bisimulation equivalence, and we present its	algorithmic efficiency;bisimulation;computation;concurrency (computer science);congruence of squares;level of detail;modal logic;probabilistic turing machine;process calculus;programming tool;stochastic process;turing completeness;usability	Marco Bernardo	1997		10.1007/3-540-63165-8_192	modal logic;process calculus;discrete mathematics;usability;computer science;artificial intelligence;mathematics;programming language;algorithm	Logic	-8.199064590177189	21.979852641446197	174848
fb671b9b897de1713aa1e63821e5d32b916809d3	a formal model of non-determinate dataflow computation	electrical engineering and computer science;thesis	Almost ten years ago, Gilles Kahn used the fixed point theory of Dana Scott to define a formal and elegant model of computation for determinate dataflow graphs, networks of determinate processes communicating asynchronously through unbounded channels. Kahn viewed each process as a function mapping each tuple of streams, or sequences of values, received through its input channels to the tuple of streams produced at its output channels. Determinacy was defined as the requirement that the mapping be functional that for each input stream tuple there be only one possible output stream tuple. Although most useful computation can be accomplished with only determinate processes, there re many important, inherently non-determinate application areas to which Kahn's theory cannot be applied. In this thesis, a formal model of computation for non-determinate networks is presented in which each possible computation of a network is represented by a scenario. A scenario is a pair consisting of an input stream tuple and an output stream tuple, together with a causality order relating each element of the input and output streams to those elements which played a role in its creation. A non-determinate network is represented by a set of scenarios, just as a determinate network is represented by a set of pairs of input and output stream tuples. Scenario sets contain but a little more information than the most straightforward extension of Kahn's theory, the representation of graphs as relations on tuples of streams. We justify the addition of this causality information by demonstrating that the relational representation is inadequately detailed for describing non-determinate computation. A formal algebra for deriving the scenario set of a graph from the scenario sets of its components is also presented. Our scenario set composition rules are very simple. Only an elementary knowledge of partial orders is required in order to understand them. We prove the correctness of our model by showing its consistency with the standard operational model of dataflow computation. Thesis Supervisor: Jack B. Dennis Title: Professor of Computer Science and Engineering	actor model and process calculi;causality;computer engineering;computer science;correctness (computer science);dataflow;elementary;fixed point (mathematics);fixed-point theorem;formal language;graph (discrete mathematics);input/output;kahn process networks;model of computation;property (philosophy);reactive programming;stream (computing)	J. Dean Brock	1983			discrete mathematics;computer science;theoretical computer science;algorithm	DB	-11.695015061803419	21.08765301067692	174862
0ec08c2edbe2281f90d554d750aac4f8a382e532	behavioural equivalence, bisimulation, and minimal realisation	algebraic specification	This paper examines three important topics in computer science: behavioural equivalence, bisimulation, and minimal realisation of automata, and discusses the relationships that hold between them. Central to all three topics is a notion of equivalence of behaviour, and by taking a coalgebraic approach to algebraic speciications we show that bisimulation is`the same as' behavioural equivalence. Moreover, we show that a particular construction for minimal realisation of behaviour corresponds to a proof technique for proving behavioural equivalence. We also argue that it is useful to consider algebraic speciications of objects as having both algebraic and coalgebraic aspects.	algebraic equation;automata theory;bisimulation;computer science;game semantics;hoc (programming language);linear algebra;programming paradigm;software engineering;turing completeness	Grant Malcolm	1995		10.1007/3-540-61629-2_53	discrete mathematics	Logic	-10.792544861337847	19.413450100771048	175204
158520e7b613979d1fb6d6afe92ceb8084d3d1a6	on liveness and reversibility of equal-conflict petri nets		Weighted Petri nets provide convenient models of many man-made systems. Real applications are often required to possess the fundamental Petri net properties of liveness and reversibility, as liveness preserves all the functionalities (fireability of all transitions) of the system and reversibility lets the system return to its initial state (marking) using only internal operations. Characterizations of both behavioral properties, liveness and reversibility, are known for well-formed weighted Choice-Free and ordinary Free-Choice Petri nets, which are special cases of Equal-Conflict Petri nets. However, reversibility is not well understood for this larger class, where choices must share equivalent preconditions, although characterizations of liveness are known. In this paper, we provide the first characterization of reversibility for all live Equal-Conflict Petri nets by extending, in a weaker form, a known condition that applies to the Choice-Free and Free-Choice subclasses. We deduce the monotonicity of reversibility in the live Equal-Conflict class. We also give counter-examples for other classes where the characterization does not hold. Finally, we focus on well-formed Equal-Conflict Petri nets, for which we offer the first polynomial sufficient conditions for liveness and reversibility, contrasting with the previous exponential time conditions.	liveness;petri net	Thomas Hujsa;Jean-Marc Delosme;Alix Munier Kordon	2016	Fundam. Inform.	10.3233/FI-2016-1376	discrete mathematics;petri net;mathematics;monotonic function;polynomial;exponential function;liveness	Logic	-7.31950885758243	22.530768334463183	175318
fdc76a6e1c8b0d7f0f40eff44ad508b7a788536e	light logics and higher-order processes	polynomial time;programming language;higher order;process algebra;linear logic	We show that the techniques for resource control that have be en d veloped in the so-called “light logics” can be fruitfully applied also to process algebras. In particular, we present a restriction of Higher-Orderπ-calculus inspired by Soft Linear Logic. We prove that any so ft process terminates in polynomial time. We argue that the class of soft processes may be naturally enlarged so that interesting processes are expressible, still maintaining the polynomial bound on executions.	complexity class;functional programming;handy board;linear grammar;linear logic;maximal set;polynomial;process calculus;software bug;time complexity	Ugo Dal Lago;Simone Martini;Davide Sangiorgi	2016	Mathematical Structures in Computer Science	10.1017/S0960129514000310	discrete mathematics;pure mathematics;mathematics;algorithm	Logic	-10.60488202140321	22.145987624440433	176127
784642261a6b99c92e9489a25c6ed5e7b65344c3	coinductive models of finite computing agents	set theory	This paper explores the role of coinductive methods in modeling finite interactive compu agents. The computational extension of computing agents from algorithms to interaction paralle mathematical extension of set theory and algebra from inductive to coinductive models. Maximal points are shown to play a role in models of observation that parallels minimal fixed points in indu mathematics. The impact of interactive (coinductive) models on Church’s thesis and the conn between incompleteness and greater expressiveness are examined. A final section shows that ac ware systems are interactive rather than algorithmic. Coinductive models could become as impor inductive models for software technology as computer applications become increasingly interactive	algorithm;conn;coinduction;computer;fixed point (mathematics);inductive reasoning;maximal set;parallels desktop for mac;set theory;warez	Peter Wegner;Dina Q. Goldin	1999	Electr. Notes Theor. Comput. Sci.	10.1016/S1571-0661(05)80270-1	discrete mathematics;computer science;theoretical computer science;mathematics;algorithm;set theory	AI	-7.352515599156861	21.982953066195897	176707
d112d31e58603f4deeec6ded75adf1f0c270e4ff	fixed points of increasing functions	parallelisme;secuencial;relation ordre partiel;programmation;sequential;fixed point;programacion;sequentiel;parallelism;paralelismo;partial ordering;informatique theorique;relacion orden parcial;programming;computer theory;informatica teorica	If d and e are increasing functions in a partial order, then the fixed points on their functional composition are just the points that are fixed for both d and e. The same is true of a form of parallel composition (fx ∨ gx), using the least upper bound ∨ in the partial order. This fact may be useful in cases when fixed points are computed by iteration, with arbitrary mixture of sequential and parallel composition		C. A. R. Hoare	1990	Inf. Process. Lett.	10.1016/0020-0190(90)90087-E	partially ordered set;fixed-point iteration;programming;combinatorics;calculus;mathematics;fixed point;algorithm	DB	-6.038559267213143	21.334901947224694	176825
5040ef371764d6e9e66bde435dd2ce9baa3028c9	costs are expensive!	temporal logic;model checking;linear time;timed automata;hybrid automata	We study the model-checking problem for WMTL, a costextension of the linear-time timed temporal logic MTL, that is interpreted over weighted timed automata. We draw a complete picture of the decidability for that problem: it is decidable only for the class of one-clock weighted timed automata with a restricted stopwatch cost, and any slight extension of this model leads to undecidability. We finally give some consequences on the undecidability of linear hybrid automata.	automata theory;hybrid automaton;model checking;temporal logic;time complexity;timed automaton;undecidable problem	Patricia Bouyer;Nicolas Markey	2007		10.1007/978-3-540-75454-1_6	time complexity;model checking;discrete mathematics;temporal logic;quantum finite automata;computer science;theoretical computer science;automata theory;mathematics;mobile automaton;timed automaton;algorithm	Logic	-10.221171361047023	23.948140263831302	176934
423b596aa642fa7ad43263ad3478b491268ee447	on the parallel complexity of model checking in the modal mu-calculus	modal mu calculus;synchronous alternating monotone fanout;liveness properties;concurrent computing;parallel constant time reduction;labeled transition system;labeled transition systems;logic;circuit value problem;model checking in the modal mu calculus;safety properties;polynomials;fixed point;datalog;model checking;concurrent systems;logic programming;parallel complexity;computational complexity;calculus;polynomial time reduction parallel complexity model checking modal mu calculus expressive logic liveness properties safety properties concurrent systems labeled transition systems model checking in the modal mu calculus propositional modal mu calculus circuit value problem synchronous alternating monotone fanout nc algorithms finite tree bounded fan out parallel constant time reduction datalog;finite tree;production facilities;polynomial time;bounded fan out;formal logic;circuits;marine safety;propositional modal mu calculus;computer science;computational complexity formal logic parallel processing logic programming;nc algorithms;polynomial time reduction;parallel processing;expressive logic;logic production facilities circuits concurrent computing calculus computer science marine safety polynomials	The modal mu-calculus is an expressive logic that can be used to specify safety and liveness properties of concurrent systems represented as labeled transition systems (LTSs). We show that Model Checking in the Modal Mu-Calculus (MCMMC) — the problem of checking whether an LTS is a model of a formula of the propositional modal mu-calculus — is P-complete even for a very restrictive version of the problem involving the alternationfree fragment. In particular, MCMMC is P-complete even if the formula is fixed and alternation-free, and the LTS is deterministic, acyclic, and has fan-in and fan-out bounded by 2. The reduction used is from a restricted version of the circuit value problem (Does a circuit α output a 1 on inputs x1, . . ., xn?) known as Synchronous Alternating Monotone Fanout 2 Circuit Value Problem. Our P-completeness result is tight in the sense that placing any further non-trivial restrictions on either the formula or the LTS results in membership in NC for MCMMC. Specifically, we exhibit efficient NC-algorithms for two potentially useful versions of the problem, both of which involve alternation-free formulas containing a constant number of fixed point operators: 1) the LTS is a finite tree with bounded fan-out; and 2) the formula is ∧-free and the LTS is deterministic and over an action alphabet of bounded size. In the course of deriving our algorithm for 2), we give a parallel constant-time reduction from the alternation-free modal mu-calculus to Datalog. We also provide a polynomialtime reduction in the other direction thereby establishing an interesting link between the two formalisms. We conclude by pointing out an open problem involving the parallel complexity of model checking in CTL. Coordinates of the corresponding author: ∗Research supported in part by NSF Grants CCR-9120995 and CCR-9208585, and AFOSR Grant F49620-93-	algorithm;circuit value problem;concurrency (computer science);datalog;directed acyclic graph;fan-in;fan-out;fixed point (mathematics);geographic coordinate system;ibm notes;liveness;modal logic;modal μ-calculus;model checking;p-complete;strong np-completeness;monotone	Shipei Zhang;Oleg Sokolsky;Scott A. Smolka	1994		10.1109/LICS.1994.316075	parallel processing;combinatorics;discrete mathematics;concurrent computing;computer science;mathematics;programming language;logic;algorithm	Logic	-6.544741483911741	21.675967057299854	177615
0e62896bb6f0d6593f4d2209d16baba4f3fa717a	boundedness of reset p/t nets	automaton complexity;complexite automate;red petri;transition system;systeme transition;informatique theorique;complejidad automata;decidibilidad;decidabilite;petri net;reseau petri;decidability;computer theory;informatica teorica	P/T nets with reset and transfer arcs can be seen as counter-machines with some restricted set of operations. Surprisingly, several problems related to boundedness are harder for Reset nets than for the more expressive Transfer nets. Our main result is that boundedness is undecidable for nets with three reset arcs, while it is decidable for nets with two resetable places.	petri net;undecidable problem	Catherine Dufourd;Petr Jancar;Philippe Schnoebelen	1999		10.1007/3-540-48523-6_27	decidability;discrete mathematics;computer science;theoretical computer science;mathematics;petri net;algorithm	Logic	-5.675681303334804	21.732034901976427	177756
1c1d398dbec31cb40d1989aea7809f730ab23dbb	a concurrency problem with exponential dpll(t) proofs		Many satisfiability modulo theories solvers implement a variant of the DPLL(T ) framework which separates theory-specific reasoning from reasoning on the propositional abstraction of the formula. Such solvers conclude that a formula is unsatisfiable once they have learned enough theory conflicts to derive a propositional contradiction. However some problems, such as the diamonds problem, require learning exponentially many conflicts. We give a general criterion for establishing lower bounds on the number of theory conflicts in any DPLL(T ) proof for a given problem. We apply our criterion to two different state-of-theart symbolic partial-order encodings of a simple, yet representative concurrency problem. Even though one of the encodings is asymptotically smaller than the other, we establish the same exponential lower bound proof complexity for both. Our experiments confirm this theoretical lower bound across multiple solvers and theory combinations.	concurrency (computer science);experiment;modulo operation;proof complexity;satisfiability modulo theories;solver;time complexity	Liana Hadarean;Alex Horn;Tim King	2015	CoRR		combinatorics;discrete mathematics;mathematics;algorithm	AI	-11.484302170647496	20.850075206054033	179725
c5224545053c7a214f73a786fd7fe3e3b81c5c6a	representation of a class of nondeterministic semiautomata by canonical words	canonical word;sistema infinito;automata no determinista;mot canonique;modulo;reecriture prefix;specification;trace assertion;affirmation trace;trace;equivalence;non deterministic automaton;semiautomate;settable;especificacion;rewriting systems;rewrite systems;informatique theorique;prefixe;prefix rewriting;nondeterministic;automate non deterministe;traza;semiautomaton;module;systeme infini;systeme reecriture;equivalencia;computer theory;infinite system;prefix continuous;informatica teorica	It has been shown recently that deterministic semiautomata can be represented by canonical words and equivalences; that work was motivated by the trace-assertion method for specifying software modules. Here we generalize these ideas to a class of nondeterministic semiautomata. A semiautomaton is settable if, for every state q, there exists a word wq such that q can be reached from some initial state by a path spelling wq, and no other state can be reached from an initial state by a path spelling wq. We extend many results from the deterministic case to settable nondeterministic semiautomata. Each word now has a number of canonical representatives. We show that a prefix-rewriting system exists for transforming any word to any of its representatives. In case the set of canonical words is prefix-continuous (meaning that, if a word w and a prefix u of w are in the set, then all prefixes of w longer than u are also in the set), the rewriting system has no infinite derivations. Examples of specifications of nondeterministic modules are given.	assertion (software development);rewriting;semiautomaton	Janusz A. Brzozowski	2006	Theor. Comput. Sci.	10.1016/j.tcs.2006.01.040	equivalence;module;combinatorics;discrete mathematics;theoretical computer science;trace;mathematics;programming language;specification;nondeterministic algorithm;algorithm;modulo;algebra	Logic	-5.48786594551166	21.605804239672416	180056
dcafbdadd75ab9a5ec106826b6bf880e6555f3b9	local bigraphs and confluence: two conjectures: (extended abstract)	pervasive computing;lambda calculus;locality;confluence;satisfiability;bigraph;reactive system;explicit substitution;work in progress	The notion of confluence is studied on the context of bigraphs. Confluence will be important in modelling real-world systems, both natural (as in biology) and artificial (as in pervasive computing). The paper uses bigraphs in which names have multiple locality; this enables a formulation of the lambda calculus with explicit substitutions. The paper reports work in progress, seeking conditions on a bigraphical reactive system that are sufficient to ensure confluence; the conditions must deal with the way that bigraphical redexes can be intricately intertwined. The conditions should also be satisfied by the lambda calculus. After discussion of these issues, two conjectures are put forward.	bigraph;church–rosser theorem;confluence;explicit substitution;lambda calculus;locality of reference;ubiquitous computing;world-system;yet another	Robin Milner	2007	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2006.07.035	discrete mathematics;bigraph;reactive system;computer science;work in process;lambda calculus;mathematics;programming language;confluence;algorithm;satisfiability	PL	-8.790097541975207	21.135574585456578	180208
150ffd504c4aeccbadad69f3dad9899ed6cea617	expressivity of time-varying graphs	theoretical computer science;computer science all	Time-varying graphs model in a natural way infrastructureless highly dynamic systems, such as wireless ad-hoc mobile networks, robotic swarms, vehicular networks, etc. In these systems, a path from a node to another might still exist over time, rendering computing possible, even though at no time the path exists in its entirety. Some of these systems allow waiting (i.e., provide the nodes with store-carry-forwardlike mechanisms such as local buffering) while others do not. In this paper, we focus on the structure of the time-varying graphs modelling these highly dynamical environments. We examine the complexity of these graphs, with respect to waiting, in terms of their expressivity; that is in terms of the language generated by the feasible journeys (i.e., the “paths over time”). We prove that the set of languages Lnowait when no waiting is allowed contains all computable languages. On the other end, using algebraic properties of quasi-orders, we prove that Lwait is just the family of regular languages, even if the presence of edges is controlled by some arbitrary function of the time. In other words, we prove that, when waiting is allowed, the power of the accepting automaton drops drastically from being as powerful as a Turing machine, to becoming that of a Finite-State machine. This large gap provides a measure of the impact of waiting. We also study bounded waiting; that is when waiting is allowed at a node for at most d time units. We prove that Lwait[d] = Lnowait; that is, the complexity of the accepting automaton decreases only if waiting is unbounded.	automaton;computable function;dynamical system;finite-state machine;hoc (programming language);linear algebra;peterson's algorithm;regular language;robot;turing machine	Arnaud Casteigts;Paola Flocchini;Emmanuel Godard;Nicola Santoro;Masafumi Yamashita	2013		10.1007/978-3-642-40164-0_12	combinatorics;computer science;theoretical computer science;mathematics;algorithm	Theory	-7.517290428553574	25.200383242830046	180576
6bf44c1fab8f1002778899e4367542485f79758f	completeness results for recursive data bases	base relacional dato;query language;langage ordre 1;language theory;first order language;teoria lenguaje;recursividad;relational database;equivalence;lenguaje interrogacion;isomorphism;isomorfismo;recursivite;logique ordre 1;base donnee relationnelle;completitud;langage interrogation;isomorphisme;completeness;completude;lenguaje orden 1;recursivity;equivalencia;first order logic;theorie langage;logica orden 1	We consider infinite recursive (i.e., computable) relational data bases. Since the set of computable queries on such data bases is not closed under even simple relational operations, one must either make do with a very modest class of queries or considerably restrict the class of allowed data bases. We define two query languages, one for each of these possibilities, and prove their completeness. The first is the language of quantifier-free first-order logic, which is shown to be complete for the non-restricted case. The second is an appropriately modified version of Chandra and Harel's language QL, which is proved complete for the case of “highly symmetric” data bases, i.e., ones whose set of automorphisms is of finite index for each tuple width. We also address the related notion of BP-completeness.	database;recursion (computer science)	Tirza Hirst;David Harel	1996	J. Comput. Syst. Sci.	10.1006/jcss.1996.0039	equivalence;recursion;combinatorics;discrete mathematics;completeness;relational database;computer science;philosophy of language;first-order logic;mathematics;isomorphism;algorithm;query language	DB	-7.275665589399484	18.515056331342247	181430
983d230b3368db892497c0cf8fe0a227d2717789	on the existence and decidability of unique decompositions of processes in the applied π-calculus	word problem;process calculus;weak bisimilarity;behavioral equivalence;cancellation;normal form;unique decomposition;strong bisimilarity;applied π calculus;behavioural equivalence;equational theory;decidability	Unique decomposition has been a subject of interest in process algebra for a long time (for example in BPP [1] or CCS [2, 3]), as it provides a normal form and useful cancellation properties. We provide two parallel decomposition results for subsets of the applied π-calculus: we show that every closed normed (i.e. with a finite shortest complete trace) process P can be decomposed uniquely into prime factors Pi with respect to strong labeled bisimilarity, i.e. such that P ∼l P1| . . . |Pn. Moreover, we prove that closed finite processes can be decomposed uniquely with respect to weak labeled bisimilarity. We also investigate whether efficient algorithms that compute the unique decompositions exist. The simpler problem of deciding whether a process is in its unique decomposition form is undecidable in general in both cases, due to potentially undecidable equational theories. Moreover, we show that the unique decomposition remains undecidable even given an equational theory with a decidable word problem.		Jannik Dreier;Cristian Ene;Pascal Lafourcade;Yassine Lakhnech	2016	Theor. Comput. Sci.	10.1016/j.tcs.2015.11.033	decidability;word problem;combinatorics;process calculus;discrete mathematics;computer science;mathematics;programming language;algorithm;algebra	Logic	-6.749273652842278	19.97247520760995	181688
60f41935ebb779775edbee7fe2bf06755d18f072	complexity of unification problems with associative-commutative operators	set matching;complexity;unit;polynomial time algorithm;unification;theorem prover;idempotent;word equations;matching;np complete;associative;equational theories;logic programs;commutative;term rewriting;identity;associative commutative	The unification problem for terms containing associative and commutative functions is of importance in theorem provers based on term rewriting and resolution methods as well as in logic programming. The complexity of determining whether two such terms are unifiable was known to be NP-hard. It is proved that the problem is NP-complete by describing a nondeterministic polynomial time algorithm for it. The case where the terms are linear and have no common variables is shown to be in P. The NP-completeness of other similar unification problems, in particular, when a function symbol is also idempotent and/or has a unit (identity), is also discussed. Finally, a table of the complexity of E-matching and E-unification problems is given.	algorithm;complexity;idempotence;logic programming;np (complexity);np-completeness;np-hardness;p (complexity);polynomial;rewriting;unification (computer science)	Deepak Kapur;Paliath Narendran	1992	Journal of Automated Reasoning	10.1007/BF00245463	matching;combinatorics;discrete mathematics;complexity;unit;np-complete;computer science;unification;associative property;mathematics;automated theorem proving;commutative property;idempotence;algebra	Theory	-6.460795073248628	18.514833727152062	181802
cffe254f484bb11a03f5a0abb47e56b8b3d6f88e	a learning-theoretic characterization of classes of recursive functions	inference inductive;computability theory;programmation;learning;complexite calcul;system theory;programacion;aprendizaje;recursive function;complejidad computacion;apprentissage;numerotation;computational complexity;theory of computation;funcion recursiva;fonction recursive;numbering;inductive inference;theory of numberings;numerotacion;programming systems;programming	It is shown that a recursively enumerable class F of total recursive functions is co-learnable in every numbering of F iff any two numberings of F are equivalent. This characterization is of interest both for the theory of programming systems and for inductive inference.	inductive reasoning;recursion (computer science);recursive set;recursively enumerable set;theory	Martin Kummer	1995	Inf. Process. Lett.	10.1016/0020-0190(95)00036-C	programming;combinatorics;discrete mathematics;computability theory;theory of computation;recursively enumerable set;computer science;inductive reasoning;primitive recursive function;mathematics;computational complexity theory;systems theory;numbering;recursively enumerable language;μ operator;algorithm	Theory	-6.276462441676513	19.30023613587557	182212
6ba031af5516eb73c78ece428b1689c992551ab7	a fresh look at free choice nets	distributed system;systeme reparti;competition;qa mathematics;selection;choix;petri net;reseau petri;competencia	"""A subclass of Petri nets called live and safe free choice nets (LSFC nets) is studied. LSFC nets model distributed systems that can exhibit both nonsequential and nondeterministic behaviours. It is shown that the restricted combination of concurrency and choice as represented by LSFC nets leads to a number of attractive system properties. It is also shown, through examples, that a """"less"""" restrictive combination of concurrency and choice destroys these properties."""		P. S. Thiagarajan;K. Vos	1984	Information and Control	10.1016/S0019-9958(84)80052-2	selection;competition;computer science;artificial intelligence;process architecture;petri net;algorithm	Logic	-8.157652666320821	23.109336903694178	182802
53ddd0415e0b3935c5546b675ec2e1a1645b2d27	weak concurrent kleene algebra with application to algebraic verification		We propose a generalisation of concurrent Kleene algebra [5] that can take account of probabilistic effects in the presence of concurrency. The algebra is proved sound with respect to a model of automata modulo a variant of rooted η-simulation equivalence. Applicability is demonstrated by algebraic treatments of two examples: algebraic may testing and Rabin’s solution to the choice coordination problem.	algebraic equation;automata theory;concurrency (computer science);kleene algebra;modulo operation;turing completeness	Annabelle McIver;Tahiry M. Rabehaja;Georg Struth	2013	CoRR		kleene star;filtered algebra;combinatorics;discrete mathematics;kleene algebra;dimension of an algebraic variety;mathematics;algebraic cycle;algorithm;algebra	Logic	-10.123787673751611	20.044175784571962	182851
58a7bf3536efc3f910a9eeadc6e052a767f1bfed	proving mutual termination of programs	mutual termination;suggested rule;proof rule;whole program;verification problem;mapped function;individual function;arbitrary input;weaker premise	Two programs are said to be mutually terminating if they terminate on exactly the same inputs. We suggest a proof rule that uses a mapping between the functions of the two programs for proving mutual termination of functions f, f′. The ruleu0027s premise requires proving that given the same arbitrary input in, f(in) and fu0027(in) call mapped functions with the same arguments. A variant of this rule with a weaker premise allows to prove termination of one of the programs if the other is known to terminate for all inputs. We present an algorithm for decomposing the verification problem of whole programs to that of proving mutual termination of individual functions, based on our suggested rules.		Dima Elenbogen;Shmuel Katz;Ofer Strichman	2012		10.1007/978-3-642-39611-3_9	algorithm	Logic	-8.861107321584168	18.436715808153735	182985
3780e4ae3f2d712bc098f7f1c265af8d87acabae	planning for stochastic games with co-safe objectives	probabilistic computation tree logic pctl;会议论文;algorithm for solving;perfect recalls;branching time;winning strategy;stochastic planning;stochastic game;planning problem	We consider planning problems for stochastic games with objectives specified by a branching-time logic, called probabilistic computation tree logic (PCTL). This problem has been shown to be undecidable if strategies with perfect recall, i.e., history-dependent, are considered. In this paper, we show that, if restricted to co-safe properties, a subset of PCTL properties capable to specify a wide range of properties in practice including reachability ones, the problem turns to be decidable, even when the class of general strategies is considered. We also give an algorithm for solving robust stochastic planning, where a winning strategy is tolerant to some perturbations of probabilities in the model. Our result indicates that satisfiability of co-safe PCTL is decidable as well.	computation tree logic;logic programming;probabilistic ctl;probabilistic turing machine;randomized algorithm;reachability;undecidable problem	Lei Song;Yuan Feng;Lijun Zhang	2015			mathematical optimization;combinatorics;discrete mathematics;artificial intelligence;machine learning;mathematics;stochastic game	Logic	-6.83745040593654	23.173417150405356	183402
da1243c7fb2e63837cb307566499d983a378e573	unprovability of the logical characterization of bisimulation	proyeccion;prueba;bisimilarite;mathematics;logique hennessy milner;articulo sintesis;proceso markov;article synthese;bisimulacion;03b45;espace etat;bisimulation;32xx;probabilistic bisimulation;contre exemple;processus stationnaire;contraejemplo;modal logic;hennessy milner logic;preuve;state space method;methode espace etat;informatique theorique;processus markov;projection;logique modale;state space;matematicas;markov process;logica modal;labelled markov process;logic in computer science;proceso estacionario;58a25;espacio estado;nonmeasurable set;review;proof;stationary process;mathematiques;counterexample;metodo espacio estado;computer theory;informatica teorica	We quickly review labelled Markov processes (LMP) and provide a counterexample showing that in general measurable spaces, event bisimilarity and state bisimilarity differ in LMP. This shows that the logic in Desharnais [3] does not characterize state bisimulation in non-analytic measurable spaces. Furthermore we show that, under current foundations of Mathematics, such logical characterization is unprovable for spaces that are projections of a coanalytic set. Underlying this construction there is a proof that stationary Markov processes over general measurable spaces do not have semi-pullbacks.	bisimulation;descriptive complexity theory;indeterminacy in concurrent computation;locality of reference;markov chain;markov decision process;markov property;modal logic;rough set;semi-continuity;semiconductor industry;stationary process;zermelo–fraenkel set theory	Pedro Sánchez Terraf	2011	Inf. Comput.	10.1016/j.ic.2011.02.003	modal logic;stationary process;projection;state space;bisimulation;counterexample;calculus;proof;mathematics;markov process;algorithm;statistics	Logic	-7.654049161113393	20.53555669929932	183658
17e0d56633308e6deb1eacf81798796c95f5f83c	concurrent realizations of reactive systems	optimal solution;asynchronous system;reactive system;petri net	The problem of finding a (functorial) concurrent realization of a reactive system by means of a labelled safe Petri net is studied. Firstly, a (functorial) construction is described that leads from the category of concrete asynchronous systems introduced by Morin to the category of labelled safe Petri nets. Then, the general problem is discussed. It is indicated that in general there are no optimal solutions, i.e., that the most concurrent realizations of a reactive system need not exist. Nevertheless, a framework to support the process of building a concurrent realization of a reactive system is presented. The framework is based on zig-zag morphisms.	asynchronous system;concurrent constraint logic programming;petri net	Marek A. Bednarczyk;Andrzej M. Borzyszkowski	1999	Electr. Notes Theor. Comput. Sci.	10.1016/S1571-0661(05)80301-9	asynchronous system;discrete mathematics;reactive system;computer science;mathematics;distributed computing;petri net;algorithm	Robotics	-8.68964768061298	23.832848606978825	184389
08a28dc7c5170c51d758f320fc70c8f1ffe269e4	on the universal and existential fragments of the µ-calculus	corresponding result;universal fragment;practical importance;model checking;existential fragment;validity problem;improved algorithm;greatest fixed point;alternation-free fragment;polynomial-time model-checking algorithm;satisfiability;polynomial time;fixed point	One source of complexity in the μ-calculus is its ability to specify an unbounded number of switches between universal (AX) and existential (EX) branching modes. We therefore study the problems of satisfiability, validity, model checking, and implication for the universal and existential fragments of the μ-calculus, in which only one branching mode is allowed. The universal fragment is rich enough to express most specifications of interest, and therefore improved algorithms are of practical importance. We show that while the satisfiability and validity problems become indeed simpler for the existential and universal fragments, this is, unfortunately, not the case for model checking and implication. We also show the corresponding results for the alternationfree fragment of the μ-calculus, where no alternations between least and greatest fixed points are allowed. Our results imply that efforts to find a polynomial-time model-checking algorithm for the μ-calculus can be replaced by efforts to find such an algorithm for the universal or existential	algorithm;boolean satisfiability problem;existential quantification;modal μ-calculus;model checking;network switch;polynomial;time complexity	Thomas A. Henzinger;Orna Kupferman;Rupak Majumdar	2003		10.1007/3-540-36577-X_5	discrete mathematics;computer science;mathematics;automaton;existential quantification;algorithm	Logic	-8.671965836695264	21.76226326271271	185423
fa343d4d6624e3fce843ecf303e02cb84f6352bb	linearity in higher-order recursion schemes		Higher-order recursion schemes (HORS) have recently emerged as a promising foundation for higher-order program verification. We examine the impact of enriching HORS with linear types. To that end, we introduce two frameworks that blend non-linear and linear types: a variant of the λY -calculus and an extension of HORS, called linear HORS (LHORS).   First we prove that the two formalisms are equivalent and there exist polynomial-time translations between them. Then, in order to support model-checking of (trees generated by) LHORS, we propose a refined version of alternating parity tree automata, called LNAPTA, whose behaviour depends on information about linearity. We show that the complexity of LNAPTA model-checking for LHORS depends on two type-theoretic parameters: linear order and linear depth. The former is in general smaller than the standard notion of order and ignores linear function spaces. In contrast, the latter measures the depth of linear clusters inside a type. Our main result states that LNAPTA model-checking of LHORS of linear order n is n-EXPTIME-complete, when linear depth is fixed. This generalizes and improves upon the classic result of Ong, which relies on the standard notion of order.   To illustrate the significance of the result, we consider two applications: the MSO model-checking problem on variants of HORS with case distinction (RSFD and HORSC) on a finite domain and a call-by-value resource verification problem. In both cases, decidability can be established by translation into HORS, but the implied complexity bounds will be suboptimal due to increases in type order. In contrast, we show that the complexity bounds derived by translations into LHORS and appealing to our result are optimal in that they match the respective hardness results.	algorithm;automata theory;exptime;existential quantification;expressive power (computer science);formal verification;linear function;linear logic;model checking;nonlinear system;polynomial;polynomial-time reduction;programming language;recursion;substructural type system;tame;time complexity;tree automaton;type theory	Pierre Clairambault;Charles Grellois;Andrzej S. Murawski	2017	PACMPL	10.1145/3158127	theoretical computer science;computer science;recursion;linearity	PL	-10.947091253613202	20.36777632630511	185615
fbabd9916a797d73274e955a6b51eabac3ef6d23	priority conflict-free petri nets	reachability;complexite calcul;red petri;probleme np complet;complejidad computacion;computational complexity;asequibilidad;atteignabilite;problema np completo;petri net;reseau petri;np complete problem	A number of problems concerning priority conflict-free Petri nets are investigated in this paper. We show the reachability problem for such Petri nets to be NP-complete. (Using a similar technique, the NP-completeness result applies to the class of priority BPP-nets as well.) As for the boundedness problem, an NP-completeness result is demonstrated for priority conflict-free Petri nets with two types of prioritized transitions. (In contrast, the problem is known to be P-complete for conflict-free Petri nets without priorities.) We also investigate the home state problem, i.e., the problem of determining whether home states exist in a given a Petri net, for conflict-free Petri nets with and without priorities. As it turns out, home states always exist for bounded conflict-free Petri nets without priorities. If an additional liveness constraint is imposed, such Petri nets are guaranteed to be ‘reversible’ (i.e., their initial states are home states). For priority conflict-free Petri nets, being bounded and live is sufficient for the existence of home states. However, if the liveness assumption is dropped, the existence of home states is no longer guaranteed.	bpp (complexity);karp's 21 np-complete problems;liveness;np-completeness;p-complete;petri net;reachability problem	Hsu-Chun Yen	1998	Acta Informatica	10.1007/s002360050138	discrete mathematics;np-complete;stochastic petri net;computer science;mathematics;distributed computing;computational complexity theory;reachability;petri net;algorithm	SE	-8.789593401107043	24.391511474096202	185945
dbf3ffdccfc8a4ff1b14a7ed5db12e18fdf772aa	non-linear invariants for coloured petri nets with interdependent tokens; application to the proof of parallel programs	coloured petri net;parallel programs;large classes	We consider the way coloured Petri nets can be used as an abstract model for parallel programs. Then we present a kind of nets for which a large class of invariants can be proved directly on the structure of the net. We show, by means of examples, how these invariants can be used to establish partial correctness of programs.	coloured petri net;interdependence	Jacques Vautherin	1985		10.1007/BFb0016224	combinatorics;discrete mathematics;mathematics;petri net;algorithm	SE	-9.047442453030193	23.327085112660882	186590
295704959b1f84be920d7c784f8a00647baf7c9f	a symbolic decision procedure for cryptographic protocols with time stamps (extended abstract)	verification;cryptographic protocol;process algebra;time domain;security;cryptographic protocols	We present a symbolic decision procedure for time-sensitive cryptographic protocols. We consider protocols described in a process algebra-like notation that includes clocks, time-stamps and time variables. While the values of all clocks increase with rate one when time passes, time variables are simply variables that range over the time domain and can be used to remember time-stamps, i.e. time values. Our symbolic decision procedure deals with secrecy, authentication and any property that can be described as a safety property. Our approach is based on a logic representation of sets of configurations that combines a decidable logic with time constraints. © 2004 Elsevier Inc. All rights reserved.	abstract interpretation;authentication;cryptographic protocol;decision problem;encryption;modulo operation;process calculus;reachability;timed event system	Liana Bozga;Cristian Ene;Yassine Lakhnech	2004		10.1007/978-3-540-28644-8_12	discrete mathematics;computer science;theoretical computer science;mathematics;algorithm	Logic	-11.384203743220995	24.905605223650504	186991
283b06d0f830f6cd6cb46ffc3f897fed5e367fc6	the relative power of composite loop agreement tasks		Loop agreement is a family of wait-free tasks that includes set agreement and simplex agreement, and was used to prove the undecidability of wait-free solvability of distributed tasks by read/write memory. Herlihy and Rajsbaum defined the algebraic signature of a loop agreement task, which consists of a group and a distinguished element. They used the algebraic signature to characterize the relative power of loop agreement tasks. In particular, they showed that one task implements another exactly when there is a homomorphism between their respective signatures sending one distinguished element to the other. In this paper, we extend the previous result by defining the composition of multiple loop agreement tasks to create a new one with the same combined power. We generalize the original algebraic characterization of relative power to compositions of tasks. In this way, we can think of loop agreement tasks in terms of their basic building blocks. We also investigate a category-theoretic perspective of loop agreement by defining a category of loops, showing that the algebraic signature is a functor, and proving that our definition of task composition is the “correct” one, in a categorical sense.	algebraic equation;category theory;linear algebra;map;maurice herlihy;non-blocking algorithm;read-write memory;string operations;type signature	Vikram Saraph;Maurice Herlihy	2015		10.4230/LIPIcs.OPODIS.2015.13	theoretical computer science;distributed computing;algorithm	Crypto	-9.552164523718325	19.88464145484161	187063
d45d33a9bf61887b43615e17fff465e4a4c6f84c	parallel and serial hypercoherences	logique lineaire;arbre graphe;sequential machine;semantica denotacional;tree graph;machine sequentielle;serial parallel graph;semantics;sequentially;semantica;semantique;maquina secuencial;denotational semantic;grafo;graphe sequentiel parallele;sequentiality;denotational semantics;graph;graphe;hypercoherence;coherence;coherencia;arbol grafo;sequentialite;linear logic;semantique denotationnelle	"""It is known that the strongly stable functions which arise in the semantics of PCF can be realized by sequential algorithms, which can be considered as deterministic strategies in games associated to PCF types. Studying the connection between strongly stable functions and sequential algorithms, two dual classes of hypercoherences naturally arise: the parallel and serial hypercoherences. The objects belonging to the intersection of these two classes are in bijective correspondence with the so-called \serial-parallel"""" graphs, that can essentially be considered as games. We show how to associate to any hypercoherence a parallel hypercoherence together with a projection onto the given hypercoherence and present some properties of this construction. Intuitively, it makes explicit the computational time of a hypercoherence. Notice: This is a preliminary version of the paper Ehr00] entitled \Parallel and serial hyperco"""	programming computable functions;sequential algorithm;time complexity	Thomas Ehrhard	2000	Theor. Comput. Sci.	10.1016/S0304-3975(00)00173-0	linear logic;combinatorics;discrete mathematics;coherence;computer science;mathematics;semantics;graph;programming language;denotational semantics;tree;algorithm;algebra	Theory	-8.565452392285126	18.988097649188006	187673
914b61c23783819d42d3db24e3f96efa2dd88af6	earliest query answering for deterministic nested word automata	memory management;streaming algorithm;query answering;large classes	Earliest query answering (eqa) is an objective of streaming algorithms for XML query answering, that aim for close to optimal memory management. In this paper, we show that eqa is infeasible even for a small fragment of XPath unless P=NP. We then present an eqa algorithm for queries and schemas defined by deterministic nested word automata (dnwas) and distinguish a large class of dnwas for which streaming query answering is feasible in polynomial space and time.	automata theory;automaton;memory management;nested word;p versus np problem;pspace;polynomial;streaming algorithm;xml;xpath	Olivier Gauwin;Joachim Niehren;Sophie Tison	2009		10.1007/978-3-642-03409-1_12	query optimization;computer science;theoretical computer science;database;streaming algorithm;programming language;memory management	DB	-6.423314405384538	18.372040009409698	188322
562712b947379aca46756bc1e1eecc0bf944586a	operations on proofs and labels	recursion operator;large classes			Tatiana Yavorskaya;Natalia Rubtsova	2007	Journal of Applied Non-Classical Logics	10.3166/jancl.17.283-316	combinatorics;discrete mathematics;computer science;mathematics;mutual recursion;algorithm	Logic	-5.344038886859115	18.79639545708791	188531
78879c53d6355ff41f555aea4ebdeb499f7997b4	on the expressiveness of parametric timed automata		Parametric timed automata (PTAs) are a powerful formalism to reason about, model and verify real-time systems in which some constraints are unknown, or subject to uncertainty. In the literature, PTAs come in several variants: in particular the domain of parameters can be integers or rationals, and can be bounded or not. Also clocks can either be compared only to a single parameter, or to more complex linear expressions. Yet we do not know how these variants compare in terms of expressiveness, and even the notion of expressiveness for parametric timed models does not exist in the literature. Furthermore, since most interesting problems are undecidable for PTAs, subclasses, such as L/U-PTAs, have been proposed for which some of those problems are decidable. It is not clear however what can actually be modeled with those restricted formalisms and their expressiveness is thus a crucial issue. We therefore propose two definitions for the expressiveness of parametric timed models: the first in terms of all the untimed words that can be generated for all possible valuations of the parameters, the second with the additional information of which parameter valuations allow which word, thus more suitable for synthesis issues. We then use these two definitions to propose a first comparison of the aforementioned PTA variants.	automata theory;consistency model;decision problem;formal language;parametric polymorphism;program test authority;real-time clock;real-time computing;regular expression;semantics (computer science);timed automaton;undecidable problem	Étienne André;Didier Lime;Olivier H. Roux	2016		10.1007/978-3-319-44878-7_2	timed automaton	Logic	-10.328314355408875	24.994271819258593	188898
87a9a1edb3e360bcd1441411c9dc3d7910619e13	an internal presentation of regular graphs by prefix-recognizable graphs	monadic second order;specification and verification;necessary and sufficient condition;regular graph	The study of infinite graphs has potential applications in the specification and verification of infinite systems and in the transformation of such systems. Prefix-recognizable graphs and regular graphs are of particular interest in this area since their monadic second-order theories are decidable. Although the latter form a proper subclass of the former, no characterization of regular graphs within the class of prefix-recognizable ones has been known, except for a graph-theoretic one in [2]. We provide here three such new characterizations. In particular, a decidable, language-theoretic, necessary and sufficient condition for the regularity of any prefix-recognizable graph is established. Our proofs yield a construction of a deterministic hyperedge-replacement grammar for any prefix-recognizable graph that is regular.	automata theory;binary tree;bisimulation;directed graph;finite-state machine;graph rewriting;graph theory;myhill–nerode theorem;nondeterministic finite automaton;pspace;pspace-complete;recursive language;regular expression;turing completeness;vertex (graph theory)	Didier Caucal;Teodor Knapik	2001	Theory of Computing Systems	10.1007/s00224-001-1015-5	1-planar graph;random regular graph;pathwidth;strongly regular graph;combinatorics;discrete mathematics;cograph;universal graph;graph product;regular graph;clique-width;forbidden graph characterization;comparability graph;lévy family of graphs;symmetric graph;mathematics;maximal independent set;modular decomposition;treewidth;partial k-tree;chordal graph;indifference graph;algebra	Theory	-4.970577277003012	20.958945870638484	190893
832325eeae681e9ed1aea818233315e2873400dc	a scheme to verify services with unboundedly many clients using nusmv		We study model checking of client - server systems, where the servers offer several types of services that may depend, at any time, on how many clients of specific types are active at that time. Since there are unboundedly many clients, the state space of such systems is infinite, rendering specification and verification hard. This problem can be circumvented by using a specification language which has monadic first-order (MFO) sentences closed with standard temporal modalities. The MFO sentences throw up a bound which can, in turn, be used to bound the state space of the input client - server system, thereby making the verification problem decidable. This scheme is implemented using the NuSMV tool.		Shamimuddin Sheerazuddin;S. Anand;R S Anish Badhri	2018	CoRR			SE	-10.810596757569716	24.97065554270101	191071
36ce8d33eac7a8bc4fb3ce08170a2e730002469c	deriving bisimulation congruences in the dpo approach to graph rewriting	developpement logiciel;bisimulacion;bisimulation;congruencia;category theory;graph rewriting;desarrollo logicial;theorie categorie;contexto;reecriture;software development;contexte;rewriting;teoria categoria;context;congruence;reescritura	Motivated by recent work on the derivation of labelled transitions and bisimulation congruences from unlabelled reaction rules, we show how to solve this problem in the DPO (double-pushout) approach to graph rewriting. Unlike in previous approaches, we consider graphs as objects, instead of arrows, of the category under consideration. This allows us to present a very simple way of deriving labelled transitions (called rewriting steps with borrowed context) which smoothly integrates with the DPO approach, has a very constructive nature and requires only a minimum of category theory. The core part of this paper is the proof sketch that the bisimilarity based on rewriting with borrowed contexts is a congruence relation.	bisimulation;category theory;congruence of squares;graph rewriting;smoothing	Hartmut Ehrig;Barbara König	2004		10.1007/978-3-540-24727-2_12	combinatorics;discrete mathematics;rewriting;computer science;bisimulation;software development;congruence;mathematics;programming language;confluence;algorithm;category theory;graph rewriting	Logic	-8.496702465231593	22.486361520059585	191710
1634332fa87164a28798750f245e6d571d2d8d43	an algorithm to test the conflict preorder	model checking;nonblocking;finite automata;process algebra	This paper proposes a way to effectively compare the potential of processes to cause  conflict . In discrete event systems theory, two concurrent systems are said to be in conflict if they can get trapped in a situation where they are both waiting or running endlessly, forever unable to complete their common task. The  conflict preorder  is a process-algebraic pre-congruence that compares two processes based on their possible conflicts in combination with other processes. This paper improves on previous theoretical descriptions of the conflict preorder by introducing  less conflicting pairs  as a concrete state-based characterisation. Based on this characterisation, an effective algorithm is presented to determine whether two processes are related according to the conflict preorder.	algorithm;conflict-driven clause learning	Simon Ware;Robi Malik	2014	Sci. Comput. Program.	10.1016/j.scico.2013.09.006	model checking;process calculus;computer science;finite-state machine;programming language;algorithm	Logic	-10.20703934741139	22.476492619157955	192123
b614af97df626abcf5273e4ff0bbf308a4e50f91	non-bisimulation-based markovian behavioral equivalences	parallel composition;state space;process algebra;word processing;markov chain	The behavioral equivalence that is typically used to relate Markovian process terms and to reduce their underlying state spaces is Markovian bisimilarity. One of the reasons is that Markovian bisimilarity is consistent with ordinary lumping. The latter is an aggregation for Markov chains that is exact, hence it guarantees the preservation of the performance characteristics across Markovian bisimilar process terms. In this paper we show that two non-bisimulation-based Markovian behavioral equivalences – Markovian testing equivalence and Markovian trace equivalence – induce at the Markov chain level an aggregation strictly coarser than ordinary lumping that is still exact. We then show that only Markovian testing equivalence may constitute a useful alternative to Markovian bisimilarity, as it turns out to be a congruence with respect to the typical process algebraic operators, while Markovian trace equivalence is not a congruence with respect to parallel composition. © 2007 Elsevier Inc. All rights reserved.	bisimulation;congruence of squares;linear algebra;lumpers and splitters;markov chain;turing completeness	Marco Bernardo	2007	J. Log. Algebr. Program.	10.1016/j.jlap.2007.02.002	markov chain;mathematical optimization;combinatorics;process calculus;discrete mathematics;computer science;state space;kinetic scheme;mathematics;programming language	Logic	-9.950456805432232	21.451003787412546	192450
ad8a144fcf9b5dad9d8295ff463776eb1a1a5c56	a model of guarded recursion via generalised equilogical spaces		We present a new model, called GuardedEqu, of guarded dependent type theory using generalised equilogical spaces. GuardedEqu models guarded recursive types, which can be used to program with coinductive types and we prove that GuardedEqu ensures that all definable functions on coinductive types, e.g., streams, are continuous with respect to the natural topology. We present a direct, elementary, construction of the new model, which, importantly, is coherent (split) by construction.	coherence (physics);coinduction;dependent type;elementary;recursion;type theory	Ales Bizjak;Lars Birkedal	2018	Theor. Comput. Sci.	10.1016/j.tcs.2018.02.012	streams;discrete mathematics;combinatorics;coinduction;dependent type;recursion;natural topology;mathematics	Logic	-10.129123397459214	18.919831285267573	192462
b8510f25e52fe3b7d0362ebfc72968ddc9befcae	composition/décomposition de réseaux de petri et de leurs graphes de couverture		— In this paper, we study composition and décomposition of Pétri nets via a common set of places or transitions. We prove that some properties are preserved by these techniques\ and some other ones can be obtained by the composition of the covering graphs. We propose some algorithms to décompose a net according to the properties that must be verified. We present an algorithm to compose minimal covering graphs, less expensive than a straightforward construction, concerning as well time as space.	algorithm;covering graph;petri net	Alain Finkel;Laure Petrucci	1994	ITA			Logic	-5.040095017788227	21.423199104712634	192744
21eadb083e1ff105355c63911e1282040cc415cf	composing semi-algebraic o-minimal automata	diophantine equation;hybrid automata;new products	This paper addresses questions regarding the decidability of hybrid automata that may be constructed hierarchically and in a modular way, as is the case in many exemplar systems, be it natural or engineered. Since an important step in such constructions is a product operation, which constructs a new product hybrid automaton by combining two simpler component hybrid automata, an essential property that would be desired is that the reachability property of the product hybrid automaton be decidable, provided that the component hybrid automata belong to a suitably restricted family of automata. Somewhat surprisingly, the product operation does not assure a closure of decidability for the reachability problem. Nonetheless, this paper establishes the decidability of the reachability condition over automata which are obtained by composing two semi-algebraic o-minimal systems. The class of semi-algebraic o-minimal automata is not even closed under composition, i.e., the product of two automata of this class is not necessarily a semi-algebraic o-minimal automaton. However, we can prove our decidability result combining the decidability of both semi-algebraic formulæ over the reals and linear Diophantine equations. All the proofs of the results presented in this paper can be found in [1]. 1 Semi-algebraic O-Minimal Automata and Composition Hybrid automata are systems in which discrete and continuous evolutions are mixed. In particular, their discrete nature is usually modeled through labeled directed graphs (called graphs in the rest of this paper), i.e., directed graphs with labels on the edges. On this kind of graphs we define: a path ph as sequence of edges; a cycle as a path in which the first and the last edges coincide; a simple cycle as a cycle without other repetitions. A hybrid automaton H = (Z, Z ′, V, E, Inv , F , Act , Res) of dimension k consists of the following components: This work is developed within HYCON, contract number FP6-IST-511368 and supported by the projects PRIN 2005 2005015491 and BIOCHECK. B.M. is supported by funding from two NSF ITR grants and one NSF EMT grant. A. Bemporad, A. Bicchi, and G. Buttazzo (Eds.): HSCC 2007, LNCS 4416, pp. 668–671, 2007. c © Springer-Verlag Berlin Heidelberg 2007 Composing Semi-algebraic O-Minimal Automata 669 1. Z = 〈Z1, . . ., Zk〉 and Z ′ = 〈Z ′ 1, . . ., Z ′ k〉 are two vectors of reals variables; 2. 〈V, E〉 is a labeled directed graph; the vertices, V, are called locations ; 3. Each vertex v ∈ V is labeled by the formulæ Inv(v)[Z] and Dyn(v)[Z, Z ′, T ] def = Z ′ = fv(Z, T ), where fv is the solution of the continuous vector field F ; 4. Each edge e ∈ E is labeled by the two formulæ Act(e)[Z] and Res(e)[Z, Z ′]. A state q of H is a pair 〈v, r〉, where v ∈ V is a location and r = 〈r1, . . . , rk〉 ∈ R k is an assignment of values for the variables of Z. A state 〈v, r〉 is said to be admissible if Inv(v)[r] is true. The semantics of hybrid automata is given in terms of continuous t −→C and discrete e −→D transitions over asmissible states in the standard way [1]. We use the notation q → q′ to denote that either q t −→C q′ or q e −→D q′. A trace tr = q0, q1, . . . , qnis a sequence of admissible states connected through transitions. The automaton H reaches a point s ∈ R (in time t) from a point r ∈ R if there exists a trace tr = q0, . . . , qn of H such that q0 = 〈v, r〉 and qn = 〈u, s〉, for some v, u ∈ V (and t is the sum of the continuous transitions elapsed times). Given a trace tr of H we can identify at least one path of 〈V, E〉 underlying tr. We call such paths corresponding paths of tr. A well-known class of hybrid automata is the class of o-minimal hybrid automata [2], defined by using formulæ taken over an ambient o-minimal theory [3] and by imposing the constraints of constant resets at discrete transitions. In the case of o-minimal automata defined by a decidable theory, reachability can be decided through bisimulation [2]. A theory which is both o-minimal and decidable is the first-order theory of (R, 0, 1, +, ∗, <) [4], also known as the theory of semialgebraic sets. In this paper we focus on semi-algebraic o-minimal hybrid automata, i.e., o-minimal hybrid automata built over the theory of (R, 0, 1, +, ∗, <). Let H1 = (Z1, Z1′, V1, E1, Inv1, F1, Act1, Res1) and H2 = (Z2, Z2′, V2, E2, Inv2, F2, Act2, Res2) be hybrid automata over distinct variables and let be a label not occurring in E1 ∪ E2. The product (see, e.g., [5,6]) of H1 and H2 is the hybrid automaton H1 ⊗ H2 = (Z, Z ′, V, E, Inv , F , Act , Res), where: 1. Z (Z ′) is the concatenation of Z1 and Z2 (Z1′ and Z2′, respectively); 2. V = V1×V2 and E = Ex ∪E1∪E2, where: Ex = {ee1,e2 |e1 ∈ E1 and e2 ∈ E2}, E1 = {ee,v | eE1 and v ∈ V2}, and E2 = {ev,e | v ∈ V1 and e ∈ E2}. 3. Inv(〈v1, v2〉)[Z] def = Inv(v1)[Z1] ∧ Inv(v2)[Z2]; 4. Dyn(〈v1, v2〉)[Z, Z ′, T ] def = Dyn(v1)[Z1, Z1′, T ] ∧ Dyn(v2)[Z2, Z2′, T ]; 5. Act(ea,b)[Z] def = ⎧ ⎨ ⎩ Act(a)[Z1] ∧ Act(b)[Z2] if ea,b ∈ Ex Act(a)[Z1] if ea,b ∈ E1 Act(b)[Z2] if ea,b ∈ E2 6. Res(ea,b)[Z, Z ′] def = ⎧ ⎨ ⎩ Res(a)[Z1] ∧ Res(b)[Z2] if ea,b ∈ Ex Res(a)[Z1] ∧ Z2′ = Z2 if ea,b ∈ E1 Z1′ = Z1 ∧ Res(b)[Z2] if ea,b ∈ E2 We study the reachability problem over H1 ⊗H2, where H1 and H2 are semialgebraic o-minimal hybrid automata, considering sets of points of the form I = I1×I2 and F = F1×F2. As noticed in [6] the decidability of reachability is not always preserved under product operations, i.e., it is possible that reachability is decidable over two classes of automata, but not over the product class. 670 A. Casagrande et al.	admissible heuristic;bisimulation;c date and time functions;concatenation;cycle (graph theory);dfa minimization;directed graph;essence;first-order logic;first-order predicate;hybrid automaton;ibm notes;lecture notes in computer science;linear algebra;reachability problem;semiconductor industry;springer (tank);z1 (computer)	Alberto Casagrande;Pietro Corvaja;Carla Piazza;Bud Mishra	2007		10.1007/978-3-540-71493-4_57	combinatorics;discrete mathematics;continuous spatial automaton;quantum finite automata;automata theory;ω-automaton;mathematics;mobile automaton;timed automaton;algorithm	Logic	-9.098890117539469	23.726478113292135	192865
814758a6d8defca92fd9ff4daacb710a171ba9ea	topological (bi-)simulation	labelled transition system;state space;transition systems	In this paper, we reason that simulation and bisimulation are not adequate in the context of hybrid systems as they are only capable of comparing states that are reachable in a finite number of transitions. To solve this problem we extend labelled transition systems with a topology on the state space. We define topological versions of simulation and bisimulation that are also capable of comparing accumulation states of infinite sequences of transitions. We show that for transition systems with an indiscrete topology, topological (bi-)simulation and standard (bi-)simulation coincide. A similar result is obtained for finite transition systems with a discrete topology.	bisimulation;hybrid system;simulation;state space;tree accumulation	Pieter J. L. Cuijpers;Michel A. Reniers	2004	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2004.08.017	combinatorics;discrete mathematics;topology;computer science;state space;bisimulation;mathematics;topological space;trivial topology;general topology	Logic	-9.605197174790355	23.81017533233026	193712
baf417db3d52c89086d40dc4797f999207d8252c	scalar outcomes suffice for finitary probabilistic testing	concurrent framework;finitary probabilistic testing;attractive possibility;scalar outcomes suffice;different denotational;success action;direct probabilistic generalisation;direct connection;bisimulation-based approach;testing framework;simpler testing approach;multiple success action	The question of equivalence has long vexed research in concurrency, leading to many different denotationaland bisimulation-based approaches; a breakthrough occurred with the insight that tests expressed within the concurrent framework itself, based on a special “success action”, yield equivalences that make only inarguable distinctions. When probability was added, however, it seemed necessary to extend the testing framework beyond a direct probabilistic generalisation in order to remain useful. An attractive possibility was the extension to multiple success actions that yielded vectors of real-valued outcomes. Here we prove that such vectors are unnecessary when processes are finitary, that is finitely branching and finite-state: single scalar outcomes are just as powerful. Thus for finitary processes we can retain the original, simpler testing approach and its direct connections to other naturally scalar-valued phenomena.	bisimulation;branch (computer science);concurrency (computer science);scalar processor;turing completeness	Yuxin Deng;Rob J. van Glabbeek;Carroll Morgan;Chenyi Zhang	2007		10.1007/978-3-540-71316-6_25	theoretical computer science;equivalence (measure theory);scalar (physics);discrete mathematics;probabilistic logic;bisimulation;concurrency;computer science;markov decision process;generalization;finitary	PL	-11.025545556582495	19.979030220675792	194236
66e203e6bb6eae5f122e73352d315707eac18f2a	refinement algebra for probabilistic programs	refinement algebra;probability;loi probabilite;ley probabilidad;algebre kleene;program transformation;filosofi;data refinement;raisonnement;atomicity refinement;informatique theorique;probability distribution;46lxx;algebra kleene;philosophy;razonamiento;kleene algebra;reasoning;47lxx;action systems;computer theory;informatica teorica	We identify a refinement algebra for reasoning about probabilistic program transformations in a total-correctness setting. The algebra is equipped with operators that determine whether a program is enabled or terminates respectively. As well as developing the basic theory of the algebra we demonstrate how it may be used to explain key differences and similarities between standard (i.e. non-probabilistic) and probabilistic programs and verify important transformation theorems for probabilistic action systems.	correctness (computer science);program transformation;randomized algorithm;refinement (computing)	Larissa Meinicke;Kim Solin	2009	Formal Aspects of Computing	10.1007/s00165-009-0111-1	probability distribution;discrete mathematics;term algebra;kleene algebra;probability;mathematics;probabilistic logic;probabilistic argumentation;reason;algorithm	Logic	-9.90092221601862	19.730234331011864	195014
28fc15301689e3a03cbb3f2daf793cd711766dfa	linear-time and may-testing in a probabilistic reactive setting	testing equivalence;qa75 electronic computers computer science;linear time;safety;probabilistic transition systems	We consider reactive probabilistic labelled transition systems (rplts), a model where internal choices are refined by probabilistic choices. In this setting, we study the relationship between linear-time and may-testing semantics, where an angelic view of nondeterminism is taken. Building on the model of dtrees of Cleaveland et al., we first introduce a clean model of probabilistic maytesting, based on simple concepts from measure theory. In particular, we define a probability space where statements of the form “p may pass test o” naturally correspond to measurable events. We then obtain an observer-independent characterization of the may-testing preorder, based on comparing the probability of sets of traces, rather than of individual traces. This entails that may-testing is strictly finer than linear-time semantics. Next, we characterize the may-testing preorder in terms of the probability of satisfying safety properties, expressed as languages of infinite trees rather than traces. We then identify a significative subclass of rplts where linear and may-testing semantics do coincide: these are the separated rplts, where actions are partitioned into probabilistic and nondeterministic ones, and at each state only one type is available.	angelic layer;automata theory;communicating sequential processes;finite-state machine;modal logic;nondeterministic algorithm;operational semantics;polynomial;probabilistic bisimulation;probabilistic semantics;time complexity;tracing (software);turing completeness	Lucia Acciai;Michele Boreale;Rocco De Nicola	2011		10.1007/978-3-642-21461-5_2	combinatorics;discrete mathematics;mathematics;probabilistic argumentation;algorithm	Logic	-10.118344385842562	23.034562688785957	195062
56725bd8f8302e0a42b1f84a7b65835999e8ff2a	on modal μ-calculus in s5 and applications	parity games;equivalence relation;model checking;μ calculus;equivalence relations	We consider the μ-calculus over graphs where the accessibility relation is an equivalence S5-graphs. We show that the vectorial μ-calculus model checking problem over arbitrary graphs reduces to the vectorial, existential μ-calculus model checking problem over S5 graphs. Moreover, we give a proof that satisfiability of μ-calculus in S5 is NP-complete, and by using S5 graphs we give a new proof that the satisfiability problem of the existential μ-calculus is also NP-complete. Finally we prove that on multimodal S5, in contrast with the monomodal case, the fixpoint hierarchy of the μ-calculus is infinite and the finite model property fails.	modal logic;modal μ-calculus	Giovanna D'Agostino;Giacomo Lenzi	2013	Fundam. Inform.	10.3233/FI-2013-844	combinatorics;discrete mathematics;mathematics;equivalence relation;algorithm	EDA	-7.059304284941878	20.533907368779946	195542
283ae8da947454e43f4f12ea4541f019a252885e	modeling concurrency with partial orders	encapsulation;competition;relation ordre partiel;semantica denotacional;temporal logic;communicating process;chaine caractere;encapsulacion;processus communiquant;reseau;linear constraint;red;conjunto parcialmento ordenado;modelisation;hybrid approach;partially ordered set;partial ordering;logique ordre 1;denotational semantics;cadena caracter;ensemble partiellement ordonne;relacion orden parcial;modeling;concurrent process;lenguaje formal;logique temporelle;one order logic;semantique denotationnelle;formal language;modelaje;network;competencia;character string;logica orden 1;real time systems;partial order;langage formel	Concurrency has been expressed variously in terms of formal languages (typically via the shuffle operator), partial orders, and temporal logic,inter alia. In this paper we extract from these three approaches a single hybrid approach having a rich language that mixes algebra and logic and having a natural class of models of concurrent processes. The heart of the approach is a notion of partial string derived from the view of a string as a linearly ordered multiset by relaxing the linearity constraint, thereby permitting partially ordered multisets orpomsets. Just as sets of strings form languages, so do sets of pomsets form processes. We introduce a number of operations useful for specifying concurrent processes and demonstrate their utility on some basic examples. Although none of the operations is particularly oriented to nets it is nevertheless possible to use them to express processes constructed as a net of subprocesses, and more generally as a system consisting of components. The general benefits of the approach are that it is conceptually straightforward, involves fewer artificial constructs than many competing models of concurrency, yet is applicable to a considerably wider range of types of systems, including systems with buses and ethernets, analog systems, and real-time systems.	analog;biologic preservation;concurrency (computer science);concurrent computing;ephrin type-b receptor 1, human;formal language;hl7publishingsubsection <operations>;order (action);page (document);programming languages;real-time clock;real-time computing;temporal logic;message;paragraphs	Vaughan R. Pratt	1986	International Journal of Parallel Programming	10.1007/BF01379149	partially ordered set;computer science;artificial intelligence;programming language;algorithm	Logic	-7.753937945228647	21.38577967565583	195560
824b115c1a8f5e70c77eaae52d844434347bd113	on reachability-related games on vector addition systems with states		A new research result in this paper shows the decidability, and the TOWER upper bound on complexity, of solving parity multi-energy games (with given initial credit) in the framework of extended vector addition systems with states (where some components in the change vectors are not fixed but can be made arbitrarily large). The result is not deep w.r.t. the state-of-the-art, since it can be shown by a simple reduction to the version without the parity condition that was solved by Brazdil, Jancar, and Kucera (ICALP 2010). Besides giving the reduction, the main aim of the paper is to highlight the crucial ideas of a direct (self-contained) proof of the result; a particular novelty here is a natural attractor construction that seems to have not been used in this context so far.	reachability	Petr Jancar	2015		10.1007/978-3-319-24537-9_6	novelty;discrete mathematics;parity (mathematics);arbitrarily large;reachability;mathematics;reachability problem;decidability;attractor;upper and lower bounds	Logic	-5.356870106509321	24.10284856999086	195587
87766b7ec5378ab581bd089182a6edae352968dc	undecidability of the first order theory of one-step right ground rewriting	first order	Is the first order theory of one-step rewriting decid-able? For an arbitrary finite term rewriting system R, is the first order theory of one-step rewriting (→ R) decidable? Decidability would imply the decidabil-ity of the first-order theory of encompassment (that is, being an instance of a subterm) [CCD93], as well as several known decidability results in rewriting. (It is well known that the theory of → * R is in general undecidable.) Remark This has been answered negatively in [Tre96, Tre98]. Sharper undecidability results have been obtained for the following subclasses of rewrite systems:	first-order logic;first-order reduction;ibm system r;rewrite (programming);rewriting;undecidable problem	Jerzy Marcinkowski	1997		10.1007/3-540-62950-5_75	discrete mathematics;computer science;first-order logic;mathematics;programming language;confluence;algorithm;algebra	Logic	-11.21472051805114	18.342027534061888	195691
3a995b7cf7862bcdeadca006e1c18950e5cd9b9f	a hierarchy of polynomial-time computable simulations for automata	labelled transition system;temps polynomial;automate bschi;automata estado finito;verification modele;simultaneidad informatica;bschi automata;program verification;systeme transition etiquete;verificacion programa;concurrency;model checking;state space;finite automata;polynomial time;finite automaton;automate fini;verification programme;simultaneite informatique;computer simulation;tiempo polinomial	We define and provide algorithms for computing a natural hierarchy of simulation relations on the state-spaces of ordinary transition systems, finite automata, and Buchi automata. These simulations enrich ordinary simulation and can be used to obtain greater reduction in the size of automata by computing the automaton quotient with respect to their underlying equivalence. State reduction for Biichi automata is useful for making explicit-state model checking run faster ([EH00, SB00, EWS01]). We define k-simulations, where 1-simulation corresponds to ordinary simulation and its variants for Buchi automata ([HKR97, EWS01]), and k-simulations, for k > 1, generalize the game definition of 1-simulation by allowing the Duplicator to use k pebbles instead of 1 (to hedge its bets ) in response to the Spoiler's move of a single pebble. As k increases, k-simulations are monotonically non-decreasing relations. Indeed, when k reaches n, the number of states of the automaton, the n-simulations defined for finite-automata and for labeled transition systems correspond precisely to language containment and trace containment, respectively. But for each fixed k, the maximal k-simulation relation is computable in polynomial time: n O(k) . This provides a mechanism with which to trade off increased computing time for larger simulation relation size, and more potential reduction in automaton size. We provide algorithms for computing k-simulations using a natural generalization of a prior efficient algorithm based on parity games ([EWS01]) for computing various simulations. Lastly, we observe the relationship between k-simulations and a k-variable interpretation of modal logic.	automaton;computable function;computer simulation	Kousha Etessami	2002		10.1007/3-540-45694-5_10	time complexity;model checking;discrete mathematics;continuous spatial automaton;concurrency;quantum finite automata;computer science;state space;theoretical computer science;deterministic automaton;ω-automaton;mathematics;finite-state machine;programming language;mobile automaton;timed automaton;algorithm	Logic	-9.019253908372283	22.922467495669057	195833
07ab6990185afc5df21a195ce8ea9f207f5a72fd	compositional verification: decidability issues using graph substitutions	carte a puce;program graph;verification compositionnelle;hipergrafico;smart card;programme commande;behavioral analysis;commande sequentielle;graph flow;flot donnee;logica monadica;composicionalidad;compositional verification;flujo datos;program verification;flow graphs;flujo grafo;control secuencial;veric ation;second order logic;logica orden 2;verificacion programa;logique ordre 2;local structure;compositionnalite;sequential control;monadic second order logic;smart cards;graphe programme;control program;flot graphe;informatique theorique;compositionality;analyse comportementale;logique monadique;tree automata;graphe flux;programa mando;monadic logic;analisis conductual;decidibilidad;treewidth;anchura arbol;graphe fluence;hypergraph;data flow;largeur arborescente;decidabilite;verification programme;grafo programa;grafo fluencia;fluence graph;verificacion composicional;decidability;hypergraphe;computer theory;informatica teorica	This paper deals with the compositional verification of sequential programs. This consists in deciding whether or not a given set of local structural properties of the functions of a program implies a given global behavioural property of the program. Here we consider properties expressed in monadic second-order logic dealing with the control flow of the program and the function calls occuring during its execution. This problem has been investigated in relation with the security of open multiapplication smart cards. We show that the compositionality is decidable for sequential programs whose control-flow graphs are of tree-width less than a fixed integer value, which includes in particular structured programs. Formally, we prove the decidability of MSO theories of families of hypergraphs obtained by uniform substitution of hyperedges by hypergraphs specified by MSO formulas.	control flow;monadic predicate calculus;smart card;treewidth	Olivier Ly	2004		10.1007/978-3-540-28629-5_41	smart card;combinatorics;discrete mathematics;computer science;theoretical computer science;mathematics;algorithm	Logic	-8.148311412623698	22.498216643277015	196093
0bbedd2dbd1a1b0e2416491c179794b9e589e266	event structures for local traces	petri net;event structures	Abstract   Local traces and local event structures have been introduced in order to lift the semantical theory of 1-safe Petri nets to the level of more general Petri nets. In this paper, we cut out Petri nets and establish a direct link between these two classes. Whereas it is relatively easy to associate a local independence relation to a local event structure, the opposite connection is much less clear. The problem here is the identification of the events in a local trace language. We consider various extensions of the classical technique which relates Mazurkiewicz' traces to prime event structures, one of which leads to a precise connection in terms of a coreflection between main subclasses of each model.	digital footprint	Jetty Kleijn;Rémi Morin;Brigitte Rozoy	1998	Electr. Notes Theor. Comput. Sci.	10.1016/S1571-0661(04)00120-3	combinatorics;discrete mathematics;computer science;mathematics;process architecture;petri net;algorithm	ECom	-9.09359855837579	20.917546576175514	196315
2ea1e1abf01db125fe8ee419c9500c8af4a33791	dynamic consistency of conditional simple temporal networks via mean payoff games: a singly-exponential time dc-checking	game theory computational complexity constraint handling directed graphs;dynamic consistency;mean payoff games;heuristic algorithms games planning algorithm design and analysis computational modeling timing terminology;singly exponential time;computational modeling;reaction time analysis;heuristic algorithms;hyper temporal networks;games;conditional simple temporal networks;reaction time analysis conditional simple temporal networks dynamic consistency mean payoff games hyper temporal networks singly exponential time;terminology;planning;algorithm design and analysis;directed weighted graphs conditional simple temporal networks dynamic consistency mean payoff games singly exponential time dc checking constraint based graph formalism conditional temporal planning cstp model cstn conp hard singly exponential time algorithm dynamic execution strategy two player infinite games finite graphs hyper temporal network model e dynamic consistency reaction time critical value linear difference constraints strict inequalities;timing	Conditional Simple Temporal Network (CSTN) is a constraint-based graph-formalism for conditional temporal planning. It offers a more flexible formalism than the equivalent CSTP model of Tsamardinos, Vidal and Pollack, from which it was derived mainly as a sound formalization. Three notions of consistency arise for CSTNs and CSTPs: weak, strong, and dynamic. Dynamic consistency is the most interesting notion, but it is also the most challenging and it was conjectured to be hard to assess. Tsamardinos, Vidal and Pollack gave a doubly-exponential time algorithm for deciding whether a CSTN is dynamically-consistent and to produce, in the positive case, a dynamic execution strategy of exponential size. In the present work we offer a proof that deciding whether a CSTN is dynamically-consistent is coNP-hard and provide the first singly-exponential time algorithm for this problem, also producing a dynamic execution strategy whenever the input CSTN is dynamically-consistent. The algorithm is based on a novel connection with Mean Payoff Games, a family of two-player infinite games played on finite graphs, well known for having applications in model-checking and formal verification. The presentation of such connection is mediated by the Hyper Temporal Network model, a tractable generalization of Simple Temporal Networks whose consistency checking is equivalent to determining Mean Payoff Games. In order to analyse the algorithm we introduce a refined notion of dynamic-consistency, named ε-dynamic-consistency, and present a sharp lower bounding analysis on the critical value of the reaction time where the CSTN transits from being, to not being, dynamically-consistent. The proof technique introduced in this analysis of the reaction time is applicable more generally when dealing with linear difference constraints which include strict inequalities.	algorithm;co-np;cobham's thesis;computational complexity theory;exptime;formal verification;network model;out-of-order execution;pollack's rule;polynomial;semantics (computer science);super-twisted nematic display;time complexity	Carlo Comin;Romeo Rizzi	2015	2015 22nd International Symposium on Temporal Representation and Reasoning (TIME)	10.1109/TIME.2015.18	planning;games;algorithm design;mathematical optimization;combinatorics;discrete mathematics;computer science;mathematics;terminology;computational model;algorithm;statistics	Logic	-6.878892824510453	23.38835451268945	196338
899dbe300e07be90bb6a81429ac73761abd7f2a8	a notion of a computational step for partial combinatory algebras		Working within the general formalism of a partial combinatory algebra (or PCA), we introduce and develop the notion of a step algebra, which enables us to work with individual computational steps, even in very general and abstract computational settings. We show that every partial applicative structure is the closure of a step algebra obtained by repeated application, and identify conditions under which this closure yields a PCA.	applicative programming language;combinatory logic;computation;semantics (computer science)	Nathanael Leedom Ackerman;Cameron E. Freer	2013		10.1007/978-3-642-38236-9_13	calculus;pure mathematics;mathematics	Logic	-10.341866656224033	20.647307509382834	196390
3c50b5e9ec456def33eca9d33e6961fc08dfa91a	the coarsest precongruences respecting safety and liveness properties	labelled transition system;logic in computer science	This paper characterises the coarsest refinement preorders on labelled transition systems that are precongruences for renaming and partially synchronous interleaving operators, and respect all safety, liveness, and conditional liveness properties, respectively.	forward error correction;liveness;refinement (computing)	Rob J. van Glabbeek	2010		10.1007/978-3-642-15240-5_3	discrete mathematics;computer science;mathematics;distributed computing;algorithm	Logic	-11.07853619686086	22.672362238597977	196415
5b1055c3232c823f3910170cec280d74de565a08	efficient detection of restricted classes of global predicates	distributed debugging;distributed system;efficient algorithm;satisfiability;mutual exclusion;predicate detection	We show that the problem of predicate detection in distributed systems is NP-complete. We introduce a class of predicates, linear predicates, such that for any linear predicate B there exists an efficient detection of the least cut satisfying B. The dual of linearity is post-linearity. These properties generalize several known properties of distributed systems, such as the set of consistent cuts forms a lattice, and the WCP and GCP predicate detection results given in earlier work. We define a more general class of predicates, semi-linear predicates, for which efficient algorithms are known to detect whether a predicate has occurred during an execution of a distributed program. However, these methods may not identify the least such cut. Any stable predicate is an example of a semi-linear predicate. In addition, we show that certain unstable predicates can also be semi-linear, such as mutual exclusion violation. Finally, we show application of max-flow to the predicate detection problem. This result solves a previously open problem in predicate detection, establishing the existence of an efficient algorithm to detect predicates of the form x1 + x2 + xn < k where xi are variables on different processes, k is some constant, and n is larger than 2.	algorithm;control theory;distributed computing;games computers play;maximum flow problem;mutual exclusion;np-completeness;predicate (mathematical logic);semiconductor industry;sensor;system of linear equations	Craig M. Chase;Vijay K. Garg	1995		10.1007/BFb0022155	computer science;theoretical computer science;distributed computing;programming language	Theory	-8.404250809093206	24.76750078237345	196645
ace6b7d9fadd89f2d13c5d95999bc56c8b9cc77b	finite failures and partial computations in concurrent logic languages	concurrent logic language;finite failure;partial computation	This paper investigates some semantic properties of concurrent logic languages. Concurrent logic languages with a commit operator differ from pure logic languages in the finite failure set. Since the new finite failure set depends on the computation rule, we define an operational semantics based on a parallel computation rule and a fair search rule. Failures with a parallel computation rule are shown to be strongly related to partial computed answer substitutions. The set of partial computed answer substitutions and the set of finite failures are defined as the least fixpoint of a transformation on pairs of interpretations.		Moreno Falaschi;Giorgio Levi	1988		10.1016/0304-3975(90)90061-L	concurrent constraint logic programming;discrete mathematics;computer science;algorithm	Logic	-11.760147064251502	20.18300487817632	196906
bae3dce19e81986c9e9ef0e5935a76324dec7860	knowledge-based graph exploration analysis	prolog;groove;graph exploration analysis;feature modelling	In a context where graph transformation is used to explore a space of possible solutions to a given problem, it is almost always necessary to inspect candidate solutions for relevant properties. This means that there is a need for a flexible mechanism to query not only graphs but also their evolution. In this paper we show how to use Prolog queries to analyse graph exploration. Queries can operate both on the level of individual graphs and on the level of the transformation steps, enabling a very powerful and flexible analysis method. This has been implemented in the graph-based verification tool groove. As an application of this approach, we show how it gives rise to a competitive analysis technique in the domain of feature modelling.	competitive analysis (online algorithm);feature model;global telecommunications system;graph rewriting;prolog;stani michiels;state space;usability	Ismênia Galvão;Eduardo Zambon;Arend Rensink;Lesley Wevers;Mehmet Aksit	2011		10.1007/978-3-642-34176-2_11	null model;graph product;computer science;clique-width;theoretical computer science;machine learning;graph;moral graph;critical graph;graph database;algorithm;graph rewriting	Logic	-7.725065991992713	24.6690793388166	197230
39000cbc6d0ca84a143ac9f157e80988cbd38083	type-free equational reasoning in the theeory of inductively defined types			recursive definition	Yasuyuki Tsukada	1998			computer science;theoretical computer science	Logic	-4.808448126959353	19.306220758474165	197376
9118312a3da5bfb4d422ab3965c9657c9f6ce569	on fairness and randomness	concept;fairness;comportement;loi probabilite;ley probabilidad;transition probability;implementation;coaccion;contrainte;transition;probabilistic system;estrategia;randomness;definicion;systeme non deterministe;probabilistic verification;systeme deterministe;equite;strategy;non deterministic system;transicion;constraint;definition;sistema determinista;conducta;informatique theorique;probability distribution;probabilistic systems;probabilidad transicion;characterization;completitud;68q10;caractere aleatoire;sistema no determinista;completeness;caracterisation;behavior;implementacion;completude;strategie;non deterministic systems;probabilite transition;caracterizacion;deterministic system;computer theory;concepto;informatica teorica	We investigate the relation between the behavior of non-deterministic systems under fairness constraints, and the behavior of probabilistic systems. To this end, first a framework based on computable stopping strategies is developed that provides a common foundation for describing both fair and probabilistic behavior. On the basis of stopping strategies it is then shown that fair behavior corresponds in a precise sense to random behavior in the sense of Martin-Löf’s definition of randomness. We view probabilistic systems as concrete implementations of more abstract non-deterministic systems. Under this perspective the question is investigated what probabilistic properties are needed in such an implementation to guarantee (with probability one) certain required fairness properties in the behavior of the probabilistic system. Generalizing earlier concepts of -bounded transition probabilities, we introduce the notion of divergent probabilistic systems, which enables an exact characterization of the fairness properties of a probabilistic implementation. Looking beyond pure fairness properties, we also investigate what other qualitative system properties are guaranteed by probabilistic implementations of fair non-deterministic behavior. This leads to a completeness result which generalizes a well-known theorem by Pnueli and Zuck.	computable function;fairness measure;markov chain;non-deterministic turing machine;randomness;transition system	Manfred Jaeger	2009	Inf. Comput.	10.1016/j.ic.2009.01.005	probability distribution;probabilistic analysis of algorithms;definition;strategy;completeness;artificial intelligence;transition;deterministic system;mathematics;probabilistic logic;constraint;implementation;probabilistic argumentation;concept;randomness;algorithm;statistics;behavior	Logic	-7.989976264236219	20.89930445832798	197422
dea9ec73f79788fa69eb679e79b448aac25dbd6c	a general approach to comparing infinite-state systems with their finite-state specifications	sistema infinito;sistema transicion;verificacion modelo;metodo reduccion;behavioral analysis;maquina estado finito;specification;verification modele;simultaneidad informatica;program verification;transition system;verificacion programa;concurrency;systeme transition;model checking;especificacion;generic relation;analyse comportementale;estructura producto;analisis conductual;methode reduction;decidibilidad;relation generique;decidabilite;machine etat fini;verification programme;reduction method;simultaneite informatique;systeme infini;structure produit;relacion generica;finite state machine;product structure;decidability;infinite system	We introduce a generic family of behavioral relations for which the regular equivalence problem (i.e., comparing an arbitrary transition system to some finite-state specification) can be reduced to the model checking problem against simple modal formulae. As an application, we derive decidability of several regular equivalence problems for well-known families of infinite-state systems.		Antonín Kucera;Philippe Schnoebelen	2006	Theor. Comput. Sci.	10.1016/j.tcs.2006.01.021	decidability;model checking;discrete mathematics;concurrency;computer science;mathematics;finite-state machine;specification;algorithm	Logic	-8.44301647838273	22.522527906208108	197468
d09e5bf6e791f3173b938da403a8bc07ef73f0fa	binary reachability of timed pushdown automata via quantifier elimination and cyclic order atoms		We study an expressive model of timed pushdown automata extended with modular and fractional clock constraints. We show that the binary reachability relation is effectively expressible in hybrid linear arithmetic with a rational and an integer sort. This subsumes analogous expressibility results previously known for finite and pushdown timed automata with untimed stack. As key technical tools, we use quantifier elimination for a fragment of hybrid linear arithmetic and for cyclic order atoms, and a reduction to register pushdown automata over cyclic order atoms. 2012 ACM Subject Classification Theory of computation → Timed and hybrid models, Theory of computation → Logic and verification, Theory of computation → Formal languages and automata theory	automata theory;deterministic pushdown automaton;integer sorting;quantifier (logic);reachability;stack (abstract data type);theory of computation;timed automaton	Lorenzo Clemente;Slawomir Lasota	2018		10.4230/LIPIcs.ICALP.2018.118	quantifier elimination;discrete mathematics;combinatorics;pushdown automaton;sort;mathematics;binary number;cyclic order;reachability;integer	Logic	-10.467224796502546	23.74582575751816	197491
ab67026ed2a96d5c98852b0d3a149b8572da2ff1	classifying recognizable infinitary trace languages using word automata	websearch;publications database;rwth publications	We address the problem of providing a Borel-like classifica- tion of languages of infinite Mazurkiewicz traces, and provide a solution in the framework of ω-automata over infinite words - which is invoked via the sets of linearizations of infinitary trace languages. We identify trace languages whose linearizations are recognized by deterministic weak or deterministic Buchi (word) automata. We present a characterization of the class of linearizations of all recognizable ω-trace languages in terms of Muller (word) automata. Finally, we show that the linearization of any recognizable ω-trace language can be expressed as a Boolean combination of languages recognized by our class of deterministic Buchi automata.	automaton	Namit Chaturvedi;Marcus Gelderie	2014		10.1007/978-3-662-44522-8_15	combinatorics;discrete mathematics;nested word;mathematics;abstract family of languages;programming language;algorithm	NLP	-4.829138161873196	19.93473950141727	197595
b8ba1785463af2952840f75abf5b5d3b0c69dbfb	a process algebraic semantics for statecharts via state refinement	labeled transition system;structured operational semantics;process algebra	We give a formal semantics for statecharts via a translation into a process algebra with state reenement, a new operator for capturing hierarchy in concurrent systems. Our main technical result can be stated as follows. Let A be a statechart automaton as deened by the operational model of A. Pnueli and M. Shalev, What is in a step: On the semantics of statecharts, LNCS number 526, 1991], and let t A be the corresponding process algebra term. Then the respective labeled transition systems of A and t A are isomorphic, thereby demonstrating the faithfulness of the translation.	algebraic semantics (computer science);automaton;concurrency (computer science);lecture notes in computer science;process calculus;state diagram	Andrew C. Uselton;Scott A. Smolka	1994			discrete mathematics;theoretical computer science;mathematics;programming language;operational semantics;denotational semantics	Logic	-11.326557679059562	22.5945359512584	198330
1da6739d757d4122a295a6a0fa8a8231a7c35f46	peek arc consistency	temps polynomial;procedure decision;espace lineaire;temps lineaire;coaccion;espacio lineal;contrainte;arc consistency;tiempo lineal;space time;polynomial;raisonnement;constraint satisfaction;espacio tiempo;68wxx;consistencia;artificial intelligent;algorithme;caracterisation algebrique;algorithm;satisfaction contrainte;constraint;decision procedure;computational complexity;informatique theorique;polinomio;robustesse;linear time;consistance;polynomial time;razonamiento;probleme satisfaction contrainte;decision;68t37;logic in computer science;robustness;procesador;constraint satisfaction problem;46axx;satisfaccion restriccion;reasoning;processeur;polynome;linear space;consistency;processor;espace temps;computer theory;robustez;algoritmo;tiempo polinomial;informatica teorica	This paper studies peek arc consistency, a reasoning techni que that extends the wellknown arc consistency technique for constraint satisfacti on. In contrast to other more costly extensions of arc consistency that have been studied in the l iterature, peek arc consistency requires only linear space and quadratic time and can be para llelized in a straightforward way such that it runs in linear time with a linear number of pro cessors. We demonstrate that for various constraint languages, peek arc consistenc y gives a polynomial-time decision procedure for the constraint satisfaction problem. We also present an algebraic characterization of those constraint languages that can be solved by peek arc consistency, and study the robustness of the algorithm.	algorithm;constraint satisfaction problem;decision problem;local consistency;time complexity	Manuel Bodirsky;Hubie Chen	2010	Theor. Comput. Sci.	10.1016/j.tcs.2009.07.059	constraint logic programming;time complexity;computer science;calculus;mathematics;algorithm;local consistency	AI	-7.691102586349536	19.57442583012375	198412
05d90d006b30ae3f249a02f4e55d1de8fa22b9da	"""expressive power of existential first-order sentences of bu""""chi's sequential calculus"""	level 2;formule booleenne;hierarchy;combinaison booleenne;automate deterministe;quantifier;03d55;palabra finita;logic;successeur;ordre 1;semigrupo;mot fini;metodo secuencial;sequential method;68wxx;expressive power;automata;first order;deterministic automaton;automata determinista;quantificateur;jerarquia;20mxx;semigroupe;03c10;methode sequentielle;semigroup;03c80;hierarchie;cuantificador;semigroups;orden 1;successor;finite word;logique;logica	The aim of this paper is to study the first-order theory of the successor, interpreted on finite words. More specifically, we are interested in the hierarchy based on quantifier alternations (or Σn-hierarchy). It was known (Thomas, 1982) that this hierarchy collapses at level 2, but the expressive power of the lower levels was not characterized effectively. We give a semigroup theoretic description of the expressive power of BΣ1, the boolean combinations of existential formulas. We also give an O(n 7)time algorithm to decide whether the language accepted by a deterministic n-state automaton is expressible by a first order sentence (respectively a BΣ1-sentence).	algorithm;automaton;cpu cache;expressive power (computer science);first-order logic;first-order predicate;quantifier (logic);theory	Jean-Éric Pin	2005	Discrete Mathematics	10.1016/j.disc.2004.04.027	combinatorics;discrete mathematics;deterministic automaton;mathematics;semigroup;logic;expressive power;algorithm;hierarchy;algebra	Logic	-6.046034328153143	19.17258261847368	198710
2478658ee5621ca3ff9e5957790a49e48f5fd2ad	automata games for multiple-model checking	temporal logic;journal article;parity games;model checking;tree automata;transition systems;multiple model;consistency;focussed transition systems;structural properties	3-valued models have been advocated as a means of system abstraction such that verifications and refutations of temporal-logic properties transfer from abstract models to the systems they represent. Some application domains, however, require multiple models of a concrete or virtual system. We build the mathematical foundations for 3-valued property verification and refutation applied to sets of common concretizations of finitely many models. We show that validity checking for the modal mu-calculus has the same cost (EXPTIME-complete) on such sets as on the set of all 2-valued models, provide an efficient algorithm for checking whether common concretizations exist for a fixed number of models, and propose using parity games on variants of tree automata to efficiently approximate validity checks of multiple models. Structural properties of a universal topological model confirm that such approximations are reasonably precise only for tree-automata-like models.	application domain;approximation algorithm;automata theory;database;decision problem;exptime;modal logic;modal μ-calculus;model checking;p (complexity);refinement (computing);temporal logic;tree automaton	Altaf Hussain;Michael Huth	2006	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2005.11.067	model checking;combinatorics;discrete mathematics;temporal logic;computer science;mathematics;consistency;algorithm	Logic	-11.096441625640487	22.228245110601556	198830
