id	title	keywords	abstract	entities	authors	year	journal	doi	fos	area	x	y	ix
d3dd5ea31212fc46759cb15f5f4af4c2cf882db3	visualizing the network of software agents for verification of multiagent systems	distributed software systems;scenario based software engineering;emergent behavior multiagent systems scenario based software engineering social network visualization distributed software systems;software agents distributed programming multi agent systems program verification program visualisation social networking online;software agents social network visualization design phase emergent behavior detection dss distributed software systems mas verification multiagent system verification;program verification;software agents;multi agent systems;distributed programming;emergent behavior;social networking online;visualization vectors social network services decision support systems software educational institutions conferences;program visualisation;social network visualization;multiagent systems	The verification of Multiagent Systems (MAS) and Distributed Software Systems (DSS) has taken a special attention due to the growing demand of having DSS in recent years. The distributed functionality and lack of having a central control in MAS and DSS may cause to emerge new behaviors in the execution time. This unexpected behavior which was not seen in the requirements is known as emergent behavior and may cause irreparable damages. Detection of these emergent behaviors is more valuable and cost effective in the early phases compared to detecting them after the deployment. In this paper we propose a new technique for the detection of a specific type of emergent behavior in the design phase. We take the advantage of social network visualization in this method. The novelty and direct advantage of this technique is presenting the exact point and cause of emergent behavior.	agent-based model;emergence;graph drawing;multi-agent system;requirement;run time (program lifecycle phase);sensor;social network;software agent;software deployment;software system	Fatemeh Hendijani Fard;Behrouz Homayoun Far	2013	2013 IEEE/ACM International Conference on Advances in Social Networks Analysis and Mining (ASONAM 2013)	10.1145/2492517.2492587	software visualization;simulation;computer science;artificial intelligence;social software engineering;software development;software agent;multi-agent system;software construction;distributed computing;software deployment;emergence;software system	SE	-55.15668684317304	29.858008299290123	149057
ce3c5c3bfa86fc20ec0c7aa85a77e00f22b0d9c0	putting performance engineering into model-driven engineering: model-driven performance engineering	model driven engineering	Late identification of performance problems can lead to significant additional development costs. Hence, it is necessary to address performance in several development phases by performing a performance engineering process. We show that Model-Driven Engineering (MDE) specifics can be utilised for performance engineering. Therefore, we propose a process combining MDE and performance engineering called ModelDriven Performance Engineering (MDPE). Additionally we present our first experiences in application of MDPE	behavioral modeling;experiment;hypertext transfer protocol;maximal set;model-driven engineering;model-driven integration;performance engineering;refinement (computing);requirement;stepwise regression;synchronization (computer science)	Mathias Fritzsche;Jendrik Johannes	2007		10.1007/978-3-540-69073-3_18	model-driven architecture;engineering optimization;information engineering;performance engineering;system of systems engineering;computer science;systems engineering;engineering;software engineering;requirements engineering;mechanical engineering	SE	-52.01168603162855	26.47782963254815	149152
182c8871fa8e30a15051f48abddde0d79a5bba7d	network management system development using an application framework	software engineering computer network management telecommunication computing software reviews;software reviews;application framework;software construction network management system development application framework netkeeper network management system communication applications;software construction;telecommunication computing;software engineering;network management system development;computer network management;application software graphical user interfaces computer network management communication system software collaborative software libraries telegraphy telephony laboratories skeleton;network management system;netkeeper network management system;communication applications	The advantages of using an application framework are described by introducing the NetKeeper network management system. Experience using NetKeeper has shown the ease of constructing communication applications and the rapidity of software construction with an application framework.	application framework;management system;software construction	Tomohiro Fujisaki	1996		10.1109/CMPSAC.1996.544605	element management system;verification and validation;computing;network management station;software project management;computer science;systems engineering;social software engineering;software framework;component-based software engineering;software development;software engineering;middleware;software construction;software as a service;network management application;application lifecycle management;resource-oriented architecture;software deployment;network monitoring;software development process;software system;computer engineering;software peer review	Mobile	-48.99927743314709	30.491515835530386	149626
3838cb698650ddd9a451fff9e9ba4875e04a8af8	teaching uml modeling before programming at the high school level	education unified modeling language programming profession robots educational institutions computer science maintenance engineering embedded system application software productivity;unified modeling language computer science education teaching;programming language;teaching programming;application software;uml;maintenance engineering;embedded system;computer science education;high school;programming profession;robots;unified modeling language;computer science;productivity;textual imperative programming language;teaching;textual imperative programming language teaching uml	This paper describes experience teaching modeling at the high school level prior to teaching programming and embedded control. An implementation- independent form of UML modeling is being used to teach students to analyze various applications, systems and problem domains. The objective is to introduce the abstract thinking processes involved in modeling before introducing the more concrete thought processes involved in programming with frequently used textual imperative programming languages. The author reports on experience teaching abstraction and UML modeling to a class of 12th graders.	embedded system;imperative programming;problem domain;programming language;uml tool;unified modeling language	Cortland Starrett	2007	Seventh IEEE International Conference on Advanced Learning Technologies (ICALT 2007)	10.1109/ICALT.2007.234	maintenance engineering;unified modeling language;uml tool;computer science;artificial intelligence;applications of uml;programming paradigm;programming language	Robotics	-50.63578021818866	29.278329318149137	150488
9865f8d042dd3d40dad49f6005918472e4637e24	teaching oo methodology in a project-driven cs2 course	objects first;frameworks;software engineering education;pedagogical issues;large scale;object oriented;cs2;design pattern;design patterns;data structure	After we adopted an objects-first approach in CS1, we had to redesign our CS2 and data structures courses. This paper reports on our efforts to develop a project-driven CS2 course that expands on the object-oriented methodology introduced in the CS1 course. We focused on using collections and base classes in meaningful, large-scale projects helping students understand why these classes are important before concentrating on implementation in the subsequent data structures and algorithms course. We also introduce the concepts of design patterns and frameworks. This paper focuses on the OO methodology developed in the course; a companion paper [6] deals with pedagogical issues in using our approach.	algorithm;data structure;design pattern;software framework	E. Frank Barry;Christopher C. Ellsworth;Barry L. Kurtz;James T. Wilkes	2005		10.1145/1094855.1094970	software design pattern;simulation;data structure;computer science;software framework;design pattern;programming language;object-oriented programming	PL	-51.04872167022846	29.165221050495067	151309
7255b4f933db062531376c688f8ddc002fb83008	model interpreter frameworks: a foundation for the analysis of domain-specific software architectures	model-driven engineering;component-based systems;software architecture;component model	Prediction of the quality attributes of software architectures requires technologies that enable the application of analytic theories to component models. However, available analytic techniques generally operate on formal models specified in notations that cannot flexibly and intuitively capture the architectures of large-scale distributed systems. The construction of model interpreters that transform architectural models into analysis models has proved to be a time-consuming and difficult task. This paper describes (1) how a reusable model interpreter framework can reduce the complexity involved in this task, and (2) how such a framework can be designed, implemented, utilized, and evaluated.1	distributed computing;list of system quality attributes;software architecture	George Edwards;Chiyoung Seo;Nenad Medvidovic	2008	J. UCS	10.3217/jucs-014-08-1182	functional software architecture;software construction;domain analysis;component-based software engineering;computer science;computer architecture;resource-oriented architecture;software design description;domain-specific software architecture;model-driven architecture	SE	-52.37862026998547	26.060329109801124	151790
59b448f4a255f4bbbef525778c3fa45fac9a8ee7	strategies for sustainable mt for basque: incremental design, reusability, standardization and open-source		We present some Language Technology applications that have proven to be effective tools to promote the use of Basque, a European less privileged language. We also present the strategy we have followed for almost twenty years to develop those applications as the top of an integrated environment of language resources, language foundations, language tools and other applications. When we have faced a difficult task such as Machine Translation to Basque, our strategy has worked well. We have had good results in a short time just reusing previous works for Basque, reusing other open-source tools, and developing just a few new modules in collaboration with other groups. In addition, new reusable tools and formats have been produced.	comparison of command shells;continuous design;language technology;machine translation;open-source software	Iñaki Alegria;Xabier Arregi;Xabier Artola;Arantza Díaz de Ilarraza;Gorka Labaka;Mikel Lersundi;Aingeru Mayor;Kepa Sarasola	2008			simulation	PL	-51.73178140514904	30.704947455318493	151981
e2a6060f7e1ce7998490c6dd425fc88570d51da7	a layered structure for uniform version management in component based systems	life cycle;component based systems;version control tools;satisfiability;software components;version control system;development tool;layered structure;component framework;software component;version management;version model;version control;visual version control tool vvct;open source	The prerequisite of component-based systems is to manage the life-cycle evolution of software components. As there are multiple versions of constituent components, a need exists to keep track of them. Various version control systems, either in the form of open-source or commercial, are available in the market to maintain the evolution history of multiple versions of constituent components with respect to component-based applications. This paper dis-cusses the requirements of a version control framework and then presents a generic framework that can handle multiple versions of different types of components. The prototype framework named as Visual Version Control Tool (VVCT), for the management of life-cycle evolution of heterogeneous component systems, is developed and tested using .NET environment. The developed tool satisfies all the conditions required for uniform version management and also becomes the basis for version model, which can be used to control the different revisions or variants of the same component in the evolving system.	component-based software engineering;control system;limbo;open-source software;prototype;requirement;version control	Parminder Kaur;Hardeep Singh	2009	ACM SIGSOFT Software Engineering Notes	10.1145/1640162.1640167	reliability engineering;computer science;revision control;systems engineering;backporting;component-based software engineering;database;programming language	SE	-54.28439677180681	29.211799755867144	152337
afefe5db1ce737ce29e99a51b8dd5403fc614c74	tutorial 2: the method framework for engineering system architectures (mfesa): a practical way to generate effective and efficient project-specific system architecture engineering methods	method engineering;system architecture system architecture engineering method engineering;component based software;engineering system;system architecture engineering;system architecture	This 1/2 day tutorial presents a new proposed method framework and associated repository of reusable method components for creating appropriate project-specific methods for engineering system architectures. Several MFESA tasks directly involve component-based software-intensive systems in that they involve the identification and analysis of potential reusable architectural work products including patterns, models, and architectural components.	component-based software engineering;mit engineering systems division;method framework for engineering system architectures;systems architecture	Donald Firesmith	2008	Seventh International Conference on Composition-Based Software Systems (ICCBSS 2008)	10.1109/ICCBSS.2008.41	enterprise architecture framework;reference architecture;software architecture;architecture description language;architecture tradeoff analysis method;database-centric architecture;mechatronics;system of systems engineering;architectural pattern;systems engineering;engineering;applications architecture;software engineering;hardware architecture;solution architecture;software architecture description;view model;systems architecture;computer engineering;systems design	SE	-52.126527471896594	26.650786570541104	152422
61ab941e4ff45e14300016e91cf2c22e599654c0	a test class framework for generating test cases from z specifications	test data;tcgs test class framework z specifications object oriented concept test framework test data oracles test case generation system;formal specification;oracles;test case generation system;tcgs;test class framework;test case generation;program testing;object oriented;computer aided software engineering formal specifications system testing software testing materials testing life testing object oriented modeling software design data mining software engineering;specification tests;test framework;object oriented concept;z specifications;program testing formal specification	This paper introduces test classes and a test class framework for generating test cases from Z specifications. We define a test class using object-oriented concept in test framework instead of Phil Stock's test template. Our test framework for Z specifications uniformly defines the test data and oracles in a test class that also contains the information of before states and after states for an operation. Thus, the derivation and construction of test case and test sequence information can be unified in a test framework. We present an example to demonstrate how to generate test cases using the test framework. To support the framework, we have designed and implemented a test case generation system, TCGS, and its functions are briefly described in the paper.	z notation	Huaikou Miao;Ling Liu	2000		10.1109/ICECCS.2000.873941	reliability engineering;test data;computer science;systems engineering;equivalence partitioning;test suite;formal specification;programming language;object-oriented programming	SE	-54.57415734291867	31.990523731351498	152480
8a877120d9953ca8f77dc402ddbf51a96c2d5a97	tool independent code generation for the uml closing the gap between proprietary models and the standardized uml model	model facade model driven software engineering code generators model transformation meta models unified modeling language uml eclipse modeling framework emf;unified modeling language generators computational modeling analytical models data models embedded systems java;xml application program interfaces embedded systems meta data program compilers source code software unified modeling language;unified modeling language uml;model transformation;eclipse modeling framework emf;meta models;code generators;model facade;model driven software engineering;tool independent code generation embedded software development model based paradigm embedded systems unified modeling language source code generators programming languages standardized extensible markup language metadata interchange format xmi uml tools model transformations application programming interface api standardized uml model	Embedded software development is moving towards the model-based paradigm to support the complexity of today's embedded systems, as they become more and more important and omnipresent in our daily lives. In this context, the Unified Modeling Language (UML) is a widely used standard. Code generators can be executed to generate source code from UML models. Usually the code generators are proprietary for one UML tool. If code generators for different targets or programming languages have to be supported by various modeling tools, the wheel must be reinvented. Code generators could use the standardized Extensible Markup Language Metadata Interchange (XMI) format of the UML as a basis. However, tools export their data to XMI differently. Therefore, the paper shows how the proprietary models of UML tools can be mapped to a standardized UML model. This is realized by using techniques for model to model transformations. These techniques need a meta-model for the source and the target model. Hence, an approach is introduced for creating meta-models for Application Programming Interfaces (APIs) of UML-tools, which act as a facade. Then the code generators can work with the standardized UML model to generate the source code. This results in an improved scalability of the code generators.	application programming interface;closing (morphology);code generation (compiler);embedded software;embedded system;list of unified modeling language tools;markup language;metamodeling;model transformation;programming language;programming paradigm;scalability;software development;uml tool;xml metadata interchange	Arne Noyer;Padma Iyenghar;Elke Pulvermüller;Florian Pramme;Joachim Engelhardt;Benjamin Samson;Gert Bikker	2014	2014 9th International Conference on Evaluation of Novel Approaches to Software Engineering (ENASE)		metamodeling;model-driven architecture;uml state machine;systems modeling language;uml tool;computer science;theoretical computer science;applications of uml;class diagram;database;shlaer–mellor method;programming language;node;object constraint language;source code	SE	-49.11512729766986	26.455258467743626	152510
77a7c47d021551699b81bfcceabbb9a130015bee	applying formal concepts analysis to the construction and evolution of domain frameworks	formal specification;life cycle;software libraries;development process;software reusability formal concepts analysis domain framework construction class library analysis tool;software reusability;software reusability formal specification software tools software libraries;software tools;object oriented modeling graphical user interfaces collaboration process design software libraries software engineering filling xml conferences;formal concept analysis	Framework development is a hard process. Hardness increases when dealing with domain frameworks, which should be quickly adapted to the changing requirements of the business areas they model. We show a development process especially designed for this kind of frameworks. Thanks to the formal support provided by some techniques, based on formal concepts analysis, and thanks to the set of tools that implement them, the process provide an automatic support for the construction of domain frameworks. Taking this process (of domain frameworks construction) as starting point, we propose the generalization of the employed techniques to support the whole framework life cycle. The different phases of the proposed process are analyzed with detail, making special emphasis in their automatic aspects. A tool in experimental phase is also described. Then, some results of using the tool for the analysis of a class library, are presented as case study.		Félix Prieto;Yania Crespo;José Manuel Marqués Corral;Miguel A. Laguna	2003		10.1109/IWPSE.2003.1231221	domain analysis;biological life cycle;reusability;personal software process;software requirements specification;verification and validation;formal methods;software engineering process group;computer science;systems engineering;formal concept analysis;package development process;software design;social software engineering;software framework;component-based software engineering;software development;feature-oriented domain analysis;software engineering;domain engineering;software construction;formal specification;computer-aided software engineering;goal-driven software development process;software development process;computer engineering	Logic	-52.688459534131	26.510634193669436	152611
d48f83a31a7b943f5fd6f80b02473db0f47ddc05	reusing class-based test cases for testing object-oriented framework interface classes	specification based testing;object oriented framework;class testing;reusable test cases;framework interface classes fics	An application framework provides a reusable design and implementation for a family of software systems. Frameworks are introduced to reduce the cost of a product line (i.e., family of products that share the common features) and to increase the maintainability of software products through the deployment of reliable large-scale reusable components. A key challenge with frameworks is the development, evolution and maintenance of test cases to ensure the framework operates appropriately in a given application or product. Reusable test cases increase the maintainability of the software products because an entirely new set of test cases does not have to be generated each time the framework is deployed. At the framework deployment stage, the application developers (i.e., framework users) may need the flexibility to ignore or modify part of the specification used to generate the reusable class-based test cases. This paper addresses how to deal effectively with the different modification forms such that the use of the test cases becomes easy and straightforward in testing the Framework Interface Classes (FICs) developed at the application development stage. Finally, the paper discusses the fault coverage and examines experimentally the specification coverage of the reusable test cases.	application framework;experiment;fault coverage;hooking;method (computer programming);norm (social);prototype;semiconductor industry;software deployment;software release life cycle;software system;system under test;template method pattern;test case	Jehad Al Dallal;Paul G. Sorenson	2005	Journal of Software Maintenance	10.1002/smr.308	reliability engineering;real-time computing;systems engineering;engineering;software engineering	SE	-55.30934597274464	31.279752707413426	152619
6bbac3e8a5b8fddf0394c3240560bcc232734c92	taming emf and gmf using model transformation	graphical modeling framework;tool support;model transformation;feature model;conference item;modelling language;inconsistency fixing;interconnect modeling;product quality;eclipse modeling framework;priority;open source	EMF and GMF are powerful frameworks for implementing tool support for modelling languages in Eclipse. However, with power comes complexity; implementing a graphical editor for a modelling language using EMF and GMF requires developers to hand craft and maintain several low-level interconnected models through a loosely-guided, labour-intensive and error-prone process. In this paper we demonstrate how the application of model transformation techniques can help with taming the complexity of GMF and EMF and deliver significant productivity, quality, and maintainability benefits. We also present EuGENia, an open-source tool that implements the proposed approach, illustrate its functionality through an example, and report on the community's response to the tool.	cognitive dimensions of notations;eclipse modeling framework;graphical modeling framework;graphical user interface;high- and low-level;model transformation;modeling language;open-source software	Dimitrios S. Kolovos;Louis M. Rose;Saad bin Abid;Richard F. Paige;Fiona A. C. Polack;Goetz Botterweck	2010		10.1007/978-3-642-16145-2_15	real-time computing;simulation;computer science;systems engineering;engineering;software engineering;programming language;feature model	SE	-50.525583178629205	25.54903078848882	154008
0a0d6d33de7b58bb76d67fa08fba949a991d6e29	architectural mismatch or why it's hard to build systems out of existing parts	programming language;probability density function;data mining;software engineering	Many would argue that future breakthroughs in software productivity will depend on our ability to combine existing pieces of software to produce new applications. An important step towards this goal is the development of new techniques to detect and cope with mismatches in the assembled parts. Some problems of composition are due to low-level issues of interoperability, such as mismatches in programming languages or database schemas. However, in this paper we highlight a different, and in many ways more pervasive, class of problem: architectural mismatch. Specifically, we use our experience in building a family of software design environments from existing parts to illustrate a variety of types of mismatch that center around the assumptions a reusable part makes about the structure of the application in which is to appear. Based on this experience we show how an architectural view of the mismatch problem exposes some fundamental, thorny problems for software composition and suggests possible research avenues needed to solve them.	database schema;function composition (computer science);high- and low-level;interoperability;pervasive informatics;programming language;software design	David Garlan;Robert Allen;John Ockerbloom	1995	1995 17th International Conference on Software Engineering	10.1145/225014.225031	probability density function;architectural pattern;computer science;systems engineering;engineering;software development;operating system;software engineering;data mining;programming language;engineering drawing	SE	-53.785493146359	27.913431583777655	154186
8884d4823dedaa4a38a6057644a4fa660a3a5033	marmi-re: a method and tools for legacy system modernization	developpement logiciel;outil logiciel;software tool;legacy software;migration;software systems;logiciel patrimonial;software evolution;reingenieria;reingenierie;desarrollo logicial;logicial herencia;software development;information system;herramienta software;legacy system;reengineering;systeme information;migracion;before present;sistema informacion	Software evolution is the process of adapting an existing software system to conform to an enhanced set of requirements. Software reengineering is software evolution performed in systematic way. Especially software system is fundamentally different from developing one from scratch. Consequently, tools to support evolution must go beyond forward engineering tools. This paper presents a reengineering method and tools for software evolution or modernization. The paper briefly describes MARMI-RE methodology before presenting the individual tools and how they interoperate to support legacy system modernization. We expect that our proposed methodology can be used flexibly because it presents various scenarios of migration process.	code refactoring;expect;interoperability;legacy system;model-driven architecture;requirement;software evolution;software system	Eun Sook Cho;Jung-Eun Cha;Young Jong Yang	2004		10.1007/11668855_4	personal software process;software modernization;software requirements specification;verification and validation;software engineering process group;computer science;systems engineering;engineering;package development process;backporting;software evolution;social software engineering;software development;software engineering;software construction;database;software deployment;computer-aided software engineering;legacy system;software requirements;software archaeology;software system	SE	-55.09066255239463	26.267722275062187	154920
0a651b3f4d56dcd3d8f2cc3871f43b700c3a774a	deceived by ease of use: using paradigmatic applications to build visual design environments	application framework;design process;building block;visual design;ease of use;graphical representation;system architecture	Application frameworks for visual design environments usually offer a wide range of features and easyto-use mechanisms to develop applications. We observed that sometimes those features deceive application designers: Tempted by the desire to make rapid progress, designers go into too much detail about easy things too early in the process, like graphical representations. After the easy-to-use mechanisms have been exploited, they find themselves stuck and frustrated. Premature design decisions made during the feature-driven phase can corrupt application system architecture or require abandonment of much work. Extensive rework endangers project success. Paradigmatic applications can help to bridge the gap between application framework features and intended application better than manuals or additional features can. As examples and sources for reusable components, this special kind of exemplary applicationsdirects the attention of designers to higher-level building blocks and helps them to avoid premature feature exploitation. We characterize paradigmatic applications and describe their impact on the design process.	application framework;applications architecture;backtracking;continuous design;graphical user interface;high- and low-level;interaction;online and offline;pretext;programming paradigm;requirement;requirements analysis;rework (electronics);shallow parsing;systems architecture;trap (computing);usability	Kurt Schneider;Alexander Repenning	1995		10.1145/225434.225454	design process;usability;human–computer interaction;computer science;systems engineering;software engineering;engineering drawing;systems architecture	HCI	-54.29099168008261	29.371286038334457	154993
51257bec685d43ca0d0ec2765089192987fb2def	icer: a tool for finding errors in a uml model	software systems;refinement;software engineering;software architecture;development environment;software development;error detection;property preserving	Detecting errors in an early phase of software development can help to reduce the cost of software systems. Many research attempts presented a fixed set of rules to help finding errors in a model. However, flexibility is one of the characteristics during software development. The correctness of a model usually depends on many factors such as development environments. The predefined rules usually fail to provide such flexibility. This paper will apply the idea from YACC/BISON to allow software engineers to define the validity of their application models in a profile. Central to the profile mechanism is the instance-of relation, which is established between an application model and a profile. As a result, engineers can first define the validity of an application in a profile and thus find errors in a model when the model is not a valid instance of the profile. Based on the profile mechanism, we build a tool, called ICER, which can automatically help developers to check the instance-of relation between a profile and an application model. As an example, we apply the reification of the Factory Method pattern to illustrate how the ICER tool helps to support error detection.	correctness (computer science);error detection and correction;factory method pattern;icer;software development;software engineer;software system;unified modeling language;yacc	Wuwei Shen;Dae-Kyoo Kim	2008		10.1145/1363686.1363870	software architecture;verification and validation;real-time computing;error detection and correction;software sizing;computer science;package development process;software framework;software development;software design description;operating system;software engineering;software construction;database;development environment;refinement;programming language;world wide web;computer security;software development process;software metric;software quality analyst;software system	SE	-54.434493307926424	29.71563228412624	155050
83644c79e42d71d4af7c31dbb0c5530867987b5a	requirements interaction detection using semi-formal methods	telecommunications domain;formal specification;requirements attributes;costs software systems waste management drives time to market large scale systems computer vision programming productivity software quality;software systems;object oriented programming formal specification software reusability;complexity;object oriented programming;time;drives;feature interaction;formal method;computer vision;large scale;feature interaction detection;software reusability;software component reuse;complexity requirements interaction detection semi formal methods software component reuse telecommunications domain requirements attributes feature interaction detection cost time;software component;requirements interaction detection;time to market;productivity;cost;programming;waste management;software quality;large scale systems;semi formal methods	Increased pressure to reduce time-to-market has resulted in an increased effort to reuse previously developed software components when developing new software systems. However, in numerous cases, reuse has resulted in interactions between features and/or requirements. As the amount of reuse increases, interaction detection becomes a more and more challenging subject. Although feature interaction is not a new problem and has already been researched especially in the telecommunications domain where new features are added to large-scale base systems, relatively little research has been done outside of telecommunications. The aim of this paper is to introduce a systematic approach for the detection of interactions based on requirements attributes. This systematic approach is part of a three-level framework that offers several approaches to feature-interaction detection in any domain at different levels of cost, time and complexity. The approach is illustrated using a case study.	formal methods;requirement;semiconductor industry	Mohamed Shehata;Armin Eberlein	2003		10.1109/ECBS.2003.1194803	reliability engineering;embedded system;programming;productivity;complexity;real-time computing;formal methods;computer science;systems engineering;component-based software engineering;operating system;software engineering;domain engineering;formal specification;programming language;object-oriented programming;software quality;software system	Robotics	-55.1567371415415	28.417630555418153	155659
5c23d13dec92f808a439032c1a300202c315db69	aspect-oriented modelling for distributed systems	uml;aspect oriented modeling;model based testing;robustness;marte;search algorithms	Aspect-Oriented Modelling techniques allow a modeller to describe within a single aspect model all model elements that define the structural and/or behavioural properties of a concern. When applied to a base model, the model weaver ensures that the entire aspect is reflected in the woven model. While this is essential for centralized systems, it is not the case when model elements of a concern are scattered over nodes in a distributed system. We propose an extension to our Reusable Aspect Models that allows the modeller to augment an aspect model of a concern that can crosscut the nodes of a distributed system with distribution role definitions. A distributed system configuration file specifies the different node types of the distributed system, and which roles of a distributed aspect are assigned to which nodes. The weaver makes sure that every role of a distributed aspect is assigned to at least one node in the system to ensure consistent aspect use. The weaver then generates for each node a final application model that only contains the model elements pertaining to the distribution roles the node plays.	aspect-oriented software development;centralized computing;distributed computing;modeller;system configuration	Wisam Al Abed;Jörg Kienzle	2011		10.1007/978-3-642-24485-8_10	unified modeling language;model-based testing;simulation;computer science;systems engineering;engineering;software engineering;programming language;engineering drawing;robustness;search algorithm	Networks	-50.59773213454715	27.029815423043768	156402
45752b875f15617f1226f15be51db48041fb9e83	search-based model transformations with momot		Many scenarios require flexible model transformations as their execution should of course produce models with the best possible quality. At the same time, transformation problems often span a very large search space with respect to possible transformation results. Thus, guidance for transformation executions to find good solutions without enumerating the complete search space is a must. This paper presents MOMoT, a tool combining the power of model transformation engines and meta-heuristics search algorithms. This allows to develop model transformation rules as known from existing approaches, but for guiding their execution, the transformation engineers only have to specify transformation goals, and then the search algorithms take care of orchestrating the set of transformation rules to find models best fulfilling the stated, potentially conflicting transformation goals. For this, MOMoT allows to use a variety of different search algorithms. MOMoT is available as an open-source Eclipse plug-in providing a non-intrusive integration of the Henshin graph transformation framework and the MOEA search algorithm framework.		Martin Fleck;Javier Troya;Manuel Wimmer	2016		10.1007/978-3-319-42064-6_6	computer science;model transformation;machine learning;search algorithm;artificial intelligence;graph rewriting;search-based software engineering	DB	-54.95295885800891	30.35235750910741	156732
b68e5aa4b3c88b2e617d3779664627b9a2eab169	model-driven development of qos-enabled distributed applications		The term Quality of Service (QoS) describes how well an application or service performs. Hence, QoS can describe properties such as response time, availability, the level of encryption, throughput etc. QoS is important for multi-media (i.e. video and audio applications) as well as for enterprise applications. The presented work focuses on QoS-aware enterprise applications. Enterprise applications are concerned with business transactions such as ordering a product or transferring money between two accounts. QoS properties of enterprise applications determine, for example, how many transactions the system can handle in a certain time frame, how many concurrent users it can serve, or how available the system will be. Middleware tools and libraries shield the developer almost completely from the realization of distribution. In an ideal world, QoS-enabled middleware could do the same for QoS, i.e. the developer does not have to care how QoS is realized. However, the design of an application is highly dependent on its QoS properties. This means that QoS must be tackled at the design phase and this is not possible with an approach solely based on QoS-enabled middleware. This thesis shows how a model-driven approach can overcome this limitation. The development starts with a platform independent model (PIM), which describes the behavior and QoS properties of an application. This model is automatically transformed by a model transformation into a platform specific model (PSM). The PSM describes the design for a concrete implementation on a specific platform, i.e. operating system, programming language, and middleware. Due to the automatic model transformation, tools can influence the platform-specific design and take care of the PIM QoS properties. To realize this scenario, two problems had to be solved: the modeling of QoS properties in the PIM and the model transformation. Current approaches to model transformation require in depth knowledge of the modeling language and its internals. To simplify the construction of transformers, the visual rule-based transformation language Kafka and associated tools based on graph transformation theory have been developed throughout this thesis. Kafka simplifies the implementation of transformers because it builds on the notation of the PIM and the PSM. Hence, it shields the developers of model transformers from the internals of the modeling languages, i.e. the meta models. To create PIMs of QoS-aware applications, a modeling language called PIQML has been developed which is based on UML 2.0 components, hierarchical message sequence charts, and a novel meta model extension for QoS contracts. The thesis shows how PIQML models can be mapped to several target platforms, i.e. programming languages and middleware products. Based on PIQML and Kafka, the CASE tool Kase has been developed which integrates the editing of PIQML models (i.e. PIMs), UML models (i.e. PSMs), and Kafka transformations. The result is an integrated tool chain for the model-driven development of QoS-aware distributed applications.	care-of address;computer-aided software engineering;distributed computing;encryption;enterprise software;graph rewriting;library (computing);logic programming;message sequence chart;metamodeling;middleware;model transformation;model-driven architecture;model-driven engineering;operating system;platform-independent model;platform-specific model;quality of service;regular expression;response time (technology);system programming language;throughput;toolchain;transformation language;transformation theory;transformers;unified modeling language	Torben Weis	2004			applied mathematics;computer science;computer engineering	Embedded	-49.221806549437076	25.77039398877919	156914
a98f4017d7ca6e15291f1872dd218510dceeabdc	solving a problem in grid applications: using aspect oriented programming	software platform;grid applications;power method;software architecture;aspect oriented programming;source code;grid computing	Aspect Oriented Programming (AOP) was introduced 10 years ago and many research projects have focused on broadening AOP and its target areas. However, few applications in the Grid computing world adopt AOP in comparison with very vigorous research of AOP. Therefore, we present a case study that covers a general networking problem in the Grid computing. AOP provides a novel solution of the problem without modifying existing source code. Aspects that we define are simple, intuitive and reusable. We believe that our implementation is very useful in developing other Grid computing software platforms, and AOP can be a powerful method in modularizing source codes and solving problems of software architectures.	aspect-oriented programming;code;grid computing;software architecture	Hyuck Han;Shin Gyu Kim;Hyungsoo Jung;Heon Young Yeom	2007		10.1007/978-3-540-72590-9_102	software architecture;real-time computing;aspect-oriented programming;power iteration;computer science;theoretical computer science;programming language;grid computing;source code	HPC	-52.612029556476436	30.35877203112271	156940
372071cf4d8cf3cccb20285c1eb9c9f471c25d2f	requirements-driven modelling as a means of controlling change in object-oriented systems			requirement	Christopher Watson	1996				Logic	-50.3185906570986	27.376892488211556	157134
3faaa623adc47cba0ea64394fbad498337765277	composite design patterns	weak pointers;resource management;object oriented framework;garbage collection;design pattern;finzlization;software design pattern;software design	Software design patterns are the core abstractions from successful recurring problem solutions in software design. Composite design patterns are the core abstractions from successful recurring frameworks. A composite design pattern is a pattern that is best described as the composition of further patterns the integration of which shows a synergy that makes the composition more than just the sum of its parts. This paper presents examples of composite patterns, discusses a role-based analysis and composition technique, and demonstrates that composite patterns extend the pattern idea from single problem solutions to object-oriented frameworks.	composite pattern;software design pattern;synergy	Dirk Riehle	1997		10.1145/263698.263739	software design pattern;real-time computing;state pattern;behavioral pattern;architectural pattern;computer science;software design;resource management;object-oriented design;interaction design pattern;database;design pattern;distributed design patterns;garbage collection;programming language;structural pattern;composite pattern;specification pattern;creational pattern	PL	-51.36461912199547	28.11963394607945	158392
7041a0428da6c1f45cef9bce5dc31efb4a7e1b0d	dynamic software product line engineering: a reference framework	variability management;runtime adaptation;dynamic software product line;self adaptive software;survey	Runtime adaptive systems are able to dynamically transform their internal structure, and hence their behavior, in response to internal or external changes. Such transformations provide the basis for new functionalities or improvements of the non-functional properties that match operational requirements and standards. Software Product Line Engineering (SPLE) has introduced several models and mechanisms for variability modeling and management. Dynamic software product lines (DSPL) engineering exploits the knowledge acquired in SPLE to develop systems that can be context-aware, post-deployment recon ̄gurable, or runtime adaptive. This paper focuses on DSPL engineering approaches for developing runtime adaptive systems and proposes a framework for classifying and comparing these approaches from two distinct perspectives: adaptation properties and adaptation realization. These two perspectives are linked together by a series of guidelines that help to select a suitable adaptation realization approach based on desired adaptation types.	adaptive system;addendum;heart rate variability;linear algebra;requirement;software deployment;software product line;taxonomy (general);titanium nitride	Mahdi Bashari;Ebrahim Bagheri;Weichang Du	2017	International Journal of Software Engineering and Knowledge Engineering	10.1142/S0218194017500085	real-time computing;simulation;computer science;systems engineering;software engineering	SE	-54.47742166864172	27.440802687885576	158486
38f3c1ff3fc4ae64d835551a9137517779962f0c	an object-oriented testing and maintenance environment	nested graphs;system testing permission power engineering and energy computer science object oriented modeling visualization computer displays marine vehicles computational modeling costs;power engineering and energy;visualization;computational modeling;marine vehicles;permission;fisheye views;computer displays;system testing;computer science;object oriented modeling;graph editor;object oriented testing;reverse engineering;software visualization	Object-oriented paradigm provides the power for software development but at the same time introduces some brand new problems. These problems include 1) the understanding problem; 2) the complex interdependency problem; and 3) the object state behavior testing prob km. In an attempt to solve these problems, the Software Engineering Center for Telecommunications at the University of Texss at Arlington has undertaken a major effort to develop an environment for object-oriented testing and maintenance [l] [2] [3]. Central to the environment is a formal test model consisting of three diagrams: a) the object relation diagram (ORD), which represents the relationships among classes in the source code; b) the object state diagram (OSD), which describes the state behavior of au object class; and c) the block branch diagram (BBD), which represents the control structure of a member function and its interface.	bucket-brigade device;control flow;emoticon;interdependence;method (computer programming);object storage;programming paradigm;software development;software engineering;state diagram	Pei Hsia;David Chenho Kung	1997		10.1145/253228.253497	software visualization;simulation;visualization;computer science;systems engineering;theoretical computer science;operating system;software engineering;programming language;management;computational model;system testing;reverse engineering;predictive maintenance	SE	-49.623525815693704	28.25399305482794	158754
41d69ff40af1f625f8195f14b5501db43f2f7f78	woped goes nlp: conversion between workflow nets and natural language		WoPeD (Workflow Petrinet Designer) is an open-source Java software for designing business processes in terms of workflow nets, a common extension of Petri nets. This demo lays the focus on two recently added features making use of Natural Language Processing (NLP) algorithms in order support the conversion of a graphical process model into a textual process description and vice versa.	algorithm;business process;graphical user interface;java;natural language processing;open-source software;petri net;process modeling	Thomas Freytag;Philip Allgaier	2018			natural language processing;natural language;workflow;computer science;artificial intelligence	NLP	-48.34219452589173	25.381926613462074	159068
1281e4fd535f764f19443bb79efc6b6e3bc96836	dynamic evolution of distributed systems specifications using reflective language	distributed system;formal specification;executable specification;distributed processing;abstract data types;object oriented programming;specification language;formal description technique;distributed processing object oriented programming object oriented languages formal specification abstract data types;modification operations dynamic evolution distributed systems specifications reflective language object oriented approach system construction formal description techniques dynamic modification executable specifications two level model object oriented specifications behavioral constraints specification consistency reflective object oriented specification language mondel meta objects;object oriented;object oriented modeling specification languages software systems software maintenance art software performance software tools genetic programming application software software engineering;object oriented approach;type classes;object oriented languages	The object-oriented approach is known by its flexibility for system construction. Current work has not addressed the dynamic modifications of specifications of distributed systems. We are concerned with formal description techniques that allow for the development and the dynamic modification of executable specifications. A two level model for the evolution of large object-oriented specifications is introduced. The first level deals with the dynamic modifications of types (classes), while the second level deals with modifications of modules. We have defined a set of structural and behavioral constraints to ensure the specification consistency after its modification at both levels. To allow for dynamic modification of types and modules, we have developed a reflective object-oriented specification language (Mondel) which uses meta objects to support the modification operations. >		Issam A. Hamid;Mohammed Erradi	1994		10.1109/APSEC.1994.465259	formal methods;object language;specification language;computer science;systems engineering;formal specification;database;programming language;object-oriented programming;language of temporal ordering specification;object definition language	DB	-48.46467651226817	28.83608496850699	160217
791845a32b65f0318aefefff90aa76e0b3919440	developing tools as plug-ins: topi 2011 special issue editorial	development environments;software engineering;plug ins;eclipse;tools;visual studio	SUMMARY#R##N##R##N#Our knowledge of how to solve software engineering problems is increasingly being encapsulated in tools. These tools are at their strongest when they operate in a pre-existing integrated development environment (IDE). This approach allows integration with existing elements such as compilers, debuggers, profilers, visualizers, and numerous other development and, often, runtime tools. Tools and environments to increase software quality and productivity have always been an important aspect of software engineering. A plug-in is a modern way for incrementally adding new tools into existing environments. However, building tools as plug-ins can be challenging. How do they interact with the core environment? How do they interact with one another - especially since each developer may choose a different set of plug-ins? How can we share tools across different, and future, core development environments?		Judith Bishop;David Notkin	2013	Softw., Pract. Exper.	10.1002/spe.2191	eclipse;plug-in;computer science;systems engineering;engineering;operating system;software engineering;programming language	Vision	-52.94378529260114	28.79304953772069	160308
7e4f5577d05b5007c643ebb6c6da4ebddf498199	domain-driven software development - a world of transformations	domain driven software development;modeling technique;omg standard domain driven software development abstraction tool support programming language domain specific language software modeling unified modeling language object management group;programming language;tool support;software modeling;omg standard;computer model;separation of concern;software systems;abstraction;software engineering;computational modeling;visual modeling;software development;unified modeling language;object management group;domain specific language;system testing;software tools;space technology;time to market;programming unified modeling language space technology domain specific languages software systems documentation system testing costs time to market computational modeling;software tools software engineering unified modeling language;programming;documentation;domain specific languages	Software development teams are faced with bridging the gap between the problem, as envisaged by the stakeholders and constrained by the environment, and a software solution, which is built upon the abstractions offered by current software technologies. Unfortunately, too often the abstractions offered are limited and disparate with respect to the problem space. Reducing this gap would facilitate more sophisticated problems to be tackled in software development projects, and it would comparatively reduce development costs and time-to-market, and remove errors caused by the disparity. In this talk, I will explore a number of techniques for improving current software development practice, which relate to the theme of domain-driven software development. Domain-driven software development is concerned with making use of languages that better capture the problem by using abstractions that are more familiar to experts in the domain. These domain-specific languages are made executable either directly (compilation or interpretation) or through tool-supported refinement/elaboration to computational models that can be executed, e.g., to a mainstream programming language where one can make use of existing frameworks, components, services, etc. In the later case, real value is added to software development only if we can automate as much as possible the transformation step(s). Automating these steps requires languages that can express such transformations in a concise and maintainable manner. The principles of abstraction, separation of concerns, and problem decomposition are essential in providing intuitive and manageable domain-specific languages. The practice of software modeling has become a significant way of applying these principles to software development. Over the last few years, the software development industry has gone through the process of standardizing visual modeling notations. The Unified Modeling Language (UML) is the product of this effort, and it unifies scores of notations that were proposed in the '80s and '90s. The language has gained significant industry support and became an object management group (OMG) standard in 1997. Nowadays, the majority of software modeling techniques and approaches use UML.	binocular disparity;bridging (networking);compiler;computation;computational model;domain-specific language;executable;problem domain;programming language;refinement (computing);sms language;separation of concerns;software development;unified modeling language;visual modeling	Shane Sendall	2004	Proceedings. 15th IEEE International Workshop on Rapid System Prototyping, 2004.	10.1109/RSP.2004.20	computer simulation;computer science;systems engineering;domain-specific language;package development process;backporting;software design;social software engineering;software framework;component-based software engineering;software development;software design description;operating system;software engineering;software construction;software walkthrough;programming language;software analytics;resource-oriented architecture;software deployment;goal-driven software development process;software development process;software metric;avionics software	SE	-53.01936888950378	27.339743460123856	160445
174b408b35ddbc12c8cbbc13de2609333045ba30	preface: object-oriented software engineering - foundations and techniques	object oriented software engineering		software engineering	John D. McGregor	1996	Ann. Software Eng.		feature-oriented domain analysis;software development;software construction;software system;software engineering;resource-oriented architecture;systems engineering;component-based software engineering;computer engineering;software requirements;computer science;social software engineering	SE	-51.59687203361399	27.407547096711248	160515
a07b6e11afcbce7f403df33507c985a4333b285a	generating domain specific graphical modeling editors from meta models	mda tools;formal specification;domain specific modeling;uml metamodel;uml2 0 representation;vendor supported technology;unified modeling language formal specification software reusability;automatic generation;domain specific graphical metaphor;domain specific modeling constraint;domain specific operator;software reusability;unified modeling language;eclipse framework;application aware graphical modeling;graphical model;eclipse framework application aware graphical modeling metamodel specification domain specific graphical metaphor domain specific modeling constraint domain specific operator uml metamodel uml2 0 representation vendor supported technology mda tools;unified modeling language application software programming costs automation information management documentation computer languages computer applications software tools;domain specificity;meta model;metamodel specification	We describe an approach for automatically generating application aware graphical modeling environments from the meta-model specification of an application domain. A generated graphical modeling environment: a) provides domain-specific graphical metaphors in the modeling palette, b) imposes domain-specific modeling constraints to prevent semantically incorrect models, and c) provides domain-specific operators and languages to capture application domain constraints. The domain meta-model is specified using a meta-model which is an extension of the UML meta-model. One of the major advantage of using application domain-specific modeling environment is to make it easy for business analyst to create semantically correct models. We use UML2.0 to specify the domain metamodel. The advantage of using UML2.0 representation is the reuse of vendor-supported technologies including MDA tools. An implementation using the Eclipse framework is also discussed	application domain;closed system;computer graphics;domain-specific language;domain-specific modeling;eclipse;emoticon;enterprise information system;graphical user interface;high- and low-level;metamodeling;model-driven architecture;palette (computing);process modeling;requirement;subject-matter expert;unified modeling language;waterfall model	Rabih Zbib;Ashish Jain;Devasis Bassu;Hiralal Agrawal	2006	30th Annual International Computer Software and Applications Conference (COMPSAC'06)	10.1109/COMPSAC.2006.48	metamodeling;unified modeling language;computer science;systems engineering;software engineering;formal specification;database;graphical model;programming language	SE	-49.3925471420336	26.2295393216006	160867
063a2de8399267df202919582f2f8af67051ad97	incremental development using object oriented frameworks: a case study	incremental development;object oriented framework;code reuse;genetic algorithm	The object oriented framework-based approach is one of the most powerful approaches to incremental development. In this paper we report on our experiences in applying the framework-based approach to the domain of genetic algorithms. Although different genetic algorithm (GA) systems have much in common with each other, each such system is typically designed and implemented from scratch. Our goal was to design an OO framework that included those aspects that are common to different GA systems, with individual GA systems being implemented as applications on top of this framework. We show how such an incremental approach to implementing GA systems not only leads to code reuse but also to reuse of the effort involved in reasoning about the behavior of such systems. We also discuss how the XMLdocumentation mechanism of C# can be used to generate precise documentation for frameworks.	code reuse;documentation;genetic algorithm;iterative and incremental development;software release life cycle	Jason O. Hallstrom;Neelam Soundarajan	2002	Journal of Object Technology	10.5381/jot.2002.1.3.a11	real-time computing;genetic algorithm;computer science;systems engineering;iterative and incremental development;engineering drawing	SE	-54.69745733476387	30.474237741267828	161291
40b893543ff7b07669b4555a6ee0a6876835b527	developing java applications for a nuclear fusion experiment: a test case for java applicability in a demanding environment	software metrics;object oriented design;framework design;software reuse	The paper describes the experience gained in the development of Java applications in a nuclear fusion experiment. Two Java tools for graphical data display and experiment configuration set-up are presented as case studies. Based on these tools, the results derived by the application of some metrics for object oriented software and by the analysis of the design patterns imported in the applications are presented to highlight the effective code reuse achieved with Java. The main issues in the applicability of Java in a demanding environment are then introduced and a few weaknesses of the language are finally discussed. Copyright  2001 John Wiley & Sons, Ltd.		Gabriele Manduchi	2001	Softw., Pract. Exper.	10.1002/spe.399	computer science;systems engineering;engineering;operating system;object-oriented design;software engineering;strictfp;real time java;programming language;java;software metric;java annotation	SE	-53.268918399009095	31.121488575917883	161514
6ffb09431a36ed9a8549a76855517ad956cb307b	preserving architectural choices throughout the component-based software development process	software testing;performance evaluation;software prototyping;prototypes;software systems;software development process;computer architecture;software architecture;transmitters;system testing;component based software development;programming;programming software architecture transmitters computer architecture software testing system testing software systems software prototyping prototypes performance evaluation	It is argued that architecture comprehension and regression testing of a software system are the most expensive maintenance activities. This is mainly due to the fact that architectural choices are either not explicit, at every stage of the software development process, or not preserved from one stage to another. In this paper, we present an Architectural Constraint Language (ACL) as a means to formally describe architectural choices at all the stages. This language is based on the UML’s Object Constraint Language and on a set of MOF-compliant metamodels. We also present a prototype which validates the proposed approach. It allows the evaluation of ACL expressions at two stages and ensures, by using a transformation mechanism, that the constraints stated at one stage are subsequently preserved.	component-based software engineering;embedded system;meta-object facility;metamodeling;model-driven engineering;object constraint language;prototype;regression testing;software development process;software system;unified modeling language	Chouki Tibermacine;Régis Fleurquin;Salah Sadou	2005	5th Working IEEE/IFIP Conference on Software Architecture (WICSA'05)	10.1109/WICSA.2005.52	reference architecture;software architecture;programming;personal software process;transmitter;computer architecture;verification and validation;architectural pattern;computer science;systems engineering;engineering;package development process;backporting;software design;social software engineering;software reliability testing;software framework;component-based software engineering;software development;software design description;software engineering;software construction;prototype;software testing;programming language;resource-oriented architecture;system testing;software deployment;software development process;software system;software peer review	SE	-49.25075927520393	27.886571802997025	161532
0edb6eaee2139b69944da16696df617d27ff989d	strategies for aligning variability model and architecture	architecture toolkit variability model tool supported approach implicit variability management explicit variability management software products product architecture refactoring strategies systematic alignment;refactoring;software maintenance;refactoring variability model software architecture consistency analysis;software engineering;software tools software architecture software maintenance software product lines;software architecture;software tools;variability model;software product lines;consistency analysis	We have recently developed a tool-supported approach for the transitioning from implicit to explicit variability management of existing software products. Such an approach requires the definition of a variability model that is then linked to the existing product architecture to document how the variability is realized in the architecture. As the existing architecture has typically not been developed with variability in mind, different inconsistencies can occur when linking the variability model to the architecture. In this paper we classify the different inconsistencies, show how they can be detected, and propose different refactoring strategies to support the systematic alignment of variability model and architecture. As a proof-of-concept, the identified strategies have been applied in a first case study of introducing explicit variability management in our own architecture toolkit.	code refactoring;heart rate variability;mind;spatial variability	Iris Groher;Rainer Weinreich	2013	2013 20th Asia-Pacific Software Engineering Conference (APSEC)	10.1109/APSEC.2013.73	enterprise architecture framework;functional software architecture;reliability engineering;reference architecture;software architecture;space-based architecture;verification and validation;database-centric architecture;software sizing;computer science;systems engineering;software development;software design description;software engineering;software construction;hardware architecture;software architecture description;resource-oriented architecture;software maintenance;code refactoring;software quality;systems architecture	SE	-54.96633070757704	27.714410685931124	161613
5ddc0ddb7b403e992a9a14a94672e4ce119afc06	product-line verification with feature-oriented contracts	verification;java modeling language;feature oriented programming;design by contract;software product lines	Software product lines allow programmers to reuse code across similar software products. Software products are decomposed into separate modules representing user-visible features. Based on a selection of desired features, a customized software product can be generated automatically. However, these reuse mechanisms challenge existing techniques for specification and verification of software. Specifying and verifying each product involves redundant steps, and is often infeasible. We discuss how method contracts (i.e., preconditions and postconditions) can be used to efficiently specify and verify product lines.	formal specification;postcondition;precondition;programmer;software product line;verification and validation	Thomas Thüm	2013		10.1145/2483760.2492396	verification and validation;real-time computing;verification;software sizing;software verification;computer science;systems engineering;design by contract;package development process;backporting;software design;software framework;component-based software engineering;software development;software design description;software engineering;java modeling language;software construction;software walkthrough;programming language;software deployment;software system	SE	-55.41016387328769	31.012842259578047	161922
3fb529e37ccd44b3a1f7057b408c549b4c469102	an experimental, pluggable infrastructure for modular configuration management policy composition	additionallyallows reuse;appropriate existing module;acm system;cm system;adesired new cm system;composedfrom small module;reusea generic cm model;cm policy;pluggable infrastructure;system isa difficult endeavor;representativecm system;modular configuration management policy;graphical user interfaces;data structures;lines of code;software inspection;computer science;capture recapture;informatics;data structure;software engineering;configuration management	Building a configuration management (CM) system isa difficult endeavor that regularly requires tens of thousandsof lines of code to be written. To reduce this effort,several experimental infrastructures have been developedthat provide reusable repositories upon which to build aCM system. In this paper, we push the idea of reusabilityeven further. Whereas existing infrastructures only reusea generic CM model (i.e., the data structures used to capturethe evolution of artifacts), we have developed a novelexperimental infrastructure, called MCCM, that additionallyallows reuse of CM policies (i.e., the rules bywhich a user evolves artifacts stored in a CM system).The key contribution underlying MCCM is that a CMpolicy is not a monolithic entity; instead, it can be composedfrom small modules that each address a uniquedimension of concern. Using the pluggable architectureand base set of modules of MCCM, then, the core of adesired new CM system can be rapidly composed bychoosing appropriate existing modules and implementingany remaining modules only as needed. We demonstrateour approach by showing how the use of MCCM significantlyreduces the effort involved in creating several representativeCM systems.	configuration management;data structure;source lines of code	Ronald van der Lingen;André van der Hoek	2004	Proceedings. 26th International Conference on Software Engineering		mark and recapture;data structure;computer science;systems engineering;engineering;operating system;software engineering;software inspection;graphical user interface;database;configuration management;programming language;informatics;source lines of code	SE	-52.296895714850805	30.258026836272492	163537
0864c599c8ebb9fca9ffc550a16f4e62d6b8a238	metaprogrammable toolkit for model-integrated computing	automatic programming;visual modeling;design and implementation;systems analysis;model integrated computing;model integrated program synthesis;complex computer based systems metaprogrammable toolkit model integrated computing model integrated program synthesis visual model building constraint management automatic program synthesis components;application software microwave integrated circuits electrical capacitance tomography software systems buildings costs computer architecture unified modeling language read only memory physics computing	Model-Integrated Computing, specifically Model-Integrated Program Synthesis (MIPS) environments that include visual model building, constraint management, and automatic program synthesis components, are well suited for the design and implementation of complex computerbased systems. However, building such an environment from scratch for each new domain can be cost-prohibitive. This paper presents a toolkit that makes the rapid creation of MIPS environments possible through metaprogramming.	automatic programming;hercules graphics card;metaprogramming;program synthesis;programming paradigm;visual modeling	Ákos Lédeczi;Miklós Maróti;Gabor Karsai;Greg Nordstrom	1999		10.1109/ECBS.1999.755896	embedded system;systems analysis;computer architecture;computer science;engineering;artificial intelligence;theoretical computer science;operating system;software engineering;programming language;computer engineering	PL	-49.45727164363164	28.96260387504166	163850
6a7f2099b7c27c7d2d9ac25b4b9c779e08d397ef	cbse and mde: approaches combination opportunities			component-based software engineering;model-driven engineering	Fatma Messaoud;Sihem Ben Sassi;Henda Hajjami Ben Ghézala	2010				NLP	-51.49449987882136	26.458107551616536	164342
9a4bfadde2649167d8f11dd573e57728fba32277	a pragmatic approach to traceability in model-driven development.	330 wirtschaft	A common problem in model-driven software development processes is the tracing of requirements across different phases of the software development life cycle and multiple levels of abstraction down to the code level. Because debugging at the model level is not feasible yet, unwanted or unexpected behavior of the executable system needs to be analyzed at the code level at run-time and in a feedback loop must be traced back to and handled at the model level. Thus, traceability is a very important success factor and quality criterion in software engineering and maintenance and especially when developing high-quality model-driven infrastructures. In this paper we present the conceptual design and prototypical implementation of a lightweight traceability approach that supports tracing requirements across different models and levels of abstraction. While providing support for representing different types of traceability links between design models and implementation details, our approach can easily be integrated into existing MDSD projects without increasing their complexity.	debugging;executable;feedback;model-driven architecture;model-driven engineering;principle of abstraction;requirement;software development process;software engineering;traceability	Markus Aleksy;Tobias Hildenbrand;Claudia Obergfell;Michael Schwind	2008			systems engineering;software development process;debugging;traceability;conceptual design;abstraction;systems development life cycle;tracing;executable;computer science	SE	-54.90266907196389	28.547164019330413	164510
6916815738d927fb2c3c22b14e50113ca645052d	integrating versions in the omt models	computer aided design;time dependent;software engineering;functional model	This paper shows how to extend the object, dynamic and functional models of the OMT method so that it integrates version modeling capabilities. Thus, this method will suit new database applications relevant to fields such as computer aided design, technical documentation or software engineering where managed data are time-dependant.	computer-aided design;data model;database design;entity–relationship model;software engineering;technical documentation	Eric Andonoff;Gilles Hubert;Annig Le Parc-Lacayrelle;Gilles Zurfluh	1996		10.1007/BFb0019941	computer science;function model;computer aided design;software engineering	SE	-50.38852075938107	27.32850008894759	165648
1d2799c1c1cfeb79fcacc9689b4ef61724dae31c	toward a tool-based development methodology for pervasive computing applications	pervasive computing;simulation;diaspec;computer architecture;software architecture;computational modeling;simulation methodology domain specific language generative programming pervasive computing toolkit programming support;design artifacts tool based development methodology pervasive computing applications distributed systems technologies development life cycle area specific building blocks architectural pattern compiler;taxonomy;domain specific language;ubiquitous computing;development methodology;programming support;generative programming;methodology;program compilers;pervasive computing taxonomy computer architecture programming domain specific languages computational modeling software architecture;programming;diasuite;ubiquitous computing program compilers software architecture;domain specific languages;toolkit	Despite much progress, developing a pervasive computing application remains a challenge because of a lack of conceptual frameworks and supporting tools. This challenge involves coping with heterogeneous devices, overcoming the intricacies of distributed systems technologies, working out an architecture for the application, encoding it in a program, writing specific code to test the application, and finally deploying it. This paper presents a design language and a tool suite covering the development life-cycle of a pervasive computing application. The design language allows us to define a taxonomy of area-specific building-blocks, abstracting over their heterogeneity. This language also includes a layer to define the architecture of an application, following an architectural pattern commonly used in the pervasive computing domain. Our underlying methodology assigns roles to the stakeholders, providing separation of concerns. Our tool suite includes a compiler that takes design artifacts written in our language as input and generates a programming framework that supports the subsequent development stages, namely, implementation, testing, and deployment. Our methodology has been applied on a wide spectrum of areas. Based on these experiments, we assess our approach through three criteria: expressiveness, usability, and productivity.	architectural pattern;compiler;distributed computing;experiment;separation of concerns;software deployment;taxonomy (general);ubiquitous computing;usability	Damien Cassou;Julien Bruneau;Charles Consel;Emilie Balland	2012	IEEE Transactions on Software Engineering	10.1109/TSE.2011.107	computer architecture;computer science;domain-specific language;theoretical computer science;operating system;software engineering;programming language;ubiquitous computing	SE	-52.43895971171204	29.24719414638978	165916
cdad34e34a245b6b46dff0801e201b904c9892dd	incremental development of a high integrity compiler: experience from an industrial development	incremental development;formal specification;application specific processors process design weapons safety defense industry high level languages sparks prototypes design engineering testing;proof techniques incremental development high integrity compiler industrial development pasp pascal like language asp high integrity processor atomic weapons establishment uk separate compilation cost effective development high integrity mathematical specification;target language;cost effectiveness;separate compilation;pascal;program compilers;formal specification program compilers software reliability pascal;software reliability	We have developed and successfully applied a technique to build a high integrity compiler from Pasp, a Pascal-like language, to Asp, the target language for a high integrity processor designed for the UK's Atomic Weapons Establishment at Aldermaston. We overview the technique itself, including a description of how it can be extended to separate compilation. We also describe some of our experiences whilst implementing this compiler, how successful the whole process has been, and the lessons we have learned. We have cost-eectively developed a compiler to high integrity by using mathematical specication and proof techniques.	b-method;compiler;ian cullimore;mathematical optimization;pascal;while	Susan Stepney	1998		10.1109/HASE.1998.731606	reliability engineering;compiler;parallel computing;dynamic compilation;pascal;cost-effectiveness analysis;compiler correctness;computer science;operating system;software engineering;iterative and incremental development;formal specification;programming language;software quality	PL	-49.936754204743536	32.1628708697319	166163
529e16947cdf2f4537a4981a255667339e7cf74d	low-level variability support for web-based software product lines	web systems domain;feature oriented software development;low level variability support for web based software product lines;articulo;software product line engineering;featureide;eclipse plugin;feature composition	The Web systems domain has faced an increasing number of devices, browsers, and platforms to cope with, driving software systems to be more flexible to accomodate them. Software product line (SPL) engineering can be used as a strategy to implement systems capable of handling such a diversity. To this end, automated tool support is almost indispensable. However, current tool support gives more emphasis to modeling variability in the problem domain, over the support of variability at the solution domain. There is a need for mapping the variability between both abstraction levels, so as to determine what implementation impact a certain variability has. In this paper, we propose the FeatureJS, a FeatureIDE extension aiming at Javascript and HTML support for SPL engineering. The tool combines feature-oriented programming and preprocessors, as a strategy to map variability at source code with the variability modeled at a higher level of abstraction. We carried out a preliminary evaluation with an industrial project, aiming to characterize the capability of the tool to handle SPL engineering in the Web systems domain.	feature-oriented programming;html;heart rate variability;javascript;problem domain;software product line;software system;spatial variability;web application;world wide web	Ivan do Carmo Machado;Alcemir Rodrigues Santos;Yguaratã Cerqueira Cavalcanti;Eduardo Gomes Trzan;Marcio Magalhães de Souza;Eduardo Santana de Almeida	2014		10.1145/2556624.2556637	domain analysis;reliability engineering;real-time computing;computer science;systems engineering;feature-oriented domain analysis;software engineering;domain engineering;programming language	SE	-55.35566184290187	31.084309082074842	166969
c4c522b83fe3aeb7c838b8384900018ab5a1244f	formality, evolution, and model-driven software engineering	formal specification;object modelling;formal methods;software engineering;formal method;software development;model driven;object model	This paper introduces an approach to software development in which a series of working implementations are generated automatically from a series of formal specifications. The implementations are data stores, communicating through standard protocols. The specifications are precise object models, in which operations are described in terms of preand post-conditions. The approach is evolutionary, in the sense that the specification may evolve while the system is in use, in response to changes in requirements, and any changes to the specification are automatically reflected in the structure of the implementation, and in the representation of any data currently stored.	data store;formal specification;model-driven architecture;model-driven engineering;requirement;software development;software engineering;technical standard	Jim Davies;Charles Crichton;Edward Crichton;David Neilson;Ib Holm Sørensen	2005	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2005.03.004	software requirements specification;verification and validation;formal methods;object model;formal verification;computer science;software development;formal specification;programming language	SE	-52.479082798974865	27.200909757523753	167039
ef5e7d60453fcd806ab40cf6dd1717549f1e4848	distributed component-based software development strategy integrated by mvcase tool	corba;catalysis;frameworks;distributed cbd;patterns and the mvcase tool.;components;component based software development;component based development;case tool;distributed objects;software engineering;code generation	1 This work is supported by Fundação de Amparo à Pesquisa do Estado da Bahia (Fapesb). ABSTRACT This paper presents a Strategy that integrates different technologies to supports Distributed Component-Based Software Development. The involved technologies are: the Catalysis method, the CORBA pattern to support components distributeds distribute the components, frameworks of components and a CASE tool. The strategy drives the software engineer in two stages: in the development of problem domain components, and in the development of applications that reuse those components.	common object request broker architecture;component-based software engineering;computer-aided software engineering;problem domain;software development;software engineer	Eduardo Santana de Almeida;Calebe De Paula Bianchini;Antônio Francisco do Prado;Luís Carlos Trevelin	2002			resource-oriented architecture;goal-driven software development process;backporting;software development;software framework;computer engineering;package development process;social software engineering;computer science;systems engineering;distributed design patterns	SE	-51.32384578415597	27.53480389560072	168962
7c960b499160357daec3fb70eed1f1eeb45ce461	toward automated retrieval for a software component repository	profile matching;computer science software reusability testing software prototyping prototypes costs programming usability application software electrical capacitance tomography;software libraries;signature matching;information retrieval;automatic programming;retrieval method;pattern matching;software component;signature matching automated retrieval software component repository retrieval methods software reuse profile matching;software reuse;pattern matching software libraries information retrieval automatic programming	Retrieval methods for software component repository are important for software reuse. Many researchers have done a lot of work in this field in the past fifteen years. The paper discusses the improvement of two different aspects of retrieval methods for software components. One is profile matching and the other is signature matching. We show some experimental results assessing the effect of the improvements.	component-based software engineering	Luqi;Jiang Guo	1999		10.1109/ECBS.1999.755867	verification and validation;software sizing;computer science;package development process;backporting;software design;software framework;component-based software engineering;software development;pattern matching;software construction;database;software testing;programming language;software analytics;resource-oriented architecture;software deployment;information retrieval;software quality;software system	SE	-55.47220419514065	32.01262418502577	169300
f374cd5cb03e0e99de9a4cdc3d3406a8caece048	towards an object-oriented design method: application to hydrological database	object oriented design			A. Manea	1995			data mining;object-oriented design;database;computer science	DB	-50.50007173780813	27.80205239913862	169884
e175e907cfe372bebaa17a28beed56c13f964cae	applying aspect-orientation in designing security systems: a case study	security policy;aspect oriented	As a security policy model evolves, the design of security systems using that model could become increasingly complicated. It is necessary to come up with an approach to guide the development, reuse and evolution of the design. In this paper, we propose an aspect-oriented design approach to designing flexible and extensible security systems. A case study demonstrates that such an approach has multifold benefits and is worth further exploration.	aspect-oriented programming;aspect-oriented software development;aspectj;common object request broker architecture;computer security model;formal methods;ibm notes;role-based access control;sensor;separation of concerns;unified modeling language	Shu Gao;Yi Deng;Huiqun Yu;Xudong He;Konstantin Beznosov;Kendra Cooper	2004			aspect-oriented programming;computer science;computer security model;systems engineering;reuse;extensibility;security policy;security service	SE	-51.34305330657088	29.787610777552487	170393
6be059fa6e468454cd22e47126d06486427b72ed	accommodating eis uml 2.0 profile using a standard uml modeling tool	uml modeling tool;information systems;rational software modeler unified modeling language eis uml 2 0 profile uml modeling tool object constraint language enterprise information systems engineering;rational software modeler;unified modeling language systems engineering and theory information systems maintenance engineering software tools power system modeling software standards computer architecture resource management network topology;uml profile;business data processing;enterprise information system;unified modeling language;enterprise information systems engineering;object oriented languages;eis uml 2 0 profile;object constraint language;modeling tool;unified modeling language business data processing information systems object oriented languages	Extension mechanisms offered by UML 2.0 are often explored in order to define UML profiles that serve specific modeling purposes. These UML 2.0 profiles should be effectively accommodated by standard UML-based modeling tools, which provide the means for applying them in practice. Almost every UML 2.0 modeling tool supports the definition of stereotypes and the description of constraints in Object Constraint Language. However, implementing a profile in practice often entails the development of additional functionality. This requirement mainly stems from the fact that when dealing with complex models it is more efficient for end-users to help them enforce a constraint rather than notify them when it is broken. Such issues, encountered when developing a UML 2.0 profile for enterprise information systems engineering using Rational Software Modeler as a standard UML 2.0 modeling tool, are discussed in the paper.	application programming interface;computation;enterprise information system;fat client;interoperability;java;object constraint language;parsing;plug-in (computing);profile (uml);rational software modeler;response surface methodology;stereotype (uml);systems design;systems engineering;uml tool;unified modeling language;xml metadata interchange	Mara Nikolaidou;Nancy Alexopoulou;Anargyros Tsadimas;Alexandros Dais;Dimosthenis Anagnostopoulos	2007	International Conference on Software Engineering Advances (ICSEA 2007)	10.1109/ICSEA.2007.13	metamodeling;unified modeling language;model-driven architecture;rm-odp;uml state machine;communication diagram;systems modeling language;uml tool;computer science;systems engineering;element;applications of uml;class diagram;object-role modeling;database;shlaer–mellor method;modeling language;programming language;object-oriented programming;node;information system;use case points;object constraint language;enterprise information system	SE	-49.63157827469195	25.814543558421416	170503
28adf5da867d596ae6c74927642815216c3b26b1	software evolution through iterative prototyping	online resources;information resources;scholarly research;computer languages;software prototyping prototypes user interfaces computer languages programming machinery software engineering system performance information analysis;information sources;academic research;programming language;software prototyping;user interface;online databases;prototypes;education resources;publishing;software systems;research databases;software engineering;system performance;software evolution;australasian research information;south east asian information;information databases;full content;education databases;australian databases;commissioning;machinery;electronic publisher;programming;information analysis;user interfaces;program development;online;e titles;library resources	The process of developing and evolving complex software systems is intrinsically exploratory in nature. Some prototyping activity is therefore inevitable in every stage of that process. Our program development and evolution methodology is predicated upon this observation. In this methodology, a prototype software system is developed as an approximation to an envisioned target system by compromising along one or more of the following dimensions: system performance, system functionality, or user interface. However, the prototype is not the end-product of the pro- cess. Instead, we support iterative evolution of the prototype towards the envisioned system by gradually dealing with the three general areas of compromise. This paper describes the methodology of using this al- ternative lifecycle; to wit, the programming language concepts and related implementation technology that support practice of the suggested methodology. We summarize the lessons we have learned in building and using this technology over the last several years.	approximation;emoticon;federated database system;iteration;iterative design;iterative method;list of toolkits;programmer;programming language;prototype;software evolution;software system;user interface	Neil M. Goldman;Khaled Narayanaswamy	1992	International Conference on Software Engineering	10.1145/143062.143109	human–computer interaction;computer science;systems engineering;engineering;operating system;software engineering;computer performance;programming language;user interface	SE	-55.16224234740959	29.262474932443443	171155
68c896a3bd7c542f69801f914654de885af014d8	context modeling to enforce interoperability in web service definition	xml open systems software architecture unified modeling language web services;web service definition language;uml;web service;iec;context model;software architecture;uml profile;unified modeling language;web services;xml;context modeling web services unified modeling language context aware services power system modeling computer integrated manufacturing iec service oriented architecture xml payloads;xml schema definition;payloads;web service definition language context modeling interoperability uml xml schema definition;interoperability;physical model;power system modeling;service oriented architecture;open systems;context modeling;computer integrated manufacturing;context aware services	Context modeling using a UML profile facilitates interoperability of web service definitions. While model-driven methodologies are a generally accepted practice for generating web service artifacts such as XSDs and WSDLs, they do not guarantee that the artifacts will be interoperable. To avoid interoperability issues, transformations from logical to physical models must be accomplished with an awareness of implementation context. An example case study based on our experience in using the IEC CIM model demonstrates the concept.	computer-integrated manufacturing;interoperability;model-driven architecture;profile (uml);unified modeling language;web service	Shawn X. K. Hu;Xiaofeng Wang;Dan Martin	2007	IEEE International Conference on Services Computing (SCC 2007)	10.1109/SCC.2007.46	computer science;database;programming language;ws-i basic profile;world wide web	SE	-49.500920514622806	25.875720389219172	171158
672d4b053e62ffa5561d1dcdc8f2820878e7d1f5	toward executable architectures to support evaluation	analytical models;architectural design;uml;uml executable architecture cpn dodaf;web services graph colouring military computing object oriented programming petri nets software architecture unified modeling language;department of defense;executable architecture framework;cpn;object oriented programming;web service;modeling language;proof of concept;information sharing;computer architecture;software architecture;dodaf;executable modeling language;architecture evaluation;unified modeling language;web services;object oriented approach;colored petri net;mathematical model;structured analysis;executable architecture;object oriented modeling unified modeling language laboratories petri nets knowledge management information analysis service oriented architecture project management performance evaluation architecture description languages;petri nets;modeling;web service executable architecture framework department of defense automatic translation information sharing structured analysis object oriented approach executable modeling language colored petri net uml;object oriented modeling;military computing;structure analysis;graph colouring;data models;automatic translation	It has been 10 years since the Department of Defense (DoD) first issued its Architecture Framework (DODAF). In the past we have shown that it is possible to take an architecture description that conforms to DODAF and convert it to an executable model to support rigorous evaluation. We now have a proof of concept that demonstrates the feasibility of making the conversion to the executable model automatically. Implementing this automatic translation will enable architects to apply more rigorous analysis and evaluation approaches to complex architecture evaluation problems such as determining the agility in particular architecture designs that are based on information sharing. This paper describes the issues in automatic translation of architectures that are based on either the Structured Analysis or the Object Oriented approaches into the rigorous executable modeling language of Colored Petri Nets. The paper includes a proof of concept case study and briefly discusses the advantages of using the executable model in evaluating logical, behavioral, and performance aspects of the architecture.	department of defense architecture framework;executable architecture;machine translation;modeling language;petri net;structured analysis	Lee W. Wagenhals;Stewart W. Liles;Alexander H. Levis	2009	2009 International Symposium on Collaborative Technologies and Systems	10.1109/CTS.2009.5067520	web service;unified modeling language;operational view;computer science;theoretical computer science;database;programming language;law	Arch	-49.112721409887186	26.968730644432238	171564
649ed5ae4d3309ae9ae0365ce7abe5ee8e6da60a	xgood: a tool to automatize the mapping rules between i* framework and uml			unified modeling language	Fernanda M. R. Alencar;Flávio Pereira Pedroza;Jaelson Brelaz de Castro;Carla Schuenemann;Ricardo Argenton Ramos	2006			systems engineering;applications of uml;uml tool;computer science;unified modeling language	Logic	-51.536375242444755	26.256685782783876	171948
bb50b7be6375a85b2d942b7191c37bc6ee377956	a knowledge engineering approach to uml modeling (s)			knowledge engineering;uml tool;unified modeling language	Bingyang Wei;Jing Sun;Yi Wang	2018		10.18293/SEKE2018-114	systems engineering;computer science;knowledge engineering;unified modeling language	SE	-51.432411010892025	26.213979354403445	172329
73c8eb5016794b422b9791be15b2f10819cfab80	making sense of runtime architecture for mobile phone software	performance;mobile phone;software architecture;architecture recovery	ABSTRACT We present a metamodel for runtime architecture and demonstrate with experimental results how this metamodel can be used to recover, analyze and improve runtime architecture of mobile phone software. Categories and Subject Descriptors D.2.11 [ Software Architectures ]: Domain-specific architectures. D.4.1 [ Process Management ]: Scheduling. General Terms Measurement, Performance. Keywords Software architecture, performance, architecture recovery 1. INTRODUCTION Last year our research group was requested to study the runtime architecture of mobile phone software to understand whether some performance aspects of a phone could be improved. The size of mobile phone software is such that a study of detailed design would require significantly more time than could have been reasonably allocated for this project. Therefore we focused on the most essential design decisions that affect runtime operation of mobile phone software or, in other words, runtime software architecture. In this paper we give an overall account of this experience, which demonstrates that understanding runtime software architecture in terms of featuresets, concurrent tasks and resource scheduling framework makes it possible to recover essential architectural decisions from execution traces and analyze the effect of architectural decisions on software schedulability and performance. In the next section, we give a description of the application domain to motivate our selection of specific performance metrics and emphasize the special importance of runtime software architecture in this domain. We then explain our understanding of what constitutes runtime software architecture and define the metamodel we have used in this study. We follow with a description of experiments and architecture recovery techniques we used. Finally we analyze the findings and discuss how the recovered information about architecture can be used to recognize patterns for improvement.	mobile phone	Alexander Ran;Raimondas Lencevicius	2003		10.1145/940071.940123	enterprise architecture framework;functional software architecture;reference architecture;embedded system;software visualization;software architecture;space-based architecture;model-driven architecture;real-time computing;simulation;database-centric architecture;performance;architectural pattern;computer science;applications architecture;software design description;software engineering;software construction;hardware architecture;solution architecture;software architecture description;programming language;resource-oriented architecture;data architecture;systems architecture	SE	-54.36245829643589	28.4135194929112	172827
88a4408a3ec14fe7c77c34f5c1c7bce76e5dbc4d	representing design patterns as design components	design pattern	Patterns should be incorporated in a software system in an explicit form so that they will be known to subsequent developers. In order to support pattern application, two basic requirements should be fulfill ed: traceabilit y and visibilit y. In our method, design patterns are represented as design components that may by placed in the library of pattern prototypes. From a prototype, an instance can be created when designing an actual application. In the paper, we describe prototype structure and the way of deriving pattern instances from the prototype.	design pattern;prototype;requirement;software system	Mária Smolárová;Pavol Návrat	1999			computer science;design pattern;structural pattern	SE	-53.491797575273	29.746646223333403	172891
eb9745daa54bbd7eb66ce52dbeb4c0ba31b441d3	software architecture: introducing ieee standard 1471	computer society;product lines;ieee standards;architecture descriptions;information systems;vocabulary;system of systems;software systems;ieee standards software architecture software standards;product line;development process;embedded system;systems of systems;architectural description practices;computer architecture;embedded systems;software architecture;standards development;ieee standard 1471;software architecture software standards computer architecture standards development embedded software vocabulary computer society software systems information systems embedded system;product family;software intensive systems;product families architectural description practices ieee standard 1471 software architecture architecture descriptions software intensive systems information systems embedded systems systems of systems product lines;software standards;information system;product families;embedded software	A lthough architecture has become a popular term in the computing community, its use is inconsistent, often bearing little resemblance to the concept’s origins in civil engineering. Architecture is used in various contexts to mean the instruction set of a central processor unit, the highest-level software modules in a large software system, or the overall structure of a business’s information technology systems. In some contexts, the architecture is both the process and the outcome of specifying the overall structure, components, and interrelationships of a computer or a network. Other organizations speak of buying or acquiring an architecture. Architecture also describes a product line’s shared attributes or features. Despite these inconsistencies, there is a growing body of recognized practice in architecture as applied to computer systems. In 2000, the Computer Society approved IEEE Standard 1471, which documents a consensus on good architectural description practices. The decision process that led to IEEE 1471’s approval demonstrates how standards can address conceptual issues and emphasizes the difficulties associated with resolving these kinds of issues in the standards development process. Five core concepts and relationships provide the foundation for the approved IEEE 1471 version:	central processing unit;computer;ieee 1471;software architecture;software system	Mark W. Maier;David E. Emery;Rich Hilliard	2001	IEEE Computer	10.1109/2.917550	multilayered architecture;enterprise architecture framework;reference architecture;software architecture;space-based architecture;architecture description language;iso/iec 42010;real-time computing;database-centric architecture;system of systems;computer science;architecture domain;applications architecture;software design description;service-oriented modeling;software engineering;solution architecture;software architecture description;architecture framework;view model;resource-oriented architecture;information system;data architecture;systems architecture;systems design	Visualization	-53.39626753846318	27.29290997240856	173151
0c779e5532bb66ba471da861d02bdb70a3e8dc14	integrative architecture elicitation for large computer based systems	information resources;integrative modeling;information sources;heterogeneous systems;tool support;software libraries;integrable model;software prototyping;computer architecture software systems hardware systems engineering and theory information resources software libraries data mining humans guidelines terminology;abstract data types;software systems;heterogeneous systems integrative architecture elicitation large computer based systems integrative modeling fundamental modeling concepts;object oriented programming;data mining;systems engineering and theory;large computer based systems;computer architecture;software architecture;guidelines;fmc modeling architecture heterogeneous systems fundamental modeling concepts;system development;fmc;terminology;humans;fundamental modeling concepts;modeling;architecture;abstract data types software architecture software prototyping object oriented programming;integrative architecture elicitation;hardware	This paper presents concepts and abstractions for integrative modeling, based on the fundamental modeling concepts. The approach reflects experiences from many architecture elicitation projects. It provides the necessary abstractions to combine the information about the different system components, including third-party products and hardware, into one integrated architecture model. It covers modeling patterns and typical abstractions, supported by guidelines for the elicitation process. The terminology and notation focuses on the communication about technical systems between persons being involved in system development. As a benefit, integrative models foster the efficient evolution of large systems, the introduction of new developers, or the handing over of a project.	fundamental modeling concepts	Peter Tabeling;Bernhard Gröne	2005	12th IEEE International Conference and Workshops on the Engineering of Computer-Based Systems (ECBS'05)	10.1109/ECBS.2005.46	software architecture;computer science;systems engineering;engineering;architecture;software engineering;programming language;computer engineering	SE	-52.86226929927445	27.62799995532482	173601
952efec53c34556fea8e5fb6a445462b4cd3ccd1	managing application complexity in the samrai object-oriented framework	adaptive mesh refinement;object oriented framework;object oriented programming;design patterns	A major challenge facing software libraries for scientific computing is the ability to provide adequate flexibility to meet sophisticated, diverse, and evolving application requirements. Object-oriented design techniques are valuable tools for capturing characteristics of complex applications in a software architecture. In this paper, we describe certain prominent object-oriented features of the SAMRAI software library that have proven to be useful in application development. SAMRAI is used in a variety of applications and has demonstrated a substantial amount of code and design re-use in those applications. This flexibility and extensibility is illustrated with three different application codes. We emphasize two important features of our design. First, we describe the composition of complex numerical algorithms from smaller components which are usable in different applications. Second, we discuss the extension of existing framework components to satisfy new application needs. Published in 2002 by John Wiley & Sons, Ltd.	algorithm;code;computational science;extensibility;john d. wiley;library (computing);numerical analysis;requirement;software architecture	Richard D. Hornung;Scott R. Kohn	2002	Concurrency and Computation: Practice and Experience	10.1002/cpe.652	software design pattern;real-time computing;adaptive mesh refinement;computer science;theoretical computer science;programming language;object-oriented programming	PL	-52.48610578180116	30.28788028293755	174535
6bbb25980c587a6e3a82ff0120122aa265e08ddd	an event-driven approach for the separation of concerns		This paper presents an event-driven approach for the separation of concerns in software systems. We introduce the EventJ framework that provides an event-driven extension to the Java programming language. The paper describes a general methodology that can be used to identify the cross-cutting concerns and separate them from the main functionality using events and event handlers. We discuss the pre-requisites to perform this change and illustrate it with a concrete example. Finally, we make a comparison between the event-driven approach and the aspect-oriented one, and conclude that the use of events to separate concerns has a positive effect on software quality attributes such as maintainability, extensibility and reusability.	aspect-oriented software development;event (computing);event-driven architecture;event-driven finite-state machine;event-driven programming;extensibility;java;list of system quality attributes;programming language;separation of concerns;software engineering;software quality;software system	Hayim Makabee	2012			systems engineering;separation of concerns;computer science	PL	-53.65684162545887	29.731156849811512	175365
3948a741d4991287b6708bc4fc0cf8b5f2017df2	development of an industrial real-time system using high level design techniques	real time systems instruments industrial control electrical equipment industry control systems computer industry quality control application software design for disassembly programmable control;design technique;client server;client server behaviour modelling industrial real time system high level design techniques software round integration object oriented analysis and design parse methodology;real time control system;object oriented analysis and design;design theory;quality control;real time systems	The software for a new industrial quality control instrument requiring real-time control systems has been developed using a hybrid methodology based round integration of different methods. The paper describes the methodology which draws together design theories and techniques from object oriented analysis and design (OOAD), from the PARSE methodology, and from the client-server behaviour modelling. This approach has been applied to the design of the new system which has been implemented and successfully installed on a number of customer sites.		A. Crookell;Innes Ritchie	1996		10.1109/EMWRTS.1996.557835	object-oriented analysis and design;embedded system;quality control;industrial control system;real-time computing;real-time control system;computer science;operating system;object-oriented design;real-time control system software;designtheory;model-based design;client–server model	EDA	-49.22815584076599	29.84652189359182	176425
f9999d81cac6c77094d4156f04dc0140fc31feef	comodeling: from requirements to an integrated software/hardware model	system engineering;comodeling;hardware partitions integrated software hardware model software hardware comodeling software partitions;software partitions;hardware software codesign;behavior trees;faculty of science environment engineering and technology;systems engineering;modelica;integrated software hardware model;modeling software architecture hardware product development;software engineering;journal article;requirements engineering;behavior trees systems engineering hardware software codesign comodeling behavior engineering modelica requirements engineering hybrid simulation;software architecture;engineering and technology;teknik och teknologier;requirement engineering;behavior engineering;080309;software hardware comodeling;hybrid simulation;modeling;hardware partitions;hardware;product development	The paper states that comodeling lets developers systematically investigate and compare different software and hardware partitions to meet a system's constraints earlier in the design process, when integration problems are easier and cheaper to resolve.	integrated software	Toby Myers;R. Geoff Dromey;Peter Fritzson	2011	Computer	10.1109/MC.2010.270	software architecture;systems modeling;computer science;software engineering;hardware architecture;modelica;requirements engineering;behavior trees;new product development	SE	-52.23086337482252	28.637381195779323	176464
0d0cab94259c29face06f7158dbcbdab99436b81	model matching for trace link generation in model-driven software development	model matching;traceability;software quality	With the advent of Model-driven Software Engineering, the advantage of generating trace links between source and target model elements automatically, eases the problem of creating and maintaining traceability data. Yet, an existing transformation engine as in the above case is not always given in model-based development, (i.e. when transformations are implemented manually) and can not be leveraged for the sake of trace link generation through the transformation mapping. We tackle this problem by using model matching techniques to generate trace links for arbitrary source and target models. Thereby, our approach is based on a novel, language-agnostic concept defining three similarity measures for matching. To achieve this, we exploit metamodel matching techniques for graph-based model matching. Furthermore, we evaluate our approach according to large-scale SAP business transformations and the ATL Zoo.	galaxy zoo;language-independent specification;metamodeling;model-driven architecture;model-driven engineering;model-driven integration;software development;software engineering;traceability	Birgit Grammel;Stefan Kastenholz;Konrad Voigt	2012		10.1007/978-3-642-33666-9_39	traceability;computer science;systems engineering;engineering;theoretical computer science;software engineering;data mining;algorithm;software quality	SE	-53.78300986890156	25.792602851311663	176487
5198705f344d4bafbf37ef35cc313a643d167b07	formalizing space shuttle software requirements: four case studies	domain model;state exploration;flight software;formal methods;space shuttle;formal method;theorem proving;requirement analysis;software requirements;technology transfer;formal specification and verification;requirements analysis	This article describes four case studies in which requirements for new flight software subsystems on NASA's Space Shuttle were analyzed using mechanically supported formal methods. Three of the studies used standard formal specification and verification techniques, and the fourth used state exploration. These applications illustrate two thesis: (1) formal methods complement conventional requirements analysis processes effectively and (2) formal methods confer benefits even when only selectively adopted and applied. The studies also illustrate the interplay of application maturity level and formal methods strategy, especially in areas such as technology transfer, legacy applications, and rapid formalization, and they raise interesting issues in problem domain modeling and in tailoring formal techniques to applications.	capability maturity model;embedded software;formal methods;formal specification;formal verification;problem domain;requirement;requirements analysis;software requirements	Judith Crow;Ben L. Di Vito	1998	ACM Trans. Softw. Eng. Methodol.	10.1145/287000.287023	requirements analysis;software requirements specification;formal methods;formal verification;computer science;systems engineering;software engineering;formal specification;refinement;computer engineering	SE	-53.72838775417003	26.71194237579403	177334
2038b3e984874bb7287251f213f3fa2490d0e178	model-based language engineering with emftext		Model-based techniques are in wide-spread use for the design and implementation of domain specific languages (DSLs) and their tooling. The Eclipse Modeling Framework (EMF) is a frequently used environment for model-based language engineering. With its underlying modelling language Ecore, its XML serialisation support and its versatile extensibility it provides a solid grounding for many task-specific language development tools. In this tutorial, we give an introduction to model-based language engineering using EMFText, which allows users to develop powerful textual editors for Ecore-based DSLs that are tightly integrated with the EMF.	digital subscriber line;domain-specific language;eclipse modeling framework;extensibility;java;modeling language;programming tool;serialization;xml namespace	Florian Heidenreich;Jendrik Johannes;Sven Karol;Mirko Seifert;Christian Wende	2011		10.1007/978-3-642-35992-7_9	first-generation programming language;very high-level programming language;universal networking language;informatics engineering;modeling language;language technology	DB	-48.90367375917735	25.490075321956603	177819
4751a96842192a5312d656ea51dc1993e1df08c7	towards a formal redesign of uml class diagrams	uml class diagram		diagram;unified modeling language	Piotr Kosiuczenko	2001			programming language;uml tool;applications of uml;class diagram;communication diagram;unified modeling language;computer science	SE	-49.46582153484253	27.001611498622207	177894
81719e27fe55d680ba409c72fad0f2342ebeb2f4	cm-builder: an automated nl-based case tool	cm builder;natural language interfaces;semantic networks computer aided software engineering software tools natural language interfaces object oriented programming systems analysis;semantic network;graphical case tool cm builder natural language based case tool software development object oriented framework requirements analysis integrated discourse model semantic network uml class model;graphical case tool;object oriented framework;software development process;natural languages;object oriented programming;semantic networks;natural language based case tool;integrated discourse model;uml class model;software requirements;computer aided software engineering;evaluation methodology;systems analysis;natural language;software development;case tool;unified modeling language;artificial intelligence;robustness;software tools;humans;computer science;computer aided software engineering object oriented modeling natural languages artificial intelligence unified modeling language programming software tools humans computer science robustness;programming;object oriented modeling;quantitative evaluation;requirements analysis	This paper describes a natural language-based CASE tool called CM-Builder which aims at supporting the Analysis stage of software development in an Object-Oriented framework. CM-Builder uses robust Natural Language Processing techniques to analyse software requirements texts written in English and build an integrated discourse model of the processed text, represented in a Semantic Network. This Semantic Network is then used to automatically construct an initial UML Class Model representing the object classes mentioned in the text and the relationships among them. The initial model can be directly input to a graphical CASE tool for further refinement by a human analyst. CM-Builder has been quantitatively evaluated in blind trials against a collection of unseen software requirements texts and we present the results of this evaluation, together with the evaluation methodology. The results are very encouraging and demonstrate that tools such as CM-Builder have the potential to play an important role in the software development process.	case-based reasoning;class consciousness;computer-aided software engineering;data interchange format;graphical user interface;nl (complexity);natural language processing;refinement (computing);requirement;semantic network;software development process;software requirements;text corpus;unified modeling language	H. M. Harmain;Robert J. Gaizauskas	2000		10.1109/ASE.2000.873649	natural language processing;computer science;systems engineering;software development;software engineering;natural language;semantic network;programming language	SE	-48.326042047812145	25.93297723838269	177957
4293c407cd456ebcc46d0d6e2e2ffca147c403a6	enhancing coordination in global cooperative software design	graph theory;global communication;groupware;lattices;communication queue;software engineering;software design delay computer science costs frequency lattices educational institutions cultural differences global communication virtual groups;virtual groups;dynamical status message notification;concurrency control;project tracking;communication delay;computer aided notification mechanism;concurrency control groupware software engineering graph theory;global cooperative software design;computer science;software design;frequency;communication queue global cooperative software design communication delay multiple component status transition graph computer aided notification mechanism project tracking dynamical status message notification;multiple component status transition graph;cultural differences	Global cooperative software design is a formidable task because of the communication and coordination issues. While rescheduling of the tasks is necessary to reduce the impact of communication delay, the dependence of tasks must be well handled. Multiple component status transition graph (MCSTG) describes task dependence within and between components efficiently and support the handle of task dependence. A computer-aided notification mechanism was developed on the basis of MCSTG. The automatic mechanism avoids the task conflicts in coordination while minimizing the cost in project tracking.	code refactoring;software design	Bin Xu;Xiaohu Yang;Zhijun He;Albert Ma	2005	Proceedings of the Ninth International Conference on Computer Supported Cooperative Work in Design, 2005.	10.1109/CSCWD.2005.194139	real-time computing;simulation;computer science;knowledge management;graph theory;software design;operating system;software engineering;concurrency control;frequency;lattice;database;distributed computing;cultural diversity	Robotics	-50.11524376310307	30.559948085841746	177985
ab759085a65d667e3b3020d8bcff0ca915a739bd	a multi-dimensional taxonomy of software development environments	multi dimensional;software development environment	A Software Development Environment (SDE) is a set of tools that, at the very least, supports coding and possibly other software development activities. Related to SDEs are meta-SDEs, which are classes of SDEs that must be configured or populated by tools before they can be useful. We will use the generic term environment to refer to both SDEs and meta-SDEs.This paper presents a multi-dimensional taxonomy of environments. The primary dimensions of our taxonomy are scale and genericity. Scale distinguishes environments that are suitable for small-scale programming from those that are suitable for large-scale software development. Genericity differentiates monolithic environments from highly configurable and extendible ones. Secondary taxonomy dimensions include tool integration, which identifies the degree of interoperability and data sharing between tools, and the historical dimension, which gives insight into past and present research trends in these environments.	integrated development environment;software development	Spiros Mancoridis	1993		10.1145/962338	real-time computing;simulation;computer science;development environment	SE	-51.59645636337728	29.782488893371156	178002
75b662b5346d079cfa180a360dfa7afe137c5c79	comparing relational model transformation technologies: implementing query/view/transformation with triple graph grammars	mda;query view transformation;model transformation;software engineering;model based software engineering;graph grammar;declarative languages;semantic gap;case tool;relational model;triple graph grammar tgg;model driven architecture;query view transformation qvt	The Model Driven Architecture (MDA) is an approach to develop software based on different models. There are separate models for the business logic and for platform specific details. Moreover, code can be generated automatically from these models. This makes transforma- tions a core technology for MDA and for model-based software engineering approaches in general. Query/View/Transformation (QVT) is the transformation technology recently proposed for this purpose by the OMG. Triple Graph Grammars (TGGs) are another transformation technology proposed in the mid-nineties, used for example in the FUJABA CASE tool. In contrast to many other transformation technologies, both QVT and TGGs declaratively define the relation between two models. With this definition, a transformation engine can execute a transformation in either direction and, based on the same definition, can also propagate changes from one model to the other. In this paper, we compare the concepts of the declarative languages of QVT and TGGs. It turns out that TGGs and declarative QVT have many concepts in common. In fact, QVT-Core can be mapped to TGGs. We show that QVT-Core can be implemented by transforming QVT-Core mappings to TGG rules, which can then be executed by a TGG transformation engine that performs the actual QVT transformation. Furthermore, we discuss an approach for mapping QVT-Relations to TGGs. Based on the semantics of TGGs, we clarify semantic gaps that we identified in the declarative languages of QVT and, furthermore, we show how TGGs can benefit from the concepts of QVT.	business logic;computer-aided software engineering;declarative programming;model transformation;model-driven architecture;qvt;relational model;transformational grammar	Joel Greenyer;Ekkart Kindler	2009	Software & Systems Modeling	10.1007/s10270-009-0121-8	relational model;computer science;software engineering;database;programming language;algorithm;semantic gap	SE	-48.31153925053192	26.305170229343982	178510
33b7903491ea3f579f7fbfadfe707e5fba729e16	design pattern modeling with constraint relaxation	design pattern	Metamodeling is a widely applied technique in the field of graphical language engineering. Environments supporting metamodeling aid rapid and flexible domain-specific modeling language (DSML) definition and utilization. In software engineering, design patterns are efficient solutions for recurring problems. With the proliferation of DSMLs, there is a need for domain-specific design patterns to offer solutions to problems recurring in different domains. The aim of this paper is to illustrate a concept that integrates modeling patterns into a metamodeling environment. The introduced approach utilizes the modeling functionalities of the environment; a visual design pattern metamodel, a system architectural metamodel extended with textual constraints are introduced. Furthermore, design patterns are validated against relaxed constraints defined in the metamodel to only allow the creation of patterns that can be extended to valid instance models.	linear programming relaxation;software design pattern	Tamás Vajk;Tamás Mészáros;Tihamer Levendovszky	2010	ECEASST	10.14279/tuj.eceasst.25.348	metamodeling;metadata modeling;software design pattern;simulation;computer science;design pattern;programming language;structural pattern	Vision	-52.822896041384034	25.514110810915042	178584
aa7b629290e9f0a8755e79d9e636e2d0dbf91e77	behavior modelling by stepwise refining behavior diagrams			behavior model;diagram;stepwise regression	Michael Schrefl	1990			refining (metallurgy);computer science;process engineering	HCI	-50.533300608843334	25.938965517400913	179138
753f11145432fb59f092f1b63fd526da93d787a0	the use of modified modelling language (uml) for model design and scientific software development	software development		software development;unified modeling language	Christian Maul	1999			software engineering;software design description;shlaer–mellor method;systems engineering;model-driven architecture;applications of uml;package development process;object constraint language;uml tool;diagramming software;computer science	SE	-51.4112947653196	26.55819365402482	180138
eedae1cf2a59ded2f6428e3d5a417f60bcae7dad	an xvcl approach to handling variants: a kwic product line example	formal specification;cobol;object oriented programming xml software reusability formal specification;product line;object oriented programming;object oriented programming xvcl xml based variant configuration language software reusability product line variant management meta component;software reusability;xml;productivity software reusability software tools computer architecture unified modeling language data processing software quality application software java computer science;large data	We developed XVCL (XML-based Variant Configuration Language), a method and tool for product lines, to facilitate handling variants in reusable software assets (such as architecture, code components or UML models). XVCL is a newer version of Bassett’s frames [1], a technology that has achieved substantial productivity improvements in large data processing product lines written in COBOL. Despite its simplicity, XVCL can effectively manage a wide range of product line variants from a compact base of meta-components, structured for effective reuse. We applied XVCL in two medium-size product line projects and a number of smaller case studies. In this paper, we communicate XVCL’s capabilities to support product lines by means of a simple, but still interesting, example of the KWIC system introduced by Parnas in 1970’s. We show how we can handle functional variants, variant design decisions and implementation-level variants in a generic KWIC system.	cobol;key word in context;knowledge-based configuration;software engineering;sourceforge;unified modeling language;xml	Hongyu Zhang;Stan Jarzabek	2003		10.1109/APSEC.2003.1254364	xml;computer science;systems engineering;software engineering;formal specification;database;cobol;programming language;object-oriented programming	SE	-52.017870400121026	30.188157495837366	180391
2aae30bc57422c9907ce39443e6b3136ed59b1c9	generative technologies for model animation in the topcased platform	metamodeling pattern;generative technologies;model execution;model animation	Domain Specific Modeling Languages (DSML) are more and more used to handle high level concepts, and thus bring complex software development under control. The increasingly recurring definition of new languages raises the problem of the definition of support tools such as editor, simulator, compiler, etc. In this paper we propose generative technologies that have been designed to ease the development of model animation tools inside the TOPCASED platform. These tools rely on the automatically generated graphical editors of TOPCASED and provide additional generators for building model animator graphical interface. We also rely on an architecture for executable metamodel (i.e., the TOPCASED model execution metamodeling pattern) to bind the behavioral semantics of the modeling language. These tools were designed in a pragmatic manner by abstracting the various model animators that had been hand-coded in the TOPCASED project, and then validated by refactoring these animators.	breakpoint;code refactoring;compiler;debugger;directory services markup language;domain-specific language;domain-specific modeling;executable;experiment;graphical user interface;high-level programming language;metamodeling;modeling language;object constraint language;software development	Xavier Crégut;Benoît Combemale;Marc Pantel;Raphaël Faudoux;Jonatas Pavei	2010		10.1007/978-3-642-13595-8_9	computer science;systems engineering;theoretical computer science;software engineering;programming language	SE	-48.29061117019909	25.738136325095798	180495
c59590c93bdbd6c31b3e08da296b529edce3e32e	re-engineering c++ component models via automatic program transformation	software analysis;rewrite rule;tool support;migration;software transformation;program transformation;abstract syntax trees;automatic programming;abstract syntax tree;compilers;component framework;legacy systems;rewrite rules;component model;patterns;software life cycle;program analysis;component architecture;c;legacy system;reengineering;component architectures	Automated program transformation holds promise for a variety of software life cycle endeavors, particularly where the size of legacy systems makes code analysis, re-engineering, and evolution difficult and expensive. But constructing highly scalable transformation tools supporting modern languages in full generality is itself a painstaking and expensive process. This cost can be managed by developing a common transformation system infrastructure re-useable by derived tools that each address specific tasks, thus leveraging the infrastructure costs. This paper describes the design maintenance system (DMS), a practical, commercial program analysis and transformation system, and discusses how it was employed to construct a custom modernization tool being applied to a large C++ industrial avionics system. The tool transforms components developed in a 1990's-era component style to a more modern CORBA-like component framework, preserving functionality.	avionics;c++;common object request broker architecture;legacy system;program transformation;scalability;software release life cycle;static program analysis;usability	Robert L. Akers;Ira D. Baxter;Michael Mehlich;Brian J. Ellis;Kenn R. Luecke	2005	12th Working Conference on Reverse Engineering (WCRE'05)	10.1016/j.infsof.2006.10.012	computer science;systems engineering;engineering;software engineering;database;programming language;legacy system;algorithm	SE	-52.320739390488264	30.246781201765316	181328
d3b1713f08f6bbad55bb94e32b4aacaecd5879c0	rigorous description of software requirements with uml	software requirements		software requirements;unified modeling language	Luigi Lavazza	2003			systems engineering;software peer review;software design description;applications of uml;computer science;software requirements;uml tool;software requirements specification;social software engineering;software architecture description	SE	-52.25102725912155	26.58675102092684	181393
4ba3d3dc4fde00f8e4f0b4c2e2eae660be24b31c	context synthesis		With the advent of component-based and distributed software development, service-oriented computing, and other such concepts, components are no longer viewed as parts of specific systems, but rather as open systems that can be reused, or connected dynamically, in a variety of environments to form larger systems. Reasoning about components as open systems is different from reasoning about closed systems, since property satisfaction may depend on the context in which a component may be introduced. Component interfaces are an important feature of open sytems, since interfaces summarize the expectations that a component has from the contexts in which it gets introduced. Traditionally, component interfaces have been of a purely syntactic form, including information about the services/methods that can be invoked on the component, and their signatures, meaning the numbers and types of arguments and their return values. However, there is a recognized need for richer interfaces that capture additional aspects of a component. For example, interfaces may characterize legal sequences of invocations to component services. Generating compact and yet useful component interfaces is a challenging task to perform manually. Over the last decade, several approaches have been developed for performing context synthesis, i.e., generating component interfaces automatically. This tutorial mostly reviews such techniques developed by the authors, but also discusses alternative techniques for context synthesis.	closed system;component-based software engineering;distributed computing;open system (computing);service-oriented software engineering;software development;type signature	Dimitra Giannakopoulou;Corina S. Pasareanu	2011		10.1007/978-3-642-21455-4_6		SE	-50.663396270200465	25.339906365691924	181997
044b260cbb031cdb000d3c49bce1a15d64cc9c55	performance analysis patterns for requirements analysis		Many problems might arise when performance requirements are not taken into account from the beginning of software development. Architectural solutions such as performance patterns represent design decisions on the architecture level that might constrain quality requirements significantly. Knowledge which is gained in the solution space, for example from performance patterns, should be reflected in the requirements engineering to obtain sound architectures and correct requirements. We propose to reuse performance architectural patterns in the requirements engineering in a systematic manner to equip requirement models with performance solution approaches early in the software development process. To this end, we propose performance analysis patterns. The performance requirement models elaborated with performance analysis patterns can easily be transformed into a particular solution at the design level.	architectural pattern;feasible region;graphical user interface;modeling and analysis of real time and embedded systems;nudge (instant messaging);performance tuning;problem domain;problem frames approach;profile (uml);profiling (computer programming);requirement;requirements analysis;requirements engineering;response time (technology);software development process;software engineer;software performance testing;throughput;unified modeling language	Azadeh Alebrahim	2015			software analysis pattern;systems engineering;architectural pattern;software development process;architecture;requirements engineering;reuse;software development;requirements analysis;computer science	SE	-54.73721722882689	27.560223736605938	182119
767da628999f32c3d87e3a333f64d7a4a107cf78	abstract factories and the shape calculator	objects first;assignments;pedagogy;object oriented;design pattern;design patterns;loose coupling;abstract coupling;cs1 cs2;software quality	The Shape Calculator is an assignment targeted at CS1 students in an objects-first curriculum. It can serve as a powerful yet entertaining example of the advantages of object-orientation.	abstract factory pattern	Eric Cheng;Dung Zung Nguyen;Mathias Ricken;Stephen B. Wong	2004		10.1145/1028664.1028705	software design pattern;simulation;computer science;design pattern;programming language;object-oriented programming;loose coupling;software quality	ML	-50.79832377168233	29.677199616317186	182655
cd810fa8ea9c9d526a0fda38d86c2969489c6c80	model-driven allocation engineering (t)	automotive engineering;software;deployment;resource management software hardware actuators computer architecture brakes automotive engineering;resource management;automotive;mechatronicuml cyber physical systems allocation deployment automotive constraints;actuators;allocation;cyber physical systems;computer architecture;brakes;mechatronicuml;unified modeling language constraint handling cyber physical systems linear programming object oriented programming resource allocation;mechatronicuml model driven allocation engineering cyber physical systems cps networked electronic control units ecu software engineers component based development approach software component allocation topology dependencies software dependencies timing dependencies memory constraints routing constraints scheduling constraints linear programs constraint allocation problem model driven ocl based allocation engineering approach;constraints;hardware	Cyber-physical systems (CPSs) provide sophisticated functionality and are controlled by networked electronic control units (ECUs). Nowadays, software engineers use component-based development approaches to develop their software. Moreover, software components have to be allocated to an ECU to be executed. Engineers have to cope with topology-, software-, and timing-dependencies and memory-, scheduling-, and routing-constraints. Currently, engineers use linear programs to specify allocation constraints and to derive a feasible allocation automatically. However, encoding the allocation problem as a linear program is a complex and error-prone task. This paper contributes a model-driven, OCL-based allocation engineering approach for reducing the engineering effort and to avoid failures. We validate our approach with an automotive case study modeled with MechatronicUML. Our validation shows that we can specify allocation constraints with less engineering effort and are able to derive feasible allocations automatically.	cognitive dimensions of notations;collocation;component-based software engineering;cyber-physical system;engine control unit;linear programming;metamodeling;model-driven architecture;model-driven integration;object constraint language;routing;software architecture;software engineer;solver	Uwe Pohlmann;Marcus Hüwe	2015	2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE)	10.1109/ASE.2015.18	real-time computing;simulation;computer science;systems engineering;engineering;resource management;cyber-physical system;software deployment;brake;actuator	SE	-52.250659161649786	30.799374251706432	182679
6574410e53d19f7eaa9667609f3e422c88f033c5	a model-driven approach for software product lines requirements engineering	home automation;requirement engineering;requirement analysis	UML and feature models complement each other well and can be the base techniques for a systematic method to identify and model software product line (SPL) requirements. In this paper, we present a modeldriven approach to trace both features and UML requirements analysis model elements, and to automatically derive valuable models for domain and application engineering. The resulting contribution is a synergetic approach for SPL requirements. We illustrate it by using a home automation system product line.	activity diagram;aspect-oriented programming;aspect-oriented software development;feature model;functional requirement;home automation;interaction;metamodeling;model-driven architecture;model-driven integration;non-functional requirement;requirement;requirements analysis;requirements engineering;software product line;synergetics (haken);unified modeling language	Mauricio Alférez;Uirá Kulesza;André Sousa;João Pedro Santos;Ana Moreira;João Araújo;Vasco Amaral	2008			systems engineering;feature-oriented domain analysis;requirement prioritization;requirements engineering;computer science;domain engineering;software requirements;requirement;reliability engineering;software product line;requirements analysis	SE	-54.05797858647632	26.070890194884402	182906
027fe9149c706c7e8fa5cda38abb44202181c7dd	architecture-driven reuse of code in kase	architectural design;knowledge bases artificial intelligence;software systems;software engineering;complex systems;software development tools;algorithms;architecture computers;algorithms and data structure;software reuse;knowledge based systems;problem solving	In order to support the synthesis of large, complex software systems, we need to focus on issues pertaining to the architectural design of a system in addition to algorithm and data structure design. In this paper, we present an approach that is based on abstracting the architectural design of a set of problems in the form of a generic architecture , and providing tools that can be used to instantiate the generic architecture for specific problem instances. Such an approach also facilitates reuse of code between different systems belonging to the same problem class. We describe an application of our approach on a realistic problem, present the results of the exercise, and discuss how our approach compares to other work in this area.	algorithm;code reuse;data structure;planetary scanner;software system;subroutine;usability	Sanjay Bhansali	1993			domain analysis;complex systems;verification and validation;computing;architectural pattern;computer science;systems engineering;engineering;package development process;software design;social software engineering;software framework;component-based software engineering;software development;feature-oriented domain analysis;software engineering;domain engineering;knowledge-based systems;software construction;software walkthrough;software analytics;resource-oriented architecture;software deployment;computer-aided software engineering;software development process;software system;computer engineering	SE	-52.95247305683277	27.541158874203482	183391
b78862e9b6cc4c2789f6c5e894926e40f800aa21	environment-model based testing with differential evolution in an industrial setting		Reactive systems interact continuously with their environments. In order to test such systems, one needs to design executable environment models. Such models are intrinsically stochastic, because environment may vary a lot, and also because they are not perfectly known. We propose an environment-model based testing framework optimized for reactive systems, where Differential Evolution (de ) is used to fine-tune the environment model and to optimize test input generation. In order to evaluate the proposed method, we present a case study involving a real-world scade system from the domain of railway automation. The problem specification was proposed by our industrial partner, Siemens. Our experimental data shows that de can be used efficiently to increase the structural coverage of the System Under Test.	differential evolution;model-based testing	Annamária Szenkovits;Noémi Gaskó;Erwan Jahier	2016		10.1007/978-3-319-31204-0_52	system under test;automation;differential evolution;control engineering;simulation;experimental data;model-based testing;siemens;executable;reactive system;computer science	Logic	-54.77418618831344	30.585023002852665	183947
1b90698cf0a2c56f9e777b6f0325543baccf44e4	on a case supported approach to object-oriented rapid prototyping			rapid prototyping	William Ian Cameron Mitchell	1997				PL	-49.673520997429314	28.325451589455472	183964
1445a6caffbc8f91ded827bb227b52219f690acc	a purely functional combinator language for software quality assessment	attribute grammars;combinators;004;functional programming;process management;process management combinators attribute grammars functional programming	Quality assessment of open source software is becoming an important and active research area. One of the reasons for this recent interest is the consequence of Internet popularity. Nowadays, programming also involves looking for the large set of open source libraries and tools that may be reused when developing our software applications. In order to reuse such open source software artifacts, programmers not only need the guarantee that the reused artifact is certified, but also that independently developed artifacts can be easily combined into a coherent piece of software. In this paper we describe a domain specific language that allows programmers to describe in an abstract level how software artifacts can be combined into powerful software certification processes. This domain specific language is the building block of a web-based, open-source software certification portal. This paper introduces the embedding of such domain specific language as combinator library written in the Haskell programming language. The semantics of this language is expressed via attribute grammars that are embedded in Haskell, which provide a modular and incremental setting to define the combination of software artifacts. 1998 ACM Subject Classification D.2.11 Software Architectures, D.4.1 Process Management	attribute grammar;coherence (physics);combinator library;combinatory logic;domain-specific language;embedded system;haskell;library (computing);open-source software;programmer;programming language;software quality;web application	Pedro Henrique Martins;João Paulo Fernandes;João Saraiva	2012		10.4230/OASIcs.SLATE.2012.51	domain analysis;software distribution;natural language processing;combinatory logic;programming domain;computer science;package development process;backporting;software design;theoretical computer science;software framework;component-based software engineering;software development;domain engineering;software construction;database;programming language;functional programming;resource-oriented architecture;world wide web;goal-driven software development process;software development process	PL	-52.274706687136494	31.521806017376655	185101
889876d44ff5542c16909590d837031e6b8db253	a model for the reuse of software design information	software design computer architecture algorithm design and analysis computer languages permission handicapped aids software libraries marine vehicles programming costs;computer languages;generic model;programming language;software libraries;system modeling;automated tool;computer architecture;handicapped aids;marine vehicles;permission;functional decomposition;analysis method;software design;programming;algorithm design and analysis;requirements analysis	This paper presents a general model for the representation and manipulation of module level software design information, leading to the effective reuse of software design information across different programming languages. Language independent design documents are represented as ASCII files containing tagged design information sufficient for the construction of a compilable program architecture. The resulting architecture is composed of documented module stubs which describe calling relationships, parameters, functional descriptions, and algorithms characteristic of the architecture. No executable code is included in the compilable modules. Frameworks of tagged locations in Zanguage dependent standard module templates are matched against corresponding tags in the ASCII design files, effectively blending language dependent and independent information into a compilable stub architecture. The process is reversible in that a language independent design file can be generated from an architecture in the standard tagged format, thus supporting the movement of design information across different programming languages.	algorithm;alpha compositing;compiler;executable;modular programming;programming language;software architecture;software design	Kevin W. Jameson	1989		10.1145/74587.74615	functional decomposition;algorithm design;programming;requirements analysis;systems modeling;computer science;software design;theoretical computer science;operating system;software engineering;programming language;management	PL	-48.39708708557494	27.800807354428393	185130
bb48e14a703f16df675b882dfa103bb2283f9367	software tracks	computer architecture;data structures;software tools;programming;domain specific languages	Railroad tracks offer guidance and support. There are various tools that can give our software the same handling. The main tool for guiding the code's direction is the language's type system. For values, the type system can help us by establishing a separate type for each distinct class; for code, interfaces and abstract classes ensure that we won't forget some crucial methods when we add functionality through a new class. With domain-specific languages or even suitably initialized data structures we can efficiently express exactly what the designer intended and nothing more. At a higher level, architectures that enforce a particular open-ended but well-defined interface will also guide a software's progress. Finally, the most flexible track-laying approach is a tool-supported software development process.	data structure;domain-specific language;nonlinear gameplay;software development process;type system	Diomidis Spinellis	2010	IEEE Software	10.1109/MS.2010.56	programming;data structure;computer science;domain-specific language;engineering;package development process;theoretical computer science;software framework;component-based software engineering;software development;software design description;software engineering;software construction;software walkthrough;programming language;resource-oriented architecture;software quality;software metric;software system;computer engineering	SE	-51.79561576255531	31.128672038402225	185631
a33570b1c13eace33a43009db9aa6dedf55781d5	using types and inheritance in object-oriented programming	computer languages;object oriented programming programming profession software maintenance organizing guidelines object oriented modeling productivity software reusability computer languages force control;software maintenance;object oriented programming;guidelines;object oriented;organizing;programming profession;software reusability;productivity;object oriented modeling;force control	To be a good object-oriented programmer, you should use types and inheritance wisely. ThiS tutorial will help you do so.	programmer	Daniel C. Halbert;Patrick D. O'Brien	1987	IEEE Software	10.1109/MS.1987.231776	method;reactive programming;computer science;systems engineering;object;component-based software engineering;software development;software engineering;computer programming;programming paradigm;inductive programming;fifth-generation programming language;programming language theory;programming language;object-oriented programming;object-modeling technique;system programming	PL	-50.74367753983115	29.491468928331567	185755
0ebed8c151f9aaf93f660f9fbb1325abaf73ce4f	reusable components for partitioning clustering algorithms	cluster algorithm;generic;k means;data mining;mpck means;kohonen som;machine learning;x means;reusable component;partitioning clustering	Clustering algorithms are well-established and widely used for solving data-mining tasks. Every clustering algorithm is composed of several solutions for specific sub-problems in the clustering process. These solutions are linked together in a clustering algorithm, and they define the process and the structure of the algorithm. Frequently, many of these solutions occur in more than one clustering algorithm. Mostly, new clustering algorithms include frequently occurring solutions to typical sub-problems from clustering, as well as from other machine-learning algorithms. The problem is that these solutions are usually integrated in their algorithms, and that original algorithms are not designed to share solutions to sub-problems outside the original algorithm easily. We propose a way of designing cluster algorithms and to improve existing ones, based on reusable components. Reusable components are well-documented, frequently occurring solutions to specific sub-problems in a specific area. Thus we identify reusable components, first, as solutions to characteristic sub-problems in partitioning cluster algorithms, and, further, identify a generic structure for the design of partitioning cluster algorithms. We analyze some partitioning algorithms (K-means, X-means, MPCK-means, and Kohonen SOM), and identify reusable components in them. We give examples of how new cluster algorithms can be designed based on them.	algorithm;binary space partitioning;cluster analysis;component-based software engineering;data mining;decision support system;decision tree;generic programming;k-means clustering;machine learning;missing data;open-source software;r language;rapidminer;requirement;self-organizing map;semiconductor industry;systems architecture;weka;white box (software engineering)	Boris Delibasic;Kathrin Kirchner;Johannes Ruhland;Milos Jovanovic;Milan Vukicevic	2009	Artificial Intelligence Review	10.1007/s10462-009-9133-6	correlation clustering;constrained clustering;data stream clustering;fuzzy clustering;computer science;theoretical computer science;canopy clustering algorithm;machine learning;cure data clustering algorithm;data mining;cluster analysis;biclustering;k-means clustering;clustering high-dimensional data	DB	-54.23222289247457	31.439220326521053	186055
b8d7b50313ed6a243208fb1ee994829d0bb010b4	enabling tool reuse and interoperability through model-driven engineering	domain specific modeling;model transformation;tool interoperability	Software components provide a wide range of functionality that can be used across several domains. In some cases, reuse at a very coarse level of granularity (e.g., reusing functionality provided within an existing tool) is desirable, but challenging to realize due to the interface boundaries of the tool and the unanticipated level of reuse. This paper describes our results in applying model-driven engineering (e.g., domain-specific modeling and model transformation) to the tool reuse problem. Our approach captures the essence of each tool in a metamodel and uses model transformations to map between the tool representations. Specifically, we describe our results in reusing the graphical layout functionality provided by one tool (e.g., GraphViz) that does not exist natively in another tool (e.g., the Eclipse Graphical Modeling Framework).	interoperability;model-driven architecture;model-driven engineering	Zekai Demirezen;Yu Sun;Jeffrey G. Gray;Frédéric Jouault	2010	J. Comput. Meth. in Science and Engineering	10.3233/JCM-2010-0278	computer science;systems engineering;data mining;database	Logic	-52.80474090780621	25.739940453595366	186646
285a7fcc31b4c08297886834c7cf6d30d1a5cb37	tool-supported refactoring of existing object-oriented code into aspects	automatic control;aspectj;tool supported refactoring;refactoring;migrating system;aspect oriented software development;program transformation;scattering;contracts;java program;object oriented programming;automatic programming;software engineering;program transformation aspect oriented software development refactoring;crosscutting concern;software tools java object oriented programming program compilers software quality;object oriented programming scattering system testing automatic programming java contracts software engineering automatic control costs humans;aspect oriented programming;system testing;software tools;humans;program compilers;software quality;program transformation aspect oriented programming crosscutting concern migrating system object oriented programming java program aspectj tool supported refactoring;java	Aspect-oriented programming (AOP) provides mechanisms for the separation of crosscutting concerns - functionalities scattered through the system and tangled with the base code. Existing systems are a natural testbed for the AOP approach since they often contain several crosscutting concerns which could not be modularized using traditional programming constructs. This paper presents an automated approach to the problem of migrating systems developed according to the object-oriented programming (OOP) paradigm into aspect-oriented programming (AOP). A simple set of six refactorings has been defined to transform OOP to AOP and has been implemented in the AOP-migrator tool, an Eclipse plug-in. A set of enabling transformations from OOP to OOP complement the initial set of refactorings. The paper presents the results of four case studies, which use the approach to migrate selected crosscutting concerns from medium-sized Java programs (in the range of 10K to 40K lines of code) into equivalent programs in AspectJ. The case study results show the feasibility of the migration and indicate the importance of the enabling transformations as a preprocessing step	aspect-oriented programming;aspectj;code refactoring;cross-cutting concern;eclipse;java;plug-in (computing);preprocessor;programming paradigm;simple set;source lines of code;testbed	David W. Binkley;Mariano Ceccato;Mark Harman;Filippo Ricca;Paolo Tonella	2006	IEEE Transactions on Software Engineering	10.1109/TSE.2006.95	real-time computing;aspect-oriented programming;computer science;software engineering;automatic control;scattering;programming language;object-oriented programming;java;system testing;code refactoring;software quality	SE	-53.47273667871238	31.493146562556028	186664
b736a3f0b07f2dc92f3ef19adef90e9852688ebd	preserving architectural styles in the search based design of software product line architectures	search based design;software product line;architectural style	Architectural styles help to improve the Product Line Architecture (PLA) design by providing a better organization of its elements, which results in some benefits, like flexibility, extensibility and maintainability. The PLA design can also be improved by using a search based optimization approach, taking into account different metrics, such as cohesion, coupling and feature modularization. However, the application of search operators changes the PLA organization, and consequently may violate the architectural styles rules, impacting negatively in the architecture understanding. To overcome such limitation, this work introduces a set of search operators to be used in the search based design with the goal of preserving the architectural styles during the optimization process. Such operators consider rules of the layered and client/server architectural styles, generally used in the search based design of conventional architectures and PLAs. The operators are implemented and evaluated in the context of MOA4PLA, a Multi-objective Optimization Approach for PLA Design. Results from an empirical evaluation show that the proposed operators contribute to obtain better solutions, preserving the adopted style and also improving some software metric values.	client–server model;cohesion (computer science);coupling (computer programming);extensibility;mathematical optimization;multi-objective optimization;programmable logic array;server (computing);software metric;software product line	Thainá Mariani;Thelma Elita Colanzi;Silvia Regina Vergilio	2016	Journal of Systems and Software	10.1016/j.jss.2016.01.039	simulation;systems engineering;engineering;operating system;software engineering;engineering drawing	SE	-53.129008824758245	30.440669745090034	186791
0ce689d9735960b543f57b6a0086fb4ecb9fa71b	building uml-based use case sub-tool for component-based software development	software systems analysis;application software;object oriented applications uml based use case sub tool component based software development software systems analysis use case models;system analysis and design;software systems;object oriented programming;component based software;computer aided software engineering;computer aided software engineering programming shape control object oriented modeling application software unified modeling language software systems software standards system analysis and design computer science;use case models;object oriented;specification languages;unified modeling language;uml based use case sub tool;object oriented programming specification languages software tools subroutines;software standards;software tools;shape control;component based software development;computer science;object oriented applications;programming;use case;object oriented modeling;subroutines	In this work, we have proposed and built a new UML-based use-case sub-tool for the analysis of component-based software systems. The introduced use-case sub-tool generates the use-case model for the application under development. It can be used to generate use-case models for both object-oriented applications and component-based applications.		Fathy E. Eassa;O. A. Abulnaja	2001		10.1109/AICCSA.2001.934042	common component architecture;uml tool;computer science;software engineering;applications of uml;programming language;object-oriented programming	SE	-49.552667228287085	27.407955397366816	186996
e2d0d176060f4489820d459dc36658d41970ce8e	rule-based detection for reverse engineering user interfaces	independent set;user interface;rule based;dynamic analysis user interface reverse engineering user interface reengineering rule based detection large information system migration manual reverse engineering legacy applications user interface functionality model partial automation language independent rules legacy code user interface component detection;information system;reverse engineering user interfaces information systems computer interfaces graphical user interfaces automation educational institutions business process re engineering open systems workstations;dynamic analysis;reverse engineering	Abstract Reengineering the user interface can be a critical part of the migration of any large information system. This paper details experiences with manually reverse engineering legacy applications to build a model of the user interface functionality, and to develop a technique for partially automating this process. The results show that a language-independent set of rules can be used to detect user interface components from legacy code, and also illustrate problems that require dynamic analysis to solve. Reengineering the user interface can be a critical part of the migration of any large information system. This paper details experiences with manually reverse engineering legacy applications to build a model of the user interface functionality, and to develop a technique for partially automating this process. The results show that a language-independent set of rules can be used to detect user interface components from legacy code, and also illustrate problems that require dynamic analysis to solve. Information systems are critical to the operations of most businesses, and many of these systems have been maintained over an extended period of time, sometimes twenty years or more [JAY93]. With the advent of clientserver technology, open systems, and high-powered graphical workstations, many businesses are choosing to reengineer their critical applications to better fit the needs of the organization and to take advantage of new technologies. In the information systems domain, this frequently entails reengineering applications that run on large mainframes, with character or form-based user interfaces, to environments that require graphical user interfaces. It has been estimated that half or more of the code in an interactive system is devoted to implementing the user interface [SUT78]. User interface code tends to be very platform-dependent, often making it necessary to completely rewrite it when the system is migrated. If the user interface components can be extracted from the computational code and expressed in an abstract model, then maintenance and future migrations can be made much simpler, since only the user interface components would need to evolve. Forward engineering tools, such as a User Interface Management System could be employed to generate the new graphical user interface. Understanding the functional requirements of the user interface is an important part of reengineering, and adding automation to this pro0-8186-7674-4196 $5.00	code refactoring;computation;functional requirement;graphical user interface;independent set (graph theory);information system;interactivity;language-independent specification;legacy code;mainframe computer;management system;model-driven architecture;reverse engineering;rewrite (programming);user interface management systems;workstation	Melody Moore Jackson	1996		10.1109/WCRE.1996.558844	user interface design;rule-based system;user;user modeling;independent set;interface metaphor;shell;human–computer interaction;natural language user interface;magic pushbutton;computer science;systems engineering;user requirements document;operating system;software engineering;interface control document;dynamic program analysis;natural user interface;user interface;graphical user interface testing;information system;multiple document interface;reverse engineering	SE	-49.82371150163303	29.09098637834064	187283
940f68f76d3abb2e159055e290c416a594fb9c3f	refactoring the junit framework using aspect-oriented programming	refactoring;programming language;software systems;object oriented framework;object oriented;aspect oriented programming;crosscutting concerns	Aspect-Oriented Programming (AOP) has been proposed as a complementary modularization technique to the existing object-oriented techniques. AOP encourages the modular development of complex software by providing support for cleanly separating the basic system functionality from its crosscutting concerns. Since, AOP aims to improve the maintainability and reusability of OO software systems, it is necessary to develop case studies that enable us to evaluate: (i) how it can be used in conjunction with existing OO techniques; and (ii) how it can be used to modularize specific software features better than OO techniques. In this work, we present the refactoring of the JUnit object-oriented framework using the AspectJ programming language. The modularization of specific features of the JUnit framework using AspectJ has brought benefits to the understanding and maintainability of the framework, as well as to implement more flexible extensions.	aspect-oriented programming;aspectj;code refactoring;cross-cutting concern;junit;programming language;software system	Uirá Kulesza;Cláudio Sant'Anna;Carlos José Pereira de Lucena	2005		10.1145/1094855.1094901	aspect-oriented programming;computer science;programming language;object-oriented programming;code refactoring;software system	SE	-53.35017055028999	31.11646705960316	187558
96e4359be18005dcc635cf906a6a0ea18f9995e5	flow: a software development environment using diagrams	developpement logiciel;flow;programming environment;program design;conception programme;diagramme;portability;diagram;software development environment;portabilite;software development;environnement programmation;diagrama	The multiuser software development system FLOW uses a diagrammatic language, FLOW-DL, to represent the system under development. Once a module has been keyed in, one of three post-processors is called to generate source code in Pascal, Fortran, or Cobol. A fourth post-processor generates documentation. The system also includes a syntax-directed editor, as well as a software production data base which holds the FLOW-DL source code, interface data relating to the program modules, and control information pertaining to the state of the system under development. The package is portable; a graphics terminal is not required. Versions of the production system have been used for the past 4 years to develop a number of medium-sized software systems.	cobol;central processing unit;computer terminal;database;diagram;documentation;fortran;graphics;integrated development environment;multi-user;pascal;production system (computer science);software development;software system;structure editor	Jeffrey W. M. Dooley;Stephen R. Schach	1985	Journal of Systems and Software	10.1016/0164-1212(85)90021-4	software visualization;verification and validation;flow;software sizing;computer science;systems engineering;engineering;package development process;diagram;backporting;software design;software framework;component-based software engineering;software development;software design description;operating system;software engineering;software construction;program design language;development environment;real-time control system software;systems development life cycle;programming language;resource-oriented architecture;software deployment;software development process;software quality;software system	SE	-50.601335787366246	30.932961285329686	187730
79938f90dc0a2546872b34497c592163a244d940	architectural viewpoints for global software development	architectural viewpoint global software development architecture modeling;architecture modeling;meta model architectural viewpoints global software development gsd system software architecture design;model driven development;receivers;computer architecture;software architecture;thesis;syntactics;architectural viewpoint;organizations;global software development;programming;question framework;programming memory syntactics computer architecture receivers organizations software architecture;memory	Global Software Development (GSD) can be considered as the coordinated activity of software development that is not localized and central but geographically distributed. Designing an appropriate software architecture of a GSD system is important to meet the requirements for the communication, coordination and control of the distributed GSD teams. A common practice in software architecture design is to apply architectural views to model the design decisions for the various stakeholder concerns. Unfortunately, existing architectural viewpoint approaches are general-purpose and not directly dedicated towards GSD projects. In this paper we propose six architectural viewpoints that have been specifically defined to model GSD systems. The architectural viewpoints are based on a meta-model that has been derived after a thorough domain analysis of the GSD literature.	domain analysis;general-purpose modeling;metamodeling;requirement;software architecture;software development	Bugra M. Yildiz;Bedir Tekinerdogan	2011	2011 IEEE Sixth International Conference on Global Software Engineering Workshop	10.1109/ICGSE-W.2011.11	software architecture;programming;economics;architectural pattern;systems engineering;organization;engineering;software engineering;memory;management;computer engineering	SE	-53.49792627480413	27.40646853734803	187907
3dcb05ec0ae248d7db9559b59eaff9b6c2c10309	a systematic approach to transform uml static models to object-oriented code	object oriented	"""Formal and semi-formal techniques can play complementary roles in objectoriented software development. The purpose of this chapter is to present a reusebased rigorous method to forward engineering UML static models. This approach is based on the integration of semi-formal notations in UML with the algebraic style. The main contributions of this chapter are the definition of the GSBLoo algebraic language to cope with concepts of the UML models, the definition of the SpReIm model for the description of the structure of reusable components and the definition of a rigorous process with reuse that assists in the transformation of UML class diagrams to object-oriented code. Eiffel was the language of choice in which to demonstrate the feasibility of our approach. INTRODUCTION The Unified Modeling Language, UML, is rapidly becoming a de-facto standard for modeling software systems (OMG, 1999). It is a set of graphical and textual notations for specifying, visualizing and documenting object-oriented systems. An important feature of UML is that it is a modeling language, not a method, and therefore it does not prescribe any particular development process. UML is not a visual programming language, but its models can be directly connected to a variety of object-oriented programming languages through forward engineering processes. These processes transform UML models into code through a mapping to an implementation language (Booch, Rumbaugh & Jacobson, 1999). 22 Favre and Clérici UML is too imprecise and ambiguous when it comes to simulation, verification, validation and forecasting of system properties and even when it comes to generating implementations from specifications. Another problem is that models written in UML are semantically richer than any other current object programming language. For example, an object-oriented language does not possess an explicit syntax to express UML associations. These can be simulated by pointers and references, but then the structure of the system is not apparent. This often leads to problems during forward/reverse engineering between the specification and code. A variety of advantages have been attributed to the use of formal software specification to solve these problems. It is commonly accepted that a formal specification can reveal gaps, ambiguities and inconsistencies. Furthermore, a precise semantics provides the basis for automated forward engineering and reverse engineering (the process of transforming code into a model through a mapping from a specific implementation language). However, semi-formal approaches still dominate even in areas where formal approaches should provide a competitive advantage. The success of graphical modeling techniques is due to several reasons. On the one hand, they provide a set of graphical and textual descriptions that are easily understandable for both system developers and expert users. In general, there are also good tools to support them. On the other hand, formal methods provide minimal guidelines for eliciting and structuring requirements, and the notation of formal specification languages requires familiarity with symbolic logic that most designers and implementers do not currently have. Besides, the learning curve for the application of these new techniques requires considerable time. Formal and informal techniques can play complementary roles in software development. The integration should be based on the following considerations: • Formal models must preserve the interpretation of object-oriented models, constructions and underlying concepts reinforcing the informal interpretations. • Specification and reasoning must be integrated with code. • It is necessary to define mappings between formal models and object-oriented model constructs and concepts that provide the basis for assisted generation of formal specifications from informal specifications without forcing the user to change specification style. • Only those parts that can benefit from more rigorous specification and analysis must be formalized. In this chapter we present a rigorous process with reuse to forward engineer UML static models. This approach is based on the integration of semi-formal notations in UML with algebraic specifications. The primary objective of this integration is to make easier the analysis, reuse, evolution and maintenance of the software. Rather than requiring that developers manipulate formal specifications, we want to provide formal semantics for graphical modeling notations and develop rigorous tools that permit developers to directly manipulate models they have created. The bases of our approach are: • The definition of the GSBLoo algebraic language. • The definition of the SpReIm model for the description of the structure of a reusable component. • The definition of a method with reuse that assists in the transformation of UML class diagrams to object-oriented code. The GSBLoo language enriches GSBL (Clérici & Orejas,1988) with constructs that allow us to express different kinds of UML relations: generalization/specialization, depen20 more pages are available in the full version of this document, which may be purchased using the """"Add to Cart"""" button on the publisher's webpage: www.igi-global.com/chapter/systematic-approach-transformuml-static/30569"""	class diagram;code reuse;eiffel;formal methods;formal specification;graphical user interface;james rumbaugh;model-driven architecture;object language;partial template specialization;pointer (computer programming);requirement;reverse engineering;sms language;semantics (computer science);semiconductor industry;simulation;software development;software documentation;software system;unified modeling language;visual programming language;web page	Liliana Favre;Silvia Clerici	2001		10.4018/978-1-930708-05-1.ch002	real-time computing;uml tool;theoretical computer science;applications of uml;programming language;object constraint language	SE	-48.47207555076686	27.1166291540794	188972
ffa0b7c7182fd7f0577d774a4778a950abfec1cb	programs = data + algorithms + architecture: consequences for interactive software engineering	architecture issue;software reuse;user interface tool;conflicting pattern;programming language;architecture-induced concurrency;interactive system;software architecture;interactive software engineering;interactive software;architecture style	This article analyses the relationships between software architecture, programming languages and interactive systems. It proposes to consider that languages, like user interface tools, implement architecture styles or patterns aimed at particular stakeholders and scenarios. It lists architecture issues in interactive software that would be best resolved at the language level, in that conflicting patterns are currently proposed by languages and user interface tools, because of differences in target scenarios. Among these issues are the contra-variance of reuse and control, new scenarios of software reuse, the architecture-induced concurrency, and the multiplicity of hierarchies. The article then proposes a research agenda to address that problem, including a requirement-and scenario-oriented deconstruction of programming languages to understand which of the original requirements still hold and which are not fully adapted to interactive systems.	algorithm;code reuse;concurrency (computer science);programming language;requirement;software architecture;software engineering;user interface	Stéphane Chatty	2007		10.1007/978-3-540-92698-6_22	reference architecture;software architecture;software design pattern;computer science;systems engineering;theoretical computer science;software development;software architecture description;programming language;resource-oriented architecture;second-generation programming language	SE	-50.66500636834198	30.015656034486106	189087
b652797a35f974729e5e6c9a607783dcddb3a116	context driven slicing based coupling measure	sensibilidad contexto;developpement logiciel;software metrics;context aware;tranchage;maintenance;software performance evaluation;message passing program slicing software metrics software quality software performance evaluation object oriented programming;object oriented programming;slicing;desarrollo logicial;envoi message;software development;software metric;message passing;chapeado;mantenimiento;sensibilite contexte;program slicing;software metrics context driven slicing based coupling measures program slicing based coupling measurements software quality evaluation coupling between object classes response from classes message passing coupling slicing based source code analysis concept tool;qualite logiciel;software quality;software quality software measurement computer science area measurement software systems software maintenance message passing performance analysis performance evaluation software metrics	We present a framework of program slicing based coupling measurements to evaluate software quality. The proposed framework combines the well-known coupling measurement, CBO (coupling between object classes), RFC (response from classes), and MPC (message passing coupling), with slicing based source code analysis. The proposed measures are implemented in our CONCEPT tool, and an initial experimental analysis has been performed to illustrate the applicability of our measurements.		Juergen Rilling;Wen Jun Meng;Olga Ormandjieva	2004		10.1109/ICSM.2004.1357874	real-time computing;computer science;engineering;operating system;software engineering;database;software metric	EDA	-53.950204708360396	31.977618010887756	189242
d03cbcfe208014e99296d6c60b07c5421d7b9924	a generic tool-supported framework for coupling task models and interactive applications	architectures materielles;task models;systemes embarques;co execution;cryptographie et securite;modelisation et simulation;genie logiciel;interactive systems;interface homme machine	Task models are a very powerful artefact describing users' goals and users' activity and contain numerous information extremely useful for designing usable interactive application. Indeed, task models is one of the very few means for ensuring effectiveness of the application i.e. that the application allows users to reach their goals and perform their tasks. Despite those advantages, task models are usually perceived as a very expensive artefact to build that has to be thrown away as soon as the interactive application has been designed, i.e. right after the early stages of the design process are performed. However, tasks models can also be of great help for instance when used to support training material production, for training of operators and for providing tasks and goals oriented contextual help while the interactive application is being used ... This paper proposes a tool-supported framework for exploiting task models throughout the development process and even when the interactive application is deployed and used. To this end, we introduce a framework for connecting task models to an existing, executable, interactive application. The main contribution of the paper lies in the definition of a systematic correspondence between the user interface elements of the interactive application and the low level tasks in the task model. Depending on the fact that the code of the application is available or not, the fact that the application has been prepared at programming time for such integration or not, we propose different alternatives to perform such correspondence (in a tool-supported way). This task-application integration allows the exploitation of task models at run time bringing in the benefits listed above to any interactive application. The approach, the tools and the integration are presented on a case study of a Flight Control Unit (FCU) used in aircraft cockpits.	context-sensitive help;control unit;executable;run time (program lifecycle phase);user interface;visual artifact	Célia Martinie;David Navarre;Philippe A. Palanque;Camille Fayollas	2015		10.1145/2774225.2774845	real-time computing;simulation;computer science;theoretical computer science	HCI	-51.307011357394586	31.44031407766413	189411
4a68f11a278794fffdb9061f2cdc97929d3aeed8	towards a two-dimensional separation of concerns (poster session)	fault tolerant;programming language;separation of concern;analysis and design;software systems;software engineering;software architecture;functional decomposition;aspect oriented programming;software migration;concurrent programs;source code;software life cycle;software quality	As the size and requirements of software systems increase, their design has reached a complexity that requires software engineers to revisit the principle of separation of concerns [5]. Traditional software organization has been performed along some form of functional decomposition. Different paradigms and languages support the implementation, and composition of sub-parts into whole systems through the availability of some modular unit of functionality (component). In essence, traditional software decomposition and current programming languages have been mutually supportive [4]. At the same time, separation of concerns can only be beneficial if the different concerns can be effectively composed to produce the overall system. The OOP paradigm seems to work well only if the problem to be solved can be described with relatively simple interfaces among objects. Unfortunately, this is not the case when we move from sequential programming to concurrent programming where the component interaction violates simple object interfaces. One of the reasons behind this is the inherent structure of today's software systems that conceptually does not lead itself to a safe decomposition. As a result, the benefits associated with OOP no longer hold. Component interactions limit reuse and make it difficult to validate the design and correctness of software systems. Reengineering of these systems is needed in order to meet future changes in requirements. This component interaction is based on a number of properties that affect the semantics or the performance of the system and do not localize well in one modular unit, but tend to cut-across groups of components resulting in a “code tangling” [4]. Example cross-cutting properties (or aspects) include synchronization, scheduling, and fault tolerance. This code tangling destroys modularity, making the source code difficult to develop and difficult to understand. It also limits reuse, making the source code difficult to evolve. It further makes programs more error prone. In essence, it destroys the quality of the software. In [1] the authors refer to these phenomena as “composition anomalies”. This composition anomaly requires a shift in the methodologies used to separate concerns. In conjunction with modular composition, adaptability and reuse remain major issues to be considered while building complex software systems. Aspect-Oriented Programming (AOP) [4] is an emerging methodology that addresses components and aspects at the analysis and design phase of the software life-cycle, using mechanisms to compose them at the implementation level with a growing number of different technologies.	anomaly detection;aspect-oriented programming;code refactoring;cognitive dimensions of notations;concurrent computing;correctness (computer science);fault tolerance;interaction;programming language;programming paradigm;requirement;scheduling (computing);separation of concerns;software engineer;software release life cycle;software system;synchronization (computer science)	Constantinos A. Constantinides;Tzilla Elrad	2000		10.1145/367845.367938	functional decomposition;software architecture;software modernization;fault tolerance;real-time computing;n-version programming;aspect-oriented programming;software sizing;separation of concerns;computer science;package development process;backporting;software design;software framework;component-based software engineering;software development;software design description;domain engineering;software construction;programming language;resource-oriented architecture;software development process;software quality;programming complexity;software metric;software system;source code;avionics software	SE	-52.86164932963881	29.6860957274036	189458
388559652d98a1a41390ebcfa8d374c5c96f4791	tool support for coordination-based software evolution	it strategy;components;object oriented methods;technological innovation;tool support;software maintenance;global competitive business environments;business strategy;software systems;contracts;object oriented programming;object oriented techniques;architecture based approach;technological advances;development tool;business environment;software tools costs contracts object oriented modeling organizational aspects power system modeling informatics buildings mathematical model technological innovation;software tool support;software evolution;compositional modelling primitive;object oriented;organizational aspects;mathematical model;object oriented methods software maintenance software tools subroutines object oriented programming;coordination contract;informatics;software tools;power system modeling;components software tool support coordination based software evolution global competitive business environments business strategy it strategy technological advances business rules object oriented techniques architecture based approach coordination contract compositional modelling primitive;business rules;object oriented modeling;buildings;subroutines;coordination based software evolution	In today’s global and highly competitive business environments, organisations are replying to the question of whether technology is forming business or vice-versa by integrating their business and IT strategies, thus using technology to do business. As a consequence, there is an increasing pressure for building software systems that are able to cope with new requirements imposed by both technological advances and different business rules. At the same time, it is now widely accepted that, although Object-Oriented techniques have provided useful tools for software construction, their support cannot be extended directly to evolution. Even worse, it is becoming evident that there is a lack of theoretical principles and accompanying practical tools that can effectively support software evolution. In this paper, we describe in detail a development tool that is based on sound mathematical principles and supports an architecture-based approach to evolution centred on the notion of coordination contract – a modelling primitive that treats components as black boxes and is compositional with respect to change.	black box;geometric primitive;glossary of computer graphics;requirement;software construction;software evolution;software system	João Gouveia;Georgios Koutsoukos;Luis Filipe Andrade;José Luiz Fiadeiro	2001		10.1109/TOOLS.2001.911772	business requirements;computer science;knowledge management;artifact-centric business process model;management science;object-oriented programming;business rule;new business development;business process modeling;strategic management	SE	-53.48417097045076	27.259553163478344	190088
1d45095e64019ce4b143c60fa3a23443a2e83ea8	using aspect-oriented php to implement crosscutting concerns in a collaborative web system	web system;new technology;web engineering;separation of concern;aspect oriented programming;software development;php;crosscutting concerns;aspect oriented;access control;version control;web development	Aspect-Oriented Programming (AOP) is a new technology that was proposed to improve separation of concerns in software development. AOP's main focus is to use aspect modules to implement concerns that would be generally scattered across the system and tangled with other modules (crosscutting concerns). Although much research has focused on AOP's application to traditional software development, little has been done towards its application to Web development. Aspect-oriented PHP (aoPHP) is an addition to PHP that allows the use of AOP in the Web development context. In this paper we describe an application of aoPHP to show that AOP can also be effectively used in theWeb development context. In particular, we have implemented two crosscutting concerns in a collaborative Web system named CoTeia: the access control and the version control functionalities. Furthermore, we discuss how AOP can enhance the design of Web applications by reasoning on the refactored system	access control;aspect-oriented programming;code refactoring;cross-cutting concern;php;separation of concerns;version control;web development;world wide web	Otávio Augusto Lazzarini Lemos;Daniel Carnio Junqueira;Marco Aurélio Graciotto Silva;Renata Pontin de Mattos Fortes;John W. Stamey	2006		10.1145/1166324.1166358	web development;web modeling;aspect-oriented programming;computer science;database;web engineering;programming language;web application development	SE	-53.1717969705875	30.5364438855252	190471
3aedb91688c181b5ab4c4131751b3aac47629a0b	languages and tools for managing feature models	formal languages;software tools;familiar;fm;tvl;complementary languages;feature models management;languages applications;modeling variability;software product lines;automated reasoning;feature models;languages;model management;software product lines;variability	Feature models (FMs) are the de facto standard for modeling variability of software product lines. The research effort is still intensive and aims at increasing the adoption of FMs in practice. Integrated solutions that combine state-of-the-art techniques, languages, and tools are emerging. We give an overview of complementary languages, TVL and FAMILIAR, and tools for the purpose of supporting the management (e.g., configuration) of FMs. We report on practical applications of the languages and tools in different domains and for different purposes. Still, we are interested in applying our solutions to other contexts (e.g., industrial) in order to determine their applicability and possible adoption by practitioners.	feature model;software product line;spatial variability	Mathieu Acher;Raphaël Michel;Patrick Heymans;Philippe Collet;Philippe Lahire	2012	2012 Third International Workshop on Product LinE Approaches in Software Engineering (PLEASE)		natural language processing;computer science;systems engineering;programming language	SE	-54.79743824726832	25.346657818065257	190756
bdf30f7f80e7ac1e41415ff86e25e062ffe3be50	software engineering design patterns for relational databases.	unified process;logic design;relational database;software engineering;design and implementation;design pattern;unified modeling language;database design	The use of design patterns such as the GRASP (General Responsibility Assignment Software Principles) or GoF (Gang-of-Four) patterns in software engineering has been well-documented and widely used in software design and implementation. Research efforts have also been made to apply these generic software engineering design patterns to other design and implementation endeavors in computer science. One such effort is our research [8] to propose a strategy for the integration of the teaching of software engineering and databases, using an innovative curriculum for teaching database design and implementation based on the UML (Unified Modeling Language), the Unified Process, and design patterns. Our previous effort [6] has demonstrated the use of GRASP patterns for the development of relational databases. In this research, we further investigate GoF design patterns for the design and implementation of relational databases. The application of generic software engineering design patterns to databases allows issues in logical design and in implementation of databases to be more easily connect with similar concerns in software engineering.	computer science;database design;design pattern;engineering design process;grasp;relational database;software design;software engineering;unified modeling language;unified process	Cyril S. Ku;Thomas J. Marlowe;Tatyana Budanskaya;Philip Kang	2007			object-oriented analysis and design;data modeling;database theory;relational model;design process;entity–relationship model;idef4;relational database;computer science;systems engineering;unified process;software design;object-oriented design;database model;interaction design pattern;software construction;data mining;database;distributed design patterns;structural pattern;computer-aided software engineering;database design	SE	-50.73629111246185	27.61375516839475	191161
a4464a6bb233e9d00da8526b54dc3037344ef000	reverse engineering reusable software components from object-oriented apis	api;frequent usage pattern;object oriented;software component;software reuse;reverse engineering	Object-oriented Application Programing Interfaces (APIs) support software reuse by providing pre-implemented functionalities. Due to the huge number of included classes, reusing and understanding large APIs is a complex task. Otherwise, software components are accepted to be more reusable and understandable entities than object-oriented ones. Thus, in this paper, we propose an approach for reengineering objectoriented APIs into component-based ones. We mine components as a group of classes based on the frequency they are used together and their ability to form a quality-centric component. To validate our approach, we experimented on 100 Java applications that used Android APIs.	android;application programming interface;code refactoring;code reuse;component-based software engineering;entity;java;reverse engineering	Anas Shatnawi;Abdelhak-Djamel Seriai;Houari A. Sahraoui;Zakarea Alshara	2017	Journal of Systems and Software	10.1016/j.jss.2016.06.101	software;software construction;real-time computing;systems engineering;component-based software engineering;software framework;computer science;reverse engineering;software development;software sizing;java	SE	-53.678092281136884	30.45461356232186	191656
23fe7925684e1338feee66f9a8cc7faa69d0d128	case environments for design automation	design automation;application software;software engineering;computer aided software engineering;modems;switches;optimizing compilers;programming;computer aided software engineering design automation software engineering programming application software modems software quality computer integrated manufacturing optimizing compilers switches;computer integrated manufacturing;software quality	This paper gives an introduction to important issues of software engineering and computer-aided software engineering (CASE), focusing on the necessary qualities for a CASE environment. These characteristics are then related to the needs of design automation, showing some of the analogies between CAD and CASE. Finally, the paper describes some properties of the Software through Pictures integrated CASE environment and shows how that environment provides those qualities.	automation;computer-aided design;computer-aided software engineering	Anthony I. Wasserman	1989	26th ACM/IEEE Design Automation Conference	10.1145/74382.74415	programming;verification and validation;computing;application software;software engineering process group;software sizing;electronic design automation;network switch;search-based software engineering;computer science;systems engineering;software design;social software engineering;software framework;component-based software engineering;software development;software engineering;software construction;computer-integrated manufacturing;software walkthrough;resource-oriented architecture;software measurement;software deployment;computer-aided software engineering;software requirements;software quality;software system;computer engineering	EDA	-52.417540667393325	28.44738098524767	192592
524fbabf82850642e3841631c5e96466384f7f07	migrating large object-oriented applications into component-based ones: instantiation and inheritance transformation	encapsulation;refactoring;component;object;code transformation;class instantiation;osgi;inheritance;java	Large object-oriented applications have complex and numerous dependencies, and usually do not have explicit software architectures. Therefore they are hard to maintain, and parts of them are difficult to reuse. Component-based development paradigm emerged for improving these aspects and for supporting effective maintainability and reuse. It provides better understandability through a high-level architecture view of the application. Thereby migrating object-oriented applications to component-based ones will contribute to improve these characteristics (maintainability and reuse). In this paper, we propose an approach to automatically transform object-oriented applications to component-based ones. More particularly, the input of the approach is the result provided by software architecture recovery: a component-based architecture description. Then, our approach transforms the object-oriented source code in order to produce deployable components. We focus in this paper on the transformation of source code related to instantiation and inheritance dependencies between classes that are in different components. We experimented the proposed solution in the transformation of a collection of Java applications into the OSGi framework. The experimental results are discussed in this paper.	component-based software engineering;encapsulation (networking);event (computing);exception handling;high-level architecture;java;osgi;programming paradigm;software architecture recovery;subroutine;substitution (logic);universal instantiation	Zakarea Alshara;Abdelhak-Djamel Seriai;Chouki Tibermacine;Hinde-Lilia Bouziane;Christophe Dony;Anas Shatnawi	2015		10.1145/2814204.2814223	real-time computing;computer science;database;programming language	PL	-52.7021714871575	29.853528776519283	192706
71951b7890087f9ddd316f739b567a38d89208d3	realizing multi-variant model transformations on top of reused atl specifications		Model transformations are crucial in model-driven software engineering (MDSE). While combining MDSE and software product line engineering (SPLE) techniques, summarized as model-driven product line engineering (MDPLE), promises increased productivity by relying on organized reuse, the benefits are impeded by transformation specifications designed exclusively for single-variant models. Applying single-variant model transformations to multi-variant input models results in output models lacking the variability information. Multi-variant model transformations (MVMT), which preserve variability information, have only recently been understood as an explicit research problem. In this paper, we propose an a posteriori approach towards MVMT. Following the paradigm of organized reuse, we propose to employ single-variant model transformations without modifications in a first step, and to transfer variability information afterwards based on the artifacts provided by the single-variant transformation specification. In particular, we implemented this approach for the well-known model-to-model transformation language ATL. To deduce variability information, the execution artifacts (trace and execution model) are analyzed. Then, variability annotations are transfered to the target model automatically. The implementation is evaluated based on a practically example of a Graph product line. Results exhibit that our approach outperforms the conventional solution with respect to user effort, accuracy and performance.	atlas transformation language;domain engineering;graph product;graph rewriting;heart rate variability;msde;model transformation language;model-driven architecture;model-driven engineering;model-driven integration;programming paradigm;software engineering;software product line;spatial variability;whole earth 'lectronic link	Sandra Greiner;Felix Schwägerl;Bernhard Westfechtel	2017		10.5220/0006137803620373	algorithm	SE	-53.60539448609521	25.445508952063395	192861
1dcf7694c7836b041ef9031e49fe0acf1dbbe93e	software component self-description: labeling components in a software supermarket	software component		component-based software engineering	Richard A. Pyne;Ezra Kaahwa Mugisa	2004			software system;embedded system;computer engineering;component-based software engineering;software;computer science	SE	-49.38134909399001	30.55020147660005	193182
67e7fe8e43080832e91cd5086ef43b2fa3317e44	using structured analysis and design technique (sadt) for simulation conceptual modelling	software requirements engineering;thesis;conceptual modelling;structured analysis and design technique;computer science;discrete event simulation		simulation;structured analysis	Fahim Ahmed	2016			computational science;simulation;computer science;systems engineering;structured analysis and design technique;structured analysis	EDA	-50.8853911779065	27.555244887941285	193617
559029cdbaf6513bc29e0c7905e9dc3eaeef2ea7	bridging java annotations and uml profiles with jump		UML profiles support annotations at the modeling level. However, current modeling tools lack the capabilities to generate such annotations required for the programming level, which is desirable for reverse engineering and forward engineering scenarios. To overcome this shortcoming, we defined an effective conceptual mapping between Java annotations and UML profiles as a basis for implementing the JUMP tool. It automates the generation of profiles from annotation-based libraries and their application to generate profiled UML models. In this demonstration, we (i) compare our mapping with the different representational capabilities of current UML modeling tools, (ii) apply our tool to a model-based software modernization scenario, and (iii) evaluate its scalability with real-world libraries and applications.	bridging (networking);java annotation;library (computing);model-driven architecture;profile (uml);reverse engineering;scalability;software modernization;uml tool;unified modeling language	Alexander Bergmayr;Michael Grossniklaus;Manuel Wimmer;Gerti Kappel	2014			database;programming language;theoretical computer science;java annotation;reverse engineering;unified modeling language;scalability;bridging (networking);computer science;jump;software modernization;annotation	SE	-48.54499113598183	25.708816153296628	193691
8a5827987fbfc6589c99d8058633e1125369cc06	uml case tool supporting ole compound document	unified modeling language computer aided software engineering documentation containers research and development productivity application software object oriented modeling power system modeling usability;object oriented methods;uml;object oriented programming;com ole;computer aided software engineering;research and development;com ole case tool uml compound document support;interoperability uml case tool ole compound document object oriented technology component based technology;object oriented;case tool;distributed object management;unified modeling language;software tools;open systems;compound document support;support function;distributed object management computer aided software engineering unified modeling language software tools object oriented programming object oriented methods open systems	Research and development projects, in the past decade, have shown that object-oriented (OO) technology could importantly contribute in productivity and reusability improvement. There are various research areas related to OO technology. Two of major research fields in this area are concerned in issues for CASE tools and component- based technologies. This paper discusses an example of applying component-based technology to a CASE tool. This paper proposes the research experience gained while we have developing OODesigner, an OO CASE tool, with compound document support functionality based on COM/OLE technology. As OODesigner with compound document support has interoperability with other application software of Windows system, it can provide more powerful documentation environment than other CASE tools. OODesigner can be used not only to model UML diagrams, but also to make documentation cooperatively with various kinds of OLE servers and containers. Therefore we can conduct powerful and consistent documentation with the tool. In this paper, we present design issues for incrementally implementing the compound document support facilities as a container and a server and show a brief sample for demonstrating the usability of the OLE enabled CASE tool.	code generation (compiler);component-based software engineering;computer-aided software engineering;diagram;documentation;interoperability;microsoft windows;object linking and embedding;reverse engineering;server (computing);software testing;systems design;unified modeling language;usability	Gilrim Choi;Taegyun Kim	2004	11th Asia-Pacific Software Engineering Conference	10.1109/APSEC.2004.105	unified modeling language;computer science;systems engineering;software engineering;database;programming language;object-oriented programming	SE	-52.75723984891848	28.475552661436456	194463
3a11ab33d1fdb22c864c067bf290287e3aae87f4	development of a reliable gui for diahdl: a web-based vhdl code generator	libraries;hardware design languages;software;synthesizable vhdl code;reliability;generators;aesthetic visualization;vhdl code generator;reliable gui;graphical user interface gui;finite impulse response filter;hardware description languages;code generation;graphical user interface;software reliability graphical user interfaces hardware description languages;interface design;digital component;finite impulse response filter libraries hardware design languages servers generators graphical user interfaces software;servers;finite impulse response;graphical user interfaces;component diagram reliability graphical user interface gui vhdl code generator;diahdl tool;web based vhdl code generator;user interaction mechanism;software component;graphic user interface;component diagram;hardware design;reliability inception;vhdl generator tool;software reliability;aesthetic visualization reliable gui web based vhdl code generator vhdl generator tool component diagram synthesizable vhdl code graphical user interface digital component reliability inception interface design user interaction mechanism diahdl tool	The VHDL generator tools aim is to translate designed component diagram to synthesizable VHDL code. The tools is web based, its provides a graphical user interface that allows the user to select a digital component, customize their parameter and generate the VHDL code. The Reliability inception in this VHDL code generator is a probability method for measurement the tools in complicated parameter to be simplified. To support the VHDL generator code tools, development of Graphic User Interface (GUI) is presented. Beginning with designing ideas of the interface within the tools based on principles of good interface design, the implementation of the design for the tools is to provide interface which address the needs of its users. Designing an interface for users its requires to deal with a number of issue. The User interaction mechanism with the tools is being the main concern to improve the tools interface for being able performed effectively with the user. The research study, it's to develop graphic user interface of DiaHDL tools, which is able to provide both functional and aesthetic visualization in design. The Graphical user interface is able to represent information into pleasing visualization.	automatic programming;client–server model;code generation (compiler);component diagram;design flow (eda);digital electronics;graphical user interface;java;logic synthesis;php;server (computing);vhdl;web application	Anita Ratna Dewi Susanti;Wildan Thoyib;Thomas Schumann	2011	Proceedings of the 2011 International Conference on Electrical Engineering and Informatics	10.1109/ICEEI.2011.6021819	user interface design;computer architecture;interface metaphor;computer science;theoretical computer science;operating system;graphical user interface;natural user interface;programming language;user interface;graphical user interface testing	HCI	-49.22410785684528	30.422016420703102	194697
a75868f226c6ada3fbd1a9ce2a441b354c82e89b	a new technique for testing settling time in a production environment.			settling time	J. Anson Whealler	1981			real-time computing;computer engineering;computer science;settling time;development environment	SE	-49.20660914362201	29.96459686287721	194845
2c68819ba6e9f33e1b504e91236cc5c60987a87d	evolution patterns: designing and reusing architectural evolution knowledge to introduce architectural styles		Software architectures are critical in the successful development and evolution of software-intensive systems. While formal and automated support for architectural descriptions has been widely addressed, their evolution is equally crucial, but significantly less well-understood and supported. In order to face a recurring evolution need, we introduce the concept of evolution pattern. It formalises an architectural evolution through both a set of concepts and a reusable evolution process. We propose it through the recurring need of introducing an architectural style on existing software architectures. We formally describe and analyse the feasibility of architectural evolution patterns, and provide a practical validation by implementing them in COSABuilder, an Eclipse plug-in for the COSA architectural description language.	critical pair (logic);eclipse;evolution;first-class function;graph rewriting;plug-in (computing);sequence analysis;software architecture;well-formed document	Dalila Tamzalit;Tom Mens	2016	CoRR		simulation;architectural geometry;architectural pattern;computer science;systems engineering;knowledge management;architectural technology;representational state transfer	SE	-53.20654327556413	25.73540827036093	194996
61591a66a17da0e7e488718c37a37fe5676994eb	intra-class testing of abstract class features	reliability engineering;software testing;design tool;performance evaluation;software libraries;system under test;power engineering and energy;power engineering computing;object oriented;software testing concrete system testing java software libraries performance evaluation software reliability reliability engineering power engineering and energy power engineering computing;system testing;computer science;static analysis;software reliability;concrete;java	One of the characteristics of the increasingly widespread use of object-oriented libraries and the resulting intensive use of inheritance is the proliferation of dependencies on abstract classes. Such classes defer the implementation of some features, and are typically used as a specification or design tool. However, since their features are not fully implemented, abstract classes cannot be instantiated, and thus pose challenges for execution-based testing strategies. This paper presents a structured approach that supports the testing of features in abstract classes. Core to the approach is a series of static analysis steps that build a comprehensive view of the inter-class dependencies in the system under test. We then leveraged this information to define a test order for the methods in an abstract class that minimizes the number of stubs required during testing, and clearly identifies the required functionality of these stubs. Our approach is based on a comprehensive taxonomy of object-oriented classes that provides a framework for our analysis. First we describe the algorithms to calculate the inter-class dependencies and the test-order that minimizes stub creation. Then we give an overview of our tool, AbstractTestJ that implements our approach by generating a test order for the methods in an abstract Java class. Finally, we harness this tool to provide an analysis of 12 substantial Java applications that demonstrates both the feasibility of our approach and the importance of this technique.	abstract type;algorithm;design tool;dynamic testing;java;library (computing);static program analysis;system under test;taxonomy (general)	Peter J. Clarke;Djuradj Babich;Tariq M. King;James F. Power	2007	The 18th IEEE International Symposium on Software Reliability (ISSRE '07)	10.1109/ISSRE.2007.11	reliability engineering;real-time computing;concrete;computer science;systems engineering;engineering;operating system;software engineering;software testing;system under test;programming language;object-oriented programming;java;system testing;static analysis;software quality	SE	-55.29787172555911	31.490855199318013	195027
3b81e11346d4ba28517dfef059e90c25501eb534	what should we collect to preserve the history of software?	informatica;museo;musee;history;raw materials;logiciel;preserving software;distributed computing;data processing;conservaciňn;source code repository;assembly;history of programming preserving software source code repository software history;conservation;guidelines;difference engines;programming profession;museographie;writing;history of programming;museum;informatique;source code;history writing documentation assembly raw materials programming profession difference engines distributed computing guidelines software packages;software history;documentation;software packages	Software is more than cards, tapes and disks; it is the meaning of the bits that they contain. To properly preserve the history of computing, we must preserve the software code, especially the source code, for analysis by future historians.	history of software	Leonard J. Shustek	2006	IEEE Annals of the History of Computing	10.1109/MAHC.2006.78	conservation;data processing;documentation;computer science;engineering;electrical engineering;artificial intelligence;operating system;software engineering;database;assembly;programming language;writing;world wide web;algorithm;source code	Arch	-50.78246823160854	31.543304893000386	195427
1a61417f5a2d6513c5defc8ed06354e1d3bf8881	feature model for modeling compound soa design patterns	semiconductor optical amplifiers;reliability engineering;feature model compound design pattern soa message oriented soa design patterns software product line;compounds;mass customization;routing;compounds semiconductor optical amplifiers mass customization service oriented architecture routing reliability engineering;service oriented architecture;software product lines mass production product customisation service oriented architecture;nonfunctional constraints feature model compound soa design pattern modelling mass customization compound design pattern software product line spl development variability model cardinality based feature model functional requirements	In this paper, we propose a new approach for modeling compound SOA design patterns. The goal is to easily building and allowing the mass customization of compound design patterns. In this regard, we have used the paradigm of Software Product Line (SPL). The SPL development is realized through several tasks. In this work, the elaboration of the variability model, in particular the cardinality-based feature model, has been considered. We propose to compose this model with three related layers. Thus, it will be easy to interpret and to understand. The first layer expresses the existing dependencies and constraints between design patterns. Thus, only valid compound design patterns can be obtained. The second one illustrates the functional requirements. The third one shows the non-functional constraints.	code generation (compiler);design pattern;feature model;functional requirement;mandatory access control;programming paradigm;separation of concerns;service-oriented architecture;software product line;spatial variability	Akram Kamoun;Mohamed Hadj Kacem;Ahmed Hadj Kacem	2014	2014 IEEE/ACS 11th International Conference on Computer Systems and Applications (AICCSA)	10.1109/AICCSA.2014.7073224	routing;real-time computing;mass customization;computer science;service-oriented architecture;database;structural pattern;computer network;oasis soa reference model	SE	-54.52982997735356	27.00111315108228	195751
9d1fb5ca64cac15a52614f866f46f31150447807	visualizing and analyzing discrete sets with a uml and ocl software design tool		This contribution discusses the visualization of discrete sets. With diagrams, we realize filtering set elements with particular properties, study set-theoretic operations, and exhibit set elements and their internal relationships. These techniques allow software developers to explore crucial set properties diagramatically.	design tool;diagram;object constraint language;set theory;software design;software developer;unified modeling language	Martin Gogolla;Khanh-Hoang Doan	2018			systems engineering;software design;unified modeling language;computer science	SE	-53.661747719509094	30.826442838549905	196049
2eaad2bc00c841d7ea16f34986d35699688b0266	design patterns as a guide to the cultural localisation of software	design pattern			Patrick A. V. Hall;Chris Lawson;Shailey Minocha	2003			software;software design pattern;design pattern;systems engineering;structural pattern;engineering	SE	-51.39534943789437	26.947769745584953	196827
5f569cf0631c693bbc9c27aeeeb7fc832f38224e	a knowledge based approach to parallel software engineering	software engineering;knowledge base	Advances in technology have resulted in the development of many different multiprocessor systems. Unfortunately these have not been accompanied by advances in portable, user-friendly program development environments. This paper overviews the prototype of a development and migration environment for parallel software engineering which incorporates the application of knowledge based techniques to the core topics of loop restructuring, code generation and code evaluation.	software engineering	Peter Milligan;Paul Sage;Paul McMullan;Patrick H. Corr	1996		10.1007/978-0-387-34984-8_28	personal software process;verification and validation;software engineering process group;software sizing;software mining;software verification;search-based software engineering;systems engineering;knowledge management;social software engineering;component-based software engineering;software development;feature-oriented domain analysis;software engineering;domain engineering;knowledge engineering;software construction;software walkthrough;software requirements;domain knowledge;software system;computer engineering	SE	-51.830223534763896	28.81742451357934	196917
101594331459b17b82a9da0615a7b60799b54292	a platform-independent uml profile for aspect-oriented development	aspect oriented system development;aspect oriented software development;aspect oriented modeling;code generation;software systems;proof of concept;uml profile;target language;interchange format;system development;aspect oriented	Aspect Oriented Software Development (AOSD) has its roots in the need to deal with requirements that cut across the primary modularization of a software system. On the programming level, mature, industrial-strength tools like the de-facto standard AspectJ exist. However, on the modeling level, there is as yet little support for AOSD. Building on previous work and using standard UML extension mechanisms, we develop UML modeling support for both static and dynamic AOSD. Code generation is done by working from the UML XMI (XML Model Interchange) format, the standard UML serialization. As a proof-of concept, we implement XSL transformations that generate valid code for two target languages, AspectJ and AspectS.	aspect-oriented programming;aspect-oriented software development;aspectj;profile (uml);requirement;serialization;software system;uml tool;unified modeling language;xml metadata interchange;xslt	Joerg Evermann;Adrian Fiech;Farhana Eva Alam	2011		10.1145/1992896.1992900	aspect-oriented programming;uml tool;computer science;applications of uml;programming language;proof of concept;code generation;software system	SE	-48.70605507358421	25.824771897211516	197196
6b2aa944b7712a1b18baaad593ad39256c66b3fa	a model-driven approach to microservice software architecture establishment			microservices;model-driven architecture;software architecture	Branko Terzic;Vladimir Dimitrieski;Slavica Kordic;Ivan Lukovic	2018		10.15439/2018F370	data mining;software architecture;computer architecture;computer science	SE	-51.8291065459245	26.32928845369456	198046
496d49a51879bc150802845bda483c8173f139d3	ao4aadl: aspect oriented extension for aadl		Managing embedded system complexity and scalability is one of the most important problems in software development. To better address this problem, it is very recommended to have an abstraction level high enough to model such systems. Architectural description languages (ADLs) intend to model complex systems and manage their structure at a high abstraction level. Traditional ADLs do not normally provide appropriate formalisms to separate any kind of crosscutting concerns. This frequently results in poor descriptions of the software architectures and a tedious adaptation to constantly changing user requirements and specifications. AOSD (Aspect Oriented Software Development) deals with these problems by considering crosscutting concerns in software development. The effectiveness of considering an aspect-oriented architectural design appears when aspect concepts are taken into account early in the software’s life-cycle. In this paper, we propose a new aspect language called AO4AADL that adequately manipulates aspect oriented concepts at architecture level in order to master complexity and ensure scalability. The abstract nature of our proposed language allows the generation of aspect code for several programming languages and platforms.	abstract syntax tree;abstraction layer;ada;architecture analysis & design language;architecture description language;aspect-oriented programming;aspect-oriented software development;aspectj;automatic programming;code generation (compiler);complex systems;cross-cutting concern;data event;embedded system;modularity (networks);programming language;prototype;real time java;requirement;run time (program lifecycle phase);scalability;software architecture;usability;user requirements document	Sihem Loukil;Slim Kallel;Bechir Zalila;Mohamed Jmaiel	2013	Central European Journal of Computer Science	10.2478/s13537-013-0105-1	real-time computing;architectural pattern;computer science;systems engineering;software development;programming language	SE	-53.19383802253778	29.65458080534471	198047
e622f7d4d8fb3c8b4a6894c489f5cfac4bb84127	bank-check processing system: modifications due to the new european currency	law legal factors europe text analysis handwriting recognition impedance writing software tools computer aided software engineering software prototyping;software tool;digit recognition bank check processing system european currency euro software tools computer aided software engineering tools khoros system system prototype visual programming environment remittance processing bank check recognition image preprocessing;bank data processing;cheque processing;visual programming;computer aided software engineering;document image processing;computer aided software engineering bank data processing cheque processing document image processing	"""The introduction of a new currency in Europe has changed the way of writing both the courtesy and the legal amount on checks. This paper presents the most important modifications brought on the bank-check processing system in order to solve the related problems also by proposing the software tools that must be utilized. The Computer Aided Software Engineering tools provided by the """"Khoros"""" system are used to support the improvement of the system prototype. A visual programming environment is used to assemble the bankcheck processing system that can be easily modified and extended. The experimental results allow the adjournment of the improved system, as the modifications are introduced."""	computer-aided software engineering;integrated development environment;prototype;visual programming language	Nancy Greco;Donato Impedovo;M. G. Lucchese;A. Salzo;L. Sarcinella	2003		10.1109/ICDAR.2003.1227686	computer vision;verification and validation;computing;simulation;speech recognition;software sizing;computer science;software design;social software engineering;software framework;component-based software engineering;software development;machine learning;software construction;software walkthrough;visual programming language;resource-oriented architecture;software deployment;computer-aided software engineering;software requirements;software system	SE	-49.70588798140967	29.337387898074937	198569
06de325836174a95c4e1ea7fbc8b3a340bef4bf0	can styles improve architectural pattern reuse ?	software representation architectural pattern reuse software patterns architecture centered software development architectural styles software systems;architectural design;architecture description language;reuse architectural patterns architectural styles;best practice;software systems;object oriented programming;reuse;software pattern;architectural styles;software architecture;general solution;software reusability object oriented programming software architecture;software reusability;software development;architectural pattern;computer architecture software architecture pattern analysis software systems context architecture description languages application software software engineering best practices programming;architectural patterns;architectural style	Software patterns are generic solutions to recurring problems. They are represented as a triplet (problem, context, solution). Several kinds of software patterns were identified, examples of which are analysis, architecture, design or implementation patterns. The current practice is to represent patterns as documents that communicate best practices. Their reuse is limited by several factors among which the lack of formalization. In the context of architecture centered software development, architectural styles are means to represent families of software systems. Several architecture description languages offer support for representing architectural styles. We believe that the use of architectural styles in the representation of architectural pattern solutions can improve the pattern reuse level. The paper details how this improvement can be achieved.	architectural pattern;architecture description language;best practice;software development;software system;triplet state	Sorana Cîmpan;Vincent Couturier	2008	Seventh Working IEEE/IFIP Conference on Software Architecture (WICSA 2008)	10.1109/WICSA.2008.38	software architecture;computer architecture;software design pattern;architectural pattern;computer science;systems engineering;engineering;software engineering;presentation–abstraction–control	SE	-53.247959374381416	27.869311579237984	198600
67ef19971e22605aac5a7f3c76bdc8b358224779	use case driven integration of tmn interface specification and application design	application development;virtual private network;vpn;tmn application development guidelines;project management;object oriented methods;functional based tmn service specification;telecommunication management network;object oriented design;application software;telecommunication computing;maintenance engineering;object modelling technique tmn interface specification tmn interface application design use case driven integration eurescom project p414 telecommunications management network vpn virtual private network tmn application development guidelines functional based tmn service specification object oriented analysis object oriented design object oriented method;network interfaces;computer aided software engineering;computational modeling;tmn interface application design;specific activity;guidelines;object oriented;object oriented method;tmn interface specification;object oriented analysis and design;object oriented analysis;requirement specification;use case;object modelling technique;computer aided software engineering object oriented modeling guidelines virtual private networks telecommunication computing project management telecommunication network management design methodology application software computational modeling;object oriented methods maintenance engineering telecommunication network management network interfaces telecommunication computing;telecommunications management network;object oriented modeling;telecommunication network management;eurescom project p414;design methodology;virtual private networks;use case driven integration	"""This paper presents results from the EURESCOM project P414-TMN (telecommunications management network) Guidelines. A case study within the VPN (virtual private network) problem domain has been executed with the aim to provide the basis for TMN application development guidelines, which enhance the efficiency of developers performing both specification activity and design activity, by minimising the conceptual and notational differences inherent in the two types of activity today. The case study used a use case approach to fill the """"gap"""" between functional-based TMN service requirements specification, object-oriented analysis and design methodologies, and the emerging (object-oriented) implementation techniques and platforms. This paper presents the proposed use case approach (originally taken from Objectory) and reports our experiences from applying an object-oriented method (OMT, object modelling technique) to TMN application development. The paper also provides guidelines for how to find a smooth path from a TMN interface specification to an application supporting the interface."""	telecommunications management network	Raymond Larsson;Laura Ferrari	1996		10.1109/NOMS.1996.539613	object-oriented analysis and design;maintenance engineering;project management;computer science	Robotics	-49.482719937493584	30.25316212526097	198875
b1477b415855a3327f5e6c4e710c35f022ab4493	advantages of uml for multidimensional modeling		In the last few years, various approaches for the multidimensional (MD ) modeling have been presented. However, none of them has been widely accepted as a standard. In this pape r, we summarize the advantages of using object orientation for MD modeling. Furthermore, we use the UML, a stand ard visual modeling language, for modeling every aspect of MD systems. We show how our approach res olves elegantly some important problems of the MD modeling, such as multistar models, shared hierarchy levels , and heterogeneous dimensions. We believe that our approach, based on the popular UML, can be succe ssfully used for MD modeling and can represent most of frequent MD modeling problems at the conceptual level.	complex systems;cryptographic hash function;molecular dynamics;object-relational database;online analytical processing;package diagram;plug-in (computing);principle of abstraction;rational rose;relational database;snow;unified modeling language;visual modeling	Sergio Luján-Mora;Juan Trujillo;Panos Vassiliadis	2004			data mining;visual modeling;online analytical processing;theoretical computer science;uml tool;applications of uml;hierarchy;unified modeling language;computer science;data warehouse;object-orientation	SE	-49.06677653015612	26.07609243886769	199313
a901b684a72384f7a0f43d980e00e7f17b0606ab	towards a metamodel design methodology: experiences from a model transformation metamodel design		— Software engineering makes extensive use of models to provide a better understanding of artifacts produced during system development. Models are specified in modeling languages such as UML or using Domain Specific Languages. In this paradigm of development, metamodeling is essential because it is usually used to specify the abstract syntax of these languages. However, the design of metamodels is not a trivial task, it requires expertise in specific domains, language definition and abstraction capabilities. This paper provides a guide for metamodel design towards a metamodel development methodology based on some lessons learned from metamodel design experiences.	abstract syntax;domain-specific language;experience;mpeg media transport;metamodeling;model transformation;model-driven engineering;programming paradigm;reverse engineering;software engineering;taxonomy (general);unified modeling language;universal instantiation	Ana Patrícia Fontes Magalhães;Rita Suzana Pitangueira Maciel;Aline Maria Santos Andrade	2015		10.18293/SEKE2015-54		SE	-52.74919896239814	25.399052489304196	199587
70e1f67f5a808ed5d8adae7c0625675f9fd382c7	model-driven functional test engineering for service centric systems	libraries;web services program testing unified modeling language;protocols;service centric system;service level;functional testing;system testing automatic testing unified modeling language protocols libraries service oriented architecture design engineering production costs communication industry;design engineering;probability density function;automatic testing;service oriented architecture model driven functional test engineering approach service centric system abstract test model test specific platform independent modeling notation utml unified test modeling language automated executable test script generation;biological system modeling;testing;data mining;modeling language;utml;model driven functional test engineering approach;communication industry;unified test modeling language;program testing;levels of abstraction;system integration;unified modeling language;web services;production;system testing;platform independent model;service oriented architecture;test specific platform independent modeling notation;abstract test model;automated executable test script generation;data models	Functional Testing of service centric systems poses new challenges to traditional test design approaches. As a mean for achieving network and service convergence, such systems integrate various different notations and technologies into a common framework. Assuming that test artifacts targeting each of the technologies involved exist, designing functional tests at the service level, by integrating existing test artifacts is still a very complex engineering task. We propose to address those challenges with a model-driven test engineering approach based on test patterns. The approach allows tests to be designed at a higher level of abstraction as abstract test models, using a test specific, but platform independent modeling notation called UTML(Unified Test Modeling Language). We argue that our approach can be helpful in speeding up the production of new test cases through reuse of existing test artifacts and test infrastructure, as well as automated generation of executable test scripts from the abstract test models.	black box;black-box testing;capability maturity model;consistency model;design pattern;executable;functional testing;model-driven architecture;model-driven engineering;model-driven integration;modeling language;test card;test case;test design	Alain-Georges Vouffo Feudjio	2009	2009 5th International Conference on Testbeds and Research Infrastructures for the Development of Networks & Communities and Workshops	10.1109/TRIDENTCOM.2009.4976223	web service;unified modeling language;data modeling;communications protocol;probability density function;model-based testing;service level;performance engineering;computer science;service-oriented architecture;functional testing;software testing;modeling language;programming language;system testing;test management approach;system integration	SE	-49.97196870311185	26.57168695273472	199823
03531824157c9579e7d5574232108067c9d89989	a design map for recording precise architecture decisions	architectural design;functional properties;software systems;traceability software architecture architecture documentation design rationale architecture styles design patterns nonfunctional requirements;navigation;software architecture;quality system;aerospace computing;computer architecture stability analysis unified modeling language observers documentation runtime throughput;airship navigation design map precise architecture decision recording design decisions architecture design quality systems architecture documentation system requirements nonfunctional properties architecture styles;design pattern;airships;design rationale;design patterns;software quality aerospace computing airships navigation software architecture;nonfunctional requirements;traceability;software quality;architecture styles;architectural style;architecture documentation	Explicit description of design decisions together with architecture design becomes an important basis for constructing and evolving quality systems. However since most of the architecture decisions remain implicit and undocumented, architecture documentation can not sufficiently support development and evolution because of its poor trace ability to system requirements. We believe that the information with which an architect can precisely estimate system's runtime properties or qualities is the key to encourage explicit description of architecture decisions. In this paper we present a design map for recoding architecture decisions together with its underlying met model. The map provides an architect with relationships between non-functional properties and architecture styles. In addition, it comprises reasons for the relationship as well as detailed models for structure and behavior of relevant styles. An architect can use our map to obtain design alternatives and elaborate which of them to actually adopt to realize a system. Throughout this process, the architect can build up explicit description of design decisions. We also present a case study in which we show how to apply our design map to architecture design of a software system for airship navigation.	architect;aspect weaver;aspect-oriented software development;design pattern;documentation;functional requirement;knowledge management;metamodeling;non-functional requirement;software architecture;software system;system requirements;traceability;undocumented feature	Atsushi Sawada;Masami Noro;Han-Myung Chang;Yoshinari Hachisu;Atsushi Yoshida	2011	2011 18th Asia-Pacific Software Engineering Conference	10.1109/APSEC.2011.36	enterprise architecture framework;reference architecture;software architecture;space-based architecture;website architecture;navigation;traceability;software design pattern;simulation;quality management system;database-centric architecture;computer science;systems engineering;engineering;service-oriented modeling;software engineering;solution architecture;software architecture description;design pattern;non-functional requirement;design rationale;software quality;data architecture;systems architecture;software system;computer engineering	SE	-54.28954084219794	27.32903678536417	199912
2a07f2224b42aeffe339b8a6966cf129c4ee71c4	role modeling for agent system analysis, design, and implementation	aspect oriented programming agent role models agent system analysis agent system design agent system implementation role theory collaboration coordination distributed systems management robot systems automated system software abstractions object oriented software engineering interaction patterns role object pattern;electrical capacitance tomography;object oriented methods;role transfer;interaction patterns;design engineering;system analysis and design;collaboration;object oriented modeling collaboration electrical capacitance tomography design engineering computer science australia pattern analysis system analysis and design software engineering role transfer;object oriented programming;software engineering;software agents;automated system;object oriented methods software agents systems analysis software engineering object oriented programming;agent system design;design and implementation;systems analysis;object oriented;aspect oriented programming;role theory;agent role models;object oriented software engineering;software abstractions;agent systems;role models;role object pattern;pattern analysis;computer science;distributed systems management;system management;robot systems;object oriented modeling;australia;coordination;agent system implementation;agent system analysis	Role theory [6] deals with collaboration and coordination; roles have also been applied to distributed systems management [31] and to agent and robot systems [2, 43]. However, it has been difficult to realize these representations in an automated or semiautomated system, due to the lack of adequate formalism and corresponding abstractions in software. Role models are relatively new concepts in object-oriented software engineering that emphasize patterns of interaction and therefore rectify this situation for software analysis and design. This paper provides examples of agent role models and explains how role modelling can be used to facilitate agent system analysis and design. We also discuss role model implementations based on two approaches: the Role Object pattern and aspect-oriented programming (AOP). 1. Role Models of Agent Systems	aspect-oriented programming;distributed computing;semantics (computer science);software engineering;system analysis;systems management	Elizabeth A. Kendall	1999		10.1109/ASAMA.1999.805405	software design;software analysis pattern;object-oriented programming	SE	-48.94867629870192	28.260164413018877	199998
