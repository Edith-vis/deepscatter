id	title	keywords	abstract	entities	authors	year	journal	doi	fos	area	x	y	ix
a0aab45f1a381ab85a860976edaa64aad66d53d3	inductive modal logics	modal logic		inductive reasoning;modal logic	Dimiter Vakarelov	1992	Fundam. Inform.		modal logic;dynamic logic;t-norm fuzzy logics;normal modal logic;modal μ-calculus;computer science;axiom s5;accessibility relation;multimodal logic	Logic	-12.934699803133888	12.321866572015534	131600
11f0e56885fb40d0d6e856c8ec6b1d20f1375e4d	axiomatic systems in fuzzy algebra			axiomatic system	Józef Drewniak	1981	Acta Cybern.		discrete mathematics;mathematics;axiomatic semantics;fuzzy logic;pure mathematics;algebra;axiomatic system	DB	-11.99419062311021	12.295157412263261	132272
722c22133d963ce31939eef73b29125f21c4ae10	an infinite-valued semantics for logic programs with negation	logica formal;representacion conocimientos;ordered set;semantica denotacional;relacion orden;ordering;ensemble ordonne;logical programming;relation ordre;programmation logique;denotational semantics;formal logic;logic programs;knowledge representation;representation connaissances;logique formelle;programacion logica;semantique denotationnelle;conjunto ordenado	We give a purely model-theoretic (denotational) characterization of the semantics of logic programs with negation allowed in clause bodies. In our semantics (the first of its kind) the meaning of a program is, as in the classical case, the unique minimum model in a programindependent ordering. We use an expanded truth domain that has an uncountable linearly ordered set of truth values between False (the minimum element) and True (the maximum), with a Zero element in the middle. The truth values below Zero are ordered like the countable ordinals. The values above Zero have exactly the reverse order. Negation is interpreted as reflection about Zero followed by a step towards Zero; the only truth value that remains unaffected by negation is Zero. We show that every program has a unique minimum model MP , and that this model can be constructed with a TP iteration which proceeds through the countable ordinals. Furthermore, collapsing the true and false values of the infinite-valued model MP to (the classical) True and False, gives a three-valued model identical to the well-founded one. 1 The Problem of Negation One of the paradoxes of logic programming is that such a small fragment of formal logic serves as such a powerful programming language. This contrast has led to many attempts to make the language more powerful by extending the fragment, but these attempts generally backfire. The extended languages can be implemented, and are in a sense more powerful; but these extensions usually disrupt the relationship between the meaning of programs as programs and the meaning as logic. In these cases the implementation of the program-as-program can no longer be considered as computing a distinguished model of the program-as-logic. Even worse, the result of running the program may not correspond to any model at all. The problem is illustrated by the many attempts to extend logic programming with negation (of atoms in the clause bodies). The generally accepted computational interpretation of negated atoms is negation-as-failure. Intuitively, a goal ¬A succeeds iff the subcomputation which attempts to establish A terminates and fails. For example, given the program p← r ← ¬p s← ¬q the query ← r fails because p succeeds, while ← s succeeds because q fails. If we assemble the results of these queries, we see that the negation-as-failure computational rule assigns the value True to p and s and the value False to q and r. These values do constitute a model of the program-as-logic, but not the only one. One can easily see that there exist five other models of the program, four of which can be ruled out as non-minimal; the remaining model however (in which r and s are False and p and q are True) is also minimal and cannot be ∗Published in JELIA 2002, S. Flesca et al., editors, LNAI 2424:456–468, 2002. This work has been partially supported by the University of Athens under the project “Extensions of the Logic Programming Paradigm”.	existential quantification;iteration;lecture notes in computer science;logic programming;negation as failure;programming language;programming paradigm;theory;whole earth 'lectronic link	Panos Rondogiannis;William W. Wadge	2002		10.1007/3-540-45757-7_38	knowledge representation and reasoning;discrete mathematics;order theory;computer science;artificial intelligence;negation;mathematics;programming language;logic;denotational semantics;algorithm	AI	-14.004443090175629	16.636463901436443	132387
34c56d1555cbd118a4b85a8a123a40f776d49b27	automating change of representation for proofs in discrete mathematics (extended version)	isabelle proof assistant;automated reasoning;change of representation;transformation	Representation determines how we can reason about a specific problem. Sometimes one representation helps us to find a proof more easily than others. Most current automated reasoning tools focus on reasoning within one representation. There is, therefore, a need for the development of better tools to mechanise and automate formal and logically sound changes of representation. In this paper we look at examples of representational transformations in discrete mathematics, and show how we have used tools from Isabelle’s Transfer package to automate the use of these transformations in proofs. We give an overview of a general theory of transformations that we consider appropriate for thinking about the matter, and we explain how it relates to the Transfer package. We show a few reasoning tactics we developed in Isabelle to improve the use of transformations, including the automation of search in the space of representations. We present and analyse some results of the use of these tactics.	discrete mathematics	Daniel Raggi;Alan Bundy;Gudmund Grov;Alison Pease	2016	Mathematics in Computer Science	10.1007/s11786-016-0275-z	transformation;computer science;theoretical computer science;mathematics;automated reasoning;programming language;algorithm;algebra	Theory	-16.649664536849304	17.73821656462401	132764
94f27ac4ce6bc69aa8e2e77a4671f1ea6e21442f	categorical modelling of structural operational rules: case studies	semantica operacional;semantica denotacional;operational semantics;semantique operationnelle;category theory;informatique theorique;theorie categorie;denotational semantics;programme recursif;programa recursivo;recursive program;teoria categoria;semantique denotationnelle;computer theory;informatica teorica	This paper aims at substantiating a recently introduced categorical theory of`well-behaved' operational semantics. A variety of concrete examples of structural operational rules is modelled categorically illustrating the versatility and modularity of the theory. Further, a novel functorial notion of guardedness is introduced which allows for a general and formal treatment of guarded recursive programs.	operational semantics;recursion	Daniele Turi	1997		10.1007/BFb0026985	computer science;artificial intelligence;mathematics;programming language;operational semantics;denotational semantics;algorithm;category theory	Logic	-14.991214164355078	16.710757446294515	133305
d1b1dcbec11d62437b2643bd293849789a64b1ef	the last paper on the halpern-shoham interval temporal logic	interval temporal logic;satisfiability;modal logic;logic in computer science	The Halpern–Shoham logic is a modal logic of time intervals. Some effort has been put in last ten years to classify fragments of this beautiful logic with respect to decidability of its satisfiability problem. We contribute to this effort by showing – what we believe is quite an unexpected result – that the logic of subintervals, the fragment of the Halpern–Shoham where only the operator “during”, or D, is allowed, is undecidable over discrete structures. This is surprising as this logic is decidable over dense orders [14] and its reflexive variant is known to be decidable over discrete structures [13]. Our result subsumes a lot of previous results for the discrete case, like the undecidability for ABE [10], BE [11], BD [12], ADB, AĀD, and so on [2, 6].	apple desktop bus;attribute-based encryption;blu-ray;boolean satisfiability problem;discrete mathematics;fuzzy logic;interval temporal logic;modal logic;undecidable problem	Jerzy Marcinkowski;Jakub Michaliszyn	2010	CoRR		modal logic;predicate logic;dynamic logic;zeroth-order logic;discrete mathematics;linear temporal logic;description logic;higher-order logic;temporal logic;many-valued logic;interval temporal logic;computer science;intermediate logic;predicate functor logic;mathematics;sequential logic;programming language;substructural logic;multimodal logic;algorithm;philosophy of logic;satisfiability	Logic	-12.497388032260464	14.308752910941532	133474
44325b4e93e606dc9c0bb05191e8409ebc82a260	axioms for total correctness	information system;operating system;data structure;communication network;information theory	A notation for total correctness of a program with respect to input and output formulas is introduced; and Hoare's loop axiom is rearranged in such a way as to form a good inference system for the total correctness. Its consistency and completeness are shown.	correctness (computer science);hoare logic;inference engine;input/output	Stefan Sokolowski	1977	Acta Informatica	10.1007/BF00263765	correctness;discrete mathematics;mathematics;hoare logic;algorithm	PL	-12.543422333256512	14.749313321567552	133492
1a176837c9414b5f5dad9bb70b411cedcee57019	coercion completion and conservativity in coercive subtyping	type theory;dependent types	Coercive subtyping ooers a general approach to subtyping and inheritance by introducing a simple abbreviational mechanism to constructive type theories. In this paper, we study coercion completion in coercive subtyping and prove that the formal extension with coercive subtyping of a type theory such as Martin-LL of's type theory and UTT is a conservative extension. The importance of coherence conditions for the conservativity result is also discussed.	ll parser;type theory	Zhaohui Luo	2001	Ann. Pure Appl. Logic	10.1016/S0168-0072(01)00063-X	discrete mathematics;dependent type;mathematics;programming language;type theory;algorithm	PL	-12.242815258978222	17.02538506537213	133770
2f213ade3f23fd555822e3dbc8eb53519639d92c	decision procedures for intuitionistic propositional logic by program extraction	preuve programme;program proof;algorithm analysis;logique propositionnelle;intelligence artificielle;logical programming;search trees;decision procedure;programmation logique;intuitionistic logic;propositional logic;logique intuitionniste;prueba programa;artificial intelligence;analyse algorithme;inteligencia artificial;logica proposicional;programacion logica;logica intuicionista;analisis algoritmo	We present two constructive proofs of the decidability of in-tuitionistic propositional logic by simultaneously constructing either a counter{model or a derivation. From these proofs, we extract two programs which have a sequent as input and return a derivation or a counter{ model. The search tree of these algorithms is linearly bounded by the number of connectives of the input. Soundness of these programs follows from giving a correct construction of the derivations, similarly to Hudel-maier's work 7]; completeness from giving a correct construction of the counter{models, inspired by Miglioli, Moscato, and Ornaghi 8].	algorithm;boolean algebra;david maier;intuitionistic logic;linear bounded automaton;logical connective;minlog;open road tolling;operational semantics;parse tree;propositional calculus;recursion;search tree	Klaus Weich	1998		10.1007/3-540-69778-0_29	discrete mathematics;intuitionistic logic;computer science;artificial intelligence;mathematics;propositional variable;propositional calculus;algorithm	Logic	-16.129461215977116	16.494335274286403	134116
a9cea148a54078061bdb3ee7dcca8c30b0a61699	a general tableau method for propositional interval temporal logics: theory and implementation	temporal logic;interval temporal logic;modal logic;proof systems;temporal properties;first order logic;tableau methods;interval temporal logics;partial order	In this paper, we focus our attention on tableau methods for propositional interval temporal logics. These logics provide a natural framework for representing and reasoning about temporal properties in several areas of computer science. However, while various tableau methods have been developed for linear and branching time point-based temporal logics, not much work has been done on tableau methods for interval-based ones. We develop a general tableau method for Venema’s CDT logic interpreted over partial orders (BCDT + for short). It combines features of the classical tableau method for first-order logic with those of explicit tableau methods for modal logics with constraint label management, and it can be easily tailored to most propositional interval temporal logics proposed in the literature. We prove its soundness and completeness, and we show how it has been implemented. © 2005 Elsevier B.V. All rights reserved.	interval temporal logic;method of analytic tableaux	Valentin Goranko;Angelo Montanari;Pietro Sala;Guido Sciavicco	2006	J. Applied Logic	10.1016/j.jal.2005.06.012	modal logic;partially ordered set;monoidal t-norm logic;t-norm fuzzy logics;discrete mathematics;classical logic;linear temporal logic;description logic;temporal logic;interval temporal logic;computation tree logic;computer science;intermediate logic;artificial intelligence;first-order logic;mathematics;programming language;method of analytic tableaux;accessibility relation;algorithm;temporal logic of actions	Logic	-14.055843109857559	13.854404069765064	134444
7f6892293e33bfaa7bc858d5416c9af7ccf329a8	unchecked exceptions can be strictly more powerful than call/cc	langage fonctionnel;lenguaje programacion;recursive types;machine turing;exceptions;control primitives;programming language;complexite calcul;language theory;lenguaje funcional;lambda calculus;studies of programming constructs;turing machine;teoria lenguaje;natural extension;functional programming;recursive function;complejidad computacion;computational complexity;recursion;type theory;funcion recursiva;langage programmation;lambda calculo;fonction recursive;λ calculus;typed lambda calculus;functional language;lambda calcul;theorie langage;maquina turing	We demonstrate that in the context of statically-typed purely-functional lambda calculi without recursion, unchecked exceptions (e.g., SML exceptions) can be strictly more powerful than call/cc. More precisely, we prove that a natural extension of the simply-typed lambda calculus with unchecked exceptions is strictly more powerful than all known sound extensions of Girard’s Fω (a superset of the simply-typed lambda calculus) with call/cc. This result is established by showing that the first language is Turing complete while the later languages permit only a subset of the recursive functions to be written. We show that our natural extension of the simply-typed lambda calculus with unchecked exceptions is Turing complete by reducing the untyped lambda calculus to it by means of a novel method for simulating recursive types using unchecked-exception–returning functions. The result concerning extensions of Fω with call/cc stems from previous work of the author and Robert Harper.	call-with-current-continuation;computable function;exception handling;recursion;recursion (computer science);rewrite (programming);robert harper (computer scientist);simply typed lambda calculus;simulation;system f;terminate (software);turing completeness;type system;whole earth 'lectronic link	Mark Lillibridge	1999	Higher-Order and Symbolic Computation	10.1023/A:1010020917337	lambda lifting;system f;recursion;typed lambda calculus;binary lambda calculus;computer science;turing machine;philosophy of language;turing completeness;simply typed lambda calculus;programming language;computational complexity theory;functional programming;church encoding;type theory;algorithm	PL	-13.02401970891654	17.919569470952034	134541
0b7701b4711760d4e7ec03701dda957823feba36	goal-directed e-unification	regle inference;theorem proving;inference rule;unification;demonstration theoreme;theorie equationnelle;rewriting systems;completitud;completeness;demostracion teorema;completude;systeme reecriture;equational theory;direct method;unificacion;regla inferencia;teoria ecuacional	We give a general goal directed method for solving the Eunification problem. Our inference system is a generalization of the inference rules for Syntactic Theories, except that our inference system is proved complete for any equational theory. We also show how to easily modify our inference system into a more restricted inference system for Syntactic Theories, and show that our completeness techniques prove completeness there also.	inference engine;syntactic predicate;unification (computer science)	Christopher Lynch;Barbara Morawska	2001		10.1007/3-540-45127-7_18	direct method;backward chaining;discrete mathematics;completeness;computer science;unification;disjunction introduction;mathematics;automated theorem proving;programming language;algorithm;rule of inference	Logic	-16.098267068347663	15.138107442571785	134959
32b1d654e123c88b9b20f1b4e92a95bc2a1c5be4	counterexample generation meets interactive theorem proving: current results and future opportunities	current counterexample generation technology;interesting problem;counterexample generation;acl2 sedan;program verification;freshmen student;interactive theorem;future opportunity;current result;pedagogical use;interactive theorem provers;future research opportunity	current counterexample generation technology;interesting problem;counterexample generation;acl2 sedan;program verification;freshmen student;interactive theorem;future opportunity;current result;pedagogical use;interactive theorem provers;future research opportunity		Panagiotis Manolios	2013		10.1007/978-3-642-39634-2_4	computer science;pure mathematics;mathematics;algorithm	NLP	-18.960646815038476	17.74674473298572	135173
676d5560f7dce1f2f487e419a08f1a4bff0b81dc	universal algebra in higher types	second order;algebraic semantic;plenitud;sistema informatico;orden 2;computer system;logique propositionnelle;theorie modeles;algebre universel;semantica algebraica;propositional logic;informatique theorique;logique ordre 1;type eleve;systeme informatique;semantique algebrique;ordre 2;completeness;logica proposicional;completude;universal algebra;teoria modelos;logique horn;first order logic;calcul lambda;computer theory;model theory;logica orden 1;informatica teorica	Abstract   We develop the elementary theory of higher-order universal algebra using the nonstandard approach to finite type theory introduced by Henkin. Basic results include: existence theorems for free and initial higher type algebras, a complete higher type equational calculus, and characterisation theorems for higher type equational and Horn classes.		Karl Meinke	1992	Theor. Comput. Sci.	10.1016/0304-3975(92)90310-C	universal algebra;subalgebra;completeness;calculus;first-order logic;mathematics;propositional calculus;second-order logic;algorithm;model theory;algebra	ECom	-13.086307439037519	16.8624017472591	135205
b65b12e3f95a6afc9fd1036014a7ae12e0d817e5	the tau-laws of fusion	computer science	We present complete axiomatizations of weak hypercongruence in the nite fragment of the fusion calculus, an extension and simpliication of the-calculus. We treat both the full fusion calculus and the subcalculus without mismatch operators. The axiomatizations are obtained from the laws for hyperequivalence and adding so called tau-laws. These are similar to the well known tau-laws for CCS and the-calculus, but there is an interesting diierence which highlights an aspect of the higher expressive power of the fusion calculus.	three laws of robotics;whole earth 'lectronic link	Joachim Parrow;Björn Victor	1998		10.1007/BFb0055618	mobile telephony;concurrency;computer science;artificial intelligence;parsing;programming language;computational complexity theory;algorithm	Logic	-15.170917415203713	14.24235968423637	135454
4b0b50926cbbd0e6d2e574652598cc5d6e409364	axiomatizations of interval logics	linear time temporal logic;temporal logic;graphical representation;hardware design	Interval logic has been introduced as a temporal logic that provides higher-level constructs and an intuitive graphical representation, making it easier in interval logic than in other temporal logics to specify and reason about concurrency in software and hardware designs. In this paper we present axiomatizations for two propositional interval logics and relate these logics to Until Temporal Logic. All of these logics are discrete linear-time temporal logics with no next operator. The next operator obstructs the use of hierarchical abstraction and reenement, and makes reasoning about concurrency diicult.	concurrency (computer science);concurrency control;graphical user interface;interval temporal logic;time complexity	George Kutty;Louise E. Moser;P. M. Melliar-Smith;Y. S. Ramakrishna;Laura K. Dillon	1995	Fundam. Inform.	10.3233/FI-1995-2441	dynamic logic;monoidal t-norm logic;t-norm fuzzy logics;discrete mathematics;classical logic;linear temporal logic;description logic;higher-order logic;principle of bivalence;temporal logic;many-valued logic;interval temporal logic;computation tree logic;computer science;intermediate logic;artificial intelligence;theoretical computer science;non-monotonic logic;łukasiewicz logic;mathematics;accessibility relation;substructural logic;multimodal logic;algorithm;philosophy of logic;temporal logic of actions	Logic	-15.013735328433494	13.7038856522889	136350
646796cd49cbf46cdccf3a121ce03ec63dbea695	fixed point semantics and partial recursion in coq	logical framework;non terminating functions;fixed point;theorem proving;the knaster tarski theorem;type theory;program extraction;classical logic;automated theorem proving;least fixed point semantics	We propose to use the Knasterâ Tarski least fixed point theorem as a basis to define recursive functions in the Calculus of Inductive Constructions. This widens the class of functions that can be modelled in type-theory based theorem proving tools to potentially nonterminating functions. This is only possible if we extend the logical framework by adding some axioms of classical logic.We claim that the extended framework makes it possible to reason about terminating or non-terminating computations and we show that extraction can also be extended to handle the new functions	abstract rewriting system;automated theorem proving;calculus of constructions;computation;coq (software);divergence (computer science);domain theory;fixed point (mathematics);fixed-point combinator;fixed-point theorem;isabelle;knaster–tarski theorem;least fixed point;logical framework;peano axioms;recursion;type theory;yet another	Yves Bertot;Vladimir Komendantsky	2008		10.1145/1389449.1389461	brouwer fixed-point theorem;kakutani fixed-point theorem;schauder fixed point theorem;computer science;fundamental theorem;automated theorem proving;fixed-point theorem;programming language;algorithm	Logic	-13.002763682075393	16.189218559199865	136543
cc29edc8bba5f2e06b953454c6e99f97f8f5391e	eligible and frozen constraints for solving temporal qualitative constraint networks	search algorithm;spatial information	In this paper we consider the consistency problem for qualitative constraint networks representing temporal or spatial information. The most efficient method for solving this problem consists in a search algorithm using, on the one hand, the weak composition closure method as a local propagation method, and on the other hand, a decomposition of the constraints into subrelations of a tractable set. We extend this algorithm with the notion of eligibility and the notion of frozen constraints. The first concept allows to characterise constraints which will not be considered during the search. The second one allows to freeze constraints in order to avoid unnecessary updates.		Jean-François Condotta;Gérard Ligozat;Mahmoud Saade	2007		10.1007/978-3-540-74970-7_58	mathematical optimization;discrete mathematics;computer science;mathematics;spatial analysis;constraint;algorithm;search algorithm	AI	-16.802909759308168	12.84402409454182	137112
a99a09f629a1349f9b894faa7b2f4e0a1d80c401	normalization by evaluation for the computational lambda-calculus	normalisation;semantics;lambda calculus;semantica;semantique;normalization by evaluation;normalizacion;lambda calculo;lambda calcul;standardization	We show how a simple semantic characterization of normalization by evaluation for the λβη-calculus can be extended to a similar construction for normalization of terms in the computational λ-calculus. Specifically, we show that a suitable residualizing interpretation of base types, constants, and computational effects allows us to extract a syntactic normal form from a term's denotation. The required interpretation can itself be constructed as the meaning of a suitable functional program in an ML-like language, leading directly to a practical normalization algorithm. The results extend easily to product and sum types, and can be seen as a formal basis for call-by-value type-directed partial evaluation.	computation;lambda calculus;normalisation by evaluation	Andrzej Filinski	2001		10.1007/3-540-45413-6_15	computer science;pure mathematics;lambda calculus;mathematics;semantics;programming language;standardization;algorithm	NLP	-12.913161853483572	16.559640042781627	137695
714db914b3e963adf478c0ea6ad8fa4beba26578	craig interpolation theorem for intuitionistic logic and extensions part iii			interpolation;intuitionistic logic	Dov M. Gabbay	1977	J. Symb. Log.		linear logic;discrete mathematics;higher-order logic;paraconsistent logic;many-valued logic;intuitionistic logic;intermediate logic;negation;mathematics;minimal logic;truth value;type theory;second-order logic	Logic	-12.23709087014987	12.909953728493534	137846
39ea89d5aaef3ae05f9a15802cadf36207f19c72	algebraic approaches to nondeterminism: an overview	algebraic approach;image coding;mri;compression	Mathematics never saw much of a reason to deal with something called nondeterminism. It works with values, functions, sets, and relations. In computing science, however, nondeterminism has been an issue from the very beginning, if only in the form of nondeterministic Turing machines or nondeterministic finite state machines. Early references to nondeterminism in computer science go back to the 1960s [Floyd 1967; McCarthy 1963]. A great variety of theories and formalisms dealing with it have been developed during the last two decades. There are the denotational models based on power domains, the predicate transformers for the choice construct, and modifications of the l-calculus [de Liguoro and Piperno 1992; Astesiano and Costa 1979; Hennessy 1980]. Nondeterminism arises in a natural way when discussing concurrency, and models of concurrency typically also model nondeterminism. There are numerous variants of process languages and algebra, event structures, state transition systems [Manna and Pnueli 1992; Lehmann and Shelah 1983], and Petri nets [Petri 1977; Reisig 1985]. In terms of modeling, nondeterminism may be considered a purely operational notion. However, one of the main reasons for considering nondeterminism in computer science is the need for abstraction, allowing one to disregard irrelevant aspects of actual computations. Typically, we prefer to work with models that do not include all the details of the physical environment of computations such as timing, temperature, representation on hardware, and the like. Since we do not want to model all these complex dependencies, we may instead represent them by nondeterministic choices. The nondeterminism of concurrent systems usually arises as an ab-	computation;computer science;concurrency (computer science);finite-state machine;lambda calculus;non-deterministic turing machine;nondeterministic algorithm;petri net;power domains;predicate transformer semantics;relevance;state transition table;theory;transformers	Michal Walicki;Sigurd Meldal	1997	ACM Comput. Surv.	10.1145/248621.248623	theoretical computer science;magnetic resonance imaging;compression	Logic	-15.097603052559055	11.643417907839249	138144
3ef0502a4822ae81d20621c7cd0d86a5c1be4709	an incremental theorem prover	theorem prover	When states of affairs are represented by theories, reasoning about them often involves making a small change to a set of axioms, and computing the consequences of that change for the set of theorems derivable from those axioms. A Prolog-like theorem prover is described which, as it explores the space of possible proofs for a set of formulae, records the structure of that space. This information can be used to search efficiently for proofs for the same formulae w i th a slightly changed set of axioms. Existing Prolog interpreters throw away all such information, so that the entire space of possible proofs for each formula must be explored from scratch every time the set of axioms is changed, no matter how l i t t le that change affects the search space's structure.	automated theorem proving;prolog;theory	Murray Shanahan	1987			discrete mathematics;armstrong's axioms;computer science;artificial intelligence;mathematics;automated theorem proving;algorithm;kuratowski closure axioms	AI	-17.86371779076199	17.148575015652792	138292
32a899921172b91bf7b5dcefcb6d66b7790b0c39	a reduction method for theorem proving based on the partial-instantiation technique	systeme aide decision;logic;calcul propositionnel;davis putnam procedure;sistema ayuda decision;satisfiability;theorem proving;demonstration theoreme;decision support system;first order;inferencia;propositional calculus;calculo proposicional;davis putnam;data handling;demostracion teorema;logical inference;instantiation partielle;reduction method;procedure davis putnam;inference;logique;logica;partial instantiation	Logical inference is of central importance in the information and decision science. First-order predicate inference (theorem proving) provides more powerful representation of models and of knowledge, but presents a hard computational problem. We extend Jeroslow's theorem-proving procedure in function-free formulas to be applicable to full first-order predicate formulas. Therefore, proposed theorem-proving procedure can be more flexible tool for data handling and inferences. Our proposed procedure is based on the partial-instantiation technique, which reduces a first-order predicate clausal-form formula to an incrementally augmented propositional formula and proves the theorem by checking the satisfiability of the propositional formula. We also show the completeness of the proposed procedure, i.e., it can detect the unsatisfiability of an input formula. Furthermore, we compare it with resolution-style theorem-proving program  otter  and show the efficiency of the proposed procedure.	automated theorem proving;universal instantiation	Masahito Yamamoto;Azuma Ohuchi	1998	Decision Support Systems	10.1016/S0167-9236(98)00044-X	decision support system;computer science;artificial intelligence;propositional calculus;atomic formula;logic;algorithm;satisfiability	Logic	-18.48540033751564	11.873331102721615	138392
61a46ed489372b39182447a7318d54f1f58b8740	verification of a distributed summation algorithm	i o automata;universiteitsbibliotheek;propagation of information with feedback;correctness proof	Abst rac t . A correctness proof of s variant of Segall's Propagation of Information with Feedback protocol is outlined. The proof, which is carried out within the I /O automata model of Lynch and Turtle, is standard except for the use of a prophecy variable. The aim of this paper is to show that, unlike what has been suggested in the literature, assertional methods based on inv~riant reasoning support an intuitive way to think about and understand this algorithm.	algorithm;automata theory;correctness (computer science);oracle rac;software propagation	Frits W. Vaandrager	1995		10.1007/3-540-60218-6_14	correctness;discrete mathematics;theoretical computer science;mathematics;algorithm	PL	-17.593048120977066	13.53112749583971	138744
cc285de50b47a037482702aee3ebbf2de3422b8e	computational complexity of a knowledge compilation. approach to the static semantics for disjunctive logic programs	computational complexity		computational complexity theory;disjunctive normal form;knowledge compilation;logic programming;programming language	Stefania Costantini;T. Morbidoni	1999			computational logic;descriptive complexity theory;theoretical computer science;knowledge compilation;computational complexity theory;computational resource;semantics;stable model semantics;computer science	AI	-16.392537258596445	13.6347335825433	138877
35d4867af30a2e7f7e0ac191130522092f55bf91	a hedge for gödel fuzzy logic	fuzzy logic;intuitionistic logic;hedges	We add to Godel propositional fuzzy logic an unary connective originating in intuitionistic logic and having a natural meaning in fuzzy logic. We prove completeness with respect to a natural many-valued semantics.	fuzzy logic;gödel;t-norm fuzzy logics	Petr Hájek;Dagmar Harmancová	2000	International Journal of Uncertainty, Fuzziness and Knowledge-Based Systems	10.1142/S0218488500000332	predicate logic;fuzzy logic;dynamic logic;zeroth-order logic;t-norm fuzzy logics;hedge;discrete mathematics;description logic;higher-order logic;many-valued logic;intuitionistic logic;computer science;intermediate logic;artificial intelligence;predicate functor logic;mathematics;minimal logic;logic;multimodal logic;second-order logic;algorithm;philosophy of logic;autoepistemic logic	Robotics	-12.227062100896445	12.556444275624402	139302
cd7fbddece89abe1692e88e72941f57b8dfd2b93	call me by your name: epistemic logic with assignments and non-rigid names		In standard epistemic logic, agent names are usually assumed to be common knowledge. This is unreasonable for various applications. Inspired by term modal logic and assignment operators in dynamic logic, we introduce a lightweight modal predicate logic whose names are not rigid. The language can handle various de dicto /de re distinctions in a natural way. We show the decidability of the logic over arbitrary models and give a complete axiomatisation over S5 models.	axiomatic system;epistemic modal logic	Jeremy Seligman;Yanjing Wang	2018	CoRR		computer science;algorithm;machine learning;predicate logic;artificial intelligence;modal logic;common knowledge;de dicto and de re;operator (computer programming);decidability;dynamic logic (digital electronics);epistemic modal logic	AI	-15.083996730144309	11.320972072843178	139322
9676cba222fecdcb8ba307d6d0816ae703397f7c	query answering via modal definability with fact++: first blood		We use results on modal definability of first-order formulas to reduce the problem of answering conjunctive queries over knowledge bases (of any expressivity) to checking inconsistency of those knowledge bases extended with a number of ALCI concept assertions. This reduction has been shown to work for conjunctive queries without cycles that only involve bound variables. In this paper, we present an optimised algorithm for the reduction, its implementation using FaCT++ as an underlying reasoner and the results of first experiments.	algorithm;conjunctive query;existential quantification;experiment;first-order predicate;free variables and bound variables;knowledge base;mathematical optimization;normal modal logic;ontology (information science);rewriting;semantic reasoner;web ontology language	Stanislav Kikot;Dmitry Tsarkov;Michael Zakharyaschev;Evgeny Zolin	2013			machine learning;conjunctive query;modal;semantic reasoner;artificial intelligence;mathematics;expressivity	AI	-16.746642325398916	12.31922407480133	140066
7c807735311b97e112408c3ae6e56ee60d15917f	linear syntax for communicating elementary mathematics	syntax for elementary mathematics;computacion informatica;computer algebra system;ciencias basicas y experimentales;mathematics education;grupo a;computer aided assessment	We consider computer aided assessment (CAA) of mathematics in which a student provides an answer in the form of a mathematical expression. A common a ppro ch is for CAA system implementors to adopt a linear syntax to allow students to co mmunicate their answer to the machine. In this paper we consider the problems students encou nter when mediating between (i) traditional mathematical notation and (ii) the requiremen ts of a strict computer algebra system (CAS) syntax. We compare the linear syntaxes of five commonly used general purpose CAS, and report surprising variety even at the elementary levels.	capability maturity model;computer algebra system;dns certification authority authorization;linear logic;linear syntax	Christopher J. Sangwin;Philip Ramsden	2007	J. Symb. Comput.	10.1016/j.jsc.2007.07.002	mathematics education;mathematics;algorithm;algebra	AI	-17.257943636847898	17.94268474273759	140187
ba1f9d6094cc6da9ee5fb717ac990ccef0e15e0e	a general refutational completeness result for an inference procedure based on associative-commutative unification	regle inference;symbolic computation;unification associative commutative;plenitud;theorem proving;calculo simbolico;inference rule;unification;demonstration theoreme;theorie equationnelle;refutation;arbre semantique;reecriture;completeness;demostracion teorema;rewriting;completude;calcul symbolique;associative commutative;unificacion;reescritura;regla inferencia		han unification	E. Paul	1992	J. Symb. Comput.		discrete mathematics;symbolic computation;rewriting;completeness;unification;mathematics;automated theorem proving;algorithm;rule of inference	Logic	-15.996505237747758	15.318155309002284	140472
0ea170531b7d6a540be5232646288857cf55fba8	conservative extensions in expressive description logics	description logic;formal ontology;ontology design	The notion of a conservative extension plays a central role in ontology design and integration: it can be used to formalize ontology refinements, safe mergings of two ontologies, and independent modules inside an ontology. Regarding reasoning support, the most basic task is to decide whether one ontology is a conservative extension of another. It has recently been proved that this problem is decidable and 2ExpTime-complete if ontologies are formulated in the basic description logic ALC. We consider more expressive description logics and begin to map out the boundary between logics for which conservativity is decidable and those for which it is not. We prove that conservative extensions are 2ExpTime-complete in ALCQI, but undecidable in ALCQIO. We also show that if conservative extensions are defined model-theoretically rather than in terms of the consequence relation, they are undecidable already in ALC.	2-exptime;approximation;computational complexity theory;dls format;description logic;ontology (information science);semiconductor industry;undecidable problem;web ontology language	Carsten Lutz;Dirk Walther;Frank Wolter	2007			discrete mathematics;description logic;computer science;artificial intelligence;theoretical computer science;mathematics;process ontology;algorithm	AI	-16.001770739376916	12.718927450670774	140501
94b1cd754897ee604cab68a7b12920ed3d19f19d	analytic tableaux for simple type theory and its first-order fragment	cut elimination;higher order;standard model;first order;decision procedure;type theory;higher order logic;first order logic	We study simple type theory with primitive equality (STT) and its first-order fragment EFO, which restricts equality and quantification to base types but retains lambda abstraction and higher-order variables. As deductive system we employ a cut-free tableau calculus. We consider completeness, compactness, and existence of countable models. We prove these properties for STT with respect to Henkin models and for EFO with respect to standard models. We also show that the tableau system yields a decision procedure for three EFO fragments.	automated theorem proving;best, worst and average case;decision problem;experimental factor ontology;farkas' lemma;first-order logic;first-order predicate;formal system;kinetic data structure;lambda calculus;lambda lifting;method of analytic tableaux;need to know;process calculus;simulation;type theory;unification (computer science);universal instantiation	Chad E. Brown;Gert Smolka	2010	Logical Methods in Computer Science	10.2168/LMCS-6(2:4)2010	discrete mathematics;higher-order logic;computer science;first-order logic;mathematics;programming language;algorithm	Logic	-12.241770595371046	16.291537427005913	140513
2ff6f4a40da3cdaaa9bbab9971bc59660498d5fe	algorithmic aspects of model representations	decision problem;functional programming;model building;machine learning;automated deduction	Herbrand models play an important role in many areas of Computer Science like Logic Programming, Functional Programming, Machine Learning, etc. Moreover, models (in particular, Herbrand models) are at the very heart of Automated Model Building, which has evolved as an important subdiscipline of Automated Deduction over the past decade. A crucial issue for dealing with models on the computer is the selection of an appropriate formalism for representing models. A desirable property of such a formalism is that (efficient) algorithms should exist for evaluating clauses in a model thus represented. Moreover, also algorithms for deciding the so-called model equivalence problem have received great interest. In this survey, we recall three formalisms for representing Herbrand models, namely atomic representations of Herbrand models ([11]), constrained atoms ([6, 7]), and contexts ([2, 3]). Specifically, we shall recall recent results on algorithms and on the complexity of the aforementioned decision problems for these model representations.	algorithm;analysis of algorithms;assassin's creed: brotherhood;automata theory;automated theorem proving;computer science;decision problem;expressive power (computer science);functional programming;logic programming;machine learning;natural deduction;semantics (computer science);tree automaton;turing completeness	Reinhard Pichler	2006			algorithmic learning theory;decision problem;theoretical computer science;functional logic programming;automated theorem proving;model building;artificial intelligence;functional programming;machine learning;computer science	AI	-18.166152052977633	12.244610152886992	140705
d9c2620f9feb510b579ad7cb6a8b74186a95107c	a categorical account of two-level languages	language use;shape analysis;code generation;partial evaluation;indexation	Abstract   We give an account of two-level languages in terms of indexed categories and universal properties well-known in the context of categorical logic.  This account provides three important insights: establishes precise analogies between two-level languages and module languages, explains the two-level languages used in partial evaluation in terms of those used for code generation, suggests extensions that should be valuable for type-specialization and shape-analysis.	formal language	Eugenio Moggi	1997	Electr. Notes Theor. Comput. Sci.	10.1016/S1571-0661(05)80155-0	natural language processing;computer science;third-generation programming language;shape analysis;cone;ontology language;programming language;partial evaluation;second-generation programming language;comparison of multi-paradigm programming languages;algorithm;code generation	Logic	-13.183275676591549	18.135975267722685	141267
113d99da48817c89b40b0def030533eed56d4513	annotated reasoning	strategies;different technique;additional knowledge;tactical theorem proving;various domain;additional strategic knowledge;proof search;annotated reasoning;rippling;general framework;possible proof step;automated deduction;generic method;formal notion;various purpose	The application of deduction in various domains resulted in a variety of different techniques to guide the proof search. Many of these techniques incorporate additional knowledge to restrict or select possible proof steps. As a consequence, usually the underlying calculus has to be modified to keep track of this information during the proof search. In this paper we present a general framework for maintaining additional strategic knowledge within a proof. We introduce a formal notion of annotations attached to the constituents of formulas and illustrate how a generic method of inheriting these annotations can be instantiated for various purposes.	algorithm;automated theorem proving;church encoding;computation;curry–howard correspondence;first-order logic;first-order predicate;frege–church ontology;glossary;heuristic (computer science);lambda calculus;natural deduction;rewrite (programming);rewriting;rho calculus;rippling;sequent calculus;test set;unification (computer science);well-formed formula	Dieter Hutter	2000	Annals of Mathematics and Artificial Intelligence	10.1023/A:1018980012242	formal proof;artificial intelligence;mathematics;algorithm	AI	-15.522812099195216	12.47421168705467	141286
4b541442b31faeb3610caed0b0b1e9fc01b745d8	a-maze-ing esterel	ing esterel	This paper shows that the kernel fragment of Esterel corresponding to combinational circuits admits a natural game–theoretic interpretation. Technically, combinational Esterel programs are mapped into finite two–player games in such a way that the standard must– and cannot–analysis of signal statuses is reflected in the computation of winning strategies. The novel game–theoretic approach complements the existing behavioral, operational, circuit–based, and model–theoretic accounts of Esterel’s semantics and offers a new didactic perspective for familiarizing students and engineers with this intricate constructive semantics.	algebraic semantics (computer science);bisimulation;boolean algebra;causality;combinational logic;compiler;computation;esterel;game semantics;game theory;interpretation (logic);linear algebra;linear logic;logical connective;operational semantics;process calculus;self-information;turing completeness	Joaquín Aguado;Michael Mendler;Gerald Lüttgen	2004	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2003.05.006	computer science;theoretical computer science;mathematics;programming language;algorithm	Logic	-14.536168580410255	12.521721219560463	141504
fb9aaf3dd3ebd74435e3ef6d2ff4ff9fef383556	on the effectiveness of belief state representation in contingent planning		This work proposes new approaches to contingent planning using alternative belief state representations extended from those in conformant planning and a new AND/OR forward search algorithm, called PrAO, for contingent solutions. Each representation was implemented in a new contingent planner. The important role of belief state representation has been confirmed by the fact that our planners all outperform other stateof-the-art planners on most benchmarks and the comparison of their performances varies across all the benchmarks even using the same search algorithm PrAO and same unsophisticated heuristic scheme. The work identifies the properties of each representation method that affect the performance. Contingent Planning and Previous Approaches Contingent Planning is the task of generating conditional plans in the presence of incomplete information, uncertain action effects, and sensing actions (Peot and Smith 1992). It is known as one of the most general and hardest problems considered in planning (Haslum and Jonsson 1999). Significant progress has been made as various contingent planner can solve problems at different level of hardness, e.g., contingent-FF (Hoffmann and Brafman 2005), POND (Bryce et al. 2006), and CLG (Albore et al. 2009). One of the most efficient approaches to contingent planning is to encode the problem into an AND/OR search problem in the belief state space. To deal with incomplete information about the world, the notion of belief state has been introduced—defined as a set of possible states. This notion is convenient for capturing the semantic of incomplete information and uncertain action effects and for defining a transition function between belief states. The use of belief states themselves in the implementation of a planner, however, is inefficient and impractical due to their exponential size. The question is then how to represent belief states and, given a representation, how to define a transition function for computing successor belief states under conditional action effects in presence of incomplete information. To address this, (Bertoli et al. 2001) proposed the use of binary decision diagrams (BDDs) (Bryant 1992) to represent belief states in a model checking based planner MBP. Later, (Bryce et al. 2006) used BDDs to represent literals and actions in the planning graph for computation of heuristics used to search for solutions in their planner Copyright c © 2011, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved. POND. The use of the BDD is advantageous since it is more compact than the belief state itself and it allows to check whether a literal holds in a world state easily. Nonetheless, the size of a BDD representation is still very large and sensitive to the order of the variables. Moreover, computing successor belief states in BDDs form during the search is very expensive, requiring intermediate BDDs formulae of exponential size. This explains why MBP and POND do not scale well as shown in (Hoffmann and Brafman 2005; Albore et al. 2009). At the other extreme of belief state representation, the proposal in (Brafman and Hoffmann 2004; Hoffmann and Brafman 2005) represents belief states indirectly through the action sequences that lead to them from the initial belief state, and uses forward search in the belief space for solutions. The advantage of this method is easily seen as it requires very little memory, scaling up pretty well on a number of problems. The trade-off is that it incurs an excessive amount of repeated computation. Moreover, checking whether a proposition holds after the execution of an action sequence is co-NP-hard. This is, as we believe, one of the main reasons for their planners using this method to hardly find a solution for even small instances of harder problems, e.g., many instances are given in (Albore et al. 2009; To et al. 2010a). (Son and Baral 2001) brought a different perspective to deal with incomplete information that approximates a belief state by the intersection of the states it contains. The advantage of this approach lies in the low-complexity: the successor (approximated) belief state can be computed in polynomial time. The approximation is, however, incomplete. To address this, (Son and Tu 2006) identifies a complete condition for the approximation and develops the technique in their conformant planner, called CPA. The advantage of this approach is that the computation of the successor belief state is still very simple. However, the approximated formula, as shown in the experiments, explodes in many problems. Our Approaches and Up-to-date Results To address the issues of the aforementioned approaches, we firstly proposed a novel approach to dealing with incomplete information by using a compact DNF formula, called minimal DNF, to represent belief states and defining a direct complete transition function for computing the successor belief states encoded in this representation in the presence of incomplete information efficiently, i.e., polynomial unProceedings of the Twenty-Fifth AAAI Conference on Artificial Intelligence	approximation algorithm;artificial intelligence;binary decision diagram;bryce;co-np;computation;contingency (philosophy);cost per action;encode;experiment;heuristic (computer science);image scaling;literal (mathematical logic);million book project;model checking;performance;planner;polynomial;search algorithm;search problem;state space;time complexity;word lists by frequency	Son Thanh To;Tran Cao Son;Enrico Pontelli	2011			mathematical optimization;machine learning	AI	-19.07698089400339	14.389225522372689	141729
21e269419359a5bdf9d6b238ec6a89648ad7793d	importing logics: soundness and completeness preservation	importing logics;completeness preservation;modalization;combined logics	Importing subsumes several asymmetric ways of combining logics, including modalization and temporalization. A calculus is provided for importing, inheriting the axioms and rules from the given logics and including additional rules for lifting derivations from the imported logic. The calculus is shown to be sound and concretely complete with respect to the semantics of importing as proposed in [12].	lambda lifting	João Rasga;Amílcar Sernadas;Cristina Sernadas	2013	Studia Logica	10.1007/s11225-011-9363-x	t-norm fuzzy logics;discrete mathematics;mathematics;algorithm	PL	-12.110047944745371	15.558927447291785	141741
2626e27ab5af85d64dfd802428dcd4e4b85ffbc9	ucpop: a sound, complete, partial order planner for adl	partial order	"""We describe the ucpop partial order planning algorithm which handles a subset of Pednault's ADL action representation. In particular, ucpop operates with actions that have conditional e ects, universally quanti ed preconditions and e ects, and with universally quanti ed goals. We prove ucpop is both sound and complete for this representation and describe a practical implementation that succeeds on all of Pednault's and McDermott's examples, including the infamous \Yale Stacking Problem"""" [McDermott 1991]."""	algorithm;automated planning and scheduling;drew mcdermott;precondition;stacking	J. Scott Penberthy;Daniel S. Weld	1992			algorithm;planner;complete partial order;partial-order planning;theoretical computer science;computer science;artificial intelligence	AI	-17.83990764489373	13.788163706848641	142032
70657db480f15ab4b266b1406bbb9c4d755d0b84	foundational issues in implementing constraint logic programming systems	satisfiability;linear logic	Implementations of Constraint Logic Programming (CLP) systems are often incomplete with respect to the theories they are intended to implement. This paper studies two issues that arise in dealing with these incomplete implementations. First, the notion of incomplete “satisfiability function” (the analogue of unification) is formally defined, and the question of which such functions are reasonable is studied. Second, techniques are given for formally (proof-theoretically) specifying an intended CLP theory or a characterizing an existing CLP system, for the purpose of proving soundness and completeness results. Notions from linear logic and the notion of Henkinness of the theory are shown to be important here.	constraint logic programming	James H. Andrews	1994		10.1007/3-540-57880-3_5	constraint logic programming;linear logic;computer science;unification;automated theorem proving;constraint;programming language;implementation;algorithm;satisfiability	Logic	-15.354536992322522	17.81612872197942	142138
166c0af15f06112a5ea51b75915bc20b3a671861	efficient model checking of causal-knowledge protocols	multi agent system;model checking;event structures	A model checking algorithm for proving correctness of causal knowledge protocols for multi-agent systems is given. Protocols are spec-iied in an extension of the temporal logic of causal knowledge 18]. The temporal language is interpreted over labelled prime event structures. The epistemic operators correspond to knowledge and goals, whereas the temporal modalities correspond to the immediate causality and causal-ity. The model checking algorithm is translated to the model checking problem for LTL and ACTL. This enables a further translation to the SAT-problem, using the technique of the bounded model checking.	algorithm;boolean satisfiability problem;causality;correctness (computer science);model checking;multi-agent system;spec#;temporal logic	Wojciech Penczek	2001		10.1007/3-540-45941-3_26	model checking;discrete mathematics;theoretical computer science;automated proof checking;mathematics;abstraction model checking;algorithm	AI	-16.184937148463668	13.412864082952172	142618
4969fc3c09c0929867b6da869b3146c2b92a23ce	the constraint language for lambda structures	scope ambiguity;lambda kalkul;anaphora;ellipsis;constraint language for lambda structures;first order;constraint logische programmierung constraint language for kambda structures;tree descriptions;underspecification;clls	This paper presents the Constraint Language for Lambda Structures (CLLS), a first-order language for semantic underspecification that conservatively extends dominance constraints. It is interpreted over lambda structures, tree-like structures that encode λ-terms. Based on CLLS, we present an underspecified, uniform analysis of scope, ellipsis, anaphora, and their interactions. CLLS solves a variable capturing problem that is omnipresent in scope underspecification and can be processed efficiently.	accessibility;algorithm;anaphora (linguistics);blue (queue management algorithm);chorusos;cobham's thesis;encode;first-order logic;first-order predicate;fragment (computer graphics);interaction;lambda calculus;lambda lifting;microsoft outlook for mac;natural deduction;parallel computing;quantifier (logic);semantics (computer science);word lists by frequency	Markus Egg;Alexander Koller;Joachim Niehren	2001	Journal of Logic, Language and Information	10.1023/A:1017964622902	natural language processing;computer science;artificial intelligence;first-order logic;mathematics;linguistics;programming language;algorithm	PL	-16.666602423847724	14.12565385437992	142659
43d682479cd4caa79b68594bc010fc12428e6368	an approach to a systematic theorem proving procedure in first-order logic	theorem proving;first order logic	A complexity degree for theorems in first-order logic is introduced which naturally reflects the difficulty of proving them. Relative to that degree it is required that a systematic proof procedure should prove simple theorems faster than harder ones. Such a systematic but relatively inefficient procedure and a semisystematic but efficient procedure are presented. Both are developed on the basis of the consistency and completeness theorem for the underlying formal system rather than Herbrand's theorem. Für Theoreme der Prädikatenlogik erster Stufe wird ein Komplexitätsgrad eingeführt, der in natürlicher Weise die Kompliziertheit der zugehörigen Beweise mißt. Im Sinne dieses Grades wird von einer systematischen Beweisprozedur verlangt, daß sie einfache Theoreme schneller beweist als schwierigere. Solch ein systematisches, jedoch relativ ineffizientes Verfahren und ein halb-systematisches, jedoch effizientes Verfahren werden in dieser Arbeit beschrieben. Beide Verfahren stützen sich auf den Konsistenz- und Vollständigkeitssatz des zugrundeliegenden formalen Systems und nicht, wie üblich, auf den Herbrand-Satz.	automated theorem proving;computational complexity theory;eddie (text editor);first-order logic;first-order predicate;first-order reduction;formal system;internet explorer;sie (file format)	Wolfgang Bibel	1974	Computing	10.1007/BF02239498	herbrand's theorem;discrete mathematics;theorem;deduction theorem;first-order logic;fundamental theorem;mathematics;automated theorem proving;compactness theorem;second-order logic;proof complexity;algorithm;gödel's completeness theorem;model theory	Logic	-12.920113790714622	13.714467305457529	142924
340f9e0fc472ae803c4bb5475466eac30414db85	decidable elementary modal logics	elementary logic;computability;modal logic;undecidability decidable elementary modal logics universal first order horn formula satisfiability problem logics classification complexity local satisfiability np complete problem pspace complete problem global satisfiability exptime complete problem;computational complexity;complexity theory standards polynomials semantics force computer science labeling;elementary logic modal logic decidability;decidability computability computational complexity;decidability	In this paper, the modal logic over classes of structures definable by universal first-order Horn formulas is studied. We show that the satisfiability problems for that logics are decidable, confirming the conjecture from [E. Hemaspaandra and H. Schnoor, On the Complexity of Elementary Modal Logics, STACS 08]. We provide a full classification of logics defined by universal first-order Horn formulas, with respect to the complexity of satisfiability of modal logic over the classes of frames they define. It appears, that except for the trivial case of inconsistent formulas for which the problem is in P, local satisfiability is either NP-complete or PSPACE-complete, and global satisfiability is NP-complete, PSPACE-complete, or EXPTIME-complete. While our results holds even if we allow to use equality, we show that inequality leads to undecidability.	exptime;first-order predicate;horn clause;karp's 21 np-complete problems;modal logic;pspace;pspace-complete;stacs;social inequality;undecidable problem	Jakub Michaliszyn;Jan Otop	2012	2012 27th Annual IEEE Symposium on Logic in Computer Science	10.1109/LICS.2012.59	modal logic;dynamic logic;decidability;t-norm fuzzy logics;normal modal logic;modal μ-calculus;combinatorics;discrete mathematics;computer science;axiom s5;mathematics;computability;kripke semantics;computational complexity theory;accessibility relation;multimodal logic;algorithm;satisfiability	Logic	-13.05779472353671	13.711967178597424	143070
1f483c340cbfb1205c2beab7987897f05a81a7ae	completeness in pvs of a nominal unification algorithm	binders;pvs;nominal unification;nominal terms;α equivalence	Nominal systems are an alternative approach for the treatment of variables in computational systems. In the nominal approach variable bindings are represented using techniques that are close to first-order logical techniques, instead of using a higher-order metalanguage. Functional nominal computation can be modelled through nominal rewriting, in which α-equivalence, nominal matching and nominal unification play an important role. Nominal unification was initially studied by Urban, Pitts and Gabbay and then formalised by Urban in the proof assistant Isabelle/HOL and by Kumar and Norrish in HOL4. In this work, we present a new specification of nominal unification in the language of PVS and a formalisation of its completeness. This formalisation is based on a natural notion of nominal α-equivalence, avoiding in this way the use of the intermediate auxiliary weak α-relation considered in previous formalisations. Also, in our specification, instead of applying simplification rules to unification and freshness constraints, we recursively build solutions for the original problem through a straightforward functional specification, obtaining a formalisation that is closer to algorithmic implementations. This is possible by the independence of freshness contexts guaranteed by a series of technical lemmas.		Mauricio Ayala-Rincón;Maribel Fernández;Ana Cristina Rocha Oliveira	2016	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2016.06.005	discrete mathematics;mathematics;algorithm	PL	-14.444526643947288	17.716403696869733	143109
41f96ca93d8a90ecc6abfd20823011d383024e93	two theorems about the completeness of hoare's logic	wijsbegeerte	Abstract   We prove two theorems about the completeness of Hoare's logic for the partial correctness of  while -programs over an axiomatic specification. The first result is a completion theorem: any specification (Σ,E) can be refined to a specification (Σ 0 , E 0 ), conservative over (Σ, E), whose Hoare's logic is complete. The second result is a normal form theorem: any complete specification (Σ, E) possessing some complete logic for partial correctness can be refined to an effective specification (Σ 0 , E 0 ) conservative over (Σ, E), which generates all true partial correctness formulae with Hoare's standard rules.		Jan A. Bergstra;J. V. Tucker	1982	Inf. Process. Lett.	10.1016/0020-0190(82)90095-3	correctness;discrete mathematics;computer science;mathematics;hoare logic;algorithm	DB	-14.195500479553889	18.162425570434493	143399
8dd9fb1d55cef27d71d1df2de7c03dc5383707f8	a counting logic for trees		It has been recently shown that the fully enriched μ-calculus, an expressive modal logic, is undecidable. In the current work, we prove that this result does not longer hold when considering finite tree models. This is achieved with the introduction of an extension of the fully enriched μ-calculus for trees with numerical constraints. Contrastively with graded modalities, which restrict the occurrence of immediate successor nodes only, the logic introduced in this paper can concisely express numerical constraints on any tree region, as for instance the ancestor or descendant nodes. In order to show that the logic is in EXPTIME, we also provide a corresponding satisfiability algorithm. By succinct reductions to the logic, we identify several decidable extensions of regular tree languages with counting and interleaving operators. It is also shown that XPath extensions with counting constructs on regular path queries can be concisely captured by the logic. Finally, we show that several XML reasoning problems (XPath queries with schemas), such as emptiness and containment, can be optimally solved with the satisfiability algorithm.	avl tree;algorithm;automated reasoning;binary decision diagram;don sannella;exptime;european joint conferences on theory and practice of software;formal language;formal methods;forward error correction;haruo hosoya;icalp;jensen's inequality;knowledge representation and reasoning;laboratory for foundations of computer science;lecture notes in computer science;modal logic;modal μ-calculus;monadic predicate calculus;numerical analysis;p (complexity);pp (complexity);pierce oscillator;red–black tree;regular expression;regular tree grammar;relevance;self-balancing binary search tree;splay tree;springer (tank);symposium on principles of database systems;tree automaton;undecidable problem;xml;xpath	Everardo Bárcenas	2015	Computación y Sistemas		dynamic logic;discrete mathematics;theoretical computer science;mathematics;algorithm	Logic	-14.681927614770382	14.344120624465035	144295
2129b01800a644d43224759855553a11024e784f	complexity issues in multiagent logics	systems;system teamlog;knowledge;multi modal logical	Our previous research presents a methodology of cooperativ problem solving for beliefdesire-intention (BDI) systems, based on a complete formal theory called TEAMLOG. This covers both a static part, defining individual, bilateral and colle ctive agent attitudes, and a dynamic part, describing system reconfiguration in a dynamic, unpredicta ble environment. In this paper, we investigate the complexity of the satisfiability problem of th e static part of TEAMLOG, focusing on individual and collective attitudes up to collective inten tio . Our logics for teamwork are squarely multi-modal, in the sense that different operators are comb ined and may interfere. One might expect that such a combination is much more complex than the basic mu lti-agent logic with one operator, but in fact we show that it is not the case: the individual part of TEAMLOG is PSPACE-complete, just like the single modality case. The full system, modelli ng a subtle interplay between individual and group attitudes, turns out to be EXPTIME-complete, and r emains so even when propositional dynamic logic is added to it. Also works: NIAS, Meijboomlaan 1, 2242 PR Wassenaar, The Netherlan ds Also works: Institute of Computer Science, Polish Academy of Sciences, Ordona 21, 01-237 Warsaw, Poland and NIAS, Meijboomlaan 1, 2242 PR Wassenaar, The Netherlands Address for correspondence: Institute of Informatics, Warsaw Uni versity, Banacha 2, 02-097 Warsaw, Poland 240 M. Dziubínski et al. / Complexity Issues in Multiagent Logics Additionally we make a first step towards restricting the lan guage of TEAMLOG in order to reduce its computational complexity. We study formulas with bound ed modal depth and show that in case of the individual part of our logics, we obtain a reduction of th e complexity to NPTIME-completeness. We also show that for group attitudes in T EAMLOG the satisfiability problem remains in EXPTIMEhard, even when modal depth is bounded by 2. We also study the c ombination of reducing modal depth and the number of propositional atoms. We show that in b oth cases this allows for checking the satisfiability in linear time.	academy;agent-based model;belief–desire–intention software model;bilateral filter;boolean satisfiability problem;computational complexity theory;computer science;dirac comb;dynamic logic (modal logic);exptime;informatics;modal depth;modal logic;modality (human–computer interaction);np-completeness;pspace-complete;problem solving;time complexity;type system	Marcin Dziubinski;Rineke Verbrugge;Barbara Dunin-Keplicz	2007	Fundam. Inform.		discrete mathematics;computer science;artificial intelligence;machine learning;mathematics;knowledge;algorithm	AI	-15.837851881203784	12.535585933068736	144599
1314d0b55092d60e1af8cd424d3f035d2e502cbd	simple proof of the completeness theorem for second-order classical and intuitionistic logic by reduction to first-order mono-sorted logic	second order;theorie classique;language theory;reduction;ordre 1;orden 2;methode;teoria lenguaje;first order;intuitionistic logic;logique ordre 1;logique intuitionniste;completitud;reduccion;classical logic;ordre 2;completeness;classical theory;completude;metodo;orden 1;method;logica intuicionista;first order logic;theorie langage;teoria clasica;logica orden 1	We present a simpler way than usual to deduce the completeness theorem for the second-oder classical logic from the first-order one. We also extend our method to the case of second-order intuitionistic logic.	first-order predicate;intuitionistic logic	Karim Nour;Christophe Raffalli	2003	Theor. Comput. Sci.	10.1016/S0304-3975(02)00731-4	dynamic logic;complete theory;linear logic;mathematical logic;higher-order logic;paraconsistent logic;many-valued logic;intuitionistic logic;computer science;computability logic;intermediate logic;calculus;first-order logic;mathematics;minimal logic;programming language;truth value;second-order logic;algorithm;original proof of gödel's completeness theorem;gödel's completeness theorem;model theory	Logic	-13.329382691818012	15.401978677560889	144600
10f67563f5df92e63b0c7de78cb78ebf82eed935	a principle for incorporating axioms into the first-order translation of modal formulae	teoria demonstracion;theorie preuve;automatic proving;consistencia semantica;proof theory;soundness;axiomatic;automatisation;logique propositionnelle;demostracion automatica;automatizacion;probleme terminaison;theorem proving;demonstration automatique;demonstration theoreme;axiomatico;modal logic;first order;propositional logic;logique modale;inferencia;consistance semantique;grounded theory;logica modal;termination problem;completitud;decidibilidad;functionality;fonctionnalite;completeness;logica proposicional;demostracion teorema;decidabilite;axiomatique;completude;problema terminacion;funcionalidad;inference;decidability;automation	In this paper we present a translation principle, called the axiomatic translation, for reducing propositional modal logics with background theories, including triangular properties such as transitivity, Euclideanness and functionality, to decidable logics. The goal of the axiomatic translation principle is to find simplified theories, which capture the inference problems in the original theory, but in a way that is more amenable to automation and easier to deal with by existing theorem provers. The principle of the axiomatic translation is conceptually very simple and can be largely automated. Soundness is automatic under reasonable assumptions, and termination of ordered resolution is easily achieved, but the non-trivial part of the approach is proving completeness.	agent-based model;automated theorem proving;description logic;experiment;finite model property;first-order logic;first-order predicate;guarded logic;interpolation;method of analytic tableaux;modal logic;modality (human–computer interaction);simulation;speedup;standard translation;theory;universal instantiation;vertex-transitive graph	Renate A. Schmidt;Ullrich Hustadt	2003		10.1007/978-3-540-45085-6_36	modal logic;decidability;soundness;discrete mathematics;completeness;computer science;automation;proof theory;first-order logic;mathematics;automated theorem proving;propositional calculus;axiom;programming language;grounded theory;algorithm	Logic	-16.11440110401037	15.441756120952153	145042
b656b0617b422b33885dab6ce979a05c0ec1d734	some thoughts on hypercomputation	informatica;lenguaje programacion;halting function;lenguaje computadora;programming language;hypercomputation;langage ordinateur;hypercalcul;computer language;langage programmation;informatique;computer science;fonction arret;theorie mathematique	We first show that the Halting Function (the noncomputable function that solves the Halting Problem) has explicit expressions in the language of calculus. Out of that fact we elaborate on the possible meaning of hypercomputation theory within the setting of formal mathematical theories. 2005 Elsevier Inc. All rights reserved.	computable function;halting problem;hypercomputation	Newton C. A. da Costa;Francisco A. Doria	2006	Applied Mathematics and Computation	10.1016/j.amc.2005.09.073	computer science;hypercomputation;algorithm	AI	-14.555079308256175	17.348626900568956	145455
2275c9c8963155673c697a27c51a57d1a4282216	parameterized splitting: a simple modification-based approach	dung style argumentation framework;answer set;top part;bottom part;simple modification-based approach;parameterized splitting;argumentation framework;answer set semantics;similar splitting result;proper splitting;logic program;disjoint part	In an important and much cited paper Vladimir Lifschitz and Hudson Turner have shown how, under certain conditions, logic programs under answer set semantics can be split into two disjoint parts, a “bottom” part and a “top” part. The bottom part can be evaluated independently of the top part. Results of the evaluation, i.e., answer sets of the bottom part, are then used to simplify the top part. To obtain answer sets of the original program one simply has to combine an answer set of the simplified top part with the answer set which was used to simplify this part. Similar splitting results were later proven for other nonmonotonic formalisms and also Dung style argumentation frameworks. In this paper we show how the conditions under which splitting is possible can be relaxed. The main idea is to modify also the bottom part before the evaluation takes place. Additional atoms are used to encode conditions on answer sets of the top part that need to be fulfilled. This way we can split in cases where proper splitting is not possible. We demonstrate this idea for argumentation frameworks and logic programs.	argumentation framework;encode;hudson;lagrangian relaxation;logic programming;stable model semantics;vladimir lifschitz	Ringo Baumann;Gerhard Brewka;Wolfgang Dvorák;Stefan Woltran	2012		10.1007/978-3-642-30743-0_5	artificial intelligence;mathematics;algorithm	AI	-18.726399836148012	14.927025082430035	145849
3e78c5d6d40548780834385d95896f4979572f9d	algebraic semantics for modal logics i			modal logic	E. J. Lemmon	1966	J. Symb. Log.		discrete mathematics;t-norm fuzzy logics;monoidal t-norm logic;normal modal logic;kripke semantics;accessibility relation;mathematics;classical logic;interior algebra;algebraic semantics	Logic	-12.622540846159271	12.51102973346672	146078
01ebc64a641d7ba797bf471aba83bd45f1ca24e1	the q* algorithm - a search strategy for a deductive question-answering system	search strategy;question answering system	An approach f o r b r i ng i ng semantic, as w e l l as s y n t a c t i c , i n fo rma t ion to bear on the problem of theorem-proving search f o r Question-Answering <QA) Sys­ tems is descr i lsed. The approach is embodied in a search a l g o r i t h m , the 0* search a l g o r i t h m , developed to c o n t r o l deduct ive searches in an exper imental system. The Q* a lgo r i t hm is p a r t of a system, termed the Mary­ land Re fu ta t i on Proof Procedure System (MRPPS), which incorpora tes both the Q* a l g o r i t h m , which performs the search requ i red to answer a ouery, and an i n f e r e n t i a l component, which performs the l o g i c a l manipulat ions necessary to deduce a c lause from one or two o ther c lauses. The i n f e r e n t i a l component inc ludes many r e ­ f inements o f r e s o l u t i o n .	algorithm;execution unit;question answering	Jack Minker;Daniel H. Fishman;James R. McSkimin	1973	Artif. Intell.	10.1016/0004-3702(73)90013-1	computer science;artificial intelligence;theoretical computer science;mathematics;best-first search;algorithm;search algorithm	AI	-17.217594546579722	13.870599689685625	146530
13b05d8afa61ca9883f9ce0bbe841e7dcd94f0da	a primer on answer set programming	answer set programming;artificial intelligent;logic in computer science;logic programs;graduate student	where A0, . . . An are atoms and not is a logical connective called negation as failure. Also, for every rule let us define head(ρ) = A0, pos(ρ) = A1, . . . , Am, neg(ρ) = Am+1, . . . , An and body(ρ) = pos(ρ)∪ neg(ρ). The head of rules is never empty, while if body(ρ) = ∅ we refer to ρ as a fact. A logic program is defined as a collection of rules. Rules with variables are taken as shorthand for the sets of all their ground instantiations and the set of all ground atoms in the language of a program Π will be denoted by IBΠ . Queries and constraints are expressions with the same structure of rules but with empty head.	answer set programming;logic programming;logical connective;negation as failure;primer	Alessandro Provetti	2004	CoRR		first-generation programming language;constraint programming;declarative programming;programming domain;computer science;artificial intelligence;theoretical computer science;extensible programming;answer set programming;functional logic programming;computational logic;programming paradigm;procedural programming;symbolic programming;inductive programming;fifth-generation programming language;programming language theory;programming language;well-founded semantics;prolog;logic programming;algorithm	AI	-17.646320264359748	14.272638773740896	147395
3ee349b69c1fb7404770d4ea7bc17d21046e934d	absys, the first logic-programming language: a view of the inevitability of logic programming			absys;logic programming;programming language	E. W. Elcock	1991			programming language;dynamic logic (modal logic);computational logic;philosophy of logic;functional logic programming;horn clause;logic programming;algorithm;absys;computer science;prolog	Theory	-15.47553921830048	13.768255991900059	148165
6ff312b63cf86ff38de5b2cba0c50cd141e56f86	combining logic programming and equation solving	inference rule;logic programs	 Conditional equational theories can be built into logic programming using a generalizedresolution rule which calls a universal unification procedure. Such unificationprocedures are often defined by sound and strongly complete sets of inference rules. 	equation solving;logic programming	Steffen Hölldobler	1991	J. Log. Comput.	10.1093/logcom/1.3.397	dynamic logic;discrete mathematics;description logic;logic optimization;horn clause;computer science;artificial intelligence;machine learning;functional logic programming;computational logic;mathematics;proof calculus;prolog;logic programming;probabilistic logic network;multimodal logic;algorithm;rule of inference;autoepistemic logic	Logic	-14.59163609661079	13.264154084669554	148262
db33317de9217af033b41c9cc93e9078a49d0e84	a rewriting system for categorical combinators with multiple arguments	lenguaje programacion;partial computation;rewriting system;programming language;language theory;lambda calculus;teoria lenguaje;functional programming;combinateur categorique;category theory;church rosser property;rewrite systems;informatique theorique;theorie categorie;combinator;reecriture;langage programmation;lambda calculo;programmation fonctionnelle;03b40;rewriting;teoria categoria;lambda calcul;programacion funcional;68c01;categorical combinator;theorie langage;reescritura;computer theory;informatica teorica	Categorical combinators have been derived from the study of categorical semantics of lambda calculus, and it has been found that they may be used in implementation of functional languages. In this paper categorical combinators are extended so that functions with multiple arguments can be directly handled, thus making them more suitable for practical computation. A rewriting system named CCLM/3 is formulated for these combinators. This system naturally corresponds to the type-free A/3-calculus. The relationship between these two systems is established, and as a result of this, the Church-Rosser property of CCLM/3 is proved. A similar relationship is also established between the original CCL/3 by Curien and the type-free A/3-calculus with product. Finally the embedding theorem of CCLM/3 into CCL/ is shown. Key words, categorical combinator, Church-Rosser property, combinator, functional programming, lambda calculus, rewriting system AMS(MOS) subject classifications. 03B40, 68C01	categorical logic;church–rosser theorem;combinatory logic;computation;fixed-point combinator;functional programming;lambda calculus;rewriting	Hirofumi Yokouchi;Teruo Hikita	1990	SIAM J. Comput.	10.1137/0219005	combinatory logic;rewriting;computer science;philosophy of language;pure mathematics;lambda calculus;mathematics;programming language;functional programming;algorithm;category theory	Logic	-12.430899012592937	17.460411214397144	148882
3a763a3722e2d0007f4c04e737a6b00c2116e9f7	fixed points of type constructors and primitive recursion	model based reasoning;raisonnement base sur modele;publikationer;tipo dato;konferensbidrag;punto fijo;data type;fixed point;point fixe;strong normalization;xed point;artiklar;rapporter;type donnee;fix point;positividad;positivity;positivite	For nested or heterogeneous datatypes, terminating recursion schemes considered so far have been instances of iteration, excluding efficient definitions of fixed-point unfolding. Two solutions of this problem are proposed: The first one is a system with equi-recursive nonstrictly positive type constructors of arbitrary finite kinds, where fixedpoint unfolding is computationally invisible due to its treatment on the level of type equality. Positivity is ensured by a polarized kinding system, and strong normalization is proven by a model construction based on saturated sets. The second solution is a formulation of primitive recursion for arbitrary type constructors of any rank. Although without positivity restriction, the second system embeds—even operationally—into the first one.	algorithm;coinduction;combinatory logic;corecursion;de bruijn graph;fixed point (mathematics);impredicativity;iteration;newman's lemma;normalization property (abstract rewriting);primitive recursive function;recursion;red–black tree;simulation;time complexity;triangular matrix;type constructor;type system;unfolding (dsp implementation)	Andreas Abel;Ralph Matthes	2004		10.1007/978-3-540-30124-0_17	combinatorics;discrete mathematics;data type;computer science;artificial intelligence;model-based reasoning;mathematics;fixed point;programming language	Theory	-12.362960924831308	16.19376297963536	149140
57efe569de39ce5534ec431e952460197a1e900b	a systematic presentation of quantified modal logics	labelled deductive systems;automated reasoning;modal logic	this paper is an attempt at providing a systematic presentation of Quantified Modal Logics (with constant domains and rigid designators). We present a set of modular, uniform, normalizing, sound and complete labelled sequent calculi for all QMLs whose frame properties can be expressed as a finite set of first-order sentences with equality. We first present CQK, a calculus for the logic QK, and then we extend it to any such logic QL. Each calculus, called CQL, is modular (obtained by adding rules to CQK), uniform (each added rule is clearly related to a property of the frame), normalizing (frame reasoning only happens at the top of the proof tree) and Kripke-sound and complete for QL. We improve on the existing literature on the subject (mainly, [21]) by extending the class of logics for which such a presentation is given, and by giving a new proof of soundness and completeness.	accessibility relation;closing (morphology);contextual query language;first-order predicate;linear temporal logic;modal logic;natural deduction;normalization property (abstract rewriting);rigid designator;sequent calculus;soundness (interactive proof)	Claudio Castellini;Alan Smaill	2002	Logic Journal of the IGPL	10.1093/jigpal/10.6.571	modal logic;dynamic logic;discrete mathematics;epistemology;computer science;artificial intelligence;theoretical computer science;mathematics;automated reasoning;multimodal logic;algorithm	Logic	-12.186419398169408	15.318230253697381	149731
70198f571990f64ba4467b5ac27f335e62a9c63f	on the synthesis of fastest programs in inductive inference	inductive inference		fastest;inductive reasoning	Thomas Zeugmann	1983	Elektronische Informationsverarbeitung und Kybernetik		inductive reasoning;theoretical computer science;mathematics;machine learning;artificial intelligence	PL	-18.994111159952936	12.14860761349592	149737
5a1e12b39025c1708126153bfdb9fe10f3b7dcb4	negative operations on proofs and labels	recursion operator	Logic of proofs LP introduced by S. Artemov in 1995 describes properties of proof predicate “t is a proof of F” in the propositional language extended by atoms of the form [[t]]F . Proof are represented by terms constructed by three elementary recursive operations on proofs. In order to make the language more expressive we introduce the additional storage predicate with the intended interpretation “x is a label for F”. It can play the role of syntax encoding, so it is useful for specification of operations that require formula arguments. In this paper we study operations on proofs and labels that can be specified in the extended language. First, we give a formal definition of an operation on proofs and labels. Then, for an arbitrary finite set of operations F the logic LPS(F) is defined. We provide LPS(F) with symbolic semantics and arithmetical semantics. The main result of the paper is the uniform completeness theorem for this family of logics with respect to the both types of semantics.	elementary;interpretation (logic);recursion	Tatiana Yavorskaya	2005	J. Log. Comput.	10.1093/logcom/exi026	discrete mathematics;computer science;mathematics;programming language;algorithm	Logic	-12.016174826204013	15.857186529874928	150012
4ac9396fb0317373ddb909c22d8fb204e9d1df85	a complete gentzen-style axiomatization for set constraints	technical report;program analysis;computer science	Set constraints are inclusion relations between expressions denoting sets of ground terms over a ranked alphabet They are the main ingredient in set based program analysis In this paper we pro vide a Gentzen style axiomatization for sequents where and are nite sets of set constraints based on the axioms of termset al gebra Sequents of the restricted form correspond to positive set constraints and those of the more general form correspond to sys tems of mixed positive and negative set constraints We show that the deductive system is i complete for the restricted sequents over standard models ii incomplete for general sequents over stan dard models but iii complete for general sequents over set theoretic termset algebras	axiomatic system;formal system;program analysis;stan;theory	Allan Cheng;Dexter Kozen	1996		10.1007/3-540-61440-0_123	program analysis;discrete mathematics;computer science;technical report;mathematics;algorithm	Logic	-13.63039139439305	16.18108697502235	150207
df1df1e2091a46b094fda99deb5a95f852a7097d	towards a logic for reasoning about logic programs transformation	inference rule;theoretical analysis;logic programs	We give a proof-theoretic analysis of logic programs transformations , viewed as operations on proof trees in the sense of 3, 4, 9, 10]. We present a logic for reasoning about (equivalence preserving) transformations of logic programs. Our main tool is the usage of inference rules; the target program may be obtained as a set of clause introduction proofs with axioms from the source program. The rules are admissible, that is every proof according to the latter can be translated back in a derivation of the same consequence built from the source program without those rules. In this formal setting, we give a general schema for program transformation analysis, which can be applied to any transformation system based on admissible rules. As examples, we treat Partial Deduction and Unfold/Fold transformations. Furthermore, the proof-theoretic framework allows a uniform generalization of the basic results to other logic programming languages satisfying the simple requirement of regularity. Our perspective and overall aim is to develop the proof-theory of (logic) program transformation.	admissible heuristic;logic programming;natural deduction;program transformation;programming language;theory;turing completeness	Alberto Momigliano;Mario Ornaghi	1997		10.1007/3-540-49674-2_12	dynamic logic;description logic;higher-order logic;computer science;theoretical computer science;bunched logic;non-monotonic logic;machine learning;computational logic;automated reasoning;probabilistic logic network;substructural logic;multimodal logic;algorithm;philosophy of logic;rule of inference;autoepistemic logic	PL	-15.614543730538157	18.047400884965516	150235
f786bd12cc8b0717a1904f1c188fe5d0fa3bd00c	parsing as deduction	general view;interesting class;chart parsing;earley deduction proof procedure;definite clause;semantics;nodes;logic;parsers;context free grammars;linkages;graphs;algorithms;edges;efficiency;simplification;artificial intelligence;computational linguistics;natural language	"""By exploring the relationship between parsing and deduction, a new and more general view of chart parsing is obtained, which encompasses parsing for grammar formalisms based on unification, and is the basis of the Earley Deduction proof procedure for definite clauses. The efficiency of this approach for an interesting class of grammars is discussed. 1. I n t r o d u c t i o n The aim of this paper is to explore the relationship between parsing and deduction. The basic notion, which goes back to Kowaiski (Kowalski, 1980} and Colmerauer {Colmeraucr, 1978), h'zs seen a very efficient, if limited, realization in tile use of the logic programming language Prolog for parsing {Colmerauer, 1978; Pereira and Warren, 1980). The connection between parsing and deduction was developed further in the design of the Eariey Deduction proof procedure (Warren, 1975), which will also be discussed at length here. Investigation of the connection between parsing and deduction yields several important benefits: • A theoretically clean mechanism to connect parsing with the inference needed for semantic interpretation. llandling of gaps and unbounded dependencies """"on the fly"""" without adding special mechanisms to the parser. :\ reinterprecation and generalization of chart parsing that abstracts from unessential datastructure details. * Techniques that are applicable to parsing in related formalisms not directly based on logic. IThis work wa~ partially supported by the Defense Advanced Research Projects Agency under Contract N00039-80-C-0575 with the Naval Electronic Systems Command. The views and conclusions contained in this article are those of the authors and should not be interpreted as representative of the official policies, either expressed or imp{led, of the Defense Advanced Research Projects Agency or the United Slates Government. • Elucidation of parsing complexity issues for related formalisms, in particular lexieal-functional grammar (LFG). Our study of these topics is still far from complete; therefore, besides offering some initial results, we shall discuss various outstanding questions. The connection between parsing and deduction is based on the axiomatization of context-free grammars in def ini te clauses, a particularly simple subset of firstorder logic (Kowalski, 1080; van Emden and Kowalski, 1976). This axiomatization allows us to identify contextfree parsing algorithms with proof procedures for a restricted class of definite clauses, those derived from context-free rules. This identification can then be generalized to inc{ude larger classes of definite clauses to which the same algorithms can be applied, with simple modifications. Those larger classes of definite clauses can be seen as grammar formalisms in which the atomic grammar symbols of context-free grammars have been replaced by complex symbols that are matched by unification (Robinson, 1965; Colmerauer, 1978; Pereir3 and Warren, 1980}. The simplest of these formalisms is definite-clause grammars (DCG) (Pereira and Warren, 1980). There is a close relationship between DCGs ~nd other ~,rammar formalisms based on unification, such as Unification Grammar {UG) (Kay, 1070), LFG, PATR-2 {Shieber. 1083) and the more recent versions of GPSG (Gazdar and Pullum, 1082). The parsing a{gorithms we are concerned with are onl ine algorithms, in the sense that they apply the constraints specified by the augmentation of a rule a~ soon as the rule is applied. In contrast, an olTline parsing algorithm will consist of two phases: a context-free parsing algorithm followed by application of the constraints to all the resulting analyses. The pap('r is organized as follows. Section 2 gives an overview of the concepts of definite clause logic, definite clause grammars, definite clause proof procedures, and chart parsing, Section 3 discusses the connection betwee DCGs and LFG. Section 4 describes the Earley Deduction definite-clause proof procedure. Section 5 then brings out the connection between Earley Deduction and chart parsing, and shows the added generality brought in by the proof procedure approach. Section 6 outlines some oi the problems of implementing Earley Deduction and similar parsing procedure~. Finally, Section 7 discusses questions of computational complexity and decidability."""	algorithm;axiomatic system;chart parser;computational complexity theory;context-free grammar;context-free language;data structure;definite clause grammar;generalized phrase structure grammar;han unification;horn clause;lexical functional grammar;logic programming;natural deduction;on the fly;parsing;programming language;prolog;semantic interpretation;three utilities problem;unification (computer science);warren abstract machine	Fernando Pereira;David H. D. Warren	1983			natural language processing;parser combinator;l-attributed grammar;parsing expression grammar;top-down parsing language;computer science;bottom-up parsing;computational linguistics;parsing;s-attributed grammar;semantics;linguistics;efficiency;natural language;context-free grammar;programming language;top-down parsing;logic;simplification;algorithm	NLP	-18.264389167999877	14.671953044574806	150753
9fec1e645dfaea71db37eac12ab39d1842dfd741	lambek's categorical proof theory and läuchli's abstract realizability				Victor Harnik;Michael Makkai	1992	J. Symb. Log.			Theory	-12.401029863185235	12.075403473295822	150896
62c57b2a27463fc0de5ad7db9c4fd6189117e49c	a general filtration method for modal logics	modal logic		modal logic	Dov M. Gabbay	1972	J. Philosophical Logic	10.1007/BF00649988	modal logic;normal modal logic;discrete mathematics;philosophy;epistemology;axiom s5;mathematics;accessibility relation;multimodal logic	Logic	-12.604906626809896	11.936361571182987	150932
51c636e43a5e5b0c7d6ee4b6486348196ea4e86a	intelligent computer mathematics	artificial intelligent;information system;knowledge discovery;data mining	This paper describes a machine-checked proof of the JordanHölder theorem for finite groups. This purpose of this description is to discuss the representation of the elementary concepts of finite group theory inside type theory. The design choices underlying these representations were crucial to the successful formalization of a complete proof of the Odd Order Theorem with the Coq system.	computational science;coq (software);type theory	Jacques Carette;David Aspinall;Christoph Lange;Petr Sojka;Wolfgang Windsteiger	2013		10.1007/978-3-642-39320-4	intelligent decision support system;computer science;data science;theoretical computer science;machine learning;intelligent agent	Theory	-18.82531395507497	16.798156735435477	151420
0a51e20bece1d29503938849e7c4def5f72a2e33	reasoning about actions in dynamic linear time temporal logic	action language;dynamic linear time temporal logic;reasoning about action;temporal logic;temporal constraints;indexation;linear time;propositional dynamic logic	In this paper we present a theory for reasoning about actions which is based on Dynamic Linear Time Temporal Logic (DLTL). DLTL is a simple extension of propositional temporal logic of linear time in which regular programs of propositional dynamic logic can be used for indexing temporal modalities. The action theory we define allows to reason with incomplete initial states, to do postdiction and to deal with ramifications and with nondeterministic actions, which are captured by possibly alternative extensions (temporal models). The expressiveness of temporal logic is exploited to enhance the action language by allowing the definition of general temporal constraints as well as complex actions in the specification of the domain description. We show that the temporal projection problem and the planning problem can be modelled as satisfiability problems in DLTL.	algol;action language;algorithm;boolean satisfiability problem;büchi automaton;computation;decision problem;dynamic logic (modal logic);enrico clementi;first-order logic;frame problem;linear temporal logic;linearizability;maximal set;modal logic;modal μ-calculus;model m keyboard;ramification problem;regular expression;semantics (computer science);situation calculus;theory (mathematical logic);time complexity;verification and validation	Laura Giordano;Alberto Martelli;Camilla Schwind	2001	Logic Journal of the IGPL	10.1093/jigpal/9.2.273	dynamic logic;zeroth-order logic;time complexity;modal μ-calculus;discrete mathematics;linear temporal logic;description logic;temporal logic;interval temporal logic;computation tree logic;action language;computer science;artificial intelligence;machine learning;mathematics;substructural logic;multimodal logic;algorithm;temporal logic of actions;autoepistemic logic	AI	-15.530848331528105	13.671492319012128	151530
191689a2fb5991d9badcb5d483a6ab20d59ce6a2	on the complexity of prefix formulas in modal logic of subset spaces	satisfiability;modal logic;model checking	Many logics used in computer science have an intractable satisfiability (model-checking, derivability) problem. This restricts their general applicability severely. May be restricting to smaller classes of admissible formulas can bring down the complexity bounds. In the present paper we follow this strategy for the subset space logic proposed by Moss and Parikh recently [Moss and Parikh 1992], [Dabrowski et al. 1996]. Forming nSAT as in sentential logic, but with prefix formulas instead of literals, we obtain nice generalizations of the following results well-known from the prepositional case: nSAT  P if n2 and nSAT is NP-complete if n>-3. Thus nSAT is feasible, iff n2. Moreover, full SAT turns out to be PSPACE-hard (as usual).	modal logic;spaces	Bernhard Heinemann	1997		10.1007/3-540-63045-7_16	modal logic;predicate logic;dynamic logic;normal modal logic;model checking;modal μ-calculus;combinatorics;discrete mathematics;linear temporal logic;description logic;higher-order logic;computer science;intermediate logic;axiom s5;mathematics;accessibility relation;multimodal logic;second-order logic;algorithm;satisfiability	Logic	-12.908825946807623	14.637871045419386	151724
3852d535fe32f736c8a862bde1b01b590f98d6ac	coalgebraic hybrid logic	computability and decidability;conference paper;generic frameworks;modal logic;communication channels information theory;hybrid logic;computer software;finite model property;modal operators;keywords coalgebraic;new results;probabilistic logics;semantic criteria	We introduce a generic framework for hybrid logics, i.e. modal logics additionally featuring nominals and satisfaction operators, thus providing the necessary facilities for reasoning about individual states in a model. This framework, coalgebraic hybrid logic, works at the same level of generality as coalgebraic modal logic, and in particular subsumes, besides normal hybrid logics such as hybrid K, a wide variety of logics with non-normal modal operators such as probabilistic, graded, or coalitional modalities and non-monotonic conditionals. We prove a generic finite model property and an ensuing weak completeness result, and we give a semantic criterion for decidability in PSPACE. Moreover, we present a fully internalised PSPACE tableau calculus. These generic results are easily instantiated to particular hybrid logics and thus yield a wide range of new results, including e.g. decidability in PSPACE of probabilistic and graded hybrid logics.	finite model property;hybrid logic;hybrid system;kripke semantics;logic programming;method of analytic tableaux;modal companion;modal logic;natural deduction;pspace;proof calculus;search algorithm;semantic analysis (compilers);semantic reasoner;sequent calculus;t-norm fuzzy logics	Robert S. R. Myers;Dirk Pattinson;Lutz Schröder	2009		10.1007/978-3-642-00596-1_11	modal logic;t-norm fuzzy logics;normal modal logic;discrete mathematics;mathematics;accessibility relation;algorithm;modal operator	Logic	-12.957609481099976	16.05774442133	151746
1aa907b6ab273c56102671408ac3e1004e6e4217	stit is dangerously undecidable		STIT is a potential logical framework to capture responsibility, counterfactual emotions and norms, which are main ingredients for specifying behaviors of virtual agents. We identify here a new fragment and its satisfiability problem is NPcomplete and in Σ3 when the number of agents is unbounded. We also identify a slightly more expressive fragment which is undecidable. This fragment is used to prove that Broersen’s XSTITwhen the semantics is standard is undecidable. We prove that with XSTIT-models, XSTITis NEXPTIME-hard when the number of agents is unbounded.	agi-plan;boolean satisfiability problem;counterfactual conditional;decision problem;description logic;finite model property;intelligent agent;logical framework;long division;method of analytic tableaux;modal depth;modal logic;nexptime;np-completeness;polynomial;undecidable problem	François Schwarzentruber;Caroline Semmling	2014		10.3233/978-1-61499-419-0-1093	algorithm	AI	-14.080913212577965	12.294991687497037	151755
c636c7cf7a7e4b7feb8d8f873a3586929ac6f600	disjunctive lp+integrity constraints= stable model semantics	minimal model;disjunctive programming;stable models;satisfiability;stable model semantics;integrity constraints;logic programs	We show that stable models of logic programs may be viewed as minimal models of programs that satisfy certain additional constraints. To do so, we transform the normal programs into disjunctive logic programs and sets of integrity constraints. We show that the stable models of the normal program coincide with the minimal models of the disjunctive program thatsatisfy the integrity constraints. As a consequence, the stable model semantics can be characterized using theextended generalized closed world assumption for disjunctive logic programs. Using this result, we develop a bottomup algorithm for function-free logic programs to find all stable models of a normal program by computing the perfect models of a disjunctive stratified logic program and checking them for consistency with the integrity constraints. The integrity constraints provide a rationale as to why some normal logic programs have no stable models.	algorithm;closed-world assumption;data integrity;design rationale;disjunctive normal form;logic programming;stable model semantics	José Alberto Fernández;Jorge Lobo;Jack Minker;V. S. Subrahmanian	1993	Annals of Mathematics and Artificial Intelligence	10.1007/BF01530802	discrete mathematics;stable model semantics;computer science;theoretical computer science;data integrity;mathematics;linguistics;algorithm;satisfiability	AI	-15.109304621229176	15.96856323858464	152343
f90b3b7b61dd0d49d787c4cb3445ebd13435fa4d	implementing first-order rewriting with constructor systems	lenguaje programacion;mathematics;programming language;semantica formal;language theory;teoria lenguaje;formal semantics;semantique formelle;first order;informatique theorique;reecriture;langage programmation;rewriting;theorie langage;reescritura;computer theory;informatica teorica	Abstract   In previous work [8] we described a technique for translating a general class of equational rewriting systems called  regular systems  [3] to constructor-based systems. This paper extends the previous results by showing that the translation technique described in [8] is much more generally applicable under a slight restriction of rewriting in the translated version of the system. The three additional classes we consider are those of semiregular systems (a generalization of regular systems), canonical systems, and arbitrary call-by-value confluent systems. It is shown that in each case the translation preserves the defining characteristics and normal forms of the class.	first-order predicate;rewriting	Satish R. Thatte	1988	Theor. Comput. Sci.	10.1016/0304-3975(88)90109-0	rewriting;computer science;philosophy of language;pure mathematics;formal semantics;first-order logic;mathematics;programming language;confluence;algorithm;algebra	Logic	-12.903238896475653	17.942090442013345	152765
c4e446fc5aa52fb9aa9a81a2a3a92fe33a6bfe9c	adding equality to semantic tableaux	theorem proving;first order logic	An extension to the system of semantic tableaux to deal with first-order logic with equality is introduced and proved sound and complete. This involves the use of partial unification, an operation which is based on unification without the presence of variables. We show, further, that semantic tableaux with partial unification provide a sound and complete proof method without needing the functionally reflexive axioms. We also give an example of an ordering rule which allows us to provide less complex proofs in the ground case.	first-order logic;first-order predicate;method of analytic tableaux;unification (computer science)	S. V. Reeves	1987	Journal of Automated Reasoning	10.1007/BF00243790	discrete mathematics;computer science;first-order logic;mathematics;automated theorem proving;programming language;algorithm	Logic	-14.261894525081907	14.867174259707461	152868
28a6d3b58b2cf222b45535e5094e560faf59bc3c	nested proof search as reduction in the lambda-calculus	focusing;evaluation strategies;calculus of structures;lambda calculus;sequent calculus;intuitionistic logic;proof search;explicit substitution;deep inference;explicit substitutions	We present a system for propositional implicative intuitionistic logic in the calculus of structures, which is a generalisation of the sequent calculus to the deep inference methodology. We show that it is sound and complete with respect to the usual sequent calculus, and consider a restricted system for a smaller class of formulas. Then, we encode lambda-terms with explicit substitutions in these formulas and exhibit a correspondence between proof search in this system and reduction in a lambda-calculus with explicit substitutions. Finally, we present a further restriction to allow a correspondence with the standard lambda-calculus, and show that we can prove results on lambda-calculi by proving results on derivations in the proof systems.	automated theorem proving;calculus of structures;encode;explicit substitution;intuitionistic logic;lambda calculus;sequent calculus	Nicolas Guenot	2011		10.1145/2003476.2003501	calculus of constructions;process calculus;typed lambda calculus;dependent type;pure type system;cut-elimination theorem;geometry of interaction;intuitionistic logic;computer science;time-scale calculus;lambda calculus;simply typed lambda calculus;proof calculus;noncommutative logic;curry–howard correspondence;sequent;programming language;sequent calculus;natural deduction;structural proof theory;proof complexity;algorithm	PL	-12.247590959643485	16.047862751286754	152905
8c673b0dd899ed448fd4996d0ee63990ac66b647	type checking and inference for polymorphic and existential types	lambda calculus;curry-style lambda calculus;type inference;type checking;existence fragment;existential fragment;domain-free polymorphic lambda calculus;existential type;type inference problem;multiple quantifier rule	This paper proves undecidability of type checking and type inference problems in some variants of typed lambda calculi with polymorphic and existential types. First, type inference in the domain-free polymorphic lambda calculus is proved to be undecidable, and then it is proved that type inference is undecidable in the negation, conjunction, and existence fragment of the domain-free typed lambda calculus. Secondly, their variants with multiple quantifier rules are introduced, and their type checking and type inference are proved to be undecidable. Finally, it is proved that we can reduce undecidability of type checking and type inference problems in the Currystyle lambda calculus in negation, conjunction, and existential fragment to undecidability of those problems in another variant of the domain-free polymorphic lambda calculus.	quantifier (logic);system f;type inference;typed lambda calculus;undecidable problem	Koji Nakazawa;Makoto Tatsuta	2009	Chicago J. Theor. Comput. Sci.		system f;type class;typed lambda calculus;discrete mathematics;dependent type;binary lambda calculus;type system;pure type system;computer science;type inference;simply typed lambda calculus;mathematics;type constructor;hindley–milner type system;programming language;kind;church encoding;lambda cube;generalized algebraic data type;type inhabitation;algorithm	PL	-12.622770214980974	17.70161360259385	152985
8e924eec08583abd0fdabb45a56346ab4f467aa1	ceres for first-order schemata		The cut-elimination method CERES (for firstand higherorder classical logic) is based on the notion of a characteristic clause set, which is extracted from an LK-proof and is always unsatisfiable. A resolution refutation of this clause set can be used as a skeleton for a proof with atomic cuts only (atomic cut normal form). This is achieved by replacing clauses from the resolution refutation by the corresponding projections of the original proof. We present a generalization of CERES (called CERESs) to first-order proof schemata and define a schematic version of the sequent calculus called LKSE , and a notion of proof schema based on primitive recursive definitions. A method is developed to extract schematic characteristic clause sets and schematic projections from these proof schemata. We also define a schematic resolution calculus for refutation of schemata of clause sets, which can be applied to refute the schematic characteristic clause sets. Finally the projection schemata and resolution schemata are plugged together and a schematic representation of the atomic cut normal forms is obtained. A major benefit of CERESs is the extension of cut-elimination to inductively defined proofs: we compare CERESs with standard calculi using induction rules and demonstrate that CERESs is capable of performing cut-elimination where traditional methods fail. The algorithmic handling of CERESs is supported by a recent extension of the CERES system.	database normalization;first-order predicate;primitive recursive function;recursion;schematic;sequent calculus	Tsvetan Dunchev;Alexander Leitsch;Mikheil Rukhaia;Daniel Weller	2017	J. Log. Comput.	10.1093/logcom/exx003	discrete mathematics;computer science;artificial intelligence;mathematics;algorithm	PL	-12.431505558158992	16.061649978001096	153076
eaf62d80fbbddd7ab5a4ee992f23603b678096a0	plane geometry theorem proving using forward chaining	theorem proving	Abstract   A computer program is described which operates on a subset of plane geometry. Its performance not only compares favorably with previous computer programs, but within its limited problem domain (e.g., no curved lines nor introduction of new points), it also invites comparison with the best human theorem provers. The program employs a combination of forward and backward chaining with the forward component playing the more important role. This, together with a deeper use of diagrammatic information, allows the program to dispense with the diagram filter in contrast with its central role in previous programs. An important aspect of human problem solving may be the ability to structure a problem space so that forward chaining techniques can be used effectively.	forward chaining	Arthur J. Nevins	1975	Artif. Intell.	10.1016/0004-3702(75)90013-2	backward chaining;discrete mathematics;computer science;artificial intelligence;mathematics;automated theorem proving;inference engine;algorithm	AI	-18.179705166623908	16.877481321547855	153429
92278a845828db6e51c08af88c288dcaee09f253	tabeql: a tableau based suite for equilibrium logic	modelizacion;logica formal;representacion conocimientos;verificacion modelo;sistema experto;stable models;model generation;circonscription;verification modele;semantics;intelligence artificielle;logical programming;semantica;semantique;circumscription;modelisation;model checking;nonmonotonic reasoning;programmation logique;answer set semantics;formal logic;artificial intelligence;inteligencia artificial;systeme expert;logic programs;knowledge representation;representation connaissances;logique formelle;programacion logica;modeling;circonscripcion;expert system	Equilibrium logic is a formal system of nonmonotonic reasoning proposed by D. Pearce [6,7] that generalises the stable model and answer set semantics for logic programs [1]. The program tabeql included several systems that are related to equilibrium logic and are based on tableau methodology: an equilibrium model generator [8], a checker for strong equivalence between theories [4] and a checker for uniform equivalence [9].	method of analytic tableaux	Agustín Valverde	2004		10.1007/978-3-540-30227-8_69	model checking;systems modeling;computer science;artificial intelligence;non-monotonic logic;mathematics;semantics;logic;expert system;circumscription;algorithm	AI	-16.27802363282613	15.10100660840533	153470
07024a11a244dc3fecba390bc3046c25928ee593	representing von neumann–morgenstern games in the situation calculus	agent interaction;multiagent system;reasoning about action;game theory;reasoning about actions and change;utility function;complete axiomatization;decision theory;knowledge representation;situation calculus;multiagent systems	Sequential von Neumann–Morgernstern (VM) games are a very general formalism for representing multi-agent interactions and planning problems in a variety of types of environments. We show that sequential VM games with countably many actions and continuous utility functions have a sound and complete axiomatization in the situation calculus. This axiomatization allows us to represent game-theoretic reasoning and solution concepts such as Nash equilibrium. We discuss the application of various concepts from VM game theory to the theory of planning and multi-agent interactions, such as representing concurrent actions and using the Baire topology to define continuous payoff functions.	automated theorem proving;axiomatic system;backward induction;cobham's thesis;columbia (supercomputer);computable function;computational complexity theory;epistemic modal logic;expressive power (computer science);first-order predicate;game engine;game theory;grammar-based code;interaction;markov chain;markov decision process;multi-agent system;nash equilibrium;natural language;patrick hanks;semantics (computer science);situation calculus;unary operation;von neumann architecture	Oliver Schulte;James P. Delgrande	2004	Annals of Mathematics and Artificial Intelligence	10.1023/B:AMAI.0000034523.18162.6b	knowledge representation and reasoning;game theory;discrete mathematics;decision theory;computer science;artificial intelligence;multi-agent system;mathematics;situation calculus;algorithm	AI	-18.212655802306585	12.581446410166032	153487
40e656f409aa3e989092d2ce74bff2b86ac00854	a variable typed logic of effects	langage fonctionnel;information systems;logique mathematique;language theory;lenguaje funcional;information systems not elsewhere classified;logica matematica;teoria lenguaje;mathematical logic;information and communication services;inference rule;dynamic logic;first order;information and communication services not elsewhere classified;functional language;information and computing sciences;theorie langage;other information and communication services;type system	In this paper we introduce a variable typed logic of effects inspired by the variable type systems of Feferman for purely functional languages. VTLoE (Variable Typed Logic of Effects) is introduced in two stages. The first stage is the first-order theory of individuals built on assertions of equality (operational equivalence a la Plotkin), and contextual assertions. The second stage extends the logic to include classes and class membership. The logic we present provides an expressive language for defining and studying properties of programs including program equivalences, in a uniform framework. The logic combines the features and benefits of equational calculi as well as program and specification logics. In addition to the usual first-order formula constructions, we add contextual assertions. Contextual assertions generalize Hoare′s triples in that they can be nested, they can be used as assumptions, and their free variables can be quantified. They are similar in spirit to program modalities in dynamic logic. We use the logic to establish the validity of the Meyer Sieber examples in an operational setting. The theory allows for the construction of inductively defined sets and derivation of the corresponding induction principles. We hope that classes may serve as a starting point for studying semantic notions of type. Naive attempts to represent ML types as classes fail in the sense that ML inference rules are not valid. © 1995 Academic Press. All rights reserved.	type theory	Furio Honsell;Ian A. Mason;Scott F. Smith;Carolyn L. Talcott	1995	Inf. Comput.	10.1006/inco.1995.1077	predicate logic;dynamic logic;zeroth-order logic;mathematical logic;description logic;higher-order logic;separation logic;type system;many-valued logic;computer science;intermediate logic;artificial intelligence;philosophy of language;bunched logic;first-order logic;mathematics;programming language;functional programming;substructural logic;multimodal logic;information system;algorithm;philosophy of logic;rule of inference;algebra	Logic	-15.410834803673831	18.09532745929346	153886
0d1318e228352e21404b45b8631f9db186a4cbeb	type inference in the presence of overloading, subtyping and recursive types	recursive types;type inference;canonical representation	We present a unified approach to type inference in the presence of overloading and coercions based on the concept of <italic>constrained types</italic>.  We define a generic inference system, show that subtyping and overloading can be treated as a special instance of this system and develop a simple algorithm to compute principal types.  We prove the decidability of type inference for the class of <italic>decomposable predicates</italic> and develop a canonical representation for principal types based on <italic>most accurate simplifications</italic> of constraint sets.  Finally, we investigate the extension of our techniques to <italic>recursive types</italic>.	algorithm;function overloading;inference engine;operator overloading;principal type;recursion (computer science);type class;type inference	Stefan Kaes	1992		10.1145/141471.141540	canonical form;computer science;recursive data type;type inference;machine learning;programming language;algorithm	PL	-13.432775069474117	17.991706607442964	154578
242f5a6ac8b9cb4a27313077b8bb477eda37d459	a companion to brady's 4-valued relevant logic bn4: the 4-valued logic of entailment e4				Gemma Robles;José M. Méndez	2016	Logic Journal of the IGPL	10.1093/jigpal/jzw011	predicate logic;dynamic logic;zeroth-order logic;description logic;higher-order logic;paraconsistent logic;many-valued logic;intermediate logic;bunched logic;predicate functor logic;default logic;logic;multimodal logic;autoepistemic logic	Logic	-13.214814162654326	12.354631462630428	154913
a86c8829a32301610e7fa733f256b1bad4c20475	minimizing disjunctive normal forms of pure first-order logic			database normalization;disjunctive normal form;first-order logic;first-order predicate	Timm Lampert	2017	Logic Journal of the IGPL	10.1093/jigpal/jzx003	mathematical optimization;combinatorics;discrete mathematics;mathematics;disjunctive normal form	AI	-13.99514717354305	13.664990231305964	155040
f25149ca62e065b49de35b3045f9112f1c525cca	on abstraction and the expressive power of programming languages	lenguaje programacion;compilacion;translating;programming language;language theory;reduction;abstraction;teoria lenguaje;abstraccion;expressive power;traduction;theory;teoria;langage programmation;compilation;preservation;reduccion;traduccion;expressivite;preservacion;theorie langage;theorie	This paper presents a tentative theory of programming language expressiveness based on reductions (language translations) that preserve observational equivalence. These are called «abstraction-preserving» reductions because of a connection with a definition of «abstraction» or «information-hiding» mechanisms. If there is an abstraction-preserving reduction from one language to another, then (essentially) every function on natural numbers that is definable in the first is also definable in the second. Moreover, an abstraction-preserving reduction must map every abstraction construct in the source language to a construct that hides analogous distinctions in the target language. Several examples and counterexamples to abstraction-preserving reductions are given		John C. Mitchell	1993	Sci. Comput. Program.	10.1016/0167-6423(93)90004-9	natural language processing;language primitive;reduction;computer science;philosophy of language;abstraction;low-level programming language;programming language;preservation;expressive power;theory;algorithm	PL	-13.312194985654823	17.98811030707055	155384
8a422557a2b02e38f70e66a54ca613a26fc1e2ff	rules dependencies in backward chaining of conceptual graphs rules	optimisation;representacion conocimientos;conceptualization;subgrafo;optimizacion;backward chaining;chainage avant;chainage arriere;conceptual analysis;analisis conceptual;conceptualizacion;unification;sous graphe;conceptual graph;representation connaissance;grafo conceptual;optimization;forward chaining;analyse conceptuelle;subgraph;knowledge representation;graphe conceptuel;conceptualisation;unificacion	Conceptual Graphs Rules were proposed as an extension of Simple Conceptual Graphs (CGs) to represent knowledge of form “if A then B”, where A and B are simple CGs. Optimizations of the deduction calculus in this KR formalism include a Backward Chaining that unifies at the same time whole subgraphs of a rule, and a Forward Chaining that relies on compiling dependencies between rules. In this paper, we show that the unification used in the first algorithm is exactly the operation required to compute dependencies in the second one. We also combine the benefits of the two approaches, by using the graph of rules dependencies in a Backward Chaining framework.	algorithm;backward chaining;breadth-first search;compiler;conceptual graph;depth-first search;forward chaining;han unification;mathematical optimization;natural deduction;rewriting;semantics (computer science);tree traversal;unification (computer science)	Jean-François Baget;Eric Salvat	2006		10.1007/11787181_8	conceptual graph;knowledge representation and reasoning;backward chaining;conceptualization;forward chaining;computer science;artificial intelligence;theoretical computer science;unification;machine learning;mathematics;inference engine;algorithm	DB	-17.192168038936426	15.125555883965113	155458
04c37d859f50ea68fe687eb21077e7324d2ca6f5	automated theorem proving in a simple meta-logic for lf	automatic proving;logical framework;programming language;complexite calcul;lambda calculus;demostracion automatica;logical programming;higher order;theorem proving;demonstration automatique;demonstration theoreme;theorem prover;complejidad computacion;inductive reasoning;programmation logique;computational complexity;propositional logic;lambda calculo;demostracion teorema;lambda calcul;programacion logica;automated theorem proving;raisonnement inductif	Higher-order representation techniques allow elegant encodings of logics and programming languages in the logical framework LF, but unfortunately they are fundamentally incompatible with induction principles needed to reason about them. In this paper we develop a metalogic M2 which allows inductive reasoning over LF encodings, and describe its implementation in Twelf, a special-purpose automated theorem prover for properties of logics and programming languages. We have used Twelf to automatically prove a number of non-trivial theorems, including type preservation for Mini-ML and the deduction theorem for intuitionistic propositional logic.	automated theorem proving;inductive reasoning;logical framework;mathematical induction;natural deduction;programming language;propositional calculus;subject reduction;twelf	Carsten Schürmann;Frank Pfenning	1998		10.1007/BFb0054266	discrete mathematics;logical framework;computer science;lambda calculus;mathematics;automated theorem proving;programming language;algorithm	PL	-14.723514875699935	16.16515785909216	155508
3090d9c11861962103f75892f1644ca777772a03	indexed systems of sequents and cut-elimination	kripke s a;reflexivity;formalization;cut elimination;reflexivite;transitivite;symetrie;symmetry;modal logic;system;logique modale;indexation;systeme;formalisation;transitivity;normalized cut	Cut reductions are defined for a Kripke-style formulation of modal logic in terms of indexed systems of sequents. A detailed proof of the normalization (cutelimination) theorem is given. The proof is uniform for the propositional modal systems with all combinations of reflexivity, symmetry and transitivity for the accessibility relation. Some new transformations of derivations (compared to standard sequent formulations) are needed, and some additional properties are to be checked. The display formulations [1] of the systems considered can be presented as encodings of Kripke-style formulations.	accessibility relation;modal logic;sequent calculus;vertex-transitive graph	Grigori Mints	1997	J. Philosophical Logic	10.1023/A:1017948105274	modal logic;discrete mathematics;reflexivity;philosophy;epistemology;system;mathematics;symmetry;transitive relation;algorithm	Logic	-12.429169806023454	13.166654118849502	155612
047346428fed2dda76db0214202fe612d0f41b51	a query language based on the ambient logic	arbre graphe;query language;representacion conocimientos;tree graph;semantica formal;distributed computing;semantics;formal semantics;semantica;semantique;lenguaje interrogacion;semantique formelle;modal logic;logique ordre 1;logique modale;logica modal;calculo repartido;langage interrogation;knowledge representation;arbol grafo;representation connaissances;calcul reparti;first order logic;logica orden 1	The ambient logic is a modal logic proposed to describe the structural and computational properties of distributed and mobile com putation The structural part of the ambient logic is essentially a logic of labeled trees hence it turns out to be a good foundation for query languages for semistructured data much in the same way as rst order logic is a tting foundation for relational query languages We de ne here a query language for semistructured data that is based on the ambient logic and we outline an execution model for this language The language turns out to be quite expressive Its strong foundations and the equiva lences that hold in the ambient logic are helpful in the de nition of the language semantics and execution model	microsoft research;modal logic;pattern language;prototype;query language;recursion;relational database;semiconductor industry;web server;xml;μ-recursive function	Luca Cardelli;Giorgio Ghelli	2001		10.1007/3-540-45309-1_1	modal logic;dynamic logic;zeroth-order logic;natural language processing;linear temporal logic;description logic;higher-order logic;computer science;artificial intelligence;theoretical computer science;bunched logic;predicate functor logic;formal semantics;first-order logic;computational logic;database;mathematics;semantics;signature;ontology language;programming language;multimodal logic;tree;algorithm;query language;autoepistemic logic	PL	-15.961149124380409	14.141973730443006	156096
af42eea25ff3c5248fc484fcdd42a4ca272a71f3	bisimulation is not finitely (first order) equationally axiomatisable	finite automata lambda calculus inference mechanisms;logic;lambda calculus;bisimulation;inference mechanisms;higher order;first order;calculus;typed lambda calculus bisimulation finite equational axiomatisations finite state processes;finite automata;writing;humans;finite equational axiomatisations;computer science;equations calculus computer science humans reactive power logic writing;typed lambda calculus;finite state processes;reactive power	This paper considers the existence of nite equational axiomatisations of bisimulation over a calculus of nite state processes. To express even simple properties such as XE = XE[E=X] equationally it is necessary to use some notation for substitutions. Accordingly the calculus is embedded in a simply typed lambda calculus, allowing axioms such as the above to be written as equations of higher type rather than as equation schemes. Notions of higher order transition system and bisimulation are then de ned and using them the nonexistence of nite axiomatisations containing at most rst order variables is shown. The same technique is then applied to calculi of star expressions containing a zero process | in contrast to the positive result given in [FZ93] for BPA ? , which di ers only in that it does not contain a zero.	bisimulation;embedded system;oracle bpa suite;regular expression;simply typed lambda calculus;transition system	Peter Sewell	1994		10.1109/LICS.1994.316086	typed lambda calculus;discrete mathematics;computer science;bisimulation;lambda calculus;mathematics;programming language;writing;logic;algorithm;algebra	Logic	-11.842709086462177	17.847505322566107	156173
8b66eca60d860cf8c8fb8539445ab42bc7eb414f	how to win a game with features	game theory;theorie jeu;programming theory;logic programming;programmation logique;langage programmation logique;kunstliche intelligenz;theorie programmation;logic programming languages	We show, that the axiomatization of rational trees in the language of features given elsewhere is complete. In contrast to other completeness proofs that have been given in this eld, we employ the method of Ehrenfeucht-Fra ss e Games, which yields a much simpler proof. The result extends previous results on complete axiomatizations of rational trees in the language of constructor equations or in a weaker feature language.	axiomatic system	Rolf Backofen;Ralf Treinen	1998	Inf. Comput.	10.1006/inco.1997.2691	game theory;computer science;artificial intelligence;mathematics;programming language;logic programming;algorithm;algebra	Theory	-13.056715230203027	15.60530764273473	156368
9926cc8c357b839edd5d38cd8a6b4d096ceb0b61	a linear space decision procedure for gödel propositional logic	electronic mail;complexity theory;encoding complexity theory semantics fuzzy logic calculus computer science electronic mail;deterministic space complexity linear space decision procedure godel propositional logic t norm based fuzzy logics intuitionistic propositional logic prelinearity axiom scheme tableaux calculus decision procedure theoremhood problem;semantics;fuzzy logic computational complexity decision making;fuzzy logic;calculus;computer science;encoding	Gödel propositional logic is one of the major t-norm based fuzzy logics. Axiomatically, Gödel propositional logic G arises by extending intuitionistic propositional logic with the prelinearity axiom scheme (φ → ψ) V (ψ → φ). In [9], Fiorino introduces a tableaux calculus yielding a decision procedure for the theoremhood problem of G that has space complexity O(n log n), where n is the length of the input formula. In this paper we provide a decision procedure that has deterministic space complexity O(n).	boolean algebra;boolean satisfiability problem;challenge-handshake authentication protocol;co-np;co-np-complete;dpll algorithm;dspace;database normalization;decision problem;directed acyclic graph;directed graph;fuzzy logic;gödel;iteration;logical connective;np-completeness;propositional calculus;sequent calculus;t-norm fuzzy logics;time complexity;verification and validation;well-formed formula;whole earth 'lectronic link	Stefano Aguzzoli	2016	2016 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE)	10.1109/FUZZ-IEEE.2016.7737687	fuzzy logic;dynamic logic;monoidal t-norm logic;zeroth-order logic;complete theory;t-norm fuzzy logics;modal μ-calculus;discrete mathematics;classical logic;resolution;description logic;higher-order logic;many-valued logic;intuitionistic logic;computer science;intermediate logic;first-order logic;mathematics;semantics;propositional variable;well-formed formula;second-order logic;algorithm;encoding;autoepistemic logic;satisfiability	Logic	-13.19748803712909	13.677319649137427	156539
0648350e45881cd9a5aca7d6ac42cc27bcbcad9c	translating combinatory reduction systems into the rewriting calculus	rewrite rule;lambda calculus;combinatory reduction systems;calcul de reecriture;higher order;rewriting calculus;first order;rewrite systems;term rewriting;lambda calcul	The last few years have seen the development of the rewriting calculus (or rhocalculus, ρCal) that extends first order term rewriting and λ-calculus. The integration of these two latter formalisms has been already handled either by enriching first-order rewriting with higher-order capabilities, like in the Combinatory Reduction Systems, or by adding to λ-calculus algebraic features. The different higher-order rewriting systems and the rewriting calculus share similar concepts and have similar applications, and thus, it seems natural to compare these formalisms. We analyze in this paper the relationship between the Rewriting Calculus and the Combinatory Reduction Systems and we present a translation of CRS-terms and rewrite rules into rho-terms and we show that for any CRS-reduction we have a corresponding rho-reduction.	first-order predicate;lambda calculus;linear algebra;rewrite (programming);rewriting;rho calculus	Clara Bertolissi;Horatiu Cirstea;Claude Kirchner	2003	Electr. Notes Theor. Comput. Sci.	10.1016/S1571-0661(04)80674-1	discrete mathematics;higher-order logic;computer science;lambda calculus;first-order logic;mathematics;semi-thue system;programming language;confluence;algorithm	Logic	-13.681584967633071	16.707131029364227	157219
bec3d68f3eab3261be91c89e4705f4daf11447ae	a category-theoretic treatment of automated theorem proving	automated theorem proving;theorem proving;inference rule;category theory	In this paper we apply category theory to investigate the mathematical structure of theorem proving derivations. A theorem-proving strategy is given by a set of inference rules and a search plan. Search plans have been usually described either informally (e.g., a criterion to select the next inference step) or procedurally (e.g., by giving a specific algorithm). Since both the completeness and efficiency of a theorem-proving strategy depend on the search plan, a formal, abstract treatment appears desirable. We propose an approach in this direction, that allows in particular for a precise definition of how the inference rules and the search plan cooperate to generate the derivations. Theorem-proving derivations are characterized by three essential properties: soundness, relevance and proof reduction. We show that they are functoriality properties: these results clarify which parts of the structure of a theory a theorem-proving derivation is required to preserve. We close the paper with a comparison with related work and a discussion on further extensions of our approach.	algorithm;automated theorem proving;category theory;essence;mathematical structure;reduction (complexity);relevance;soundness (interactive proof)	Maria Paola Bonacina;Jieh Hsiang	1996	J. Inf. Sci. Eng.		fixed-point theorem;proofs of fermat's little theorem;discrete mathematics;combinatorics;proof complexity;category theory;compactness theorem;automated proof checking;fundamental theorem;automated theorem proving;mathematics	AI	-17.704114507163965	16.601539237856056	157616
0aeff0eac7f2ff866551de83fb67d8279d5c439c	modelling satisfiability problems: theory and practice		Boolean Satisfiability (SAT) solvers are a mature technology to solve hard combinatorial problems. The input to a SAT solver is the problem translated to propositional logic in conjunctive normal form (CNF). This thesis studies such translations and aims to make SAT solvers more accessible to non-encoding experts.	boolean satisfiability problem;conjunctive normal form;propositional calculus;solver	Valentin Mayer-Eichberger	2016				AI	-18.203626964972106	15.079169509418605	158019
397b03f58f42c7c07e0795d5f66f9d1f890381f6	introduction to the obdd algorithm for the atp community	canonical form;automated reasoning;ordered binary decision diagram;computer security;computational logic;indexation;automatic theorem proving	We describe in terms familiar to the automated reasoning community the graph-based algorithm for deciding propositional equivalence published by R. E. Bryant in 1986. Such algorithms, based onordered binary decision diagrams orOBDDs, are among the fastest known ways to decide whether two propositional expressions are equivalent and are generally hundreds or thousands of times faster on such problems than most automatic theorem-proving systems. An OBDD is a normalized IF (‘if-then-else’) expression in which the tests down any branch are ascending in some previously chosen fixed order. Such IF expressions represent a canonical form for propositional expressions. Three coding tricks make it extremely efficient to manipulate canonical IF expressions. The first is that two canonicalized expressions can be rapidly combined to form the canonicalized form of their disjunction (conjunction, exclusive-or, etc.) by exploiting the fact that the tests are ordered. The second is that every distinct canonical IF expression should be assigned a unique integer index to enable fast recognition of identical forms. The third trick is that the operation in which one combines canonicalized subterms term should be ‘memo-ized’ or cached so that if the same operation is required in the future its result can be looked up rather than recomputed.	algorithm;automated reasoning;automated theorem proving;binary decision diagram;exclusive or;fastest;turing completeness	J. Strother Moore	1994	Journal of Automated Reasoning	10.1007/BF00881842	canonical form;discrete mathematics;computer science;artificial intelligence;theoretical computer science;computational logic;mathematics;automated reasoning;programming language;algorithm	AI	-17.64280209021022	16.084070716341188	158081
e8fc12746b09780ed3c26ff4856a29b9cd02be72	using symbolic descriptions to explain similarity on cbr	case base reasoning;anti unification;case based reasoning;symbolic similarity	The explanation of the results is a key point of automatic problem solvers. CBR systems solve a new problem by assessing its similarity with already solved cases and they commonly show the user the set of cases that have been assessed as the most similar to the new problem. Using the notion of symbolic similarity, our proposal is to show the user a symbolic description that makes explicit what the new problem has in common with the retrieved cases. In particular, we use the notion of anti-unification to build this symbolic description.	actor-based concurrent language;approximation;case-based reasoning;intensional logic;lazy evaluation;lazy learning;unification (computer science)	Eva Armengol;Enric Plaza	2005			discrete mathematics;theoretical computer science;mathematics;symbolic data analysis;symbolic trajectory evaluation;algorithm	Logic	-16.994262689020335	11.868400783263867	158899
c6851aeb61b3e701943930a328f7f3914461cc23	a soft stairway to institutions	algebraic specification;equational logic	Abs t rac t . The notion of institution is dissected into somewhat weaker notions. We introduce a novel notion of institution morphism, and characterize preservation of institution properties by corresponding properties of such morphisms. Target of this work is the stepwise construction of a general framework for translating logics, and algebraic specifications using logical systems. Earlier translations of order-sorted conditional equational logic and of conditional equational logics for partial algebras into equational type logic axe revisited in this light. Model-theoretic results relating to compactness axe presented as well.	linear algebra;stepwise regression;theory	Antonino Salibra;Giuseppe Scollo	1991		10.1007/3-540-56379-2_47	discrete mathematics;equational logic;mathematics;algorithm	Logic	-13.05199744463404	14.9577120662289	160728
ca9ba111eb6394de6685ec215a1a2b4419871cf1	first order meta theories	first order			Alan Hutchinson	1997	Logic Journal of the IGPL	10.1093/jigpal/5.1.97	computer science;first-order logic;programming language	Vision	-14.433544803968747	13.167902053376089	161343
42ee2f9828611e8d5a7721cf42ff82b666b667de	extensions of constraint solving for proof planning	theorem proving;consistency checking;constraint solving;generating function;off the shelf;problem solving	The integration of constraint solvers into proof planning has pushed the problem solving horizon. Proof planning benefits from the general functionalities of a constraint solver such as consistency check, constraint inference, as well as the search for instantiations. However, off-the-shelf constraint solvers need to be extended in order to be be integrated appropriately: In particular, for correctness, the context of constraints and Eigenvariable-conditions have to be taken into account. Moreover, symbolic and numeric constraint inference are combined. This paper discusses the extensions to constraint solving for proof planning, namely the combination of symbolic and numeric inference, first-class constraints, and context trees. We also describe the implementation of these extensions in the constraint solver CoSIE .	automated theorem proving;cal;constraint inference;constraint logic programming;constraint programming;constraint satisfaction problem;correctness (computer science);level of detail;logical framework;norm (social);numerical analysis;problem solving;programming language;requirement;solver;symbolic-numeric computation	Erica Melis;Jürgen Zimmer;Tobias Müller	2000			constraint logic programming;concurrent constraint logic programming;mathematical optimization;constraint programming;generating function;binary constraint;constraint satisfaction;constraint learning;computer science;constraint graph;constraint satisfaction dual problem;complexity of constraint satisfaction;automated theorem proving;constraint;constraint satisfaction problem;hybrid algorithm;local consistency	AI	-18.498033141751005	14.238404540291928	162158
2a21adcb761e934c3a74a76bafe4b6b741300b22	animated fuzzy logic	key concept;fuzzy logic;animated fuzzy logic;functional language;fuzzy subset;first-class value;declarative nature;language haskell	In this paper we aim to give an introduction to fuzzy logic using the language Haskell to implement our solutions. We shall see how the high-level, declarative nature of a functional language allows us to implement easily and eeciently solutions to problems using fuzzy logic and, in particular, how the presence of functions as rst-class values allows us to model the key concept of the fuzzy subset in a natural way.	functional programming;fuzzy logic;fuzzy set;haskell;high- and low-level	Gary Meehan;Mike Joy	1998	J. Funct. Program.		fuzzy logic;combs method;fuzzy electronics;description logic;fuzzy cognitive map;computer science;theoretical computer science;neuro-fuzzy;computational logic;fuzzy associative matrix;programming language;fuzzy set operations;multimodal logic;fuzzy control language;algorithm;fuzzy control system	PL	-16.430403996291908	12.127378167802469	162596
7bef9374edf67ef7926aebeab5821c668845ab02	singleton, union and intersection types for program extraction	extraction programme;lenguaje programacion;type;theorie type;tipo;programming language;lambda calculus;interseccion;extraccion;informatique theorique;langage programmation;lambda calculo;union;intersection;lambda calcul;intersection types;extraction;singleton;computer theory;informatica teorica	Two types theories, ATT and ATTT, are introduced. ATT is an impredicative type theory closely related to the polymorphic type theory of implicit typing of MacQueen et al. ((1986), Inform. and Control 71, 95-130). ATTT is another version of ATT that extends the Girard-Reynolds second order lambda calculus. ATT has notions of intersection, union, and singleton types. ATTT has a notion of refinement types as in the type system for ML by Freeman and Pfenning ((1991), in «ACM SIGPLAN '91», ACM Press), plus intersection and union of refinement types and singleton refinement types. We will show how singleton, union, and intersection types serve for development of programs without unnecessary codes via a variant of the Curry-Howard isomorphism. More exactly, they give a way to write types as specifications of programs without the unnecessary codes which are inevitable in the usual Curry-Howard isomorphism		Susumu Hayashi	1994	Inf. Comput.	10.1006/inco.1994.1016	extraction;computer science;pure mathematics;intersection;lambda calculus;mathematics;programming language;type;singleton;algorithm;algebra	Logic	-12.638538871005439	17.927716615279802	162640
4ccbcee41bd287c028a467df4c601fc665cb52ca	real number calculations and theorem proving	theorem proving;algebraic setting;formal proof;real number;explicit calculation;pragmatic approach;ordinary real number expression;rational interval arithmetic;lower bound;proof assistant;real number calculation	Wouldn’t it be nice to be able to conveniently use ordinary real number expressions within proof assistants? In this paper we outline how this can be done within a theorem proving framework. First, we formally establish upper and lower bounds for trigonometric and transcendental functions. Then, based on these bounds, we develop a rational interval arithmetic where real number calculations can be performed in an algebraic setting. This pragmatic approach has been implemented as a strategy in PVS. The strategy provides a safe way to perform explicit calculations over real numbers in formal proofs.	automated theorem proving;formal proof;interval arithmetic;proof assistant;prototype verification system	César A. Muñoz;David R. Lester	2005		10.1007/11541868_13	discrete mathematics;computer science;artificial intelligence;mathematics;upper and lower bounds;programming language;algorithm;pragmatics	Logic	-18.168104342364344	18.14550539027652	163115
24da0b7b29f59d36b8edfb472b06bc806450a1c5	propositional attitudes: fregean representation and simulative reasoning				Lewis G. Creary	1979				AI	-13.326321224044145	11.235062167109996	163988
1c91046aa78773d147a1a7e7ab2aaf6f28dbcea8	a divergence critic for inductive proof	artificial intelligent;theorem prover	"""Inductive theorem provers often diverge. This paper describes a simple critic, a computer program which monitors the construction of inductive proofs attempting to identify diverging proof attempts. Divergence is recognized by means of a \di erence matching"""" procedure. The critic then proposes lemmas and generalizations which \ripple"""" these differences away so that the proof can go through without divergence. The critic enables the theorem prover Spike to prove many theorems completely automatically from the de nitions alone."""	automated theorem proving;computer program;inductive reasoning;mathematical induction	Toby Walsh	1996	J. Artif. Intell. Res.	10.1613/jair.275	discrete mathematics;computer-assisted proof;computer science;artificial intelligence;machine learning;mathematics;automated theorem proving;algorithm	ML	-17.887449794781997	17.064496710018194	164387
10b8635a388e7a9653ecbe3497d5e55d384f9b0f	verification system for partial correctness of communicating sequential processes	communicating sequential process	The communication sequential processes (CSP) system proposed by Hoare is a model for parallel computation which has no shared variables and performs information exchange and synchronization among processes by means of communication commands. In this paper we first consider a set of states for the given CSP program. Using a binary relation on the set, we introduce a semantics representing only the input-output relations of the CSP program. Based on this semantics, we propose an axiom system which serves to verify the partial correctness of CSP. We prove the soundness of this axiom system. The axiom system proposed in this paper differs from the previously proposed systems in the following aspects. In our system, the inferences proceed simultaneously over all processes. On the other hand, conventional methods adopt a procedure wherein a given property is first proved independently for each process and it is then shown that a certain condition holds among the processes. Our method of proof is a more direct representation of the actual execution of process.	axiomatic system;communicating sequential processes;computation;correctness (computer science);hoare logic;information exchange;shared variables;soundness (interactive proof)	Masaki Murakami;Yasuyoshi Inagaki	1986	Systems and Computers in Japan	10.1002/scj.4690171102	discrete mathematics;computer science;theoretical computer science;algorithm	AI	-16.770117979156133	13.70446016924533	165267
e01d2356e86e4e3b24c29444564b6c7782a7c180	equational logic: a great pedagogical tool for teaching a skill in logic	equational logic	Without Abstract		David Gries	1995		10.1007/3-540-60271-2_141	dynamic logic;zeroth-order logic;discrete mathematics;description logic;higher-order logic;horn clause;bunched logic;predicate functor logic;computational logic;mathematics;multimodal logic;algorithm;philosophy of logic;autoepistemic logic	Logic	-14.310989436790049	12.446599935488223	166457
a1cd37d24b2a41d2859325f48beac06ef64cb871	linear lambda calculus with non-linear first-class continuations	continuations;lambda calculus;linear logic;functional programming language;programming language theory	The Curry-Howard isomorphism is the correspondence between propositions and types, proofs and lambda-terms, and proof normalization and evaluation. In Curry-Howard isomorphism, we find a duality between values and continuations in pure functional languages with respect to logical negation. My previous paper and other researchers' studies reveal that we can obtain a first-class continuation mechanism by providing duplicability and removability of continuations, which is equivalent to the right-contraction and weakening rules in Gentzen's deductive system, the sequent calculus. In the lambda calculus, it is allowed to duplicate and remove values, but the continuations are impossible to duplicate and remove. In our previous paper, we showed that we can obtain the lambda calculus with first-class continuations providing duplicability and removability of both values and continuations. In this paper, we will study a calculus in which we only have duplicability and removability of continuations. We formalize this calculus in the framework of linear logic, which is a logical system sensitive to duplicability and removability, proposed by Jean-Yves Girard.	continuation;curry;curry–howard correspondence;formal system;functional programming;jean;lambda calculus;linear logic;nonlinear system;sequent calculus	Shin-ya Nishizaki	2017		10.1145/3056662.3056693	typed lambda calculus;discrete mathematics;binary lambda calculus;mathematics;natural deduction;algorithm	PL	-12.477669986668689	16.364673667287587	166641
618cf514707eda18bc5392fb07f5fe7ccb7ab7ae	a dialectic procedure for sceptical, assumption-based argumentation	tools for argumentation;argumentation frameworks;well founded semantics;logic programs	We present a procedure for computing the sceptical “ideal semantics” for argumentation in assumption-based frameworks. This semantics was first proposed for logic programming in [1], extending the well-founded semantics. The proof procedure is defined by means of a form of dispute derivations, obtained by modifying the dispute derivations given in [2] for computing credulous admissible argumentation. The new dispute derivations are sound for the “ideal semantics” in all cases where the dispute derivations of [2] are complete for admissible argumentation. We prove that this is the case for the special kind of assumption-based frameworks with a finite underlying language and with the property of being “p-acyclic”.	academy;argumentation framework;coherence (physics);directed acyclic graph;logic programming;qp state machine frameworks;well-founded semantics;whole earth 'lectronic link	Phan Minh Dung;Paolo Mancarella;Francesca Toni	2006			algorithm	AI	-13.97650026277083	13.288674149941908	166699
090330eaa66391011f085c7c301d090723ddf353	circumscribing datalog: expressive power and complexity	expressive power	In this paper we study a generalization of DATALOG, the language of function-free definite clauses. It is known that standard DATALOG semantics (i.e., least Herbrand model semantics) can be obtained by regarding programs as theories to be circumscribed with all predicates to be minimized. The extension proposed here, called DATALOG~!~~, consists in considering the general form of circumscription, where some predicates are minimized, some predicates are fixed, and some vary. We study the complexity and the expressive power of the language thus obtained. We show that this language (and, actually, its non-recursive fragment) is capable of expressing all the queries in DB-co-m and, as such, is much more powerful than standard DATALOG, whose expressive power is limited to a strict subset of PTIME queries. Both data and combined complexities of answering DATALOGCIRC queries are studied. Data complexity is proved to be co-NP-complete. Combined complexity is shown to be in general hard for co-NE and complete for co-NE in the case of Herbrand bases containing k distinct constant symbols, where k is bounded.	circumscription (logic);co-np;co-np-complete;complexity;datalog;expressive power (computer science);np-completeness;p (complexity);recursion;theory	Marco Cadoli;Luigi Palopoli	1998	Theor. Comput. Sci.	10.1016/S0304-3975(97)00108-4	discrete mathematics;computer science;mathematics;datalog;programming language;expressive power;algorithm	DB	-17.118953984556686	12.442450695863016	167295
985a2f8393eadf56622440016dd6f5e71d2d5922	resource-sensitive reasoning with sequential information	cut elimination;indexation;password authentication;linear logic	A logic called sequence-indexed linear logic (SLL) is proposed to appropriately formalize resource-sensitive reasoning with sequential information. The completeness and cut-elimination theorems for SLL are shown, and SLL and a fragment of SLL are shown to be undecidable and decidable, respectively. As an application of SLL, some specifications of secure password authentication systems are discussed.	linear logic;norm (social);secure password authentication;undecidable problem	Norihiro Kamide;Ken Kaneiwa	2010		10.1007/978-3-642-17432-2_3	linear logic;discrete mathematics;computer science;theoretical computer science;password authentication protocol;mathematics;algorithm	AI	-12.707274271587616	14.910755437679542	167547
82d5cb184e4bff8d95b14c6627c51a547a66f072	a hybrid tableau algorithm for alcq	description logic	We propose an approach for extending a tableau-based satisfiability algorithm by an arithmetic component. The result is a hybrid satisfiability algorithm for the Description Logic (DL) ALCQ which extends ALC with qualified number restrictions. The hybrid approach ensures a more informed calculus which, on the one hand, adequately handles the interaction between numerical and logical restrictions of descriptions, and on the other hand, when applied is a very promising framework for average case optimizations.	algorithm;best, worst and average case;boolean satisfiability problem;description logic;method of analytic tableaux;numerical analysis	Jocelyne Faddoul;Nasim Farsiniamarj;Volker Haarslev;Ralf Möller	2008			algorithm	AI	-17.843143806796242	13.832234797757492	168329
c368653ec6f2ff8ceffc32ca75eeb3746cdd8e3b	cylindrical decomposition under application-oriented paradigms		Quantifier elimination (QE) is a powerful tool for problem solving. Once a problem is expressed as a formula, such a method converts it to a simpler, quantifier-free equivalent, thus solving the problem. Particularly many problems live in the domain of real numbers, which makes real QE very interesting. Among the so far implemented methods, QE by cylindrical algebraic decomposition (CAD) is the most important complete method. The aim of this thesis is to develop CAD-based algorithms, which can solve more problems in practice and/or provide more interesting information as output. An algorithm that satisfies these standards would concentrate on generic cases and postpone special and degenerated ones to be treated separately or to be abandoned completely. It would give a solution, which is locally correct for a region the user is interested in. It would give answers, which can provide much valuable information in particular for decision problems. It would combine these methods with more specialized ones, for subcases that allow for. It would exploit degrees of freedom in the algorithms by deciding to proceed in a way that promises to be efficient. It is the focus of this dissertation to treat these challenges. Algorithms described here are implemented in the computer logic system REDLOG and ship with the computer algebra system REDUCE.	algorithm;computer algebra system;computer-aided design;decision problem;exploit (computer security);problem solving;quantifier (logic);query expansion;reduce	Andreas Seidl	2006			computational physics;cylinder;mathematics	AI	-18.532715592936206	17.002391423288966	168605
5945fed3e468f9b77209f500c8112adfbe6238b3	a calculus for higher order procedures with global variables	higher order	An arithmetically complete axiom system for full Algol-like higher order procedures with mode depth one is presented. To show soundness, a translation of the calculus into a variant of Dynamic Logic is deened. The completeness proof is outlined.	algol;axiomatic system;dynamic logic (modal logic)	Werner Stephan;Andreas Wolpers	1993		10.1007/3-540-57182-5_62	higher-order logic;computer science;mathematics;programming language	Theory	-13.311397447196237	16.50353934348114	169033
78205d4750ee3beff4566454e0f16fe76d0c0904	logic as calculus versus logic as language, language as calculus versus language as universal medium, and syntax versus semantics		This paper discusses the distinctions indicated in its title. It is argued that the distinction between syntax and semantics is much more important for the present situation in logic than other distinctions. In particular, doing formal syntax and formal semantics requires the use of an informal melanguage based on ordinary mathematics. Mathematics Subject Classification. 03A5.	formal grammar;mathematics subject classification;semantics (computer science)	Jan Wolenski	2012	Logica Universalis	10.1007/s11787-012-0059-4	natural language processing;abstract syntax;classical logic;description logic;higher-order logic;formal semantics;object language;syntax;communicating sequential processes;formal semantics;mathematics;semantics;proof calculus;linguistics;signature;operational semantics;algorithm;philosophy of logic;syntax error	Logic	-11.848494904661338	14.734901741992633	169216
13c04dd7ec4bbf3ae0f8cec34494c800f51d7367	functional data term models and semantic unification	programming language;functional programming;functional data;knowledge representation	A unified language which combines logic and functional programming is a good candidate for a basic programming language for the knowledge representation. A new semantic of such a language is presented. The interpretation is based on functional data term models. The universe of such a model is a set of data terms defined by constructor symbols. The symbols of defined functions are interpreted as partial functions on data terms. The chosen axioms for the equality do not contain the reflexivity axiom. Terms can only be equal if the terms are defined terms. A new unification algorithm for the presented semantic is given and the completeness of it is proved.	han unification	Hans-Joachim Goltz	1988		10.1007/3-540-50667-5_68	natural language processing;declarative programming;language primitive;programming domain;computer science;theoretical computer science;functional logic programming;programming paradigm;procedural programming;symbolic programming;inductive programming;fifth-generation programming language;programming language theory;programming language;purely functional	NLP	-17.343628216461582	12.15825341956901	169382
eb3aef745bf9365b81eecbc321dab27adaf31654	a foundation for region-based qualitative geometry		We present a highly expressive logical language for describing qualitative configurations of spatial regions, based on Tarski’s Geometry of Solids , in which theparthoodrelation and the concept ofsphereare taken as primitive. We give a categorical axiom system, whose models can be interpreted classically in t erms of Cartesian spaces over R.We show that within this system the concept of sphere and thecongruencerelation are interdefinable. We investigate the 2nd-order character of the theory and prove incompl eteness of some weaker 1st-order variants.	automated reasoning;axiomatic system;cartesian closed category;embedded system;entity;logical framework;semantics (computer science)	Brandon Bennett;Anthony G. Cohn;Paolo Torrini;Shyamanta M. Hazarika	2000			cartesian coordinate system;computer science;axiom;categorical variable;geometry;congruence relation	AI	-14.493289813032803	11.77723100889184	170465
21d286d602d5813e3c419d0ba51be3291ad57f22	downward löwenheim-skolem theorem and interpolation in logics with constructors		The present paper describes a method for proving Downward Löwenheim-Skolem Theorem within an arbitrary institution satisfying certain logic properties. In order to demonstrate the applicability of the present approach, the abstract results are instantiated to many-sorted first-order logic and preorder algebra. In addition to the first technique for proving Downward Löwenheim-Skolem Theorem, another one is developed, in the spirit of institution-independent model theory, which consists of borrowing the result from a simpler institution across an institution comorphism. As a result the Downward LöwenheimSkolem Property is exported from first-order logic to partial algebras, and from higher-order logic with intensional Henkin semantics to higher-order logic with extensional Henkin semantics. The second method successfully extends the domain of application of Downward Löwenheim-Skolem Theorem to other non-conventional logical systems for which the first technique may fail. One major application of Downward Löwenheim-Skolem Theorem is interpolation in constructor-based logics with universally quantified sentences. The interpolation property is established by borrowing it from a base institution for its constructor-based variant across an institution morphism. This result is important as interpolation for constructor-based first-order logics is still an open problem.	atomic formula;bell's theorem;constructor (object-oriented programming);first-order logic;first-order predicate;first-order reduction;intensional logic;interpolation;kinetic data structure;method (computer programming);quantifier (logic);theory;type signature;universal quantification;well-formed formula	Daniel Gâinâ	2017	J. Log. Comput.	10.1093/logcom/exv018	mathematical analysis;discrete mathematics;topology	Logic	-12.298108020520893	15.986228374015804	170684
1b5b80a87610f1d32dac4b9d40a7542ccccb76e7	temporal logic and recursion	temporal logic		recursion;temporal logic	Fred Kröger;Stephan Merz	1991	Fundam. Inform.		dynamic logic;linear temporal logic;temporal logic;interval temporal logic;computation tree logic;computer science;substructural logic;multimodal logic;temporal logic of actions	AI	-14.40243458465949	13.844364834976624	170750
035da124520c9580d919c6dd4e9db1f21563f71a	sequents, frames, and completeness	complejidad programa;logique propositionnelle;logical programming;specification programme;programmation logique;propositional logic;informatique theorique;program complexity;logica proposicional;program specification;programacion logica;especificacion programa;disjunctive logic programming;complexite programme;computer theory;informatica teorica	Entailment relations, originated from Scott, have been used for describing mathematical concepts constructively and for representing categories of domains. This paper gives an analysis of the freely generated frames from entailment relations. This way, we obtain completeness results under the unifying principle of the spatiality of coherence logic. In particular, the domain of disjunctive states, derived from the hyperreso-lution rule as used in disjunctive logic programs, can be seen as the frame freely generated from the opposite of a sequent structure. At the categorical level, we present equivalences among the categories of sequent structures, distributive lattices, and spectral locales using appropriate morphisms.	disjunctive normal form	Thierry Coquand;Guo-Qiang Zhang	2000		10.1007/3-540-44622-2_18	discrete mathematics;computer science;mathematics;propositional calculus;algorithm	Logic	-13.363827772620311	15.684735869312743	171005
1fe65e5b5eba08570c96a222cd989d79a4694676	quantifier elimination over algebraically closed fields in a proof assistant using a computer algebra system	proof assistant;quantifier elimination;coq;computer algebra system;theorem proving;algebraically closed fields;decision procedure;maple;computer algebra	We propose a decision procedure for algebraically closed fields based on a quantifier elimination method. The procedure is intended to build proofs for systems of polynomial equations and inequations. We describe how this procedure can be carried out in a proof assistant using a Computer Algebra system in a purely skeptical way. We present an implementation in the particular framework of Coq and Maple giving some details regarding the interface between the two tools. This allows us to show that a Computer Algebra system can be used not only to bring additional computational power to a proof assistant but also to enhance the automation of such tools.	algebraic equation;computer algebra system;coq (software);decision problem;maple;proof assistant;quantifier (logic);system of polynomial equations	David Delahaye;Micaela Mayero	2006	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2005.11.023	discrete mathematics;quantifier elimination;symbolic computation;elimination theory;computer science;theoretical computer science;mathematics;automated theorem proving;proof assistant;programming language;algorithm	Logic	-18.159591236619605	18.19681636793095	171012
b02a5362a3e6de37329778e5e281f4173cbdc47d	specification of abstract dynamic-data types: a temporal logic approach	temporal logic;dynamic data;first order logic	Abstract   A concrete dynamic-data type is just a partial algebra with predicates such that for some of the sorts there is a special predicate defining a transition relation.  An abstract dynamic-data type (ad-dt) is an isomorphism class of such algebras. To obtain specifications for ad-dt's, we propose a logic which combines many-sorted first-order logic with branching-time combinators.  We consider both an initial and a loose semantics for our specifications and give sufficient conditions for the existence of the initial models. Then we discuss structured specifications and implementation.	temporal logic	Gerardo Costa;Gianna Reggio	1997	Theor. Comput. Sci.	10.1016/S0304-3975(96)00165-X	predicate logic;dynamic logic;zeroth-order logic;discrete mathematics;linear temporal logic;description logic;dynamic data;higher-order logic;temporal logic;interval temporal logic;computation tree logic;computer science;intermediate logic;theoretical computer science;bunched logic;predicate functor logic;first-order logic;mathematics;predicate variable;signature;programming language;substructural logic;multimodal logic;algorithm;temporal logic of actions	Logic	-15.492148967596023	17.25322391567803	171035
bda0b3d20798c585446850eb82fd243914514330	"""a """"game semantical"""" intuitionistic realizability validating markov's principle"""	004;markov s principle intuitionistic realizability heyting arithmetic game semantics	We propose a very simple modification of Kreisel’s modified realizability in order to computationally realize Markov’s Principle in the context of Heyting Arithmetic. Intuitively, realizers correspond to arbitrary strategies in Hintikka-Tarski games, while in Kreisel’s realizability they can only represent winning strategies. Our definition, however, does not employ directly game semantical concepts and remains in the style of functional interpretations. As term calculus, we employ a purely functional language, which is Gödel’s System T enriched with some syntactic sugar.	gödel;markov chain;purely functional programming	Federico Aschieri;Margherita Zorzi	2013		10.4230/LIPIcs.TYPES.2013.24	computer science	Logic	-12.446112071344283	15.230312436798814	171729
1890e01bc18758038028039205f467f75c83af1a	building constraint satisfaction problem solvers using rewrite rules and strategies	rewritinglogic;rewrite rule;computational systems;constraint satisfaction problems;rewriting logic;constraint satisfaction problem	In this paper, we formalize Constraint Satisfaction Problem manipulation using a rule-based approach. Based on the notion of Computational Systems, we associate basic transformations carried out by traditional constraint solving algorithms with rewrite rules, and heuristics with strategies establishing the order of application of the inferences. In this way, a constraint solver can be viewed as a computational system aimed to transform a set of constraints in a particular solved form. The distinction made between deduction rules and strategies, allows to describe constraint handling in a very abstract way, prototype new heuristics almost by modifying only the choice of rules, prove termination in an easier way, and combine constraint solving with other computational systems. To validate our approach we have implemented the system COLETTE which is currently executable in ELAN, an environment for prototyping computational systems. We have realized how easy it is to integrate and reuse solvers developed following this approach. We hope that this work leads the way to integrating the knowledge existing in the domains of Automated Deduction and Constraint Solving.	constraint satisfaction problem	Carlos Castro	1998	Fundam. Inform.	10.3233/FI-1998-34303	constraint logic programming;concurrent constraint logic programming;constraint programming;discrete mathematics;binary constraint;decomposition method;constraint satisfaction;constraint learning;computer science;constraint graph;theoretical computer science;constraint satisfaction dual problem;mathematics;complexity of constraint satisfaction;constraint;constraint satisfaction problem;algorithm;hybrid algorithm;local consistency;backtracking	AI	-19.077457611700684	15.63983960757537	171884
18bb9530f4f47efaf4bff969ca05f1cd401029e0	positive negative conditional equations: a constructor-based framework for specification and inductive theorem proving			automated theorem proving	Claus-Peter Wirth	1997				Logic	-13.422379763410422	13.24521231027177	171932
3d184cce71a557296bcb7441429fcc428f89c394	aggregating inductive expertise	agregacion;language theory;teoria lenguaje;recursividad;aggregation;induccion;recursivite;induction;inferencia;agregation;recursivity;lenguaje formal;theorie langage;formal language;inference;langage formel	The aggregation problem is to design an inferential agent that makes intelligent use of the theories offered by a team of inductive inference machines working in a common environment. The present paper formulates several versions of the aggregation problem and investigates them from a recursion theoretic point of view.	inductive reasoning;inferential programming;recursion;theory	Daniel N. Osherson;Michael Stob;Scott Weinstein	1986	Information and Control	10.1016/S0019-9958(86)80025-0	natural language processing;recursion;formal language;computer science;artificial intelligence;philosophy of language;mathematics;programming language;algorithm	AI	-18.433091917533815	11.564891511116725	172486
867ff8d431a4a0e3ec4e74caddca97c235f250a8	a sound and complete reified temporal logic	temporal knowledge representation;predicate logic;temporal logic;hybrid temporal logics;complete axiomatization;temporal information;temporal knowledge representation modal logic tense logics hybrid temporal logics predicate logic temporal argument methods reified temporal logics;reified temporal logic;expressive power;qa75 electronic computers computer science;modal logic;logic functions cognition educational institutions periodic structures lifting equipment computer science terminology;periodic structures;tense logics;cognition;logic functions;terminology;lifting equipment;g400 computing;computer science;completeness;reified temporal logic completeness;reified temporal logics;theoretical foundation;temporal argument methods	There are mainly two known approaches to the representation of temporal information in Computer Science: modal logic approaches (including tense logics and hybrid temporal logics) and predicate logic approaches (including temporal argument methods and reified temporal logics). On one hand, while tense logics, hybrid temporal logics and temporal argument methods enjoy formal theoretical foundations, their expressiveness has been criticised as not power enough for representing general temporal knowledge; on the other hand, although current reified temporal logics provide greater expressive power, most of them lack of complete and sound axiomatic theories. In this paper, we propose a new reified temporal logic with a clear syntax and semantics in terms of a sound and complete axiomatic formalism which retains all the expressive power of the approach of temporal reification.	computer science;modal logic;reification (computer science);semantics (computer science);temporal logic;theory	Guoxing Zhao;Jixin Ma;Fuxing Shen;Miltos Petridis	2008	2008 Ninth ACIS International Conference on Software Engineering, Artificial Intelligence, Networking, and Parallel/Distributed Computing	10.1109/SNPD.2008.16	modal logic;predicate logic;t-norm fuzzy logics;linear temporal logic;cognition;temporal logic;interval temporal logic;computation tree logic;completeness;computer science;artificial intelligence;theoretical computer science;terminology;expressive power;algorithm;temporal logic of actions;lifting equipment	Logic	-15.479836803700938	11.578695184631114	172542
1565c8e882b4500224f5010320a6536b70bcb396	constructive provability logic		We present constructive provability logic, an intuitionstic modal logic that validates the Löb rule of Gödel and Löb’s provability logic by permitting logical reflection over provability. Two distinct variants of this logic, CPL and CPL*, are presented in natural deduction and sequent calculus forms which are then shown to be equivalent. In addition, we discuss the use of constructive provability logic to justify stratified negation in logic programming within an intuitionstic and structural proof theory. All theorems presented in this paper are formalized in the Agda proof assistant. An earlier version of this work was presented at IMLA 2011 [Simmons and Toninho 2011].	accessibility;agda;angular defect;approximation;axiomatic system;blu-ray;cpl;computer science;existential quantification;first-order logic;first-order predicate;frank pfenning;gödel;intuitionistic logic;logic programming;modal logic;modal operator;modality (human–computer interaction);model checking;natural deduction;programming language;proof assistant;provability logic;sequent calculus;surround sound;theory;twelf;x10;λprolog	Robert J. Simmons;Bernardo Toninho	2011	CoRR		predicate logic;dynamic logic;zeroth-order logic;linear logic;discrete mathematics;higher-order logic;logical framework;paraconsistent logic;provability logic;many-valued logic;intuitionistic logic;intermediate logic;mathematics;sequent;logic;substructural logic;multimodal logic;algorithm;rule of inference	Logic	-12.673147985228882	13.443649265575578	173141
63c5209b3d120984934b449245948ece18ae829e	2atas make dls easy		In this paper we demonstrate that two-way alternating automata on infinite trees (2ATAs) provide a very elegant and effective formal tool for addressing reasoning in expressive DLs. Indeed, the encoding of a DL concept (to be checked for satisfiability) into an automaton (to be checked for non-emptiness) is: (i) intuitive, indeed, comparable to tableaux rules; (ii) modular, since each construct is dealt with separately; (iii) short, since the encoding is polynomial; and (iv) computationally adequate, i.e., optimally w.r.t. the complexity class of reasoning. To make these claims concrete, we illustrate the use of 2ATAs to decide satisfiability of three expressive DLs of increasing complexity, namely ALCFIreg , which corresponds to converse-pdl with local functionality, ALCFIbreg , which extends ALCFIreg with boolean combinations of roles, and ALCQIbreg , which further extends ALCFIbreg with qualified number restrictions.	alternating finite automaton;automata theory;boolean satisfiability problem;complexity class;exptime;mathematical optimization;method of analytic tableaux;polynomial;tree automaton	Diego Calvanese;Giuseppe De Giacomo;Maurizio Lenzerini	2002			algorithm;satisfiability;mathematics	Logic	-15.424734622788288	16.56537665539315	173315
3bee34d5e8ba5f18475a39a314cc706cf130abbf	from conventional to institution-independent logic programming		We propose a logic-independent approach to logic programming through which the paradigm as we know it for Horn-clause logic can be explored for other formalisms. Our investigation is based on abstractions of notions such as logic program, clause, query, solution, and computed answer, which we develop over Goguen and Burstall’s theory of institutions. These give rise to a series of concepts that formalize the interplay between the denotational and the operational semantics of logic programming. We examine properties concerning the satisfaction of quantified sentences, discuss a variant of Herbrand’s theorem that is not limited in scope to any particular logical system or construction of logic programs, and describe a general resolution-based procedure for computing solutions to queries. We prove that this procedure is sound; moreover, under additional hypotheses that reflect faithfully properties of actual logic-programming languages, we show that it is also complete.	formal system;horn clause;logic programming;operational semantics;programming language;programming paradigm	Ionut Tutu;José Luiz Fiadeiro	2017	J. Log. Comput.	10.1093/logcom/exv021	concurrent constraint logic programming;constraint programming;declarative programming;logic optimization;horn clause;logic family;reactive programming;functional logic programming;programming paradigm;procedural programming;inductive programming;fifth-generation programming language;prolog;logic programming	PL	-15.9960736840862	18.246137579824442	173355
56abd6e17b897f5bea7a0733241e735881fb5a39	a tableaux-based decision procedure for multi-parameter propositional schemata		Background In (Aravantinos et al. 2011) the ST procedure for STAB (Schemata TABleaux) is provided deciding the satisfiability problem for an expressive class of propositional schemata, the class of regular propositional schemata. In (Aravantinos et al. 2013) a resolution calculus is provided deciding the satisfiability problem for a class of schematic clause sets which can encode regular schemata and to some extent propositional schemata with multiple parameters. In our work, we investigate which subclasses of the class of propositional schemata with multiple parameters can be decided using a slight extension of STAB. Results Our goal is to find subclasses of the class of propositional schemata with multiple parameters which have a decision procedure for satisfiability while avoiding the extra machinery of normalized clause sets, introduced in (Aravantinos et al. 2013), as well as the transformation of propositional schemata into CNF formulae. We provide two classes of propositional schemata extending regular schemata which both have a decision procedure based on the tableaux procedure of (Aravantinos et al. 2011) and allow for restricted use of multiple parameters. Overview First, we will provide a short description of the class of propositional schemata, and in particular, the class of regular schemata. We introduce the class of linked schemata and pure overlap schemata. Finally, we show how the ST procedure (Aravantinos et al. 2011) can be augmented to decide the satisfiability problem for these two classes of schema.	boolean satisfiability problem;conjunctive normal form;decision problem;encode;propositional calculus;schematic	David Cerna	2014		10.1007/978-3-319-08434-3_6	discrete mathematics;mathematics;algorithm	AI	-13.994070514342605	15.519896276629062	173373
15d47ef8a1a70723023b898ea650351fd55b0c01	encoding two-valued nonclassical logics in classical logic	classical logic;two-valued nonclassical logic			Hans Jürgen Ohlbach;Andreas Nonnengart;Maarten de Rijke;Dov M. Gabbay	2001			dynamic logic;monoidal t-norm logic;t-norm fuzzy logics;classical logic;higher-order logic;paraconsistent logic;intuitionistic logic;intermediate logic;łukasiewicz logic;minimal logic;substructural logic;multimodal logic	Logic	-12.731654083522214	12.426868607817998	173522
f450151c6226d60e9e63f5f2be479eb4e363e5f2	semantics of non-deterministic possibility computation	domain theory;hoare powerdomain;possibility measure;formal semantics;possibility computation;sugeno integral	Possibility computation, introduced by Chen and Wu in 2008, is a kind of computational model to deal with non-determinism, based on the axiomatic rule of possibility measures in the framework of domain theory. In this paper, we consider the case of non-determinism of possibility computation, i.e., non-deterministic and possibility computations co-exist. Both its denotational semantics, i.e., state transformer semantics, and logical semantics, i.e., predicate transformer semantics are established and their duality is verified in the framework of fuzziness. The denotational semantics is defined to be a Scott-continuous function from the input spaces to Hoare possibilistic powerdomain of output spaces. The logical semantics is given by strongly healthy fuzzy predicate transformers from fuzzy predicates on the domain of output spaces to the ones on the domain of input spaces. We prove a duality property between these two semantics by means of Sugeno integral with respect to possibility valuations. Finally, we establish the semantics of a fuzzy programming language in terms of our methods. © 2012 Elsevier B.V. All rights reserved.	computation;computational model;denotational semantics;domain theory;entity–relationship model;fuzzy set;hoare logic;map;nondeterministic algorithm;plotkin bound;power domains;predicate transformer semantics;programming language;sugeno integral;transformers;uncertainty principle	Hengyang Wu;Yixiang Chen	2012	Fuzzy Sets and Systems	10.1016/j.fss.2012.01.022	discrete mathematics;formal semantics;computer science;domain theory;proof-theoretic semantics;formal semantics;mathematics;predicate transformer semantics;denotational semantics of the actor model;axiomatic semantics;well-founded semantics;operational semantics;denotational semantics;algorithm;computational semantics	Logic	-13.57486496933057	12.606064748055488	173526
0801e5ed08c24f2dc86519cc3ab11f7e2c69adbf	a theory for program and data type specification	lenguaje programacion;algebraic semantic;langage ordre 1;programming language;semantica formal;sistema informatico;first order language;lambda calculus;computer system;abstract data type;data type;specification programme;formal semantics;semantique formelle;semantica algebraica;informatique theorique;type abstrait;langage programmation;lambda calculo;systeme informatique;tipo abstracto;semantique algebrique;lambda calcul;program specification;lenguaje orden 1;especificacion programa;computer theory;informatica teorica	The theory presented here, IOCC (Impredicative theory of Operations, Control and Classes) is an essentially first-order, two-layered theory. The lower layer is a theory of program equivalence and definedness. Program primitives that can be treated within this theory include functional application and abstraction, conditional, numbers, pairing, and continuation capture and resumption. The upper layer is a theory of class membership with a general comprehension principle for defining classes. Many standard class constructions and data types can be represented naturally including algebraic abstract data types, list-, record-, and function-type constructions		Carolyn L. Talcott	1992	Theor. Comput. Sci.	10.1016/0304-3975(92)90169-G	data type;computer science;lambda calculus;formal semantics;mathematics;programming language;abstract data type;algorithm	Logic	-13.567682297304867	17.894145229068673	173555
2da719c98fbb5786ef270e7d54ccbf16ac17993c	some embedding theorems for conditional logic	embedding;conditional logic;embedding theorem;logics;modal logic;non monotonic logic;classical conditioning;cumulant;logique;sublogic relation	We prove some embedding theorems for classical conditional logic, covering ‘finitely cumulative’ logics, ‘preferential’ logics and what we call ‘semi-monotonic’ logics. Technical tools called ‘partial frames’ and ‘frame morphisms’ in the context of neighborhood semantics are used in the proof.		Ming Xu	2006	J. Philosophical Logic	10.1007/s10992-005-9021-8	modal logic;dynamic logic;monoidal t-norm logic;t-norm fuzzy logics;normal modal logic;classical conditioning;combinatorics;discrete mathematics;classical logic;description logic;higher-order logic;principle of bivalence;philosophy;epistemology;many-valued logic;intermediate logic;non-monotonic logic;łukasiewicz logic;embedding;mathematics;kripke semantics;accessibility relation;substructural logic;multimodal logic;cumulant	Logic	-12.115312660544431	12.000996347798244	174444
007200c72ef48f6bdd67900ca64768f622cca75e	minimal model generation with positive unit hyper-resolution tableaux	minimal model;model generation;article	Herbrand models for clausal theories are useful in several areas of computer science. In most cases, however, the conventional model generation algorithms are inappropriate because they generate non-minimal Herbrand models and can be ineecient. This article describes a novel approach for generating minimal Herbrand models of clausal theories. The approach builds upon positive unit hyper-resolution (PUHR) tableaux, that are in general smaller than conventional tableaux. To generate only minimal Herbrand models, a complement splitting expansion rule and a speciic search strategy are applied. The proposed procedure is optimal in the sense that each minimal model is generated only once, and nonminimal models are rejected before their complete construction. First measurements on an implementation point to its eeciency.	algorithm;computer science;consistency model;theory	François Bry;Adnan H. Yahya	1996		10.1007/3-540-61208-4_10	arithmetic;pure mathematics;mathematics;algorithm	AI	-12.916065334776544	16.10591833884139	174661
d795495c54f183ab11893dadba45c5c04b31257f	reasoning for fuzzy description logic with comparison expressions	description logic	The fuzzy extensions of description logics support representation and reasoning for fuzzy knowledge. But the current fuzzy description logics do not support the expression of comparisons between fuzzy membership degrees. The paper proposes ALCfc, a fuzzy extension of description logic ALC with comparison expressions. ALCfc defines comparison cut concepts to express complex comparisons, and integrate them with fuzzy ALC. The challenges of reasoning in ALCfc is discussed, and a tableau algorithm is presented. It enables representation and reasoning for expressive fuzzy knowledge about comparisons.	algorithm;description logic;long division	Dazhou Kang;Baowen Xu;Jianjiang Lu;Yanhui Li	2006			dynamic logic (modal logic);substructural logic;t-norm fuzzy logics;multimodal logic;machine learning;fuzzy logic;description logic;mathematics;artificial intelligence;autoepistemic logic;intermediate logic	AI	-15.523056438861623	11.235179222550391	174792
dddd8bc4684eb672942369755a2b3cad37d73e70	higher-order rewriting: framework, confluence and termination	proof assistant;confluencia;lambda calculus;confluence;program verification;probleme terminaison;higher order;first order;pattern matching;abstract syntax;reecriture;lambda calculo;termination problem;concordance forme;higher order functions;rewriting;lambda calcul;problema terminacion;reescritura;reecriture ordre superieur	Equations are ubiquitous in mathematics and in computer science as well. This first sentence of a survey on first-order rewriting borrowed again and again characterizes best the fundamental reason why rewriting, as a technology for processing equations, is so important in our discipline [10]. Here, we consider higher-order rewriting, that is, rewriting higher-order functional expressions at higher-types. Higher-order rewriting is a useful generalization of first-order rewriting: by rewriting higher-order functional expressions, one can process abstract syntax as done for example in program verification with the prover Isabelle [27]; by rewriting expressions at higher-types, one can implement complex recursion schemas in proof assistants like Coq [12].	coexist (image);confluence;critical pair (logic);path ordering (term rewriting);recursion;rewriting	Jean-Pierre Jouannaud	2005		10.1007/11601548_14	abstract syntax;discrete mathematics;prefix grammar;higher-order logic;rewriting;computer science;pattern matching;lambda calculus;first-order logic;mathematics;semi-thue system;proof assistant;programming language;higher-order function;confluence;algorithm;graph rewriting	Logic	-14.4079239543664	16.32774917749351	174835
740cc1990803385c22c2c35ab3ded8c6f21d1758	on logics with coimplication	propriete du modele fini;implication;possibility;kripke s a;tense logic;theoreme blok esakia;operator;possibilite;axiomatization;logics;duality;semantics;semantique;dualite;co implication;axiomatisation;hilbert d;intuitionistic logic;logique intuitionniste;operateur;modal;completeness;extension;logique du temps;decidabilite;completude;heyting a;godel k;brouwer l e j;logique;decidability;systeme s4	This paper investigates (modal) extensions of Heyting-Brouwer logic, i.e., the logic which results when the dual of implication (alias coimplication) is added to the language of intuitionistic logic. We rst develop matrix as well as Kripke style semantics for those logics. Then, by extending the Godel-embedding of intuitionistic logic into S4, it is shown that all (modal) extensions of Heyting-Brouwer logic can be embedded into tense logics (with additional modal operators). An extension of the Blok-EsakiaTheorem is proved for this embedding.	brouwer fixed-point theorem;embedded system;intuitionistic logic;modal companion;modal logic	Frank Wolter	1998	J. Philosophical Logic	10.1023/A:1004218110879	modal logic;dynamic logic;decidability;s5;t-norm fuzzy logics;normal modal logic;modal μ-calculus;modal;discrete mathematics;classical logic;linear temporal logic;description logic;duality;higher-order logic;relevance logic;principle of bivalence;many-valued logic;completeness;intuitionistic logic;intermediate logic;operator;axiom s5;mathematics;semantics;programming language;kripke semantics;accessibility relation;substructural logic;multimodal logic;algorithm	Logic	-12.85365952581065	13.003723164277805	175186
e623d2bba86ad8489351d6e8325b212eeddb8943	inductive logic programming		Planning is the model-based approach to autonomous behaviour where the action to do next is derived from a model. The main challenge in planning is computational, as all models, whether accommodating non-determinism and feedback or not, are intractable in the worst case. In the last few years, however, significant progress has been made resulting in algorithms that can produce plans effectively in a variety of settings. These developments have to do with the formulation and use of general inference techniques and transformations. In this talk, I review the inference techniques that have proven useful for solving individual planning instances, and discuss also the use of learning methods and transformations for solving complete planning domains. The former include the automatic derivation of heuristic functions to guide the search for plans, and the identification of helpful actions and landmarks. The latter include methods for deriving generalized policies and finite state controllers capable of dealing with changes in the initial situation and in the number of objects. I’ll also discuss the alternative ways in which learning can be used in planning and the challenges ahead. S.H. Muggleton, A. Tamaddoni-Nezhad, F.A. Lisi (Eds.): ILP 2011, LNAI 7207, p. 1, 2012. c © Springer-Verlag Berlin Heidelberg 2012	algorithm;automated planning and scheduling;autonomy;best, worst and average case;computation;feedback;finite-state machine;heuristic;inductive logic programming;lecture notes in computer science;springer (tank)	Randy Goebel;Yuzuru Tanaka;Stephen H. Muggleton;Alireza Tamaddoni-Nezhad;Francesca A. Lisi;Wolfgang Wahlster	2011		10.1007/978-3-642-31951-8	inductive programming;algorithm;dynamic logic (modal logic);logic family;functional logic programming;horn clause;inductive logic programming;logic programming;computer science;prolog	AI	-18.66698426261741	13.32577111739111	175222
8acb2a00f5b888d78b6e8968f1d79691e8fd453b	des: a challenge problem for nonmonotonic reasoning systems	stable models;benchmark problem;artificial intelligent;nonmonotonic reasoning;data encryption standard;logic programs	The US Data Encryption Standard, DES for short, is put forward as an interesting benchmark problem for nonmonotonic reasoning systems because (i) it provides a set of test cases of industrial relevance which shares features of randomly generated problems and real-world problems, (ii) the representation of DES using normal logic programs with the stable model semantics is simple and easy to understand, and (iii) this subclass of logic programs can be seen as an interesting special case for many other formalizations of nonmonotonic reasoning. In this paper we present two encodings of DES as logic programs: a direct one out of the standard specifications and an optimized one extending the work of Massacci and Marraro. The computational properties of the encodings are studied by using them for DES key search with the Smodels system as the implementation of the stable model semantics. Results indicate that the encodings and Smodels are quite competitive: they outperform state-of-the-art SAT-checkers working with an optimized encoding of DES into SAT and are comparable with a SAT-checker that is customized and tuned for the optimized SAT encoding.	benchmark (computing);boolean satisfiability problem;conjunctive normal form;directed acyclic graph;encryption;logic programming;non-monotonic logic;procedural generation;randomness;relevance;stable model semantics;test case;turing completeness	Maarit Hietalahti;Fabio Massacci;Ilkka Niemelä	2000	CoRR		stable model semantics;computer science;artificial intelligence;theoretical computer science;non-monotonic logic;machine learning;mathematics;algorithm	AI	-18.215000916010222	15.610353259320666	175585
5f730bab712ff8139673e4e02101a2f740f8f570	computational euclid		We analyse the axioms of Euclidean geometry according to standard object-oriented software development methodology. We find a perfect match: the main undefined concepts of the axioms translate to object classes. The result is a suite of C++ classes that efficiently supports the construction of complex geometric configurations. Although all computations are performed in floating-point arithmetic, they correctly implement as semi-decision algorithms the tests for equality of points, a point being on a line or in a plane, a line being in a plane, parallelness of lines, of a line and a plane, and of planes. That is, in accordance to the fundamental limitations to computability requiring that only negative outcomes are given with certainty, while positive outcomes only imply possibility of these conditions being true.	algorithm;c++ classes;computability;computation;euclid;semiconductor industry;software development process;undefined behavior	M. H. van Emden;Belaid Moa	2006	CoRR			Theory	-15.747047856867265	17.31702702488827	175742
dc25c3a1a06af8bc8b4dcab657d5502dd1c010bb	linus - a link instantion prover with unit support	competition;theorem prover;hyperlinking;automated theorem proving;first order logic;mate saturation;linus	LINUS is a theorem prover for clause logic based on hyperlinking. The main new feature of the system is the emphasis on the preference for unit clauses, which are generated as a by-product of the hyperlinking method. The mechanism of unit support also motivates a slightly different interpretation of hyperlinking, namely, as mate saturation. Mate saturation can be viewed as a generalization of unit-resulting resolution that is compatible with any set-of-support strategy. We give a survey on the theoretical background and the architecture of the system, and decribe its performance.	automated theorem proving;decision problem;hyperlink;iterative deepening depth-first search;iterative method;operator associativity;redundancy (engineering);universal instantiation	Reinhold Letz	1997	Journal of Automated Reasoning	10.1023/A:1005839531398	discrete mathematics;computer science;mathematics;automated theorem proving;programming language;algorithm	AI	-14.364332810760358	16.35715208505342	176044
34178422b868e0019a33747b091a9377e7af12ad	on the algebraic structure of declarative programming languages	declarative programming;teoria demonstracion;lenguaje programacion;prueba;programmation logique avec contrainte;semantica operacional;logica algebraica;espacio matematico;syntax;constraint logic programs;algebraic semantic;bottom up;theorie preuve;51e24;algebraic logic;03cxx;programming language;proof theory;category;logique categorielle;68t15;espace mathematique;68q65;virgule fixe;coaccion;abstract data types;operational semantics;espace etat;horn clauses;contrainte;programacion logica con restriccion;punto fijo;index;theorie modeles;lenguaje algebraico;abstract data type;syntaxe;coma fija;fixed point;semantica algebraica;modele semantique;categorie;semantique operationnelle;constraint;03fxx;preuve;logic programming;state space method;methode espace etat;point fixe;indice;informatique theorique;logique algebrique;state space;indexation;estructura datos;type abstrait;indexed categories;structure algebrique;68p05;langage programmation;langage algebrique;clause horn;structure donnee;tipo abstracto;semantique algebrique;68n17;constraint logic programming;logic programs;algebraic structure;68n15;08axx;03gxx;sintaxis;espacio estado;proof;data structure;teoria modelos;logique horn;algebraic language;fix point;categorical logic;metodo espacio estado;computer theory;model theory;mathematical space;informatica teorica	We develop an algebraic framework, Logic Programming Doctrines, for the syntax, proof theory, operational semantics and model theory of Horn Clause logic programming based on indexed premonoidal categories. Our aim is to provide a uniform framework for logic programming and its extensions capable of incorporating constraints, abstract data types, features imported from other programming language paradigms and a mathematical description of the state space in a declarative manner. We define a new way to embed information about data into logic programming derivations by building a sketch-like description of data structures directly into an indexed category of proofs. We give an algebraic axiomatization of bottom-up semantics in this general setting, describing categorical models as fixed points of a continuous operator. © 2009 Elsevier B.V. All rights reserved.	abstract data type;algebraic equation;axiomatic system;bottom-up parsing;data structure;declarative programming;fixed point (mathematics);horn clause;linear algebra;logic programming;operational semantics;programming language;state space	Gianluca Amato;James Lipton;Robert McGrail	2009	Theor. Comput. Sci.	10.1016/j.tcs.2009.07.038	constraint programming;discrete mathematics;declarative programming;horn clause;data structure;stable model semantics;programming domain;reactive programming;algebraic modeling language;computer science;functional logic programming;mathematics;signature;programming paradigm;procedural programming;inductive programming;fifth-generation programming language;programming language theory;programming language;well-founded semantics;prolog;logic programming;abstract data type;comparison of multi-paradigm programming languages;algorithm	PL	-14.762471856924785	16.627184248579493	176193
30d0aa6160ca8942029c1b3567d41afc0ed8dbd2	building decision procedures for modal logics from propositional decision procedure - the case study of modal k	satisfiability;modal logic;decision procedure;davis putnam	 . The goal of this paper is to propose a new technique for developingdecision procedures for propositional modal logics. The basicidea is that propositional modal decision procedures should be developedon top of propositional decision procedures. As a case study, weconsider satisfiability in modal K(m), that is modal K with m modalities,and develop an algorithm, called Ksat, on top of an implementationof the Davis-Putnam-Longemann-Loveland procedure. Ksat isthoroughly tested and... 	decision problem;modal logic	Fausto Giunchiglia;Roberto Sebastiani	1996		10.1007/3-540-61511-3_115	modal logic;dynamic logic;s5;t-norm fuzzy logics;normal modal logic;modal μ-calculus;discrete mathematics;axiom s5;mathematics;method of analytic tableaux;accessibility relation;multimodal logic;algorithm;satisfiability	AI	-14.330472675290801	13.905908421245337	176421
b107eaa4c2c0e520e68ad676b27e76e2bd493db9	a domain reasoner for propositional logic	feed forward;domain reasoner;learning environment;intelligent tutoring;feedback;propositional logic;normal forms	Students learn propositional logic in programs such as mathematics, philosophy, computer science, law, etc. An important topic in courses in propositional logic is rewriting propositional formulae with standard equivalences, and the application of this technique in exercises on rewriting a formula in normal form, proving the equivalence between two formulae or proving that a formula is a consequence of a set of formulae. Existing learning environments for propositional logic offer limited feedback and feed forward. This paper analyses what kind of feedback is offered by the various learning environments for rewriting propositional logic formulae, and discusses how we can provide these kinds of feedback in a learning environment. To give feedback and feed forward, we define solution strategies for several classes of exercises. We offer an extensive description of the knowledge necessary to support solving this kind of propositional logic exercises in a learning environment. This description serves as an illustration of how to develop the artificial intelligence for a particular domain.	artificial intelligence;computer science;feed forward (control);propositional calculus;rewriting;semantic reasoner;turing completeness	Josje Lodder;Bastiaan Heeren;Johan Jeuring	2016	J. UCS		dynamic logic;zeroth-order logic;decidability;t-norm fuzzy logics;modal μ-calculus;classical logic;resolution;description logic;interval temporal logic;computer science;artificial intelligence;database normalization;feedback;predicate variable;propositional variable;well-formed formula;propositional calculus;feed forward;algorithm;autoepistemic logic	AI	-14.673715367372925	12.363966157760611	176499
dc1ae684796d0ccc67ee5b84f48e526bbdf023a7	a many-sorted resolution based on an extension of a first-order language	first order		first-order predicate	Keki B. Irani;D. G. Shin	1985			computer science;artificial intelligence;first-order logic	NLP	-13.330177139868184	14.29150306013153	176584
3bba4ba94393ae39c3f59727ae635e1a3db936ea	separation principles in the hierarchy theory of pure first-order logic			first-order logic;first-order predicate	Melven R. Krom	1963	J. Symb. Log.		discrete mathematics;bunched logic;first-order logic;mathematics;separation principle;algorithm	Logic	-13.198944570773088	12.953384043788137	176657
fe47a59199bb5ca6ae78a87cb896da3a2548d6dd	data structures and program transformation	formalisme bird meertens;programmation;qualite;program transformation;transformation programme;homomorphism;programacion;transformacion programa;quality;informatique theorique;estructura datos;homomorphisme;structure donnee;homomorfismo;programming;data structure;calidad;computer theory;informatica teorica	Aktract. ‘The construction of structure-preserving maps, “homomorphisms”, is described for an arbitrary data type, and a “promotion” theorem is derived for proving equalities of homomorphisms. Examples are given for finite lists, tree structum and types defined by mutual induction; the construction is then dualised to data types with infinite objects, such as infinite lists. The promotion theorem allows the development of concise, calculational proofs: several examples are given of its application to program transformation.	lazy evaluation;map;mutual recursion;program transformation	Grant Malcolm	1990	Sci. Comput. Program.	10.1016/0167-6423(90)90023-7	homomorphism;programming;data structure;computer science;programming language;algorithm	PL	-12.653260304976412	17.810029534536145	177049
9d7ab89ca1bc7da4e5c0a238de0e8ba67224951a	engineering design is a computable function	grammar;engineering;modele abstrait;computable function;machine turing;engineering design;metodologia;fonction calculable;computability;specification;abstraction;conception;turing machine;abstraccion;methodologie;ingenierie;design artifacts;especificacion;grammaire;calculabilite;diseno;design;ingenieria;decidibilidad;methodology;decidabilite;gramatica;maquina turing;calculabilidad;decidability	Computational abstraction of engineering design leads to an elegant theory defining (1) the process of design as an abstract model of computability, the Turing machine; (2) the artifacts of design as enumerated strings from a (possibly multidimensional) grammar; and (3) design specifications or constraints as formal state changes that govern string enumeration. Using this theory, it is shown that engineering design is a computable function. A computational methodology based on the theory is then developed that can be described as a form follows function design paradigm.	computable function	Patrick A. Fitzhorn	1994	AI EDAM	10.1017/S0890060400000445	decidability;design;computer science;turing machine;methodology;grammar;abstraction;computability;computable function;specification;algorithm;engineering design process;computable analysis	AI	-16.170833246652336	17.436008792166813	177865
dde7558c7f80b640efb6318d075fffd7ef5966dc	before announcement		We axiomatize the mono-agent logic of knowledge with public announcements and converse public announcements. A special variant of our logic is determined by the model of maximal ignorance wherein the agent considers all valuations of atomic	computability;existential quantification;feedback;introspection;linear algebra;maximal set;modality (human–computer interaction);multi-agent system;open road tolling;philippe kruchten;turing completeness	Philippe Balbiani;Hans van Ditmarsch;Andreas Herzig	2016				AI	-13.004147904061988	12.102801870878512	178037
53cc0d343c7c408d1ee75252624280c92c618d86	working group report: negation, functions and construction in rule-based languages for complex objects	working group;rule based		logic programming	Peter Sander;Simone Rehm;Jan Van den Bussche	1989			rule-based system;algorithm;negation;computer science	DB	-18.21421966843753	11.451108260482359	178242
ebc6367c40c0431c4730c8a65a8277efa2be9983	the specification and implementation of a first order logic for uncertain temporal domains	first order logic		first-order logic	Ehric Ho;André Trudel	1994			linear temporal logic;discrete mathematics;multimodal logic;logic optimization;interval temporal logic;dynamic logic (modal logic);substructural logic;autoepistemic logic;computer science;temporal logic of actions	Logic	-14.377154909658808	13.813934726653851	178332
9a9694482bd76d49b06617e9593706e425c92d87	an eight-valued praconsistent logic		A b s t r a c t. It is known that many-valued paraconsistent logics are useful for expressing uncertain and inconsistency-tolerant reasoning in a wide range of Computer Science. Some four-valued and sixteen-valued logics have especially been well-studied. Some four-valued logics are not so ne-grained, and some sixteen-valued logics are enough ne-grained, but rather complex. In this paper, a natural eight-valued paraconsistent logic rather than four-valued and sixteen-valued logics is introduced as a Gentzen-type sequent calculus. This eight-valued logic is enough ne-grained and simpler than sixteen-valued logic. A triplet valuation semantics is introduced for this logic, and the completeness theorem for this semantics is proved. The cut-elimination theorem for this logic is proved, and this logic is shown to be decidable.		Norihiro Kamide	2014	Reports on Mathematical Logic		monoidal t-norm logic;t-norm fuzzy logics;principle of explosion;discrete mathematics;classical logic;description logic;higher-order logic;paraconsistent logic;relevance logic;principle of bivalence;many-valued logic;intermediate logic;non-monotonic logic;łukasiewicz logic;first-order logic;computational logic;mathematics;kripke semantics;logic;substructural logic;second-order logic;algorithm;philosophy of logic	EDA	-12.839564899188286	12.826232270775495	178424
61e6fbfd77525f7aec2b9454425e3122827a0470	calcolo del modello well-founded di programmi datalog			datalog	Francesco Scarcello	1993			algorithm;datalog;mathematics	DB	-14.120132397924666	12.977759993975189	178610
fd12f936c15a0f567a8527103fef69383f53aca3	act-p: a configurable theorem-power	metodologia;conception;estrategia;resolution control strategies;controle;methodologie;theorem proving;strategy;resolucion problema;demonstration theoreme;theorem prover;informatique theorique;diseno;arquitectura;design;control;adequacy;methodology;demostracion teorema;meta level architecture;completude;strategie;architecture;meta niveau;control strategy;problem solving;resolution probleme;computer theory;design methodology;check;informatica teorica	There has been a considerable amount of research into the provision of explicit representation of control regimes for resolution-based theorem provers. However, most of the existing systems are either not adequate in that they do not allow the user to express any arbitrary control regime, or are too inefficient to be of practical use. In this paper a theorem prover, ACT-P, which is adequate but retains satisfactory efficiency is presented. It does so by providing a number of user-changeable heuristics which are called at specific points during the search for a proof. The set of user-changeable heuristics was determined on the basis of a classification of the heuristics used by existing resolution-based theorem provers.	power architecture	Ioannis Hatzilygeroudis;Han Reichgelt	1994	Data Knowl. Eng.	10.1016/0169-023X(94)90029-9	computer science;artificial intelligence;heuristics;automated theorem proving;algorithm	DB	-16.831761881038823	15.389955780647158	178738
accfbdb4d66039cb649c9dbf7e7cd1746ac45775	morphos configuration engine: the core of a commercial configuration system in clp(fd)	mce product model;constraint programming;case based reasoning;product configuration	Product configuration systems are an emerging software technology that supports companies in deploying mass customization strategies. In this paper, we describe a CLP-based reasoning engine that we developed for a commercial configuration system. We first illustrate the advantages of the CLP approach to product configuration over other ones. Then, we describe the actual encoding of the considered product configuration problem as a constraint satisfaction problem. We devote a special attention to the key issues of constraint propagation and optimization as well as to the relevant process of assignment revision. A comparison with existing systems for product configuration concludes the paper.	algorithm;approximation;computation;configuration management;constraint (mathematics);constraint logic programming;constraint satisfaction problem;eclipse;exemplification;fixed-point arithmetic;floor and ceiling functions;interval arithmetic;knowledge-based configuration;linuxmce;local consistency;mathematical optimization;morphos;numerical analysis;ontology (information science);process modeling;prolog;radix point;requirement;swi-prolog;semantic reasoner;semiconductor industry;software propagation;solver;tinymce	Dario Campagna;Christian De Rosa;Agostino Dovier;Angelo Montanari;Carla Piazza	2010	Fundam. Inform.	10.3233/FI-2010-360	case-based reasoning;constraint programming;computer science;artificial intelligence;programming language	AI	-18.575529080189824	14.263080072968194	179062
5e5a5e785e59d44ee9ae6b7876704c999366f6ec	an alternative approach to the semantics of disjunctive logic programs and deductive databases	minimal model;theoretical framework;model generation;computational complexity;logic programs;point of view;closed world assumption;disjunctive logic programming;deductive databases	In this paper, we study a new semantics of logic programming and deductive databases. Thepossible model semantics is introduced as a declarative semantics of disjunctive logic programs. The possible model semantics is an alternative theoretical framework to the classical minimal model semantics and provides a flexible inference mechanism for inferring negation in disjunctive logic programs. We also present a proof procedure for the possible model semantics and show that the possible model semantics has an advantage from the computational complexity point of view.	abductive reasoning;agile software development;autoepistemic logic;bottom-up parsing;commonsense reasoning;computation;computational complexity theory;deductive database;disjunctive normal form;emoticon;existential quantification;kilobyte;logic programming;maxima and minima;objective-c;p (complexity);stable model semantics;top-down and bottom-up design;wavefront .obj file	Chiaki Sakama;Katsumi Inoue	1994	Journal of Automated Reasoning	10.1007/BF00881915	closed-world assumption;classical logic;description logic;higher-order logic;formal semantics;stable model semantics;computer science;artificial intelligence;game semantics;theoretical computer science;predicate functor logic;proof-theoretic semantics;formal semantics;computational logic;mathematics;predicate transformer semantics;programming language;axiomatic semantics;computational complexity theory;well-founded semantics;operational semantics;multimodal logic;denotational semantics;algorithm;computational semantics	DB	-17.72126044698992	11.866275235917076	179304
46c71a4cbbced2430107fc807ca0ba61c80c34d2	axiom systems for first order logic with finitely many variables			first-order logic	James S. Johnson	1973	J. Symb. Log.		predicate logic;dynamic logic;zeroth-order logic;axiom schema;axiom of extensionality;discrete mathematics;higher-order logic;many-valued logic;intermediate logic;predicate functor logic;axiom s5;first-order logic;mathematics;predicate variable;algebra	Logic	-12.413616541998865	13.110361803787256	179349
1689d7a3e9dac12c0a0f8733da4ec55d779cc407	meta-level definition and compilation of inference engines in the epsilon logic programming environment			logic programming	Patrizia Coscia;Paola Franceschi;Giorgio Levi;Giuseppe Sardu;Luigia Torre	1988			dynamic logic (modal logic);bunched logic;probabilistic logic network;horn clause;functional logic programming;theoretical computer science;logic programming;proof calculus;computer science;prolog	ML	-15.41757812342057	13.657790589470165	179556
2a2e4773f9e10a15facb078e33bccaa091dc7fd8	a cps-transform of constructive classical logic	cut elimination;semantica denotacional;program transformation;logical programming;transformation programme;functional programming;transformacion programa;programmation logique;intuitionistic logic;informatique theorique;denotational semantics;natural deduction;logique intuitionniste;programmation fonctionnelle;classical logic;programacion logica;programacion funcional;logica intuicionista;semantique denotationnelle;computer theory;informatica teorica	We show that the cut-elimination for LKT, as presented in Danos et al.(1993), simulates the normalization for classical natural deduction(CND). Particularly, the denotation for CND inherits the one for LKT. Moreover the transform from CND proof (i.e., Parigot's -term) to LKT proof can be considered as a classical extension to call-by-name (CBN) CPS-transform.	category theory;coherence (physics);domain theory;linear logic;simulation	Ichiro Ogata	1999		10.1007/3-540-46674-6_23	discrete mathematics;classical logic;intuitionistic logic;computer science;mathematics;programming language;functional programming;natural deduction;denotational semantics;algorithm	Crypto	-13.3853416782071	15.908269365543454	179638
c691777b87c2e932404ca64eb5a2a9d895681bf9	computing preferred and weakly preferred answer sets by meta interpretation in answer set programming	answer set programming;knowledge representation	Preferred and Weakly Preferred Answer Sets are extensions to Answer Set Programming (ASP) which allow the user to specify priorities for rules. In this paper we present a first implementation of these formalisms by means of “metainterpreters” on top ofDLV, an efficient engine for Disjunctive ASP. This approach shows the suitability of ASP in general and ofDLV in particular for fast prototyping and experimenting with new languages and knowledge-representation formalisms. In addition to two “straightforward” metainterpreters, we also present a graph-based meta-interpre that often allows for more efficient computations.	answer set programming;computation;disjunctive normal form;experiment;knowledge representation and reasoning;stable model semantics	Thomas Eiter;Wolfgang Faber;Nicola Leone;Gerald Pfeifer	2001				AI	-18.040918466263953	13.320661137298954	179919
6b15938d9449fc0daaead380bfe5701ca75a6a9e	recursive modes for precise analysis of logic programs	logic programs		logic programming;recursion	Jichang Tan;I-Peng Lin	1997			dynamic logic;logic optimization;computer science;theoretical computer science;bunched logic;signature;programming language;axiomatic semantics;multimodal logic;algorithm	Arch	-14.792775186440753	13.908384934106623	179996
7a6b37f9099a23a455b690bad6aa6e3a39d9de94	procedural interpretation of non-horn logic programs	theorem prover;query answering;logic programs;closed world assumption	Procedural interpretation in logic programming consists of two parts: answering positive queries and answering negative queries. Answering positive queries can be done using a general theorem prover. To answer negative queries it is necessary, in most practical cases, to augment a theorem prover with default rules. Such an approach has been taken with Horn clause logic programs in the definition of SLDNF-resolution. We describe a similar proof procedure for non-Horn programs and define an inference system, SLINF-resolution, for this purpose. SLI-resolution is used as the main inference mechanism and a weaker form of the generalized closed world assumption, called the Support-for-Negation Rule, is used as the default rule for answering negative queries.	horn clause;logic programming	Jack Minker;Arcot Rajasekar	1988		10.1007/BFb0012837	dynamic logic;closed-world assumption;discrete mathematics;description logic;computer science;artificial intelligence;theoretical computer science;computational logic;mathematics;automated theorem proving;multimodal logic;second-order logic;algorithm	Logic	-16.657595132760104	12.716371206367217	180009
a95ae2689cded3143c261bceeaf55105024a983b	exptime tableaux for using sound global caching	tableau based decision procedures;global caching complexity optimal tableaux;data description;formal languages;keywords decision procedure;satisfiability;journal article;modal logic;formal logic;exptime;description logic;optimisation techniques;optimization description logic	We present a simple ExpTime (complexity-optimal) tableau decision procedure based on and-or graphs with sound global caching for checking satisfiability of a concept w.r.t. a TBox in $\mathcal{ALC}$ . Our algorithm is easy to implement and provides a foundation for ExpTime (complexity-optimal) tableau-based decision procedures for many modal and description logics, to which various optimisation techniques can be applied.	algorithm;cache (computing);decision problem;description logic;exptime;mathematical optimization;method of analytic tableaux;modal logic;tbox	Rajeev Goré;Linh Anh Nguyen	2007	Journal of Automated Reasoning	10.1007/s10817-011-9243-0	modal logic;formal language;discrete mathematics;description logic;exptime;computer science;theoretical computer science;mathematics;logic;algorithm;satisfiability	AI	-16.767938293856428	14.404527868415588	180292
d275dd3602b6bbd8e6cf0b1974a1c07055cfd809	a predicative operator and underspecification by the type theory of acyclic recursion	type theory;intension;predicative constructions;predicative operator;acyclic recursion;underspecification;denotation	This paper provides an introduction of the formal apparatus of the algorithmic calculus of Moschovakis' type theory of acyclic recursion L   $_{\rm ar}^{\lambda}$    for procedural semantics of predicative constructions. We introduce a generalized predicative operator in the formal language of acyclic recursion L   $_{\rm ar}^{\lambda}$   , for algorithmic representation of semantic underspecification. The paper investigates the potential use of such an operator for computational semantics of human language and algorithmic classification of predicative expressions.	directed acyclic graph;recursion;type theory	Roussanka Loukanova	2012		10.1007/978-3-642-41578-4_7	discrete mathematics;philosophy;computer science;intension;mathematics;linguistics;type theory;algorithm;denotation;algebra	PL	-12.2512284430324	11.955493824799188	180635
b9a7e2a7362843df37683b88ce6bcd56c86f20ca	classical by-need	lazy evaluation;call by need;lambda calculus;sigma equivalence;krivine abstract machine;lambda mu calculus;classical logic;control operators;krvine abstract machine;linear logic;linear head reduction	Call-by-need calculi are complex to design and reason with. When adding control effects, the very notion of canonicity is irremediably lost, the resulting calculi being necessarily ad hoc. This calls for a design of call-by-need guided by logical rather than operational considerations. Ariola et al. proposed such an extension of call-by-need with control making use of Curien and Herbelin’s duality of computation framework. In this paper, Classical by-need is developed as an alternative extension of call-by-need with control, better-suited for a programmingoriented reader.This method is proof-theoretically oriented by relying on linear head reduction (LHR) – an evaluation strategy coming from linear logic – and on the λμ-calculus – a classical extension of the λcalculus. More precisely, the paper contains three main contributions: – LHR is first reformulated by introducing closure contexts and extended to the λμ-calculus; – it is then shown how to derive a call-by-need calculus from LHR. The result is compared with standard call-by-need calculi, namely those of Ariola–Felleisen and Chang–Felleisen; – it is finally shown how to lift the previous item to classical logic, that is from the λ-calculus to the λμ-calculus, providing a classical by-need calculus, that is a lazy λμ-calculus. The result is compared with the call-by-need with control of Ariola et al.	analysis of algorithms;calculus of constructions;computation;continuation;control flow;explicit substitution;hoc (programming language);lambda calculus;lambda-mu calculus;lazy evaluation;linear logic;natural deduction;olivier fourdan;platoon (automobile);semi-continuity;sequent calculus;shape context;smoothing	Pierre-Marie Pédrot;Alexis Saurin	2016		10.1007/978-3-662-49498-1_24	lambda lifting;linear logic;typed lambda calculus;classical logic;binary lambda calculus;computer science;lambda calculus;simply typed lambda calculus;lazy evaluation;programming language;church encoding;algorithm	PL	-13.296881539257388	16.75289366979823	181287
fd97761f8f4d44d0836a66d21cb7c3a20977d58c	a decidable fragment of second order linear logic	second order;decision procedure;linear logic	Existentially quantiied variables are the source of non decid-ability for second order linear logic without exponentials (MALL2). We propose a decision procedure for a fragment of MALL2 based on a canon-ical instantiation of these variables and using inference permutability in proofs.	categorial grammar;decision problem;linear logic;natural deduction;natural language;parsing;universal instantiation;ical	Guy Perrier	1997		10.1007/3-540-63045-7_32	zeroth-order logic;decidability;linear logic;combinatorics;discrete mathematics;linear temporal logic;higher-order logic;computer science;intermediate logic;predicate functor logic;mathematics;substructural logic;second-order logic;algorithm	Logic	-12.870281097917974	14.184341150344334	181546
6d9aa8f8bd8fd74d470bf66c907be2c66968c7c8	disjunctive logic programs with existential quantification in rule heads		We consider disjunctive logic programs without function symbols but with existential quantification in rule heads, under the semantics of general stable models. There are at least two interesting prospects in these programs. The first is that a program can be made more succinct by using existential variables, and the second is on the potential in representing defeasible ontological knowledge by these logic programs. This paper studies some of the properties of these programs. First, we show a simple yet intuitive definition of stable models for these programs that does not resort to second-order logic. Second, the stable models of these programs can be characterized by an extension of progression for disjunctive programs, which provides a native characterization of justification for stable models. We then study the decidability issue. While the stable model existence problem for safe disjunctive programs is decidable, with existential quantification allowed in rule heads the problem becomes undecidable. We identify an interesting decidable fragment by exploring a new notion of stratification over existential quantification.	color gradient;defeasible reasoning;disjunctive normal form;existential quantification;logic programming;stable model semantics;undecidable problem	Jia-Huai You;Heng Zhang;Yan Zhang	2013	TPLP	10.1017/S1471068413000355	stable model semantics;programming language;existential quantification;algorithm	AI	-13.85687920676562	16.982809412842492	181673
295cc6bf40f152b700af47df1673875fd6005a74	the independence of peano's fourth axiom from martin-lof's type theory without universes		On demontre lu0027independance du quatrieme axiome de Peano de la theorie du type de Martin-Lof sans univers	type theory	Jan M. Smith	1988	J. Symb. Log.		recursion;mathematical logic;pure mathematics;mathematics;propositional calculus;programming language;type theory;algorithm	Logic	-12.067708574882538	11.644228782045703	182030
00eb8a477fe98115a1b276aa56650f1da6b240e7	a temporal logic for planning under uncertainty		Dealing with uncertainty in the context of planning has been an active research subject in AI. Addressing the case when uncertainty evolves over time can be difficult. In this work, we provide a solution to this problem by proposing a temporal logic to reason about quantities and probability. For this logic, we provide a PSPACE SAT algorithm together with a complete calculus. The algorithm enables us to perform planning under uncertainty via SAT, extending a technique used for classic planning. We can show that any obtained plan will have certain properties (desired or undesired). The calculus can also be used to derive the impossibility of a plan, given a set of specifications.	algorithm;boolean satisfiability problem;international symposium on fundamentals of computation theory;pspace;propositional calculus;robot;temporal logic	Manuel Biscaia;Pedro Baltazar;Paulo Mateus;Rajagopal Nagarajan	2013			impossibility;artificial intelligence;machine learning;temporal logic;computer science;pspace	AI	-18.529283004165126	13.156152969114178	182176
43c4ef14e6321ad8907beda11f6aa41e9a15c063	tree automata and automated model building	automated deduction;regular tree grammars;model building;tree automata;building model;first order logic	The use of regular tree grammars to represent and build models of formulae of rst-order logic without equality is investigated. The combination of regular tree grammars with equational constraints provides a powerful and general way of representing Herbrand models. We show that the evaluation problem (i.e. the problem of nding the truth value of a formula in a given model) is decidable when models are represented in the way we propose. We also deene a method to build such representations of models for rst-order formulae. These results are a powerful extension of our former method for simultaneous search for refutations and models.	regular tree grammar;tree automaton	Nicolas Peltier	1997	Fundam. Inform.	10.3233/FI-1997-30105	combinatorics;discrete mathematics;l-attributed grammar;model building;computer science;regular tree grammar;first-order logic;mathematics;programming language;algorithm	SE	-15.04660435068541	16.995297100279323	182256
6ad634c650b85c7c41704fdbc007b4b089f85652	on the relation between context and sequence unification	computacion informatica;information extraction;program transformation;word unification;context unification;computational linguistic;ciencias basicas y experimentales;rule based programming;xml document;sequence unification;grupo a	Both Sequence and Context Unification generalize the same problem: Word Unification. Besides that, Sequence Unification solves equations between unranked terms involving sequence variables, and seems to be appealing for information extraction in XML documents, program transformation, knowledge representation, and rule-based programming. It is decidable. Context Unification deals with the same problem for ranked terms involving context variables, and has applications in computational linguistics and program transformation. Its decidability is a long-standing open question. In this work we study a relation between these two problems. We introduce a variant (restriction) of Context Unification, called Left-Hole Context Unification (LHCU), to which Sequence Unification is P-reduced: We define a partial currying procedure to translate Sequence Unification problems into Left-Hole Context Unification problems, and prove the soundness of the translation. Furthermore, a precise characterization of the shape of the unifiers allows us to easily reduce Left-Hole Context Unification to (the decidable problem of) Word Unification with Regular Constraints, obtaining then a new decidability proof for Sequence Unification. Finally, we define an extension of Sequence Unification (ESU) and, closing the circle, prove the inter-P-reducibility of LHCU and ESU.	closing (morphology);computational linguistics;currying;decision problem;han unification;information extraction;knowledge representation and reasoning;logic programming;program transformation;regular expression;the circle (file system);unification (computer science);uniform resource locator;xml	Temur Kutsia;Jordi Levy;Mateu Villaret	2010	J. Symb. Comput.	10.1016/j.jsc.2009.07.001	discrete mathematics;xml;unification;mathematics;information extraction;algorithm	AI	-15.306719122442939	15.347260233564445	182364
a3ba85458aa556a1e983169b0165d2cd113a53a3	levi contractions and agm contractions: a comparison	filosofi;satisfiability;philosophy;representation theorem;measures of information		belief revision	Sven Ove Hansson;Erik J. Olsson	1995	Notre Dame Journal of Formal Logic	10.1305/ndjfl/1040308830	combinatorics;topology;mathematics;linguistics;algorithm;satisfiability	NLP	-12.138263804616091	11.947782297212742	182416
7d7dd1680cbf35a95bb2157d9381123585a28b3e	fork algebras as a sufficiently rich universal institution	developpement logiciel;algebra relacional;logique propositionnelle;logical programming;dynamic logic;first order;computational logic;programmation logique;linear temporal logic;propositional logic;desarrollo logicial;logique ordre 1;software development;algebre relationnelle;logica proposicional;programacion logica;relational algebra;first order logic;logica orden 1	Algebraization of computational logics in the theory of fork algebras has been a research topic for a while. This research allowed us to interpret classical first-order logic, several propositional monomodal logics, propositional and first-order dynamic logic, and propositional and first-order linear temporal logic in the theory of fork algebras. In this paper we formalize these interpretability results as institution representations from the institution of the corresponding logics to that of fork algebra. We also advocate for the institution of fork algebras as a sufficiently rich universal institution into which institutions meaningful in software development can be represented.	accessibility;description logic;dynamic logic (modal logic);epistemic closure;first-order logic;first-order predicate;fork (software development);linear temporal logic;modal logic;software development;theory;while	Carlos López Pombo;Marcelo F. Frias	2006		10.1007/11784180_19	monoidal t-norm logic;t-norm fuzzy logics;discrete mathematics;classical logic;computer science;artificial intelligence;first-order logic;mathematics;propositional variable;algorithm	Logic	-14.016002861568941	16.06976673015954	182599
1901b923e15c4c7404d532ace7f52c3fc7691d08	the algebraic essence of k-rep		The modal description logic AEA:/C both constitutes a promising framework for reasoning about actions and allows for the formalization of several non-first-order aspects of KR systems based on DLs. However, other nonmonotonic features of DL-based KR systems, in particular role and concept closure inside the knowledge base, lack an intuitive formalization in this modal framework. To overcome these difficulties, we propose a modification of the semantics for .A£CIC, which consists in allowing selective minimization of primitive concepts and roles, thus providing for a correct formalization of the notion of role and concept closure.	description logic;first-order predicate;knowledge base;modal logic	Frank J. Oles;Eric Mays;Robert A. Weida	1996			function field of an algebraic variety;algebraic number;discrete mathematics;algebraic cycle;algebraic extension;differential algebraic geometry;description logic;mathematics;a¹ homotopy theory;dimension of an algebraic variety	AI	-14.760344121895123	11.86981694370215	183067
054a37d0bb3e3541e1f71cbfc0bbc85efc161d52	combinatory categorial grammar as a substructural logic - - preliminary remarks -	substructural bcwk-logic;preliminary remark;combinatory categorial grammar;substructural combinatory logic;typological discussion;subdirectional combinatory logic;subdirectional logic;combinatory hypothesis;hilbert-style proof system;relevance logic;substructural logic;gentzen-style proof system	substructural bcwk-logic;preliminary remark;combinatory categorial grammar;substructural combinatory logic;typological discussion;subdirectional combinatory logic;subdirectional logic;combinatory hypothesis;hilbert-style proof system;relevance logic;substructural logic;gentzen-style proof system	combinatory categorial grammar	Daisuke Bekki	2010		10.1007/978-3-642-25655-4_3	categorial grammar;bunched logic;mathematics;linguistics;substructural logic;combinatory categorial grammar;algorithm	NLP	-12.544798233225698	11.338632568947798	183668
680436e30934add373bb809e8df5b588b62740bf	optimal multi-binding unification for sharing and linearity analysis		In the analysis of logic programs, abstract domains for detecting sharing properties are widely used. Recently the new domain ShLin has been introduced to generalize both sharing and linearity information. This domain is endowed with an optimal abstract operator for single-binding unification. The authors claim that the repeated application of this operator is also optimal for multi-binding unification. This is the proof of such a claim.	abstract interpretation;logic programming;sensor;unification (computer science)	Gianluca Amato;Francesca Scozzari	2014	TPLP	10.1017/S1471068413000070	algorithm	AI	-13.313639660295454	16.285037279442005	183754
b1e2213c337a41efd9e95d4aab1e8e4d2c2bc2b5	multiple propositional dynamic logic of parallel programs (extended abstract)	parallel programs;extended abstract;multiple propositional dynamic logic	Without Abstract	dynamic logic (modal logic)	Ryszard Danecki	1988		10.1007/BFb0017147	dynamic logic;zeroth-order logic;t-norm fuzzy logics;modal μ-calculus;discrete mathematics;classical logic;resolution;linear temporal logic;description logic;stable model semantics;interval temporal logic;intermediate logic;theoretical computer science;propositional variable;algorithm;autoepistemic logic	Theory	-14.663215978772937	13.992971414126837	184448
f5f0fd1c109e72b1a3219b29f2463edb6138b266	a top down proof procedure for default logic by using abduction	top down;default logic		abductive reasoning;default logic	Ken Satoh	1994			machine learning;artificial intelligence;algorithm;computer science;default logic;top-down and bottom-up design;proof procedure	AI	-17.47949652078092	11.551551730792784	184611
0af1e91b77f458aedbd5ade63842ed846d2a6356	deriving interpretations of the gradually-typed lambda calculus	2 level continuation passing style;program transformation;closures;gradual types;layered semantics	Siek and Garcia (2012) have explored the dynamic semantics of the gradually-typed lambda calculus by means of definitional interpreters and abstract machines. The correspondence between the calculus's mathematically described small-step reduction semantics and the implemented big-step definitional interpreters was left as a conjecture. We prove and generalise Siek and Garcia's conjectures using program transformation. We establish the correspondence between the definitional interpreters and the reduction semantics of a closure-converted gradually-typed lambda calculus that unifies and amends various versions of the calculus. We use a layered approach and two-level continuation-passing style so that the correspondence is parametric on the subsidiary coercion calculus. We have implemented the whole derivation for the eager error-detection policy and the downcast blame-tracking strategy. The correspondence can be established for other choices of error-detection policies and blame-tracking strategies, by plugging in the appropriate artefacts for the particular subsidiary coercion calculus.	continuation-passing style;defense in depth (computing);definition;downcasting;error detection and correction;operational semantics;program transformation;programming language;typed lambda calculus	Álvaro García-Pérez;Pablo Nogueira;Ilya Sergey	2014		10.1145/2543728.2543742	system f;process calculus;typed lambda calculus;normalisation by evaluation;closure;computer science;simply typed lambda calculus;programming language;church encoding;lambda cube;natural deduction;algorithm	PL	-13.813605808966097	18.14999862072801	184734
b35445898bb0d25938d7c334a884dbe429c4e048	recursive models for three-valued propositional calculi with classical implication			propositional calculus;recursion (computer science)	Vladeta Vuckovic	1967	Notre Dame Journal of Formal Logic	10.1305/ndjfl/1093956253	discrete mathematics;recursion;mathematics	Logic	-12.250155535628041	13.093192200970284	184783
9b8965f963e2b91968799ca1ddbcf389fa51297a	correctness of a logical system for structured specifications	logical system;structured specification	The main aim of this paper is to present a completeness proof of a formal system for reasoning about logical consequences of structured specifications. The system is based on the proof rules for structural specifications build in an arbitrary institution as presented in [ST 88]. The proof of its completeness is inspired by the proof due to M. V. Cengarle (see [Cen 94]) for specifications in first-order logic and the logical system for reasoning about them presented also in [Wir 91].	correctness (computer science);formal system	T. Borzyskowski	1997		10.1007/3-540-64299-4_29	completeness (statistics);algorithm;theoretical computer science;formal system;correctness;logical consequence;computer science	DB	-14.006272367036603	13.914796660063587	185056
8cb0abce4f069af78e4a42f0dac52292683ffb92	modeling and verifying inconsistency-tolerant temporal reasoning with hierarchical information: dealing with students' learning processes	students learning processes;temporal logic;computability;computer aided instruction;temporal reasoning computability computational complexity computer aided instruction deterministic algorithms formal verification temporal logic;complexity;inconsistency tolerant temporal reasoning modeling deterministic ptime complete deterministic exptime complete model checking problem satisfiability problem validity problem inconsistency tolerant reasoning sequence modal operators paraconsistent negation connective spctl sequential paraconsistent computation tree logic temporal logic formal method student learning processes hierarchical information inconsistency tolerant temporal reasoning verification;deterministic algorithms;computation tree logic;formal verification;students learning processes computation tree logic paraconsistent logic model checking complexity;model checking;computational complexity;temporal reasoning;cognition educational institutions computational modeling model checking complexity theory biology ontologies;paraconsistent logic	In this paper, we propose a formal method for modeling and verifying inconsistency-tolerant temporal reasoning with hierarchical information. For this purpose, a temporal logic called sequential paraconsistent computation tree logic (SPCTL) is obtained from the well-known computation tree logic (CTL) by adding a paraconsistent negation connective and some sequence modal operators. SPCTL can appropriately represent both, inconsistency-tolerant reasoning by the paraconsistent negation connective, and hierarchical information by the sequence modal operators. The validity, satisfiability and model-checking problems of SPCTL are shown to be EXPTIME-complete, deterministic EXPTIME-complete and deterministic PTIME-complete, respectively. Some new illustrative examples for students' learning processes are presented using SPCTL.	computation tree logic;exptime;formal methods;logical connective;modal logic;model checking;negation as failure;norm (social);p (complexity);paraconsistent logic;temporal logic;verification and validation;whole earth 'lectronic link	Norihiro Kamide	2013	2013 IEEE International Conference on Systems, Man, and Cybernetics	10.1109/SMC.2013.320	model checking;discrete mathematics;linear temporal logic;complexity;paraconsistent logic;temporal logic;formal verification;computation tree logic;computer science;theoretical computer science;mathematics;computability;computational complexity theory;algorithm	Robotics	-15.855112999165028	13.141860817334704	185435
b08f8d6151389b85afade1c1e8eaddca4b6c6f9a	inclp(r) - interval-based nonlinear constraint logic programming over the reals	constraint logic programs		constraint logic programming	Leslie De Koninck;Tom Schrijvers;Bart Demoen	2006			constraint logic programming;concurrent constraint logic programming;mathematical optimization;constraint programming;discrete mathematics;binary constraint;horn clause;constraint satisfaction;interval temporal logic;intermediate logic;mathematics;satisfiability modulo theories;algorithm	Logic	-14.634233772928614	14.350211559892223	185537
120485089a7fc64d9fb929b28f7c0ff43ea47578	structural resolution with co-inductive loop detection		c Yue Li This work is licensed under the Creative Commons Attribution-Share Alike License. A way to combine co-SLD style loop detection with structural resolution was found and is introduced in this work, to extend structural resolution with co-induction. In particular, we present the operational semantics, called co-inductive structural resolution, of this novel combination and prove its soundness with respect to the greatest complete Herbrand model.	coinduction;cycle detection;operational semantics	Yue Li	2016		10.4204/EPTCS.258.4	discrete mathematics;rule of inference;algorithm;mathematics;horn clause;first-order logic;soundness;logic programming;special case;prolog;sld resolution	SE	-13.211559245013257	14.701649963850244	186161
97d1e60928555b227762682e640b89ff731beb88	a solved form algorithm for ask and tell herbrand constraints	concurrent constraint programming	We consider the problem of defining a solved form for ask and tell equalities over the Herbrand universe used as semantic domain of concurrent constraint programs. We give a solved form which is unique up to renaming for equivalent constraints, and we show an algorithm to compute it. The solved form and the related algorithm are extended to reactive trees consisting of ask and tell constraints. The algorithms are finally shown to be correct, i.e. to preserve the semantics of ask and tell constraints and of reactive trees.	algorithm	Maurizio Gabbrielli;Giorgio Levi	1991		10.1007/3-540-53982-4_18	concurrent constraint logic programming;mathematical optimization;constraint programming;discrete mathematics;constraint satisfaction;mathematics;algorithm	Logic	-17.664472425617475	14.377201051681581	186326
f4d4cecbd705793310e9cad9898ade0ea19dd234	a rewriting approach to binary decision diagrams	decision tree;binary decision diagrams;rewrite systems;term rewriting;binary decision diagram	Binary decision diagrams (BDDs) provide an established technique for propositional formula manipulation. In this paper, we present the basic BDD theory by means of standard rewriting techniques. Since a BDD is a DAG instead of a tree we need a notion of shared rewriting and develop appropriate theory. A rewriting system is presented by which canonical reduced ordered BDDs (ROBDDs) can be obtained and for which uniqueness of ROBDD representation is proved. Next, an alternative rewriting system is presented, suitable for actually computing ROBDDs from formulas. For this rewriting system a layerwise strategy is defined, and it is proved that when replacing the classical apply-algorithm by layerwise rewriting, roughly the same complexity bound is reached as in the classical algorithm. Moreover, a layerwise innermost strategy is defined and it is proved that the full classical algorithm for computing ROBDDs can be replaced by layerwise innermost rewriting without essentially affecting the complexity. Finally a lazy strategy is proposed sometimes performing much better than the traditional algorithm. © 2001 Elsevier Science Inc. All rights reserved.	algorithm;binary decision diagram;ccir system a;directed acyclic graph;lazy evaluation;rewriting	Hans Zantema;Jaco van de Pol	2001	J. Log. Algebr. Program.	10.1016/S1567-8326(01)00013-3	discrete mathematics;computer science;theoretical computer science;decision tree;mathematics;semi-thue system;confluence;binary decision diagram;algorithm	Logic	-15.488115164511857	18.07818925924006	186601
490fd0047a87dfff53a9600dd61a3167e37734f8	on a rewriting approach to satisfiability procedures: extension, combination of theories and an experimental appraisal	estensibilidad;probleme satisfiabilite;teoria demonstracion;theorie preuve;parametric test;proof theory;quantifier;satisfiabilite;logical programming;probleme terminaison;satisfiability;theorem proving;demonstration theoreme;theorem prover;programmation logique;rewriting systems;logique ordre 1;reecriture;problema satisfactibilidad;quantificateur;inferencia;prueba parametrica;termination problem;test parametrique;extensibilite;scalability;demostracion teorema;rewriting;cuantificador;programacion logica;empirical evaluation;satisfiability problem;systeme reecriture;problema terminacion;first order logic;inference;reescritura;satisfactibilidad;logica orden 1	The rewriting approach to T -satisfiability is based on establishing termination of a rewrite-based inference system for first-order logic on the T -satisfiability problem. Extending previous such results, including the quantifier-free theory of equality and the theory of arrays with or without extensionality, we prove termination for the theories of records with or without extensionality, integer offsets and integer offsets modulo. A general theorem for termination on combinations of theories, that covers any combination of the theories above, is given next. For empirical evaluation, the rewrite-based theorem prover E is compared with the validity checkers CVC and CVC Lite, on both synthetic and realworld benchmarks, including both valid and invalid instances. Parametric synthetic benchmarks test scalability, while real-world benchmarks test ability to handle huge sets of literals. Contrary to the folklore that a general-purpose prover cannot compete with specialized reasoners, the experiments are overall favorable to the theorem prover, showing that the rewriting approach is both elegant and practical.	adobe flash lite;automated theorem proving;experiment;first-order logic;first-order predicate;general-purpose modeling;inference engine;modulo operation;quantifier (logic);rewrite (programming);rewriting;scalability;semantic reasoner;synthetic intelligence;theory;uninterpreted function	Alessandro Armando;Maria Paola Bonacina;Silvio Ranise;Stephan Schulz	2005		10.1007/11559306_4	discrete mathematics;computer science;artificial intelligence;mathematics;automated theorem proving;programming language;algorithm	Logic	-15.142337448363701	16.433235881177506	187094
2e3ca0d37723b0f48308e84f6a9211d435373b30	communicating answer set programs	declarative programming;004;answer set programming;mathematics and statistics;multi agent;logic programming	Answer set programming is a form of declarative programming that has proven very successful in succinctly formulating and solving complex problems. Although mechanisms for representing and reasoning with the combined answer set programs of multiple agents have already been proposed, the actual gain in expressivity when adding communication has not been thoroughly studied. We show that allowing simple programs to talk to each other results in the same expressivity as adding negation-as-failure. Furthermore, we show that the ability to focus on one program in a network of simple programs results in the same expressivity as adding disjunction in the head of the rules.	answer set programming;computational complexity theory;declarative programming;disjunctive normal form;np-completeness;np-hardness;negation as failure;simulation;stable model semantics	Kim Bauters;Jeroen Janssen;Steven Schockaert;Dirk Vermeir;Martine De Cock	2010		10.4230/LIPIcs.ICLP.2010.34	declarative programming;stable model semantics;computer science;theoretical computer science;answer set programming;functional logic programming;inductive programming;programming language;logic programming;algorithm	AI	-18.278064214682185	13.02865836380318	187702
392798d3293da7204f8a2664dba45ab1366135df	solving equations involving sequence variables and sequence functions	modelizacion;symbolic computation;intelligence artificielle;automated reasoning;calculo simbolico;modelisation;unification;artificial intelligence;completitud;decidibilidad;inteligencia artificial;completeness;decidabilite;completude;modeling;calcul symbolique;unificacion;decidability	Term equations involving individual and sequence variables, and individual and sequence function symbols are studied. Function symbols can have either fixed or flexible arity. A new unification procedure for solving such equations is presented. Decidability of unification is proved. Completeness and almost minimality of the procedure is shown.	buchberger's algorithm;completeness (knowledge bases);logic programming;navier–stokes equations;pc bruno;unification (computer science);uninterpreted function	Temur Kutsia	2004		10.1007/978-3-540-30210-0_14	decidability;discrete mathematics;symbolic computation;systems modeling;completeness;computer science;artificial intelligence;unification;mathematics;automated reasoning;algorithm	AI	-16.058677805664743	15.355541193614734	187714
c515d8ad7e98f1120644f81bfb90e7dfa88dacdf	generating minimal herbrand models step by step	minimal model;automatic proving;search space;model generation;demostracion automatica;logical programming;theorem proving;demonstration automatique;demonstration theoreme;programmation logique;logique ordre 1;analisis semantico;demostracion teorema;analyse semantique;programacion logica;first order logic;semantic analysis;logica orden 1	This paper presents a way to improve minimal model generation for clausal theories. It works by breaking up the model generation process into several steps according to several parts of the given theory. It is shown that elimination of non-minimal or duplicate models can be performed after each step, which reduces the overall search space. An even stronger reduction of the search space is possible if we are interested only in certain parts of the models to be generated.#R##N##R##N#The techniques are applicable to any method for the generation of minimal Herbrand models. The paper goes into some detail how they can be integrated tightly into the PUHR tableau method.		Heribert Schütz	1999		10.1007/3-540-48754-9_23	discrete mathematics;computer science;artificial intelligence;first-order logic;mathematics;automated theorem proving;programming language;algorithm	Vision	-16.505367251249996	16.03231814261104	188184
8c1bba8afe24d28900bb7d81e71e2bce2bf41b87	real-time linear logic	real-time linear logic		linear logic;real-time transcription	James F. Peters	1994	Meth. of Logic in CS		dynamic logic;zeroth-order logic;linear temporal logic;logic optimization;diode–transistor logic;logic gate;logic family;intermediate logic;predicate functor logic;sequential logic;substructural logic	Logic	-14.568491541060435	13.664341143323504	188942
c8362c4bce65a791282f1c438501b7c3d2d8d157	an extension of computational logic			computational logic	Alan Rose	1952	J. Symb. Log.		dynamic logic;logic synthesis;logic optimization;horn clause;computability logic;computational resource;computational logic;mathematics;fair computational tree logic;substructural logic;multimodal logic	Logic	-14.624072069594597	13.574064795138657	188971
5dcd8beeaa83e5fe28c1c669408b7e4fd7b466c6	automated theorem proving in mathematics	knowledge based system;set theory;theorem prover;discrete geometry;cellular automata;linear space;automated theorem proving;knowledge base	TheMuscadet theorem prover is a knowledge-based system able to prove theorems in some non-trivial mathematical domains. The knowledge bases contain some general deduction strategies based onnatural deduction, mathematical knowledge and metaknowledge. Metarules build new rules, easily usable by the inference engine, from formal definitions. Mathematical knowledge may be general or specific to some particular field.Muscadet proved many theorems in set theory, mappings, relations, topology, geometry, and topological linear spaces. Some of the theorems were rather difficult.Muscadet is now intended to become an assistant for mathematicians in discrete geometry for cellular automata. In order to evaluate the difficulty of such a work, researchers were observed while proving some lemmas, andMuscadet was tested on easy ones. New methods have to be added to the knowledge base, such as reasoning by induction, but also new heuristics for splitting and reasoning by cases. It is also necessary to find good representations for some mathematical objects.	automata theory;automated theorem proving;cellular automaton;heuristic (computer science);inference engine;knowledge base;knowledge-based systems;mathematical induction;natural deduction;set theory	Dominique Pastre	1993	Annals of Mathematics and Artificial Intelligence	10.1007/BF01530801	discrete geometry;mathematical optimization;knowledge base;discrete mathematics;computer science;artificial intelligence;pure mathematics;mathematics;automated theorem proving;algorithm	AI	-18.360557305652296	17.231120750789017	189107
2452df9cdf08d8352398b428fc513c303067c797	core algebra revisited	parametric polymorphism;parametricite;category;categorie;theorie equationnelle;algebre noyau;parametricity;informatique theorique;polymorphism;reynolds;core algebra;polymorphisme;polimorfismo;equational theory;computer theory;teoria ecuacional;informatica teorica	Reynolds’s work in parametric polymorphism when specialized to a particular example gives rise to the notion of the core of a category and its associated equational theory of core algebras. c © 2007 Published by Elsevier B.V.	parametric polymorphism	Peter J. Freyd	2007	Theor. Comput. Sci.	10.1016/j.tcs.2006.12.033	polymorphism;parametric polymorphism;category;computer science;pure mathematics;parametricity;mathematics;programming language;algorithm	Logic	-12.457509680845513	17.529924178765725	189650
bb657b65fe84e764e0e502d3eda5017f1e7e93ca	non deterministic classical logic: the lambda-mu++-calculus		In this paper, we present an extension of $\lambda\mu$-calculus called $\lambda\mu^{++}$-calculus which has the following properties: subject reduction, strong normalization, unicity of the representation of data and thus confluence only on data types. This calculus allows also to program the parallel-or.	modal μ-calculus;non-deterministic turing machine	Karim Nour	2002	Math. Log. Q.	10.1002/1521-3870(200204)48:3%3C357::AID-MALQ357%3E3.0.CO;2-L		Theory	-11.934376574471942	14.476275408464652	189734
ab8aabdab1a478e68cf4b438588c5ce520b7f079	non-commutative intuitionistic linear logic	non commutative;linear logic		linear logic	V. Michele Abrusci	1990	Math. Log. Q.	10.1002/malq.19900360405	linear logic;higher-order logic;intuitionistic logic;intermediate logic;mathematics;minimal logic;programming language;truth value;substructural logic;second-order logic	Logic	-12.08414166460713	12.869760016247717	189864
66e10a19439d7ab65ae7d5f25c029489daf34759	lucid - a formal system for writing and proving programs	program proving;formal semantics;qa76 electronic computers computer science computer software;qa75 electronic computers computer science;formal systems	"""Lucid is both a programming language and a formal system for proving properties of Lucid programs. The programming language is unconventional in many ways, although programs are readily understood as using assignment statements and loops in a """"structured"""" fashion. Semantically, an assignment statement is really an equation between """"histories"""", and a whole program is simply an unordered set of such equations. From these equations, properties of the program can be derived by straightforward mathematical reasoning, using the Lucid formal system. The rules of this system are mainly those of first order logic, together with extra axioms and rules for the special Lucid functions. This paper formally describes the syntax and semantics of programs, and justifies the axioms and rules of the formal system. Key words, program proving, formal semantics, formal systems Introduction. Lucid is both a language in which programs can be written, and a formal system for proving properties of such programs. These properties are also expressed in Lucid. This is possible because a Lucid program is itself simply an unordered set of assertions, or axioms, from which other assertions may be derived by fairly conventional mathematical reasoning. The statements in Lucid programs are special cases of Lucid terms. In this paper we present the formal basis for Lucid, giving its semantics and justifying various axioms and rules of inference that are used in Lucid proofs. An informal introduction to Lucid can be found in [1], together with a discussion of implementation considerations. This paper will be rather formal, with motivating explanations and examples confined mainly to this introduction. The language considered here might be called Basic Lucid, since it does not include features like arrays and defined functions. Such extensions are considered in[l]. The main idea in Lucid is that programs should be """"denotational"""" and """"referentially transparent"""", even when they contain assignment statements. This means that all expressions in a program must mean something, and that two occurrences of the same expression in a program must denote the same """"something"""". Lucid achieves this aim, and yet manages to treat assignment statements as equations. (Thus, if a Lucid program contains the (assignment) statement Y X+ Z, every occurrence of Y in the program can be replaced by X+ Z, without changing the meaning of the program.) This is accomplished by considering the program to be talking about the """"histories"""" of the various variables. Semantically, all expressions in programs without nested loops will denote infinite sequences of * Received by the editors April 22, 1975, and in revised form November 20, 1975. """" Department of Computer Science, University of Waterloo, Waterloo, Ontario, Canada N2L 3G1. : Computer Science Department, University of Warwick, Coventry, England CV4 7AL. 336 D ow nl oa de d 12 /2 1/ 12 to 1 50 .1 35 .1 35 .7 0. R ed is tr ib ut io n su bj ec t t o SI A M li ce ns e or c op yr ig ht ; s ee h ttp :// w w w .s ia m .o rg /jo ur na ls /o js a. ph p"""	apl;array data structure;assertion (software development);assignment (computer science);augmented assignment;axiomatic system;command & conquer:yuri's revenge;computer science;control flow;first-order logic;formal system;formal verification;lucid;numerical aperture;operational amplifier;programming language;referential transparency;semantics (computer science);unordered associative containers (c++);waterloo	Edward A. Ashcroft;William W. Wadge	1976	SIAM J. Comput.	10.1137/0205029	formal system;formal methods;object language;formal verification;syntax;computer science;theoretical computer science;formal semantics;mathematics;programming language;algorithm	PL	-18.74115290149695	15.552899425438367	189957
018b8a2ab937f17a96fcda81271e53634396ab08	optimized translation of multi modal logic into predicate logic	second order;quantifier elimination;modal logic;first order	The functional translation from modal logic into first-order predicate logic is revised. Quantifier elimination of second-order predicates is used to translate almost arbitrary modal systems, i.e. not only modal formulae, but also characteristic Hilbert axioms, fully automatically into predicate logic. Various optimizations of the functional translation are investigated. They even permit the translation of modal systems like the McKinsey axiom, whose correspondence property of the accessibility relation is not first-order axiomatizable. Quantifier exchange rules are defined for modifying the translated Hilbert axioms and thus simplifying their transformation into theory unification algorithms.	modal logic	Hans Jürgen Ohlbach	1993		10.1007/3-540-56944-8_58	modal logic;dynamic logic;normal modal logic;modal μ-calculus;linear temporal logic;quantifier elimination;description logic;logic optimization;higher-order logic;intermediate logic;theoretical computer science;predicate functor logic;axiom s5;first-order logic;predicate variable;accessibility relation;multimodal logic;second-order logic;algorithm	Logic	-13.700049943650795	14.086537499379379	190174
13da07c5b84fcb8e5340d74847f88304d08245b5	formalizing non-termination of recursive programs	fixed point;xed point	In applicative theories the recursion theorem provides a term rec which solves recursive equations. However, it is not provable that a solution obtained by rec is minimal. In the present paper we introduce an applicative theory in which it is possible to define a least fixed point operator. Still, our theory has a standard recursion theoretic interpretation.	applicative programming language;divergence (computer science);fixed point (mathematics);fixed-point combinator;kleene's recursion theorem;least fixed point;provable security;recursion (computer science);theory	Reinhard Kahle;Thomas Studer	2001	J. Log. Algebr. Program.	10.1016/S1567-8326(01)00006-6	combinatorics;discrete mathematics;computer science;double recursion;mathematics;fixed point;mutual recursion;algorithm	PL	-12.417952337825904	16.28024779444744	190462
8236d97b564a215af75e9682f1e8e8a058f416db	some modifications of carnap's modal logic	carnap;modal logic;epistemic logic;possible worlds	In this paper, Carnap's modal logic C is reconstructed. It is shown that the Carnapian approach enables us to create some epistemic logics in a relatively straight-forward way. These epistemic modifications of C are axiomatized and one of them is compared with intuitionistic logic. At the end of the paper, some connections between this epistemic logic and Medvedev's logic of finite problems and inquisitive semantics are shortly discussed.	modal logic	Vít Puncochár	2012	Studia Logica	10.1007/s11225-012-9413-z	modal logic;predicate logic;dynamic logic;s5;normal modal logic;discrete mathematics;description logic;higher-order logic;epistemic modal logic;philosophy;epistemology;many-valued logic;intuitionistic logic;intermediate logic;predicate functor logic;axiom s5;computational logic;mathematics;possible world;epistemic possibility;accessibility relation;logic;term logic;multimodal logic;algorithm;philosophy of logic	Logic	-13.898259949779872	11.30029192574023	190660
cf7a102fe44c82f3bd0c48bca82e020a2ccc4586	semantic resolution for horn sets	resolution;interpretations;horn sets interpretations models semantic resolution;horn sets;semantic resolution;semantic;false positive;models	"""A new resolution strategy for Horn sets of clauses, each clause of which contains no more-than one positive literal, is presented which requires that in each resolution either one ancestor be a false positive unit or that one ancestor and the resolvent both be false. This strategy emphasizes """"relevant"""" positive units while controlling the explosive nonunit resolution. Some properties of interpretations for Horn sets are reviewed and used to significantly reduce the computation and storage required to implement semantic resolution for Horn sets."""	computation;literal (mathematical logic);resolution (logic);rough set	Lawrence J. Henschen	1975	IEEE Transactions on Computers	10.1109/TC.1976.1674700	arithmetic;resolution;type i and type ii errors;sld resolution;mathematics;algorithm;statistics	AI	-17.10322983007984	13.308453858129505	190814
440e0a2dd852c5a39e3c969e11d7c3732f007369	parameterised boolean equation systems	verification;sistema infinito;boolean equation;eliminacion;system modeling;lambda calculus;controle modele;parameterised boolean equation systems;equivalence;ecuacion booliana;infinite state systems;article letter to editor;boole algebra;modal logic;first order;model checking;informatique theorique;logique modale;boolean algebras;transition systems;logica modal;equation booleenne;lambda calculo;first order modal µ calculus;elimination;verificacion;external research report;first order modal μ calculus;lambda calcul;article in monograph or in proceedings;systeme infini;equivalencia;computer theory;infinite system;informatica teorica	Boolean equation system are a useful tool for verifying formulas from modal mu-calculus on transition systems (see [18] for an excellent treatment). We are interested in an extension of boolean equation systems with data. This allows to formulate and prove a substantially wider range of properties on much larger and even infinite state systems. In previous works [11, 15] it has been outlined how to transform a modal formula and a process, both containing data, to a so-called parameterised boolean equation system, or equation system for short. In this article we focus on techniques to solve such equation systems. We introduce a new equivalence between equation systems, because existing equivalences are not compositional. We present techniques similar to Gauß elimination as outlined in [18] that allow to solve each equation system provided a single equation can be solved. We give several techniques for solving single equations, such as approximation (known), patterns (new) and invariants (new). Finally, we provide several small but illustrative examples of verifications of modal mu-calculus formulas on concrete processes to show the use of the techniques.	approximation;automated reasoning;bellman equation;boolean algebra;clu;decision problem;eb-eye;expressive power (computer science);file binder;first-order logic;first-order predicate;first-order reduction;fixed point (mathematics);fixed-point combinator;formal system;gaussian elimination;invariant (computer science);iteration;kahn process networks;method of analytic tableaux;modal logic;modal μ-calculus;modality (human–computer interaction);model checking;overhead (computing);petri net;presburger arithmetic;recursion;regular expression;rewriting;smoothing;turing completeness;verification and validation	Jan Friso Groote;Tim A. C. Willemse	2005	Theor. Comput. Sci.	10.1016/j.tcs.2005.06.016	modal logic;equivalence;model checking;boolean algebra;combinatorics;discrete mathematics;verification;systems modeling;computer science;lambda calculus;first-order logic;mathematics;programming language;algorithm;elimination;algebra	Logic	-14.272654581792882	16.37440440608294	190908
2cb57fc2b5c9c545030bdc7a4a569e91c31ece72	explicitly typed lambda µ-calculus for polymorphism an call-by-value	preuve programme;program proof;lambda calculus;logical programming;programmation logique;informatique theorique;polymorphism;prueba programa;lambda calculo;polymorphisme;polimorfismo;lambda calcul;programacion logica;computer theory;informatica teorica	We introduce an explicitly typed λμ-calculus of call-by-value as a short-hand for the 2nd order Church-style. Our motivation comes from the observation that in Curry-style polymorphic calculi, control operators such as callcc or μ-operators cannot, in general, treat the terms placed on the control operator's left. Following the continuation semantics, we also discuss the notion of values in classical system, and propose an extended form of values. It is shown that the CPS-translation is sound with respect to A2 (2nd order λ-calculus). Next, we provide an explicitly and an implicitly typed Damas-Milner systems with μ-operators. Finally, we give a brief comparison with standard ML plus callcc, and discuss a natural way to avoid the unsoundness of ML with callcc.		Ken-etsu Fujita	1999		10.1007/3-540-48959-2_13	system f;polymorphism;typed lambda calculus;computer science;artificial intelligence;lambda calculus;simply typed lambda calculus;mathematics;programming language;algorithm	Logic	-13.230831872507167	17.69330707566965	192114
9835646ac3e9db084cb3fda69c583bc53fb67c7b	equator: a many-sorted prolog based on equational unification			han unification;prolog	Thierry Conrad	1988			equator;programming language;algorithm;unification;mathematics;prolog	NLP	-14.160610381349565	14.770891604283051	192302
b7d38c81e43ae3acfb787baf241cdcfe52075e46	the infinite-valued semantics: overview, recent results and future directions	negation in logic programming;preferential logic programming;infinite valued logics;semantics of programming languages	Abstract The infinite-valued semantics was introduced in Rondogiannis and Wadge (2005) as a purely logical way for capturing the meaning of well-founded negation in logic programming. The purpose of this paper is threefold: first, to give a non-technical introduction to the infinite-valued semantics; second, to discuss the applicability of the infinite-valued approach to syntactically richer extensions of logic programming; and third, to present the main open problems whose resolution would further enhance the applicability of the technique.		Panos Rondogiannis;Antonis Troumpoukis	2013	Journal of Applied Non-Classical Logics	10.1080/11663081.2013.798959	declarative programming;higher-order logic;principle of bivalence;horn clause;stable model semantics;negation as failure;game semantics;theoretical computer science;functional logic programming;formal semantics;mathematics;programming paradigm;inductive programming;fifth-generation programming language;programming language;well-founded semantics;prolog;logic programming;operational semantics;multimodal logic;denotational semantics;algorithm;semantics;autoepistemic logic	Logic	-15.283124490276872	14.705560994534466	192583
d15bf69b0467a3c8f403da821720c54ff40084ab	efficient handling of context dependency in the cached event calculus	mathematical analysis;context dependent;event calculus	This paper deals with the problem of providing temporal deductive databases with an eecient implementation in a logic programming framework. We restrict our attention to historical databases based on Kowalski and Sergot's Event Calculus extended with context-dependency. The paper aims at being beneecial to both the theoretically-minded and the implementation-oriented research communities. It provides a mathematical analysis of the computational complexity of query and update processing in the Event Calculus, and proposes a cached version of the calculus that moves computational complexity from query to update processing, and features an absolute improvement of performance when context-dependency is added.	computational complexity theory;consortium;const (computer programming);context-sensitive language;deductive database;event calculus;like button;logic programming;prolog	Luca Chittaro;Angelo Montanari	1994			calculus of communicating systems;cache;event calculus;process calculus;proof calculus;algorithm;computer science	AI	-16.72605566756677	14.43231484481512	192702
47e305cabb745c39f7ccd5dc83fd78959bb5c73c	spass & flotter version 0.42	inference rule	"""System Description FLOTTER 1 and SPASS 2 are a clause normal form translator for rst-order logic and a theorem prover for rst-order logic with equality, respectively. The algorithm implemented by FLOTTER includes an improved form of the renaming technique developed by Thierry Boy de la Tour 2], the optimized Skolemization technique by Ohlbach and Weidenbach 7] and some improvements leading to smaller Skolem function. SPASS is based on the superposition calculus developed by Bachmair and Ganzinger 1] extended with the sort techniques developed by Weidenbach 14, 15]. The superposition calculus relies on a reduction ordering which is total on ground terms. For SPASS we chose an extension of the well known Knuth-Bendix ordering, rst presented by Peterson 10]. In addition to the usual inference and reduction rules, SPASS includes a rule for case analysis, called splitting. 1 SPASS 1.1 Calculus A clause in SPASS has the form sort constraint atoms || antecedent atoms-> succedent atoms. with the semantics sort constraint atoms ^ antecedent atoms succedent atoms The inference rules equality resolution, equality factoring, superposition left and superposition right are applied to the antecedent and succedent literals with respect to the usual ordering restrictions 1]. However, their application is limited to clauses with a solved sort constraint. The sort constraint represents the sort restrictions on the variables. There are two extra inference rules which transform the sort constraint into solved form: Sort resolution and empty sort. These rules 1 The name is the result of a lunch break, FLOTTER means \faster"""", in German."""	automated theorem proving;conjunctive normal form;integer factorization;knuth–bendix completion algorithm;linear algebra;literal (mathematical logic);peterson's algorithm;quantum superposition;rewrite order;spass;skolem normal form;superposition calculus;whole earth 'lectronic link	Christoph Weidenbach;Bernd Gaede;Georg Rock	1996		10.1007/3-540-61511-3_75	computer science;artificial intelligence;rule of inference	Logic	-13.22206403425067	14.928195118177463	192766
a19c705e81006b4860e23d887b78e771691bd1d2	using proof theory to optimize proof search			automated theorem proving	Natarajan Shankar	1994			proof complexity;proof theory;discrete mathematics;computer-assisted proof;mathematics	Theory	-13.200311979497243	14.08370396497992	192823
1ce1dd19ebbbfe552b54054486086d020ca3275c	constraint cnf: sat and csp language under one roof	004;selected works;bepress;propositional satisfiability constraint programming	A new language, called constraint CNF, is proposed. It integrates propositional logic with constraints stemming from constraint programming. A family of algorithms is designed to solve problems expressed in constraint CNF. These algorithms build on techniques from both propositional satisfiability and constraint programming. The result is a uniform language and an algorithmic framework, which allow us to gain a deeper understanding of the relation between the solving techniques used in propositional satisfiability and in constraint programming and apply them together. 1998 ACM Subject Classification I.2.4 Knowledge Representation Formalisms and Methods	algorithm;answer set programming;automated reasoning;boolean satisfiability problem;conjunctive normal form;constraint learning;constraint programming;essence;knowledge representation and reasoning;propositional calculus;software propagation;solver;stable model semantics;stemming;venue (sound system);warez	Broes De Cat;Yuliya Lierler	2016		10.4230/OASIcs.ICLP.2016.12	constraint logic programming;concurrent constraint logic programming;constraint programming;binary constraint;constraint satisfaction;constraint learning;constraint graph;complexity of constraint satisfaction;propositional variable;fifth-generation programming language;programming language;satisfiability modulo theories;constraint satisfaction problem;algorithm;hybrid algorithm	AI	-17.767078541073065	15.071926521837655	192917
5cd251d52e799e0ab6e668352d10b5fd527f355d	languages for polynomial-time queries - an ongoing quest	first order;polynomial time;logic in computer science	References 1] S. Abiteboul and V. Vianu. Fixpoint extensions of rst-order logic and Datalog-like languages.	datalog;fixed point (mathematics);time complexity;victor vianu	Phokion G. Kolaitis	1995		10.1007/3-540-58907-4_4	time complexity;computer science;theoretical computer science;first-order logic;computational logic;ontology language;algorithm	Logic	-15.07541383496721	14.2579878257559	192967
7bc65376cbb8bc6eacb8edd1c06289a0b848af08	a science of reasoning (extended abstract)		How can we understand reasoning in general and mathematical proofs in particular? It is argued that a high-level understanding of proofs is needed to complement the low-level understanding provided by Logic. A role for computation is proposed to provide this high-level understanding, namely by the association of proof plans with proofs. Criteria are given for assessing the association of a proof plan with a proof. 1 Motivation: The Understanding of Mathematical Proofs We argue that Logic1 is not enough to understand reasoning. It provides only a low-level, step by step understanding, whereas a high-level, strategic understanding is also required. Many commonly observed phenomena of reasoning cannot be explained without such a high-level understanding. Furthermore, automatic reasoning is impractical without a high-level understanding. We propose a science of reasoning which provides both a lowand a highlevel understanding of reasoning. It combines Logic with the concept of proof plans, [Bundy, 1988]. We illustrate this with examples from mathematical reasoning, but it is intended that the science should eventually apply to all kinds of reasoning. 2 The Need for Higher-Level Explanations A proof in a logic is a partially ordered set of formulae where each formula in the set is either an axiom or is derived from earlier formulae in the set by a rule of inference. Each mathematical theory defines what it means to be a formula, an axiom or a rule of inference. Thus Logic provides a low-level explanation of a mathematical proof. It explains the proof as a sequence of steps and shows how ? The research reported in this paper was supported by EPSRC grant GR/L/11724. I would like to thank two anonymous referees and other members of the mathematical reasoning group at Edinburgh for feedback, especially Richard Boulton, Mitch Harris, Colin Phillips, Frank van Harmelen and Toby Walsh. The full version of this extended abstract appeared in [Bundy, 1991]. 1 We adopt the convention of using uncapitalised ‘logic’ for the various mathematical theories and capitalised ‘Logic’ for the discipline in which these logics are studied. H. de Swart (Ed.): TABLEAUX’98, LNAI 1397, pp. 10–17, 1998. c © Springer-Verlag Berlin Heidelberg 1998 A Science of Reasoning 11 each step follows from previous ones by a set of rules. Its concerns are limited to the soundness of the proof, and to the truth of proposed conjectures in models of logical theories. While Logic provides an explanation of how the steps of a proof fit together, it is inadequate to explain many common observations about mathematical proofs. – Mathematicians distinguish between understanding each step of a proof and understanding the whole proof. – Mathematicians recognise families of proofs which contain common structure. – Mathematicians distinguish between ‘interesting’ and ‘standard’ steps of a proof. – Mathematicians describe proofs to each other at different levels of detail. Their high level descriptions contain only very brief summaries of standard steps but give more detail about the interesting ones. – Mathematicians use their experience of previously encountered proofs to help them discover new proofs. – Mathematicians often have an intuition that a conjecture is true, but this intuition is fallible. – Students of mathematics, presented with the same proofs, learn from them with varying degrees of success. 3 Common Structure in Proofs Several researchers in automatic theorem proving have identified common structure in families of proofs. For instance, – [Bundy & Welham, 1981] describes the common structure in solutions to symbolic equations. This common structure was implemented in a process of meta-level inference which guided the search for solutions to equations. – [Bundy et al, 1988] describes the common structure in inductive theorems about natural numbers, lists, etc. This common structure was implemented as an inductive proof plan which was used to guide the search for proofs of such theorems. – [Bledsoe et al, 1972] describes the common structure in theorems about limits of functions in analysis. This common structure was implemented as the limit heuristic and used to guide the search for proofs of such theorems. – [Wos & McCune, 1988] describes the common structure in attempts to find fixed-points combinators. This common structure was implemented as the kernel method and used to guide the search for such fixed-points. – [Polya, 1965] describes the common structure in ruler and compass constructions. This common structure was implemented by [Funt, 1973] and used to guide the search for such constructions. – [Huang et al, 1995] and [Gow, 1997] describe the common structure in diagonalization proofs. This common structure has been implemented (twice) as a diagonalization proof plan and used to guide the proofs of a variety of theorems.	automated reasoning;automated theorem proving;combinatory logic;hadamard transform;harris affine region detector;heuristic;high- and low-level;high-level programming language;kernel method;lecture notes in computer science;level of detail;mathematical induction;plan 9 from bell labs;springer (tank);symbolic computation;theory;toby turner	Alan Bundy	1998		10.1007/3-540-69778-0_2	computer-assisted proof;theoretical computer science;proof theory;mathematics;mathematical proof;proof assistant;structural proof theory;proof complexity;algorithm;statistical proof	AI	-18.974244834635513	17.423337561928356	192975
5b9a5b9f44db8b8c1fbf7a86e43f31c14f0fba84	specifying properties of basic lotos processes using temporal logic	basic lotos;temporal logic;modal -calculus;basic lotos specification and verification;specifying properties;partial specification;data type;process algebra	Temporal logic can be used to describe desirable properties of a system in a more abstract, less constructive, manner than when using process algebra alone. This is a well researched area for other process algebras, but not so for LOTOS. This paper is an initial attempt to fill that gap by investigating the use of the modal -calculus with Basic LOTOS, laying the groundwork for current work on Full LOTOS, i.e. including data types, and logic.	language of temporal ordering specification;modal logic;process calculus;temporal logic	Carron Kirkwood	1995			process calculus;linear temporal logic;description logic;temporal logic;data type;interval temporal logic;computation tree logic;computer science;theoretical computer science;programming language;multimodal logic;algorithm;language of temporal ordering specification;temporal logic of actions	Logic	-15.659418042265884	17.358012959913022	193074
42d18b237fe93649aefe5ce20535528f9a7dc918	conditional xpath, the first order complete xpath dialect	temporal logic;universiteitsbibliotheek;expressive power;first order;xml document;first order logic	"""XPath is the W3C -- standard node addressing language for XML documents. XPath is still under development and its technical aspects are intensively studied. What is missing at present is a clear characterization of the expressive power of XPath, be it either semantical or with reference to some well established existing (logical) formalism. Core XPath (the logical core of XPath 1.0 defined by Gottlob et al.) cannot express queries with conditional paths as exemplified by """"do a child step, while test is true at the resulting node."""" In a first-order complete extension of Core XPath, such queries are expressible, We add conditional axis relations to Core XPath and show that the resulting language, called conditional XPath, is equally expressive as first-order logic when interpreted on ordered trees. Both the result, the extended XPath language, and the proof are closely related to temporal logic. Specifically, while Core XPath may be viewed as a simple temporal logic, conditional XPath extends this with (counterparts of) the since and until operators."""	apache axis;expressive power (computer science);first-order logic;first-order predicate;formal system;temporal logic;xml;xpath	Maarten Marx	2004		10.1145/1055558.1055562	computer science;xpath 2.0;path expression;first-order logic;database;programming language;algorithm	DB	-16.548460676130347	16.762285679612546	193215
5292ffda015c690721cfc021e1f16376a7eb4407	finite model reasoning in horn-shiq		Finite model reasoning in expressive DLs such as ALCQI and SHIQ requires non-trivial algorithmic approaches that are substantially differerent from algorithms used for reasoning about unrestricted models. In contrast, finite model reasoning in the inexpressive fragment DL-LiteF of ALCQI and SHIQ is algorithmically rather simple: using a TBox completion procedure that reverses certain terminological cycles, one can reduce finite subsumption to unrestricted subsumption. In this paper, we show that this useful technique extends all the way to the popular and much more expressive Horn-SHIQ fragment of SHIQ.	algorithm;conjunctive query;horn clause;subsumption architecture;tbox	Yazmin Angélica Ibáñez-García;Carsten Lutz;Thomas Schneider	2013			discrete mathematics;reasoning system;mathematics	AI	-17.018787304350436	12.604959841347839	193254
da72926dd34395e235e058b092421aafde5098ff	optimization in temporal qualitative constraint networks		Various formalisms for representing and reasoning about temporal information with qualitative constraints have been studied in the past three decades. The most known are definitely the Point Algebra $$(\mathsf {PA})$$ ( PA ) and the Interval Algebra $$({\mathsf {IA}})$$ ( IA ) proposed by Allen. In this paper, for both calculi, we study a problem that we call the minimal consistency problem $$(\mathsf {MinCons})$$ ( MinCons ) . Given a temporal qualitative constraint network $$(\mathsf {TQCN})$$ ( TQCN ) and a positive integer $$k$$ k , this problem consists in deciding whether or not this $$\mathsf {TQCN}$$ TQCN admits a solution using at most $$k$$ k distinct points on the line.We show that $$\mathsf {MinCons}$$ MinCons for $$\mathsf {PA}$$ PA can be encoded into the finitary versions of Gödel logic. Furthermore, we prove that the $$\mathsf {MinCons}$$ MinCons problem is $$\mathsf {NP}$$ NP -complete for both $$\mathsf {PA}$$ PA and $${\mathsf {IA}}$$ IA , in the general case. However, we show that for $$\mathsf {TQCN}$$ TQCN s defined on the convex relations, $$\mathsf {MinCons}$$ MinCons is polynomial. For such $$\mathsf {TQCN}$$ TQCN s, we give a polynomial method that allows one to obtain compact scenarios.	allen's interval algebra;approximation algorithm;artificial intelligence;certificate authority;cobham's thesis;gödel logic;iterative method;local consistency;logical framework;morgan;np-completeness;polynomial;social constructivism;software propagation;temporal logic;time complexity	Jean-François Condotta;Souhila Kaci;Yakoub Salhi	2015	Acta Informatica	10.1007/s00236-015-0228-z	discrete mathematics;topology;calculus;mathematics	AI	-12.687073806057727	14.212177151779986	193308
94f04fd2a07894c818c8855b334ac23c67e1774a	automatic derivation of the irrationality of e	infinite series;automatic generation;inference rule	Abstract   As part of a project on automatic generation of proofs involving both logic and computation, we have automatically generated a proof of the irrationality of e. The proof involves inequalities, bounds on infinite series, type distinctions (between real numbers and natural numbers), a subproof by mathematical induction, and significant mathematical steps, including correct simplification of expressions involving factorials and summing an infinite geometrical series. Metavariables are instantiated by inference rules embodying mathematical knowledge, rather than only by unification. The proof is generated completely automatically, without any interactive component.		Michael Beeson	1999	Electr. Notes Theor. Comput. Sci.	10.1016/S1571-0661(05)80613-9	discrete mathematics;computer science;mathematics;series;algorithm;rule of inference	Theory	-17.919096905628674	17.80340315058852	194129
93da4c80c96c1505528980edcce6f4728862e164	system f2lp - computing answer sets of first-order formulas	answer sets;event calculus;answer set programming;stable models;rule based;first order;stable model semantics	We present an implementation of the general language of stable models proposed by Ferraris, Lee and Lifschitz. Under certain conditions, system f2lp turns a first-order theory under the stable model semantics into an answer set program, so that existing answer set solvers can be used for computing the general language. Quantifiers are first eliminated and then the resulting quantifier-free formulas are turned into rules. Based on the relationship between stable models and circumscription, f2lp can also serve as a reasoning engine for general circumscriptive theories. We illustrate how to use f2lp to compute the circumscriptive event calculus.	answer set programming;circumscription (logic);event calculus;first-order logic;first-order predicate;quantifier (logic);semantic reasoner;stable model semantics;vladimir lifschitz	Joohyung Lee;Ravi Palla	2009		10.1007/978-3-642-04238-6_51	rule-based system;stable model semantics;computer science;artificial intelligence;answer set programming;first-order logic;event calculus;algorithm	AI	-16.49613737660917	12.138916203518637	194305
0cd420f6fc6e0c4ad960b342abed32a8348fce6e	sequence unification through currying	information extraction;program transformation;rule based programming;xml document	Sequence variables play an interesting role in unification and matching when dealing with terms in an unranked signature. Sequence Unification generalizes Word Unification and seems to be appealing for information extraction in XML documents, program transformation, and rule-based programming. In this work we study a relation between Sequence Unification and another generalization of Word Unification: Context Unification. We introduce a variant of Context Unification, called Left-Hole Context Unification that serves us to reduce Sequence Unification to it: We define a partial currying procedure to translate sequence unification problems into left-hole context unification problems, and prove soundness of the translation. Furthermore, a precise characterization of the shape of the unifiers allows us to easily reduce Left-Hole Context Unification to (the decidable problem of) Word Unification with Regular Constraints, obtaining then a decidability proof for an extension of Sequence Unification.	admissible rule;curry;currying;decision problem;emoticon;han unification;information extraction;logic programming;program transformation;tip (unix utility);unification (computer science);xml	Temur Kutsia;Jordi Levy;Mateu Villaret	2007		10.1007/978-3-540-73449-9_22	discrete mathematics;xml;computer science;unification;mathematics;programming language;information extraction;algorithm	AI	-15.282270951696304	15.321279446824507	194380
352a9a2666cd50802cfddf3f4d9c21388846e4f8	the connection between axiomatic and denotational semantics of programming languages	programming language;denotational semantic	Systems of proof rules are sometimes called “axiomatic semantics”, and are developed from intuitively or explicitly known, e.g. denotational or operational, semantical models. Reversely, it has so far not been clear under what conditions systems of proof rules actually do specify the semantics of a programming language. This is clarified by the following results: rnrn1.rnrnThere are conditions s.t. a system of proof rules is a syntactic specification of a predicate transformer semantics (PTS).rnrnrnrnrn2.rnrnDenotational semantics (DS) and PTS may both constitute forward or backward semantics, depending on whether initial states resp. pre-conditions are transformed into final states resp. post-conditions, or reversely.rnrnrnrnrn3.rnrnAny proper axiomatic semantics has the ws-property, i.e. any pre- is transformed into a strongest post-condition, and any post-condition is transformed into a weakest pre-condition.rnrnrnrnrn4.rnrn[ws-Lemma] For any pre- resp, post-conditions P.Q which are tight w.r.t. a construct cs: P is weakest pre-condition of Q iff Q is strongest post-condition of P (w.r.t.cs).rnrnrnrnrn5.rnrnForward DS and forward/backward PTS can be transformed into each other so that DS and PTS are equivalent specifications of semantics.	denotational semantics;programming language;semantics (computer science)	Peter Raulefs	1978		10.1007/978-3-642-87956-2_13	apply;normalisation by evaluation;action semantics;programming domain;computer science;theoretical computer science;functional logic programming;domain theory;programming paradigm;inductive programming;fifth-generation programming language;programming language theory;programming language;denotational semantics of the actor model;operational semantics;second-generation programming language;comparison of multi-paradigm programming languages;denotational semantics;algorithm	PL	-15.166450395885795	18.017390483416065	194733
38277e8a08f8ffb759121e38c19108abd5bd3fbd	symbolic constraint handling through unification in finite algebras	finite domain;development environment;constraint handling;constraint satisfaction problem;digital circuits	The constraint satisfaction problem (CSP) over finite domains is reduced to unification in finite algebras. A CSP defines a unification problem with a most general unifier that naturally expresses the solution of the given CSP in symbolic form. The approach is based on a unitary unification algorithm for arbitrary finite algebras, which is presented. The unification algorithm has been incorporated in the experimental Prolog system PROLOG-XT, which has been successfully applied to the verification of large combinatorial digital circuits, and is now in use in an industrial circuit development environment.	admissible rule;algorithm;constraint satisfaction problem;digital electronics;prolog;unification (computer science)	Wolfram Büttner;Klaus Estenfeld;Richard Schmid;Hans-Albert Schneider;Erik Tidén	1990	Applicable Algebra in Engineering, Communication and Computing	10.1007/BF01810294	constraint logic programming;combinatorics;discrete mathematics;constraint satisfaction;mathematics;development environment;constraint satisfaction problem;digital electronics;algebra	AI	-17.167412111683323	17.487480276374896	196102
1c80c617271ab39b17c64c16d29968859d4bbbe9	description logics over multisets	extended description logics;satisfiability;classical description logics;multisets	Description Logics (DLs) are a family of knowledge representation languages that have gained considerable attention the last 20 years. It is wellknown that the interpretation domain of classical DLs is a classical set. However, in Science and in the ordinary life the situation is not at all like this. In order to handle these types of knowledge in DLs, in this paper we present a DL framework based on multiset theory. Concretely, we present the DL over multisets ALCmsets which is a semantic extension of the classical DL ALC. The syntax and semantics of ALCmsets are presented. Moreover, we investigate the logical properties of ALCmsets and provide a sound and terminating reasoning algorithm for satisfiability problem of ALCmsets.	algorithm;boolean satisfiability problem;cartesian closed category;description logic;knowledge representation and reasoning;mathematical optimization;newman's lemma	Yuncheng Jiang	2010			discrete mathematics;mathematics;algorithm	AI	-15.686921221913758	12.587403162836463	196222
9193ea815238d9cf860ed537528b83a38a934081	satisfiability checking and query answering for large ontologies		In this paper we develop a sound, complete and terminating superposition calculus plus a query answering calculus for the BSH-Y2 fragment of the Bernays – Schönfinkel Horn class of first-order logic. BSH-Y2 can be used to represent expressive ontologies. In addition to checking consistency, our calculus supports query answering for queries with arbitrary quantifier alternations. Experiments on BSH-Y2 (fragments) of several large ontologies show that our approach advances the state of the art.	beanshell;bernays–schönfinkel class;first-order logic;first-order reduction;newman's lemma;ontology (information science);quantifier (logic);superposition calculus;year 2000 problem	Christoph Weidenbach;Patrick Wischnewski	2012			theoretical computer science;satisfiability;mathematics;ontology (information science)	AI	-14.171237804983184	14.760726025397245	197072
814c9ca371af30cc9fb0285ac3e79bcffbfd6502	classes of first order formulas under various satisfiability definitions	relational database;satisfiability;first order;logic programs;first order logic	In this paper we consider some special satisfiability problems of first order logic. We study effects of a unique name assumption and a domain closure assumption on complexity of satisfiability tests for certain classes of formulas interesting in logic programming or relational database theory. It is shown that the last assumption simplifies the satisfiability problem for first order logic. However for classes of formulas with lower complexity of the unrestricted satisfiability problem no general reduction of complexity can be determined.		Hans Kleine Büning;Theodor Lettmann	1986		10.1007/3-540-16780-3_119	dynamic logic;combinatorics;discrete mathematics;description logic;computer science;first-order logic;mathematics;programming language;algorithm	DB	-13.71108127294022	15.368314215354234	197290
f73d196b8e84ecbd531127c83ffbcde0b3a81f5f	tableaux for structural abduction			abductive reasoning	Ángel Nepomuceno-Fernández;Francisco J. Salguero-Lamillar;David Fernández-Duque	2012	Logic Journal of the IGPL	10.1093/jigpal/jzq054	discrete mathematics;mathematics	Logic	-12.727103882511917	11.548116321987667	197539
97c21dc82d11dcd31ab0fc1fdc26d0b57b155a9f	the mathematics of dispatchability revisited	formalism;controllability;computer programs;sequencing;dynamic characteristics;mathematical models;scheduling;schedules;algorithms;control;consistency	Dispatchability is an important property for the efficient execution of temporal plans where the temporal constraints are represented as a Simple Temporal Network (STN). It has been shown that every STN may be reformulated as a dispatchable STN, and dispatchability ensures that the temporal constraints need only be satisfied locally during execution. Recently it has also been shown that Simple Temporal Networks with Uncertainty, augmented with wait edges, are Dynamically Controllable provided every projection is dispatchable. Thus, the dispatchability property has both theoretical and practical interest. One thing that hampers further work in this area is the underdeveloped theory. The existing definitions are expressed in terms of algorithms, and are less suitable for mathematical proofs. In this paper, we develop a new formal theory of dispatchability in terms of execution sequences. We exploit this to prove a characterization of dispatchability involving the structural properties of the STN graph. This facilitates the potential application of the theory to uncertainty reasoning.	algorithm;super-twisted nematic display	Paul Henry Morris	2016			mathematical optimization;discrete mathematics;controllability;schedule;computer science;theoretical computer science;operating system;sequencing;mathematical model;mathematics;consistency;scheduling;formalism;scientific control	DB	-16.67856935034002	12.301198493368451	197570
d1ecd587f7f7b58f471341e7866ec29caa9a1a04	a simple fixpoint argument without the restriction to continuity	lenguaje de programacion;programming language semantics;repetition;programming language;predicate transformer;semantics;punto fijo;semantica;semantique;point fixe;langage programmation;repeticion;weakest precondition;fix point	In programming language semantics, the introduction of unbounded nondeterminacy, which amounts to the introduction of noncontinuous predicate transformers, is needed for dealing with such concepts as fair interleaving. With the semantics of the repetition given as the strongest solution of a fixpoint equation, the weakest precondition expressed in closed form would then require transfinite ordinals. Here, however, it is shown that, even in the case of unbounded nondeterminacy, the fundamental theorem about the repetition can be proved by a simple and quite elementary argument.	fixed point (mathematics);forward error correction;precondition;predicate transformer semantics;programming language;scott continuity;semantics (computer science);transfinite induction;transformers;unbounded nondeterminism	Edsger W. Dijkstra;A. J. M. van Gasteren	1986	Acta Informatica	10.1007/BF00268074	discrete mathematics;computer science;mathematics;semantics;predicate transformer semantics;programming language;algorithm	Theory	-12.262427369584001	17.39882797454873	197663
a27ee1b434cf9febbdf61b0c4986eb3811ca0561	partial equilibrium logic	well founded semantics;logic programming;nonmonotonic reasoning;stable model semantics;partial equilibrium;logic programs;03b60;03b55;nonclassical logics;partial equilibrium logic;68t27	Partial equilibrium logic (PEL) is a new nonmonotonic reasoning formalism closely aligned with logic programming under well-founded and partial stable model semantics. In particular it provides a logical foundation for these semantics as well as an extension of the basic syntax of logic programs. In this paper we describe PEL, study some of its logical properties and examine its behaviour on disjunctive and nested logic programs. In addition we consider computational features of PEL and study different approaches to its computation.	computation;disjunctive normal form;logic gate;logic programming;non-monotonic logic;operational semantics;semantics (computer science);stable model semantics	Pedro Cabalar;Sergei P. Odintsov;David Pearce;Agustín Valverde	2007	Annals of Mathematics and Artificial Intelligence	10.1007/s10472-007-9075-0	predicate logic;dynamic logic;partial equilibrium;discrete mathematics;classical logic;description logic;higher-order logic;horn clause;stable model semantics;many-valued logic;computer science;intermediate logic;theoretical computer science;bunched logic;non-monotonic logic;predicate functor logic;computational logic;mathematics;programming language;axiomatic semantics;well-founded semantics;logic programming;substructural logic;multimodal logic;algorithm;philosophy of logic;autoepistemic logic	AI	-14.843870609824716	12.642311679904937	197987
f812d6db91174106b14f836387a4885612d8a906	answer set programming and its applications in planning and multi-agent systems		The paper presents some applications in planning and multi-agent systems of answer set programming. It highlights the benefits of answer set programming based techniques in these applications. It also describes a class of multi-agent planning problems that is challenging to answer set programming.	answer set programming;multi-agent system	Tran Cao Son	2017		10.1007/978-3-319-61660-5_3	theoretical computer science;inductive programming;computer science;programming paradigm;answer set programming;multi-agent system;symbolic programming	AI	-18.66874218042344	12.973856014781667	198388
2bde7aa703f3bbd05a677bc2a1d7d1f2a5b6d625	modgen: theorem proving by model generation	generic model;model generation;theorem proving;first order;first order logic	ModGen (Model Generation) is a complete theorem prover for rst order logic with nite Herbrand domains. ModGen takes rst order formulas as input, and generates models of the input formulas. ModGen consists of two major modules: a module for transforming the input formulas into propositional clauses, and a module to nd models of the propositional clauses. The rst module can be used by other researchers so that the SAT problems can be easily represented , stored and communicated. An important issue in the design of ModGen is to ensure that transformed propositional clauses are satissable ii the original formulas are. The second module can be easily replaced by any advanced SAT problem solver. Mod-Gen is easy to use and very eecient. Many problems which are hard for general resolution theorem provers are found easy for ModGen.	automated theorem proving;boolean satisfiability problem;resolution (logic);solver	Sun Kim;Hantao Zhang	1994			herbrand's theorem;resolution;horn-satisfiability;computer science;artificial intelligence;first-order logic;automated theorem proving;propositional variable;algorithm	AI	-17.59510666230733	17.406465755234485	198632
63d43685d463872cf933d641dad0c473426b81a8	a survey of some methods for real quantifier elimination, decision, and satisfiability and their applications		Effective quantifier elimination procedures for first-order theories provide a powerful tool for generically solving a wide range of problems based on logical specifications. In contrast to general first-order provers, quantifier elimination procedures are based on a fixed set of admissible logical symbolswith an implicitly fixed semantics. This admits the use of sub-algorithms from symbolic computation. We are going to focus on quantifier elimination for the reals and its applications giving examples from geometry, verification, and the life sciences. Beyond quantifier elimination we are going to discuss recent results with a subtropical procedure for an existential fragment of the reals. This incomplete decision procedure has been successfully applied to the analysis of reaction systems in chemistry and in the life sciences.	algorithm;decision problem;first-order predicate;quantifier (logic);symbolic computation	Thomas Sturm	2017	Mathematics in Computer Science	10.1007/s11786-017-0319-z	combinatorics;discrete mathematics;quantifier elimination;computer science;mathematics;existential quantification;algorithm;algebra	Logic	-15.105678126771165	17.11804424163039	198724
e74707c98d636e19ab919601bf1b43b33e1c86b4	rewrite rule systems for modal propositional logic	rewrite rule;propositional logic	D This paper explains new results relating modal propositional logic and rewrite rule systems. More precisely, we give complete term rewriting systems for the modal propositional systems known as K, Q, T, and S5. These systems are presented as extensions of Hsiang’s system for classical propositional calculus. We have checked local confluence with the rewrite rule system K.B. (cf. the Knuth-Bendix algorithm) developed by the Formel project at INRIA. We prove that these systems are noetherian, and then infer their confluence from Newman’s lemma. Therefore each term rewriting system provides a new automated decision procedure and defines a canonical form for the corresponding logic. We also show how to characterize the canonical forms thus obtained.	confluence (abstract rewriting);decision problem;knuth–bendix completion algorithm;modal logic;newman's lemma;propositional calculus;rewrite (programming);rewriting;s5 (modal logic)	Annie Foret	1992	J. Log. Program.	10.1016/0743-1066(92)90028-2	modal logic;propositional formula;dynamic logic;zeroth-order logic;absorption;modal μ-calculus;discrete mathematics;classical logic;resolution;intuitionistic logic;computer science;intermediate logic;axiom s5;mathematics;negation introduction;propositional variable;well-formed formula;propositional calculus;confluence;algorithm;rule of inference;autoepistemic logic	Logic	-12.904575040215658	14.402301958535443	198743
4bbe571e47413271f978f3f310311fe48388edec	an improved refutation system for intuitionistic predicate logic	kripke model;intuitionistic logic	In this paper a refutation calculus for intuitionistic predicate logic is presented where the necessity of duplicating formulas to which rules are applied is analyzed. In line with the semantics of intuitionistic logic in terms of Kripke models a new signF C beside the SignsT andF is added which reduces the size of the proofs and the involved nondeterminism. The resulting calculus is proved to be correct and complete. An extension of it for Kuroda logic is given.	intuitionistic logic;kripke semantics;kuroda normal form	Pierangelo Miglioli;Ugo Moscato;Mario Ornaghi	1994	Journal of Automated Reasoning	10.1007/BF00881949	modal logic;predicate logic;zeroth-order logic;linear logic;discrete mathematics;higher-order logic;many-valued logic;intuitionistic logic;computer science;intermediate logic;predicate functor logic;axiom s5;negation;mathematics;proof calculus;predicate variable;minimal logic;curry–howard correspondence;monadic predicate calculus;programming language;kripke semantics;truth value;natural deduction;logic;algorithm	Logic	-12.099641759359015	13.999763692752506	198761
66b4fd415c0c2b386422117c324237caa364a0a1	combining syntax and semantics through prime form representation	model counting;belief revision;knowledge compilation;prime implicants;knowledge representation	This article presents an algorithm that, besides calculating the number of models of a propositional logic theory, also determines the distribution of these models among the terms of a disjunctive normal form representation of the theory. Using prime implicants to represent the target theory, in a knowledge compilation context, we discuss how this distribution can be used to define belief change operators that respect the theory structure. Some experimental results are also presented.	algorithm;compiler;disjunctive normal form;knowledge compilation;propositional calculus;theory (mathematical logic)	Guilherme Bittencourt	2008	J. Log. Comput.	10.1093/logcom/exm051	knowledge representation and reasoning;implicant;discrete mathematics;computer science;artificial intelligence;mathematics;belief revision;algorithm	AI	-15.014970914255645	11.922766936274849	199705
87d73a4bba48e2a52d150cdfa05fef5a7f399a2e	alpha-structural induction and recursion for the lambda calculus in constructive type theory	formal metatheory;substitution;lambda calculus;constructive type theory	We formulate principles of induction and recursion for a variant of lambda calculus in its original syntax (i.e., with only one sort of names) where α-conversion is based upon name swapping as in nominal abstract syntax. The principles allow to work modulo α-conversion and implement the Barendregt variable convention. We derive them all from the simple structural induction principle on concrete terms and work out applications to some fundamental meta-theoretical results, such as the substitution lemma for α-conversion and the lemma on substitution composition. The whole work is implemented in Agda.		Ernesto Copello;Alvaro Tasistro;Nora Szasz;Ana Bove;Maribel Fernández	2016	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2016.06.008	system f;intuitionistic type theory;typed lambda calculus;discrete mathematics;dependent type;binary lambda calculus;pure type system;computer science;lambda calculus;simply typed lambda calculus;mathematics;hindley–milner type system;programming language;church encoding;lambda cube;algorithm;change of variables	PL	-12.723735136628685	17.67301053418702	199763
5235f54bbdaf42960c5d8fa21de2cbb73b30ce98	first-order glue	second order;first order linear logic;compositional semantics;first order;typing systems;syntax semantics interface;glue;linear logic	Glue has evolved significantly during the past decade. Although the recent move to type-theoretic notation was a step in the right direction, basing the current Glue system on System F (second-order λ-calculus) was an unfortunate choice. An extension to two sorts and ad hoc restrictions were necessary to avoid inappropriate composition of meanings. As a result, the current system is unnecessarily complicated. A first-order Glue system is hereby proposed as its replacement. This new system is not only simpler and more elegant as it captures the exact requirements for Gluestyle compositionality without ad-hoc improvisations, but it also turns out to be more powerful than the current two-sorted (pseudo-) secondorder system. First-order Glue supports all existing Glue analyses as well as more elegant alternatives. It also supports new, more demanding analyses.	dick smith (software);first-order predicate;glue code;hoc (programming language);lambda calculus;lexical functional grammar;linear logic;natural language;requirement;system f;type theory	Miltiadis Kokkonidis	2008	Journal of Logic, Language and Information	10.1007/s10849-006-9031-0	linear logic;computer science;artificial intelligence;theoretical computer science;adhesive;first-order logic;programming language;second-order logic;algorithm;principle of compositionality	PL	-17.476663392876148	18.198087519229194	199797
