id	title	keywords	abstract	entities	authors	year	journal	doi	fos	area	x	y	ix
0c0c1c86921a938cbd37651cc8419c434fa91eeb	an efficient compilation framework for languages based on a concurrent process calculus	lenguaje programacion;programming language;computability;dynamical processes;concurrent program;object oriented;calculabilite;programa competidor;langage programmation;oriente objet;communication channels;orientado objeto;concurrent process;calculabilidad;programme concurrent	We propose a framework for compiling programming languages based on concurrent process calculi, in which computation is expressed by a combination of processes and communication channels. Our framework realizes a compile-time process scheduling and unboxed channels. The compile-time scheduling enables us to execute multiple independent processes without a scheduling pool operation. Unboxed channels allow us to create a channel without memory allocations and to communicate values on registers. The framework is given as a set of translation rules from a concurrent calculus to an ML-like sequential program. Experimental results show that our compiler can execute sequential programs written in the process calculus only a few times slower than equivalent C programs. This indicates that pure process calculi like ours and programming languages based on them can be implemented e ciently, without losing their simplicity, purity, and elegance.	algorithm;compile time;compiler;computation;overhead (computing);parallel computing;process (computing);process calculus;programming language;pure function;scheduling (computing)	Yoshihiro Oyama;Kenjiro Taura;Akinori Yonezawa	1997		10.1007/BFb0002781	real-time computing;computer science;artificial intelligence;operating system;database;mathematics;distributed computing;computability;programming language;object-oriented programming;algorithm;channel	PL	-25.01954047672694	32.35921967840195	187252
3ffaf769724535efe2b4fa78b20b4c540dfffe15	programming and debugging for massively parallelism: the case for a parallel object-oriented language a-netl	object oriented language;message passing	This paper describes the two major issues of programming and debugging with a parallel object-oriented language, A-NETL. A-NETL programming is supported by several language facilities, such as the static definition and dynamic creation of massively parallel objects, asynchronous message passing of past, now, and future types and their multicast versions, and declarative synchronization schemes. A-NETL debugging requires special support for verifying the behavior of asynchronous operations. The major feature of the A-NETL debugger is the utilization of logical time, based on the happened before relation among events. During a test execution, the events and their logical time are recorded as an event history. The history is edited and presented to the user to provide a global view of the execution. The history is also utilized at the replay phase to provide a virtual event-level clock to a multicomputer and to keep the happened-before relation at test execution time. This not only enables cyclic debugging but also simplifies debugging by showing originally asynchronous operations synchronously.		Takanobu Baba;Tsutomu Yoshinaga;Takahiro Furuta	1995		10.1007/3-540-61487-7_21	first-generation programming language;computer architecture;parallel computing;message passing;very high-level programming language;language primitive;programming domain;data control language;computer science;data parallelism;low-level programming language;programming language;high-level programming language;implicit parallelism;task parallelism	PL	-24.219848692694367	34.26762166178055	188358
2b4935f323c0f922d4910d11bcae3b0a41d0ad88	ariadne: analysis for machine learning programs		Machine learning has transformed domains like vision and translation, and is now increasingly used in science, where the correctness of such code is vital. Python is popular for machine learning, in part because of its wealth of machine learning libraries, and is felt to make development faster; however, this dynamic language has less support for error detection at code creation time than tools like Eclipse. This is especially problematic for machine learning: given its statistical nature, code with subtle errors may run and produce results that look plausible but are meaningless. This can vitiate scientific results. We report on : applying a static framework, WALA, to machine learning code that uses TensorFlow. We have created static analysis for Python, a type system for tracking tensors—Tensorflow’s core data structures—and a data flow analysis to track their usage. We report on how it was built and present some early results.	core data;correctness (computer science);data structure;data-flow analysis;dataflow;eclipse;error detection and correction;library (computing);machine learning;python;static program analysis;tensorflow;type system	Julian Dolby;Avraham Shinnar;Allison Allain;Jenna Reinen	2018		10.1145/3211346.3211349	theoretical computer science;error detection and correction;program analysis;correctness;computer science;machine learning;python (programming language);static analysis;data-flow analysis;artificial intelligence	PL	-20.40900641827381	32.69631177648998	188891
24b8a3f15db28393d0593a4d90485ce8997971e1	debugging high-performance component-based applications	debugging;components;cca;event tracing;high performance		component-based software engineering;debugging	Torsten Wilde;James Arthur Kohl	2007	Concurrency and Computation: Practice and Experience	10.1002/cpe.1056	parallel computing;real-time computing;computer science;operating system;programming language;debugging	HPC	-24.629573523491157	36.53956681982077	189661
5cf17466b0169c78c0805674e8150678224583ef	data provenance tracking for concurrent programs	multi-threading;program debugging;source code (software);system monitoring;apache;ctraps;leveldb;mysql;parsec benchmarks;communication traps;concurrent programs;data provenance information tracking;debugability improvement;interthread communication;last writer slicing;mem-cached;mulithreaded programs;multiple dynamic analysis tools;multithreaded code;server programs	We propose Last Writer Slicing (LWS), a mechanism for tracking data provenance information in multithreaded code in a production setting. Last writer slices dynamically track provenance of values by recording the thread and operation that last wrote each variable. We show that this information complements core dumps and greatly improves debugability. We also propose communication traps (CTraps), an extensible framework that uses LWS to interpose on operations that lead to inter-thread communication. We show how to use CTraps to implement multiple dynamic analysis tools for mulithreaded programs. Our evaluation on server programs and PARSEC benchmarks shows that LWS has low run time overheads (0--15%) for many applications, including memcached, LevelDB, MySQL, and Apache. Our debugging case studies of real, buggy programs shows that LWS are indeed useful for debugging.	benchmark (computing);comment (computer programming);concurrent computing;debugging;inter-process communication;interrupt handler;leveldb;memcached;mysql;parsec;run time (program lifecycle phase);semiconductor;server (computing);source lines of code	Brandon Lucia;Luis Ceze	2015	2015 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)		parallel computing;real-time computing;software bug;concurrent computing;computer science;operating system;coalescer;instruction set;dynamic program analysis;programming language;debugging	Arch	-20.543308621598335	38.57022619629511	191109
8daec18002799d534bff78f3d9cfd944b11e2099	pl/i as a discrete event simulation tool	langage simulation;queue;simulator;synchronisation;evenement discret;pl1 language;synchronization;pl1;modele simulation;simulateur;simulation language;sincronizacion;event;entity;simulation model;attribute;discrete event simulation	Abstract#R##N##R##N#The programming language PL/I is considered as a most useful and portable discrete event simulation tool. This paper discusses design facilities required in simulation languages, making use of a model described in PL/I. The problem of queues, parallelism and synchronization in a simulator is solved. The structure of the simulator is considered.	pl/i;simulation	Anna Hác	1984	Softw., Pract. Exper.	10.1002/spe.4380140706	synchronization;real-time computing;simulation;computer science;theoretical computer science;simulation language	Logic	-25.54480261014576	32.74790065118204	191652
d7ec982ad06e480cdd80939a2d50f440a11fb305	optimizing type-specific instrumentation on the jvm with reflective supertype information		Abstract Reflective supertype information (RSI) is useful for many instrumentation-based type-specific analyses on the Java Virtual Machine (JVM). On the one hand, while such information can be obtained when performing the instrumentation within the same JVM process executing the instrumented program, in-process instrumentation severely limits the bytecode coverage of the analysis. On the other hand, performing the instrumentation in a separate process can achieve full bytecode coverage, but complete RSI is generally not available, often requiring the insertion of expensive runtime type checks in the instrumented program. In this article, we present a novel technique to accurately reify complete RSI in a separate instrumentation process. This is challenging, because the observed application may make use of custom classloaders and the loaded classes in one application execution are generally only known upon termination of the application. We implement our technique in an extension of the dynamic analysis framework DiSL. The resulting framework guarantees full bytecode coverage, while providing RSI. Evaluation results on a task profiler demonstrate that our technique can achieve speedups up to a factor of 6.24× wrt. resorting to runtime type checks in the instrumentation code for an analysis with full bytecode coverage.		Andrea Rosà;Walter Binder	2018	J. Vis. Lang. Comput.	10.1016/j.jvlc.2018.10.007	data mining;bytecode;programming language;virtual machine;computer science;java;instrumentation	DB	-21.796995527034586	35.99169752113103	191675
d0f541fd31ad4257811051758f4744186f0f57d7	the algebra of multi-tasking	developpement logiciel;algebraic specification;formal specification;calculus of communicating systems;ingenieria logiciel;software engineering;calcul systeme communicant;specification formelle;especificacion formal;formal verification;desarrollo logicial;specification algebrique;asynchronous communication;software development;genie logiciel;verification formelle;280302 software engineering;task scheduling;process algebra;700199 computer software and services not elsewhere classified;real time systems	Modelling multi-tasking behaviour is an important phase of real-time system design. It is shown how task scheduling principles can be captured in a CCS-based process algebra via extensions for both asymmetric interleaving, to model intraprocessor scheduling decisions, and for asynchronous communication, to model interprocessor precedence constraints. Examples are given of task preemption, blocking on shared resources, and multi-task transactions.	algorithm;andy wellings;automata theory;blocking (computing);causal filter;computer multitasking;concurrency (computer science);denotational semantics;embedded system;european joint conferences on theory and practice of software;formal aspects of computing;formal methods;formal proof;formal system;forward error correction;jackson;lecture notes in computer science;mv-algebra;model checking;partial order reduction;preemption (computing);process calculus;real-time clock;real-time computing;real-time locating system;real-time operating system;real-time transcription;scheduling (computing);springer (tank);systems design;the australian;timed automaton;transition system	Colin J. Fidge	2000		10.1007/3-540-45499-3_17	process calculus;real-time computing;formal verification;computer science;theoretical computer science;software development;operating system;asynchronous communication;formal specification;database;distributed computing;programming language;calculus of communicating systems;algorithm	Embedded	-24.651778528304607	32.35822130419859	192147
4d58fbe2b7168104522265ed72b65c67459beb51	comparing performance parameters of mobile app development strategies	windows phone performance parameters mobile app development strategies cross platform tools cpts codebase application performance analysis android phone ios phone;computer languages;performance evaluation;smart phones;mobile application development;ios;android;runtime;source code software android operating system ios operating system microsoft windows operating systems mobile computing smart phones software performance evaluation software tools;cross platform tools;mobile applications;mobile communication;performance analysis;windows phone mobile application development cross platform tools performance analysis android ios;windows phone;mobile communication smart phones runtime performance analysis computer languages mobile applications performance evaluation	Mobile cross-platform tools (CPTs) provide an interesting alternative to native development. Cross-platform tools aim at sharing a significant portion of the application codebase between the implementations for the different platforms. This can drastically decrease the development costs of mobile applications. There is, however, some reluctance of mobile application developers to adopt these tools. One of the reasons is that the landscape of CPTs is so diverse that it is hard to select the most suitable CPT to implement a specific application. The contribution of this paper is twofold. First, it presents a performance analysis of a fully functional mobile application implemented with ten cross-platform tools and native for Android, iOS and Windows Phone. The performance tests are executed on a high- and low-end Android and iOS device, and a Windows Phone device. Second, based on the performance analysis, general conclusions of which application developers should be aware when selecting a specific (type of) cross-platform tool are drawn.	algorithm;android;cpt (file format);library (computing);microsoft windows;mobile app;mobile device;overhead (computing);persistent memory;profiling (computer programming);programming tool;sensor;user interface;windows phone;ios	Michiel Willocx;Jan Vossaert;Vincent Naessens	2016	2016 IEEE/ACM International Conference on Mobile Software Engineering and Systems (MOBILESoft)	10.1145/2897073.2897092	embedded system;real-time computing;computer science;operating system	SE	-20.42794164540142	37.5876931372497	193387
6410bec0e21e22eb8225d92dcfb55ae58cbd9000	language constructs and transformation for hard real-time systems	real time;timing analysis;charts;programming language	In practice, time critical portions of hard real-time systems are still implemented in low-level programming languages and manually tuned to meet all the timing requirements. Without a real-time language that supports an appropriate way of specifying timing constraints for a generic hard real-time systems, and high precision timing analysis that is transparent to users, the users will ever suffer from the complex coding and analysis, particularly for systems requiring fast turnaround responses.In this paper, we propose novel language constructs that can be added to any imperative programming language so that the extended language provides users a way to specify relative timing constraints between arbitrary operations at instruction-level. The compilation techniques unique to transformation of the proposed language are also presented as a part of CHaRTS, the Compiler for Hard Real-Time Systems, which generates a valid instruction sequence for a target execution model.	chart;compiler;high- and low-level;imperative programming;low-level programming language;real-time clock;real-time computing;real-time operating system;real-time transcription;requirement;static timing analysis	Tai M. Chung;Henry G. Dietz	1995		10.1145/216636.216654	real-time computing;language primitive;specification language;data control language;computer science;chart;low-level programming language;fifth-generation programming language;programming language;programming language specification;high-level programming language;static timing analysis;algorithm	Embedded	-23.692002246072708	33.62244737961823	193701
e65347dd70c6d3eeb1496dba08ab84eed26a3679	allocation folding based on dominance	garbage collection;write barriers;memory managment;javascript;dynamic optimization	Memory management system performance is of increasing importance in today's managed languages. Two lingering sources of overhead are the direct costs of memory allocations and write barriers. This paper introduces it allocation folding, an optimization technique where the virtual machine automatically folds multiple memory allocation operations in optimized code together into a single, larger it allocation group. An allocation group comprises multiple objects and requires just a single bounds check in a bump-pointer style allocation, rather than a check for each individual object. More importantly, all objects allocated in a single allocation group are guaranteed to be contiguous after allocation and thus exist in the same generation, which makes it possible to statically remove write barriers for reference stores involving objects in the same allocation group. Unlike object inlining, object fusing, and object colocation, allocation folding requires no special connectivity or ownership relation between the objects in an allocation group. We present our analysis algorithm to determine when it is safe to fold allocations together and discuss our implementation in V8, an open-source, production JavaScript virtual machine. We present performance results for the Octane and Kraken benchmark suites and show that allocation folding is a strong performance improvement, even in the presence of some heap fragmentation. Additionally, we use four hand-selected benchmarks JPEGEncoder, NBody, Soft3D, and Textwriter where allocation folding has a large impact.	algorithm;allocation group;benchmark (computing);bounds checking;colocation centre;fragmentation (computing);global value numbering;inline expansion;javascript;mathematical optimization;memory management;open-source software;optimizing compiler;overhead (computing);pointer (computer programming);thermal copper pillar bump;throughput;virtual machine;write barrier	Daniel Clifford;Hannes Payer;Michael Starzinger;Ben L. Titzer	2014		10.1145/2602988.2602994	parallel computing;real-time computing;region-based memory management;computer science;slab allocation;static memory allocation;distributed computing;javascript;garbage collection;programming language	PL	-19.569364548286753	36.02006114076098	194273
7908f16fe0f377da751bc746c856cd07f736e954	code annotation for safe and efficient dynamic object resolution	object oriented programming;dynamic linking;just in time;work in progress;type system;intermediate representation	The execution time of object oriented programs can be drastically reduced by transforming ”non escaping” objects into a collection of its component scalar data fields. But for languages that support dynamic linking, this kind of optimization (which we call ”object resolution”) can usually only be performed at runtime, when the entire program is available for analysis. In such cases, the resulting performance increases will be offset by the additional costs that arise during the analysis and restructuring phases. In this paper, we describe work in progress, which provides an annotation technique that reduces the runtime overhead required for performing object resolutions. Our method performs a partial static escape analysis of each class at compile-time and then annotates the intermediate representation of that class with information which the just-in-time (JIT) compiler can use for object resolution. We apply this technique to the SafeTSA intermediate representation, producing a simple extension to SafeTSA’s type system that guarantees a safe and verifiable transmission of the annotated program.	benchmark (computing);compile time;compiler;dynamic linker;escape analysis;formal verification;intermediate representation;java;just-in-time compilation;mathematical optimization;overhead (computing);powerpc;run time (program lifecycle phase);type system	Andreas Hartmann;Wolfram Amme;Jeffery von Ronne;Michael Franz	2003	Electr. Notes Theor. Comput. Sci.	10.1016/S1571-0661(05)82597-6	method;real-time computing;type system;computer science;theoretical computer science;work in process;database;data transfer object;programming language;intermediate language;object-oriented programming	PL	-21.54276765411934	35.029196918904404	194510
44548f55cf88a9092ac207e99dc28f7d2ae539ce	a static region-based compiler for the dalvik virtual machine	android;dalvik virtual machine;region based compilation	The Dalvik virtual machine (VM) is an integral component used to execute applications in Android, which is one of the leading operating systems for mobile devices. The Dalvik VM is an interpreter and is equipped with a trace-based just-in-time compiler for enhancing the execution performance of frequently executed paths, or traces. However, traces generated by the Dalvik VM can be stopped in a conditional branch or a method call/return, which means that these traces usually have a short lifetime, decreasing the effectiveness of the compiler optimizations applied to them. Furthermore, the just-in-time compiler applies only a few simple optimizations because of performance considerations. In this article we present a traces-to-region (T2R) framework that extends traces to regions and statically compiles these regions into native binaries so as to improve the execution of Android applications. The T2R framework involves three main stages: (i) the profiling stage, in which the run-time trace information of an application is extracted; (ii) the compilation stage, in which regions are constructed from the extracted traces and are statically compiled into a native binary; and (iii) the execution stage, in which the compiled binary is loaded into the code cache when the application starts to execute. Experiments performed on an Android tablet demonstrated that the T2R framework was effective in improving the execution performance of applications by 10.5–16.2% and decreasing the size of the code cache by 4.6–28.5%. Copyright © 2015 John Wiley & Sons, Ltd.	android;binary file;branch (computer science);cpu cache;interpreter (computing);john d. wiley;just-in-time compilation;method (computer programming);mobile device;operating system;optimizing compiler;profiling (computer programming);tablet computer;tracing (software);virtual machine	Yi-Ping You;Jian-Ru Chen	2016	Softw., Pract. Exper.	10.1002/spe.2344	parallel computing;real-time computing;computer science;operating system;programming language;android	OS	-19.139653671161145	36.489136595162	194924
20cd1cacd8806f69b31bdff64e7bc032c822bb61	monitoring access to shared memory-mapped files	shared memory;memory management;search space;memory access monitor;event reconstruction;memory access;runtime monitoring;memory mapping;reading and writing;causality	The post-mortem state of a compromised system may not contain enough evidence regarding what transpired during an attack to explain the attacker’s modus operandi. Current systems that reconstruct sequences of events gather potential evidence at runtime by monitoring events and objects at the system call level. The reconstruction process starts with a detection point, such as a file with suspicious contents, and establishes a dependency chain with all the processes and files that could be related to the compromise, building a path back to the origin of the attack. However, system call support is lost after a file is memory-mapped because all read and write operations on the file in memory thereafter are through memory pointers. We present a runtime monitor to log read and write operations in memory-mapped files. The basic concept of our approach is to insert a page fault monitor in the kernel’s memory management subsystem. This monitor guarantees the correct ordering of the logs that represent memory access events when two or more processes operate on a file in memory. Our monitor increases accuracy to current reconstruction systems by reducing search time, search space, and false dependencies.	byte;functional dependency;memory management;page fault;paging;prototype;run time (program lifecycle phase);shared memory;system call	Christian G. Sarmoria;Steve J. Chapin	2005			uniform memory access;distributed shared memory;shared memory;interleaved memory;parallel computing;real-time computing;distributed memory;causality;computer science;physical address;operating system;database;overlay;extended memory;flat memory model;data diffusion machine;memory map;non-uniform memory access;memory management	OS	-20.536216469646245	38.85384514932676	196013
415f5c2f41902ce9c0ed3ed401ab6d732a949bc8	optimizing java programs in the presence of exceptions	developpement logiciel;dynamic programming;programacion dinamica;object oriented language;java programming;optimizacion compiladora;object oriented programming;analisis programa;program optimization;desarrollo logicial;compiler optimization;software development;programmation dynamique;optimisation programme;program analysis;analyse programme;static analysis;programmation orientee objet;optimisation compilateur;dynamic analysis;optimizacion programa	The support for precise exceptions in Java, combined with frequent checks for runtime exceptions, leads to severe limitations on the compiler’s ability to perform program optimizations that involve reordering of instructions. This paper presents a novel framework that allows a compiler to relax these constraints. We first present an algorithm using dynamic analysis, and a variant using static analysis, to identify the subset of program state that need not be preserved if an exception is thrown. This allows many spurious dependence constraints between potentially excepting instructions (PEIs) and writes into variables to be eliminated. Our dynamic algorithm is particularly suitable for dynamically dispatched methods in object-oriented languages, where static analysis may be quite conservative. We then present the first software-only solution that allows dependence constraints among PEIs to be completely ignored while applying program optimizations, with no need to execute any additional instructions if an exception is not thrown. With a preliminary implementation, we show that for many benchmark programs, a large percentage of methods can be optimized (while honoring the precise exception requirement) without any constraints imposed by frequent runtime exceptions. Finally, we show that relaxing these reordering constraints can lead to substantial improvements (up to a factor of 7 on small codes) in the performance of programs.	algorithm;benchmark (computing);dynamic dispatch;dynamic problem (algorithms);dynamic program analysis;exception handling;instruction scheduling;java;linear programming relaxation;mathematical optimization;optimizing compiler;out-of-order execution;program transformation;scheduling (computing);state (computer science);static program analysis	Manish Gupta;Jong-Deok Choi;Michael Hind	2000		10.1007/3-540-45102-1_21	real-time computing;computer science;programming language;object-oriented programming;algorithm	PL	-20.13715825160375	34.21491754163923	198354
bd18c271727e46e883dcd53ca36df165e8866451	a distributed implementation of a mode switching control program	automatic control;real time constraints;control systems;exceptions;processor scheduling;real time;distributed processing;system monitoring;exception handling robots distributed processing real time systems scheduling system monitoring;control engineering;mode switching control program;automata;control systems automatic control automata real time systems switches computer science control engineering robots processor scheduling power system modeling;scheduling;robots;schedule;exception handling;control program design;distributed implementation;real time automatons;computer science;power system modeling;real time constraints distributed implementation mode switching control program robot control program design real time automatons schedule system monitoring exceptions transputers;switches;transputers;robot;switching control;real time systems	A distributed implementation of a mode switched control program for a robot is described. The design of the control program is given b y a set of real-time automatons. One of them plans a schedule for switching between a B e d set of control functions, another dispatches the control functions according to the schedule, and a final one monitors the system for eaceptions that shall lead to a halt. The implementation uses four transputers with a distribution of phases of the automatons over the individual processors. The main technical result of the paper is calculations that illustrate how to justify that the implementation meets real-time constraints.	automaton;central processing unit;control function (econometrics);halting problem;pdf/a;real-time cmix;real-time transcription;robot;transputer	Michael Holdgaard;Thomas J. Eriksen;Anders P. Ravn;Torben O. Andersen	1995		10.1109/EMWRTS.1995.514307	robot;real-time computing;computer science;control system;automatic control;distributed computing	Robotics	-25.192533848879794	34.713743237901696	198658
c312045080f2ae81902d8af5aa46e6e8ab69bde0	eliminating race conditions in system-level models by using parallel simulation infrastructure	computational modeling parallel processing data models hazards encoding debugging analytical models;program compilers discrete event simulation embedded systems hazards and race conditions parallel architectures;embedded systems;parallel architectures;hazards and race conditions;program compilers;compiler race condition elimination system level models parallel simulation infrastructure top down system design flow specification model embedded system parallelism insertion parallel execution free of race conditions parallel implementation discrete event simulation simulation errors parallel simulator race condition diagnosis tool embedded multimedia application models;discrete event simulation	For a top-down system design flow, a well-written specification model of an embedded system is crucial for its successful design and implementation. However, the task of writing a correct system-level model is difficult, as it involves, among other tasks, the insertion of parallelism. In this paper, we focus on ensuring model correctness under parallel execution. In particular, the model must be free of race conditions in all accesses to shared variables, so that a safe parallel implementation is possible. Eliminating race conditions is difficult because discrete event simulation often hides such flaws. In particular, the absence of simulation errors does not prove the correctness of the model. We propose to use advanced conflict analysis in the compiler, fast checking in a parallel simulator, and a novel race-condition diagnosis tool, that not only exposes all race conditions, but also locates where and when such problems occur. Our experiments have revealed a number of dangerous race conditions in existing embedded multi-media application models and enabled us to efficiently and safely eliminate these hazards.	array data structure;compiler;correctness (computer science);electronic system-level design and verification;embedded system;experiment;explicit parallelism;level design;overhead (computing);parallel computing;pointer (computer programming);race condition;shared variables;simulation;systems design;top-down and bottom-up design	Weiwei Chen;Che-Wei Chang;Xu Han;Rainer Dömer	2012	2012 IEEE International High Level Design Validation and Test Workshop (HLDVT)	10.1109/HLDVT.2012.6418253	embedded system;parallel computing;real-time computing;computer science;discrete event simulation;operating system;distributed computing;programming language;algorithm	Embedded	-23.23721755285688	34.82932289329028	198907
e9dfad5017e9159d6a9e6461d274292232231b23	analysis of real-time rule-based systems with bahavioral constraint assertions specified in estella	verification;systeme temps reel;control systems;sistema experto;bounded response time;real time systems constraint handling expert systems formal specification knowledge representation;formal specification;analyse statique;expert systems;application specific knowledge;efficient algorithm;rule based system;real time;rule based;specification;special form;rule based programmer;ingenieria logiciel;indexing terms;satisfiability;estella;software engineering;real time systems knowledge based systems expert systems monitoring delay control systems humans artificial intelligence embedded computing performance analysis;behavioral constraint assertions;rule based expert systems;forme speciale;knowledge decision processing;monitoring;especificacion;real time rule based systems;performance analysis;rule based programming;genie logiciel;constraint handling;artificial intelligence;decision process;efficiency analysis;real time system;humans;sistema tiempo real;systeme expert;verificacion;knowledge representation;static analysis;human expertise;application specific knowledge real time rule based systems behavioral constraint assertions estella rule based expert systems knowledge decision processing human expertise monitor respond cycle bounded response time rule based programmer;large classes;monitoring and control;monitor respond cycle;knowledge based systems;embedded computing;real time systems;expert system	Rule-based expert systems are increasingly used to monitor and control the operations of complex real-time systems which require intensive knowledge-decision processing and human expertise. These embedded AI systems must respond to events in the rapidly changing external environment so that the results of the expert system's computation in each monitor-respond cycle are valid in safely operating the real-time system. Determining how fast an expert system can respond under all possible situations is a difficult problem. We have developed an efficient analysis methodology for a large class of rule-based EQL programs to determine whether a program in this class has bounded response time. In particular, we have identified several sets of primitive behavioral constraint assertions: an EQL program which satisfies all constraints in one of these sets of assertions is guaranteed to have bounded response time. Here, we enhance the applicability of our analysis technique by introducing a facility with which the rule-based programmer can specify application-specific knowledge that is too difficult to be mechanically detected in the new language Estella in order to determine the performance of an even wider range of programs. We also describe efficient algorithms for implementing the analysis tools. >	real-time transcription;rule-based system	Albert Mo Kim Cheng;James C. Browne;Aloysius K. Mok;Rwo-Hsi Wang	1993	IEEE Trans. Software Eng.	10.1109/32.241770	real-time computing;verification;index term;computer science;artificial intelligence;operating system;software engineering;formal specification;programming language;specification;expert system;static analysis;algorithm;satisfiability	Embedded	-25.23503141480866	34.75780463528018	199150
debf670c8c6d6b4d060ca3437ef6201ee5e4a5f6	integrating generations with advanced reference counting garbage collectors	reference counting;memory management;garbage collection;runtime systems;garbage collector;runtime system;generational garbage collection	We propose the use of generations with modern reference counting. A reference counting collector is well suited to collect the old generation, containing a large fraction of live objects that are modified infrequently. Such a collector can be combined with a tracing collector to collect the young generation, typically containing a small fraction of live objects. We have designed such a collector appropriate for run on a multiprocessor. As our building blocks, we used the sliding-views on-the-fly collectors.	garbage collection (computer science);multiprocessing;reference counting	Hezi Azatchi;Erez Petrank	2003		10.1007/3-540-36579-6_14	garbage;real-time computing;computer hardware;computer science;operating system;garbage collection;programming language	PL	-20.700424917129865	38.24957859873174	199476
