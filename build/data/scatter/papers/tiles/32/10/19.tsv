id	title	keywords	abstract	entities	authors	year	journal	doi	fos	area	x	y	ix
d5841bc68379bb28e0913c6dfc9fa5e4c9eef641	invariant discovery and refinement plans for formal modelling in event-b	thesis	The continuous growth of complex systems makes the development of correct software increasingly challenging. In order to address this challenge, formal methods offer rigorous mathematical techniques to model and verify the correctness of systems. Refinement is one of these techniques. By allowing a developer to incrementally introduce design details, refinement provides a powerful mechanism for mastering the complexities that arise when formally modelling systems. Here the focus is on a posit-and-prove style of refinement, where a design is developed as a series of abstract models introduced via refinement steps. Each refinement step generates proof obligations which must be discharged in order to verify its correctness – typically requiring a user to understand the relationship between modelling and reasoning. This thesis focuses on techniques to aid refinement-based formal modelling, specifically, when a user requires guidance in order to overcome a failed refinement step. An integrated approach has been followed: combining the complementary strengths of bottomup theory formation, in which theories about domains are built based on basic background information; and top-down planning, in which meta-level reasoning is used to guide the search for correct models. On the theory formation perspective, we developed a technique for the automatic discovery of invariants. Refinement requires the definition of properties, called invariants, which relate to the design. Formulating correct and meaningful invariants can be tedious and a challenging task. A heuristic approach to the automatic discovery of invariants has been developed building upon simulation, proof-failure analysis and automated theory formation. This approach exploits the close interplay between modelling and reasoning in order to provide systematic guidance in tailoring the search for invariants for a given model. On the planning perspective, we propose a new technique called refinement plans. Refinement plans provide a basis for automatically generating modelling guidance when a step fails but is close to a known pattern of refinement. This technique combines both modelling and reasoning knowledge, and, contrary to traditional pattern techniques, allow the analysis of failure and partial matching. Moreover, when the guidance is only partially instantiated, and it is suitable, refinement plans provide specialised knowledge to further tailor the theory formation process in an attempt to fully instantiate the guidance. We also report on a series of experiments undertaken in order to evaluate the approaches and on the implementation of both techniques into prototype tools. We believe the techniques presented here allow the developer to focus on design decisions rather than on analysing low-level proof failures. To the memory of my father, Guillermo Llano, and my Grandma, Yayita. You will always be in my heart.	bus mastering;complex systems;correctness (computer science);experiment;failure analysis;formal methods;heuristic;high- and low-level;invariant (computer science);prototype;refinement (computing);simulation;theory;top-down and bottom-up design	Maria Teresa Llano Rodriguez	2013			discrete mathematics;data mining;mathematics;refinement;algorithm	AI	-41.89114041959272	28.07781888332161	170306
9cfa0bc0b3c302687a2e8b4fd2941ea6e659c4af	scenariotools - a tool suite for the scenario-based modeling and analysis of reactive systems		Abstract ScenarioTools is an Eclipse-based tool suite for the scenario-based modeling and analysis of reactive systems. ScenarioTools especially targets the modeling and analysis of systems where the behavior of the components is sensitive to changes in the component structure that can occur at run-time. For example, in a system of communicating cars, the carsu0027 relationships can change due to their movement and influence how cars must interact. The modeling in ScenarioTools is based on the Scenario Modeling Language (SML), an extended variant of Live Sequence Charts (LSCs). For modeling structural changes and conditions, graph transformation rules can be combined with SML. The specifications are executable and can be analyzed by simulation. ScenarioTools further supports a formal synthesis procedure that can find specification inconsistencies or prove the specificationu0027s realizability. In this article, we illustrate the features of ScenarioTools by an example and describe its architecture.	chart;cyber-physical system;dynamical system;eclipse;executable;gif;graph rewriting;interaction;modeling language;simulation	Joel Greenyer;Daniel Gritzner;Timo Gutjahr;Florian König;Nils Glade;Assaf Marron;Guy Katz	2017	Sci. Comput. Program.	10.1016/j.scico.2017.07.004	modeling language;theoretical computer science;architecture;computer science;graph rewriting;suite;reactive system;executable;realizability	Logic	-41.919384474439724	29.907251401462457	170551
e058184a77d9eca8da49075a1bf9e4bb6d09f33b	static validation of ws-cdl documents	xml schema;ws cdl;b method;web service;abstract machine;web services;validation;static analysis;meta model	This paper presents an approach to validate WS-CDL documents statically. To deal with those constraints appeared in CDL documents, which cannot be captured by its meta model (XML Schema) totally, we design a machine-based constraint language based on B Method, which uses abstract machines to represent the constraints of the relations among XML nodes. After modelling the constraints, the corresponding checking algorithm can be designed to implement the static validation of CDL documents. Meanwhile, the checking algorithm is integrated into the WS-CDL editor plug-in for Eclipse project. The case studies show that our approach is effective for real examples in practice. 2009 Elsevier B.V. All rights reserved.	abstract machine;algorithm;b-method;compiler description language;eclipse;macintosh common lisp;metamodeling;monte carlo localization;plug-in (computing);ws-security;xml schema	Geguang Pu;Zheng Wang;Lei Zhou;Hanyi Zhang;Tao Wang;Chuchao Yang;Liyang Peng;Meng Sun	2009	Simulation Modelling Practice and Theory	10.1016/j.simpat.2009.06.013	web service;xml validation;computer science;document structure description;xml schema;database;abstract machine;programming language;world wide web;xml schema editor	SE	-46.7428571749145	26.272817844589923	170708
7b775170a7e5511719d24e2e91eacb9add386af9	an object-oriented implementation of an entity relationship model	entity relationship model;object oriented language;software engineering;object oriented;system design;entity relationship modeling;object oriented implementation;entity relationship	During systems design and implementation, high level models need to be suitably transformed to suit the lower level constructs supported by the implementation language. In cases where an entity relationship (ER) model needs to be implemented in an object-oriented environment, substantial coding is required. This is because many of the concepts in the entity relationship model are not  directly  supported in object-oriented languages. This tedious and error prone coding can be substantially eliminated. Much of the required codes can be consolidated into a layer of generic ER classes that directly represent the various concepts found in the entity relationship model. Specific ER models for application domains can then be directly modeled as subclasses of the generic ER classes, with minimal coding. Besides reducing coding, these classes also eliminate the transformation task otherwise required of the implementor. The design of the generic ER classes is described and discussed.	entity–relationship model	Hock Chuan Chan;Danny Chiang Choon Poo;Cheng Peng Woon	1998	Journal of Systems and Software	10.1016/S0164-1212(97)10012-7	entity–relationship model;computer science;data mining;database;programming language;engineering drawing;weak entity	OS	-47.257871208705694	25.87114661198177	171319
bf016329eb5da35f232bb9339e3776e00673dfbd	a generic library for gui reasoning and testing	generic model;user interface;behavior modeling;testing;graphical user interfaces;interactive application;fault detection;graphic user interface;model based testing;models;reverse engineering	Graphical user interfaces (GUIs) make software easy to use by providing the user with visual controls. Therefore, correctness of GUI's code is essential to the correct execution of the overall software. Models can help in the evaluation of interactive applications by allowing designers to concentrate on its more important aspects.  This paper presents a generic model for language-independent reverse engineering of graphical user interface based applications, and we explore the integration of model-based testing techniques in our approach, thus allowing us to perform fault detection.  A prototype tool has been constructed, which is already capable of deriving and testing a user interface behavioral model of applications written in Java/Swing.	behavioral modeling;correctness (computer science);fault detection and isolation;graphical user interface;java;language-independent specification;make;model-based testing;prototype;reverse engineering	João Carlos Silva;João Saraiva;José Francisco Creissac Freitas de Campos	2009		10.1145/1529282.1529307	user interface design;look and feel;user;10-foot user interface;user modeling;shell;human–computer interaction;computer science;operating system;graphical user interface;natural user interface;programming language;user interface;graphical user interface testing;multiple document interface	SE	-47.170358777347445	29.03532683024062	171895
4224e086c8e0d349e6936cf6c428b37df2d7ee4a	the analysis of uml state machine formal checking methods	state machine	Thc purposc of this paper is to discuss currcnt trends of such UML statc mactrine model chccking rnethods, where model checkirrg is perforrrred by translation into formal notations. Formal methods have shown their advantages for functional requircments' inconsistency checking and their climirration at early stages of development and for cnrichirrg graphical notations to reveal vaguerress and inaccuracics as discussed in this paper.	formal methods;uml state machine;unified modeling language	Gundars Alksnis	2007			abstract state machines;finite-state machine;applications of uml;uml state machine;horizontal position representation;virtual finite-state machine;trailer;programming language;mechanical engineering;communication channel;computer science	SE	-45.16923716191847	29.504669064459563	172488
00e6d419f5e8fc8913b8e1a2d01f537c2cbd3d0f	system assistance in structured domain model development	domain model	In this paper, we introduce a domain model-ing tool that supports users in the incremental and modular development of verified models of planning domains. It relies on a logic-based concept for systematic domain model construction that provides well-defined, safe operations for the union, extension, and refinement of already existing models. The system is equiped with a deductive component. It automatically performs the proofs necessary to guarantee both the consistency of single models and the safety of operations on models. By means of detailed examples, it is shown how the system has been used for the structured development of a model for a complex, safety-critical planning domain. 1 Introduction As soon as we aim at using planning systems in the context of realistic applications, the task of generating the underlying domain model becomes increasingly crucial. It is not only difficult to overlook the great amount of object types, relations, and actions involved when specifying such a model. It is also difficult to keep consistency in mind, which is of particular importance if the application domain is a safety-critical one. Consequently, system assistance in constructing safe models of complex planning domains would be of real help. Our work is motivated by the experiment of using a de-ductive planning system in the simulation of a safety-critical application, namely a chemical warehouse. This planning domain is quite complex and it has turned out that the construction of a clearly structured, adequate, and consistent model would have been almost infeasi-ble if done without any system support. that specifying a complex planning domain is an iterative process which includes frequent modifications of already specified parts and attempts to extend parts and finally put them together. In this paper, we introduce a domain modeling tool (DMT) that supports users in the incremental and modular development of safe, i.e. provably consistent, models of planning domains. It relies on the concept of systematic domain model construction proposed by [Bi-undo and Stephan, 1996]. This approach—based on a modal temporal logic—considers domain models as formal structures. Domain models consist of signatures, action definitions, and domain constraints. The well-defined operations of union, extension, and refinement allow for building complex domain models out of already existing simpler ones. We have improved this domain modeling concept in order to make it really useful for practical applications. We have introduced the notion of static constraints, in addition to domain constraints and have extended the operations …	application domain;data domain;digital monetary trust;domain model;iteration;mind;modal logic;object type (object-oriented programming);refinement (computing);simulation;temporal logic;type signature;undo;whole earth 'lectronic link	Susanne Biundo-Stephan;Werner Stephan	1997			computer science;domain model	AI	-41.981416273927785	29.028068045399785	172551
94d6c862754910203fd6fe8e4af9168988ea8bbf	role based platform independent web application modeling	application software;helium;logic;collaboration;software engineering;levels of abstraction;application software middleware collaboration helium chemical technology logic unified modeling language laboratories software engineering computer science;unified modeling language;role models;middleware;platform independent model;object role modeling;computer science;chemical technology	Web application modeling and implementation method are related with middleware platform tightly, and its models usually can’t be reused on different platform. In order to reuse web application models, it is necessary to raise the level of abstraction of models, constructing middleware platform independent models. Roles are meant to capture observable behavioral aspects of objects. Role models describe the set of valid object collaboration tasks. This paper proposes a method for constructing platform independent models for Web applications. It consists of a stepwise process, a template role model and a mapping from role model to class model. The method can improve the reusability of models at different level of abstraction. The paper shows how the method works by a simple example	middleware;observable;stepwise regression;web application	Chengwan He;Wenjie Tu;Keqing He	2005	Sixth International Conference on Parallel and Distributed Computing Applications and Technologies (PDCAT'05)	10.1109/PDCAT.2005.208	unified modeling language;middleware;application software;parallel computing;computer science;theoretical computer science;operating system;middleware;database;distributed computing;helium;programming language;logic;collaboration	SE	-41.7113316344958	32.21311785851038	173119
e28d8e593731e20e8ce4099b50e1bfdebd9c8244	an approach to formal specification and verification of map-centered applications	geographic information system;software engineering;formal method;domain specific language;formal specification and verification;formal language	Users in the domain of map-centered applications who want to specify a new application rely only on informal languages such as English. There is also no standardized terminology, resulting in ambiguous specifications. This work proposes an approach to specify and verify map-centered applications. This domain has been studied under different perspectives but there is a lack of research from the software engineering viewpoint. We characterize the domain by presenting a classification of different space models that appear in the Geographical Information Systems (GIS) literature, as well as of some of the problems addressed by map-centered applications. The proposed solution includes a language with semantics based in a formalization of each space model. This helps in verifying properties over a specification written using the formal language.  2001 Elsevier Science Ltd. All rights	ambiguous grammar;formal language;formal specification;formal verification;geographic information system;requirement;requirements analysis;software documentation;software engineering;specification language;systems design;type system;verification and validation	Maria Augusta V. Nelson;Paulo S. C. Alencar;Donald D. Cowan	2001	Environmental Modelling and Software	10.1016/S1364-8152(01)00017-2	domain analysis;formal system;formal language;formal methods;object language;specification language;formal verification;computer science;domain-specific language;theoretical computer science;domain engineering;formal specification;database;geographic information system;programming language;programming language specification;language of temporal ordering specification	SE	-45.92801699054103	26.659162337934745	173159
72db51a55498a17b5224e475ad6af1c916ccb2b1	a property specification tool for generating formal specifications: prospec 2.0	formal specification	Numerous formal approaches to software assurance are available, including: runtime monitoring, model checking, and theorem proving. All of these approaches require formal specifications of behavioral properties to verify a software system. Creation of formal specifications is difficult, and previously, there has been inadequate tool support for this task. The Property Specification tool, Prospec, was developed to assist users in the creation of formal specifications. This paper describes Prospec 2.0, an improvement to the previous version, by addressing the results of a study conducted to assess the usability of the tool and by adding functionality that supports the	automated theorem proving;formal specification;microsoft software assurance;model checking;software system;usability	Irbis Gallegos;Omar Ochoa;Ann Q. Gates;Steve Roach;Salamah Salamah;Corina Vela	2008			formal methods;specification language;formal verification;computer science;software engineering;formal specification;refinement;language of temporal ordering specification	SE	-45.081545975190366	30.656379204330715	173863
f670f930d4076ad52b854b6daa4486af329f13e3	requirements and obstacles for the transformation of grafcet specifications into iec 61131–3 plc programs	time dependent;transient analysis computer languages discrete event systems semantics syntactics iec standards software;programmable controllers;formal specification;programming language;executive control;specification language;discrete event system;iec standards;specification languages;specification languages control engineering computing discrete event systems formal specification iec standards programmable controllers;discrete event systems;programmable logic controllers grafcet specification iec 61131 3 plc program discrete event system controller specification specification language;control engineering computing	GRAFCET is a powerful means for the specification of controllers in discrete event systems. As GRAFCET is a specification language and not a programming language, GRAFCET specifications have to be transformed into executable control programs, e.g. in a programming language according IEC 61131–3. Such a transformation requires consideration of particular characteristics of GRAFCET, such as transient evolutions. In previous research concerning this transformation, only subclasses of GRAFCET have been taken into account, and e.g. time dependencies have been neglected so far. The current research of the authors intends to contribute to a wider acceptance of GRAFCET as a control specification standard by developing algorithms for an unambiguous transformation of GRAFCET constructs into controller programs in accordance with the IEC61131–3 standard.	apl;algorithm;executable;programming language;specification language	Frank Schumacher;Alexander Fay	2011	ETFA2011	10.1109/ETFA.2011.6059134	real-time computing;specification language;computer science;software engineering;programmable logic controller;formal specification;programming language;language of temporal ordering specification	PL	-41.915851748707794	29.296909217128167	174453
dc7fd497f028353521f63b2be0968676eafb70f1	enforcement of patterns by constraint-aware model transformations		Patterns are descriptions and solutions for recurring prob lems in software design and implementation. In this paper, some ideas toward s a formal approach to the specification of patterns in model-driven engineering ( MDE) is presented. The approach is based on the Diagram Predicate Framework which p rovides a formal approach to (meta)modelling, model transformation and model management in MDE. In particular, patterns are defined as diagrammatic specific ations and constraintaware model transformations are adapted to enforce pattern s. Moreover, running examples are used to illustrate the facade design pattern in structural models.	anti-pattern;diagram;metamodeling;model transformation;model-driven architecture;model-driven engineering;software design pattern;taxonomy (general)	Yngve Lamo;Adrian Rutle;Florian Mantz	2010	ECEASST	10.14279/tuj.eceasst.31.576	computer science;data mining;structural pattern;algorithm	SE	-45.86505177242627	26.296535245730855	174847
4229b8276ca4c7d4afcb6ac9cac5f8b40999adc9	espem – a spem extension for enactable behavior modeling	process model;behavior model;enactable behavior modeling;spem standard;fine-grained behavior;fine-grained behavior model;coarse granularity;automated enactment;uml meta-model;development process;spem extension;coarse description;meta model;behavior modeling	OMG’s SPEM – by means of its (semi-)formal notation – allows for a detailed description of development processes and methodologies, but can only be used for a rather coarse description of their behavior. Concepts for a more fine-grained behavior model are considered out of scope of the SPEM standard and have to be provided by other standards like BPDM/BPMN or UML. However, a coarse granularity of the behavior model often impedes a computer-aided enactment of a SPEM-based process model. Therefore, in this paper we present eSPEM, an extension of SPEM, that is based on the UML meta-model and focused on fine-grained behavior and life-cycle modeling and supports automated enactment of development processes.	behavior model;business process definition metamodel;meta-process modeling;metamodeling;process modeling;unified modeling language	Ralf Ellner;Samir Al-Hilank;Johannes Drexler;Martin Jung;Detlef Kips;Michael Philippsen	2010		10.1007/978-3-642-13595-8_11	real-time computing;simulation;computer science;systems engineering	AI	-45.57650075419899	26.10866260365619	175008
c00c08f1bfaa02bb760461ae88021f38c56dace5	overview of slicing and feedback techniques for efficient verification of uml/ocl class diagrams		Model-driven engineering is a methodology for software development that focuses on the use of models in the software development process. These models can be transformed into code, saving developers both time and effort. One of the most widely used models for transformation is the unified modeling language (UML) class diagram, along with its object constraint language (OCL) constraints. Before transforming UML/OCL models into code, it is essential to find defects in the model, as model transformations and code generation may spread errors to other notations where they are more difficult and time-consuming to trace and detect. Formal verification of models is a time-consuming process and there are several formal verification tools that can check the accuracy of UML/OCL models, but their high computational complexity limits their scalability. In this paper, we present an overview of disjoint and non-disjoint slicing techniques that can break UML/OCL class diagrams into independent submodels in order to reduce the complexity. These submodels can then be verified separately through any verification tool or engine. Furthermore, an overview of a novel feedback technique is also proposed, which highlights any unsatisfiable submodels with their integrity constraints from the complex hierarchy of a UML/OCL class diagram.	class diagram;code generation (compiler);computational complexity theory;data integrity;formal verification;model-driven architecture;model-driven engineering;object constraint language;scalability;software development process;unified modeling language	Asadullah Shaikh;Uffe Kock Wiil	2018	IEEE Access	10.1109/ACCESS.2018.2797695	software development process;class diagram;software development;theoretical computer science;distributed computing;object constraint language;computer science;unified modeling language;formal verification;code generation;data integrity	SE	-43.63498401911629	30.712065863031253	175363
f0bac33655d084fe1baf767ffd30de0323f8f6dc	tgg-based process for automating the transformation of uml models towards b specifications	uml graph transformation;elevator control;object modelling;b method;statechart diagrams;uml diagrams;lift control;unified modelling language;triple graph grammar	The UML notation provides a standard framework for the purpose of object modelling by several diagrams (classes, statecharts, etc.). These form confirmed advantages: re-use of components, high level of abstraction, semantic richness, graphic and synthetic view. Nevertheless, the object-oriented notations lack of formalisation and miss of reliable bases for the analysis and verification of the applications. To overcome this problem, we suggest a solution to the UML graph transformation towards formal methods, in particular the B method. The goal of this paper is to automate the generation of B language, starting from UML class and statechart diagrams by mean of graph grammar rules. This automation is achieved by the tool TGG Interpreter. The major advantage of this transformation: it is a declarative; visual; and formal approach to handle graphs. A lift control system is developed to illustrate our study.	transformational grammar;unified modeling language	Seidali Rehab;Allaoua Chaoui	2015	IJCAET	10.1504/IJCAET.2015.071299	unified modeling language;uml state machine;uml tool;computer science;applications of uml;programming language;engineering drawing;algorithm;object constraint language	DB	-45.44707330186782	26.77856228355222	175669
2aee11819fc28a811e73038d9fd423b6a63d5938	modeling and validation of service-oriented architectures: application vs. style	application development;inf;system modeling;service oriented architectures;modeling middleware platforms;graph transformation;model checking;middleware;service oriented architecture;architectural style;graph transformation system	Most applications developed today rely on a given middleware platform which governs the interaction between components, the access to resources, etc. To decide, which platform is suitable for a given application (or more generally, to understand the interaction between application and platform), we propose UML models of both the architectural style of the platform and the application scenario. Based on a formal interpretation of these as graphs and graph transformation systems, we are able to validate the consistency between platform and application.	graph rewriting;interpretation (logic);middleware;service-oriented architecture;unified modeling language	Luciano Baresi;Reiko Heckel;Sebastian Thöne;Dániel Varró	2003		10.1145/940071.940082	middleware;real-time computing;computer science;theoretical computer science;service-oriented architecture;distributed computing	SE	-41.20805609607138	31.879354043580516	177337
0368f73e0a5b5cd43616b885f4ed552a9e46bd1e	a relational approach to defining transformations in a metamodel	developpement logiciel;lenguaje uml;semantics;langage modelisation unifie;qa 76 software;lenguaje especializado;semantica;semantique;specification language;computer programming;metamodel;metamodele;object oriented;metamodelo;desarrollo logicial;abstract syntax;unified modelling language;software development;oriente objet;lenguaje especificacion;langage specialise;special purpose language;orientado objeto;langage specification	Metamodelling is becoming a standard way of defining languages such as the UML. A language definition distinguishes between concrete syntax, abstract syntax and semantics domain. It is possible to define all three using a metamodelling approach, but it is less clear how to define the transformations between them. This paper proposes an approach which uses metamodelling patterns that capture the essence of mathematical relations. It shows how these patterns can be used to define both the relationship between concrete syntax and abstract syntax, and between abstract syntax and semantics domain, for a fragment of UML. A goal of the approach is to provide a complete specification of a language from which intelligent tools can be generated. The extent to which the approach meets this goal is discussed in the paper.	abstract syntax;automaton;character encoding;customer relationship management;diagram;hierarchical and recursive queries in sql;meta-object facility;metamodeling;model checking;model-driven architecture;parse tree;prototype;request for proposal;sms language;scalability;unified modeling language	David H. Akehurst;Stuart Kent	2002		10.1007/3-540-45800-X_20	natural language processing;abstract syntax;specification language;computer science;software development;computer programming;semantics;programming language;homoiconicity;algorithm;abstract syntax tree	SE	-41.96815829608113	25.431536934459615	178395
2f655419ac56750e27f55d0fe4e2214cbaa7112b	model-checking behavioral programs	formal specification;java programming;java behavioral programming;behavioral programming;program verification;software engineering;model checking;synchronization;games;state space;software tools formal specification java program verification;safety;visual language;execution state space model checking behavioral program system specification visual language live sequence charts software module coding model checking tool behavioral java program verification;software tools;context modeling;programming;use case;java programming synchronization safety games software engineering context modeling;live sequence chart;java	System specifications are often structured as collections of scenarios and use-cases that describe desired and forbidden sequences of events. A recently proposed behavioral programming approach, which evolved from the visual language of live sequence charts (LSCs), calls for coding software modules in alignment with such scenarios. We present a methodology and a supporting model-checking tool for verifying behavioral Java programs, without having to first translate them into a specific input language for the model checker. Our method facilitates early discovery of conflicting or under-specified scenarios, which can often be resolved by adding new scenarios rather than by changing existing code. Also, counterexamples provided by the tool are themselves event sequences that can serve directly for refinements and corrections. Our tool reduces the size of the execution state-space using an abstraction that focuses on behaviorally interesting states and treats transitions between them as atomic.	chart;java;linearizability;model checking;state space;verification and validation;visual language	David Harel;Robby Lampert;Assaf Marron;Gera Weiss	2011	2011 Proceedings of the Ninth ACM International Conference on Embedded Software (EMSOFT)	10.1145/2038642.2038686	use case;model checking;games;synchronization;programming;real-time computing;computer science;state space;theoretical computer science;operating system;formal specification;context model;programming language;java	SE	-41.948589798878615	30.040938739596548	179015
f345f620aca09634796b221c456abcc817da8cea	formal modelling of a coordination system: from practice to theory, and back again	formal model;linda;rule based system;formal methods;web service;formal method;software development;web services;xml document;coordination;coordinate system	In this work, we report an experience that illustrates the interplay between formal methods and real software development. Starting from aWeb-enable Coordination Service (WCS) based on JavaSpaces technology which had been successfully used in an industrial project, we built a formal model for the system in order to study its properties; specifically, our aim was to prove that Linda semantics was preserved in several layers of complex mappings from XML documents to Java objects. Once this objective was achieved (at least in a simplified, idealistic version), we observed several possibilities of extending the coordination system at the model level. In particular, we identified that it was possible to enhance the formal model with transactional capabilities, taking advantage of the similarity of our model to rule-based systems. At present, we are working on the translation of this theoretical result to practice, in order to improve our Web Coordination Service.		Eloy J. Mata;Pedro Álvarez;José A. Bañares;Julio Rubio	2006		10.1007/978-3-540-75524-1_13	formal methods;formal verification;computer science;knowledge management;theoretical computer science;formal specification;database	NLP	-44.22963024932958	25.720032828296926	179654
978d075df6c7aaf47b087921aaaafa5af6bf5652	lessons from the application of formal methods to the design of a storm surge barrier control system	fiabilidad;reliability;securite;criticite;program verification;development process;formal method;control proceso;verificacion programa;control system;formal verification;critical system;storm surge;fiabilite;safety;process control;industrial application;verification formelle;verification programme;seguridad;criticidad;commande processus;criticality	We describe the experience of the industrial application of formal methods in the development of a mission critical system. We give a description of the system that was to be developed and the methods that were employed to realize the high level of reliability that was required. In this paper we will describe which formal techniques were used, how these techniques were used, the influence of formal methods on the development process and recommendations for managing the use of formal methods.	control system;critical system;formal methods;high-level programming language;mission critical	Michel R. V. Chaudron;Jan Tretmans;Klaas Wijbrans	1999		10.1007/3-540-48118-4_30	simulation;formal methods;formal verification;computer science;control system;process control;formal specification;reliability;programming language;storm surge;software development process;criticality	Robotics	-42.13393807272973	27.149868762560374	179752
1c6f245a8097c09b97a97bbbf46e6249bbe0d79f	how to identify binary relations for domain models	requirements engineering;high degree;entity relationship modeling;domain model;natural language definition;automated teller machine;new approach;case study;binary relation;object class;abstract data type;natural languages;abstract data types;binary relations;data engineering;databases;natural language;automation;requirement engineering;entity relationship model;formal specification;art;context modeling;atm;domain models;object oriented analysis;data processing	Many approaches to requirements engineering include building a model of the domain. Those using entity relationship modeling or deriving from it employ the concept of relations between entities, but identifying the relations is still more of an art than science or engineering. We deal with this problem primarily in the context of object oriented analysis (OOA), where relations between object classes are to be identified. Our new approach uses natural language definitions of object classes and looks for names of other object classes in these definitions, since such a reference indicates a relation. Based on this idea, we identify most binary relations for domain models in a new way. We also provide tool support for this method, which shows that a high degree of automation is possible. Both a case study using the well known ATM (automated teller machine) example and real world experience with our approach suggest its usefulness.	atm turbo;entity;entity–relationship model;natural language;relation (database);requirements engineering;whole earth 'lectronic link	Hermann Kaindl	1996			natural language processing;entity–relationship model;computer science;theoretical computer science;software engineering;domain model;binary relation;database;requirements engineering;natural language;programming language;abstract data type	SE	-46.11205461206196	26.978185746091544	179758
55ea08b8b5e14e6730817d41cc1c33288f3c650e	a practical notation for object oriented analysis with a formal meaning	symmetric relationship;formal approach;user friendly method;computer languages;information model;object oriented methods;formal specification;composition;practical notation;formal specification object oriented programming object oriented methods;graphical notation;subtyping;formal methods;object oriented programming;software engineering;formal method;strict mathematical meaning;dependency;technology and engineering;reference;object oriented modeling information analysis unified modeling language mathematical model object oriented methods programming computer languages computer errors computer science software engineering;unified modeling language;mathematical model;information modeling;object oriented information modeling;strict mathematical meaning practical notation object oriented analysis formal meaning formal approach object oriented information modeling dependency reference composition subtyping symmetric relationship graphical notation user friendly method information model;computer science;object oriented analysis;programming;information analysis;object oriented modeling;computer errors;formal meaning	In this paper a more formal approach to object oriented information modeling [8] i s proposed. T h e five basic associations (dependency, reference, composition, subtyping and symmetric relationship) are defined mathematically, but m a y still be used in a graphical notation in a user-friendly way. In this way, it i s possible to obtain a n information model with a strict mathematical meaning without additional effort.	graphical user interface;information model;usability	Joseph Hoffman	1997		10.1109/TOOLS.1997.681873	engineering notation;computer science;theoretical computer science;programming language	SE	-47.69070717273968	27.941155548208076	180027
8861cb3e89d9ea0ad6c55c4bac9c4a9e95656b4a	towards improved class parameterization and class generation in modelica	systemdynamik und regelungstechnik war entwurfsorientierte regelungstechnik;language design;class parameterization	Class parameterization and class generation enhance the object-oriented means of Modelica, either by making them better accessible for the user or more powerful to apply for the library designer. Nevertheless, the current solution in Modelica does not properly distinguish between these two concepts, and hence it does not represent a fully satisfying solution. This paper presents a proposal or vision for a partial redesign of the language by separating class parameterization and class generation. In this way, the language becomes simpler and yet more powerful. The derived concepts may serve as guideline for future considerations of the Modelica language design.		Dirk Zimmer	2010			simulation;computer science;algorithm	AI	-47.35462793264838	25.372290196286077	180543
1ba281cfa9210baa1efb454d2d1d0da1ff1b337c	verifying behavioral uml systems via cegar		This work presents a novel approach for applying abstraction and refinement in the verification of behavioral UML models. The Unified Modeling Language (UML) is a widely accepted modeling language for embedded and safety critical systems. As such the correct behavior of systems represented as UML models is crucial. Model checking is a successful automated verification technique for checking whether a system satisfies a desired property. Nevertheless, its applicability is often impeded by its high time and memory requirements. A successful approach to avoiding this limitation is CounterExample-Guided Abstraction-Refinement (CEGAR). We propose a CEGAR-like approachion-Refinement (CEGAR). We propose a CEGAR-like approach for UML systems. We present a model-to-model transformation that generates an abstract UML system from a given concrete one, and formally prove that our transformation creates an over-approximation. The abstract system is often much smaller, thus model checking is easier. Because the abstraction creates an over-approximation we are guaranteed that if the abstract model satisfies the property then so does the concrete one. If not, we check whether the resulting abstract counterexample is spurious. In case it is, we automatically refine the abstract system, in order to obtain a more precise abstraction.	apple rhapsody;approximation;australasian conference on information systems;chart;chow–liu tree;concurrency (computer science);continuous design;converge;damm algorithm;edmund m. clarke;electron;embedded system;formal methods;formal specification;formal verification;harald ganzinger;heuristic (computer science);iteration;keneth alden simons;lecture notes in computer science;model checking;model transformation;nico habermann;orna grumberg;promela;reachability;real-time locating system;refinement (computing);requirement;spin model checker;schmidt decomposition;semantics (computer science);simulation;software engineering;software testing;springer (tank);spurious emission;state diagram;symbolic execution;symposium on foundations of computer science;temporal logic;uml state machine;unified modeling language;verification and validation;yang	Yael Meller;Orna Grumberg;Karen Yorav	2014		10.1007/978-3-319-10181-1_9	abstract state machines;computer science;theoretical computer science;programming language;unified modeling language;finite-state machine;abstraction	Logic	-44.229809982998354	30.95589303418579	181096
65880acb1a33a808cede3e3e21e46ba0c9e8d900	integrating requirements: the behavior tree philosophy	analytical models;behavior tree requirements modelling analysis integration;informal language description;formal specification;trees mathematics formal specification;formal model;ovens analytical models buildings syntactics context synchronization joining processes;functional system requirements;building block;integrated modelling;requirements integration;behavior tree philosophy;trees mathematics;integration;requirements;requirement analysis;syntactics;synchronization;ovens;joining processes;analysis;graphical modelling notation;functional requirement;formal model requirements integration behavior tree philosophy graphical modelling notation functional system requirements informal language description;behavior tree;context;buildings	Behavior Trees were invented by Geoff Dromey as a graphical modelling notation. Their design was driven by the desire to ease the task of capturing functional system requirements and to bridge the gap between an informal language description and a formal model. Vital to Dromey's intention is the idea of incrementally building the model out of its building blocks, the functional requirements. This is done by graphically representing each requirement as its own Behavior Tree and incrementally merging the trees to form a more complete model of the system. In this paper we investigate the essence of this constructive approach to creating a model in general notation-independent terms and discuss its advantages and disadvantages. The result can be seen as a framework of rules and provides us with a semantic underpinning of requirements integration. Integration points are identified by examining the (implicit or explicit) preconditions of each requirement. We use Behavior Trees as an example of how this framework can be put into practise.	behavior tree;functional requirement;graphical user interface;mathematical model;precondition;system requirements	Kirsten Winter;Ian J. Hayes;Robert Colvin	2010	2010 8th IEEE International Conference on Software Engineering and Formal Methods	10.1109/SEFM.2010.13	requirements analysis;computer science;artificial intelligence;software engineering;programming language	SE	-43.52963845006453	27.591216046397705	182369
aad482ad43eb5ea286f71c756a510f8303a91899	specification and verification of complex business processes - a high-level petri net-based approach	bpmn;recatnets;maude language and tool;conditional rewriting logic;business process modelling	The Business Process Modeling Notation BPMN has been widely used as a tool for business process modeling. However, BPMN suffers from a lack of standard formal semantics. This weakness can lead to inconsistencies, ambiguities, and incompletenesses within the developed models. In this paper we propose a formal semantics of BPMN using recursive ECATNets. Owing to this formalism, a large set of BPMN features such cancellation, multiple instantiation of subprocesses and exception handling can be covered while taking into account the data flow aspect. The benefits and usefulness of this modelling are illustrated through two examples. Moreover, since recursive ECATNets semantics is expressed in terms of conditional rewriting logic, one can use the Maude LTL model checker to verify several behavioral properties related to BPMN models.	petri net	Ahmed Kheldoun;Kamel Barkaoui;Malika Ioualalen	2015		10.1007/978-3-319-23063-4_4	xpdl;computer science;engineering;database;business process model and notation;programming language;business process modeling;algorithm	Logic	-43.658422076434306	28.16489788444394	182766
068191fa97902c15b283bf3755ca59f77c84cb33	towards a mof/qvt-based domain architecture for model driven security	artefacto;developpement logiciel;modelizacion;software modeling;securite;interoperabilite;interoperabilidad;lenguaje uml;service web;program transformation;model transformation;langage modelisation unifie;web service;transformation programme;orientado servicio;artefact;langage dedie;modelisation;software architecture;transformacion programa;visual languages;metamodel;metamodele;metamodelo;langage visuel;desarrollo logicial;security requirements;unified modelling language;model integration;software development;safety;visual language;domain specific language;architecture basee modele;platform independent model;oriente service;interoperability;software design;seguridad;modeling;reference architecture;model driven architecture;software product lines;architecture logiciel;servicio web;service oriented;arquitectura basada modelo;lenguaje dedicado;real time systems	The Sectet-framework realizes an extensible domain architecture for the collaborative development and management of security-critical, inter-organizational workflows. Models integrate security requirements at the abstract level and are rendered in a visual language based on UML 2.0. The models form the input for a chain of integrated tools that transform them into artefacts configuring security components of a Web services-based architecture. Based on findings of various projects, this contribution has three objectives. First, we detail the MOF based metamodels defining a domain specific language for the design of inter-organizational workflows. The language supports various categories of security patterns. We then specify model-to-model transformations based on the MDA standard MOF-QVT. The mappings translate platform independent models into platform specific artefacts targeting the reference architecture. Third, we exemplarily show how model-to-code transformation could be implemented with an MDA-framework like openArchitectureWare.	.net framework;domain-specific language;mda framework;meta-object facility;metamodeling;qvt;reference architecture;requirement;unified modeling language;visual language	Michael Hafner;Muhammad Alam;Ruth Breu	2006		10.1007/11880240_20	metamodeling;web service;unified modeling language;reference architecture;embedded system;interoperability;software architecture;simulation;systems modeling;computer science;systems engineering;domain-specific language;engineering;software design;software development;software engineering;modeling language	SE	-41.86994828139087	25.421504322679677	183016
4082fab41dfc85f15eec34f5d2195654e585c69d	towards a tool support for specifying complex software systems by categorical modeling language	tool support;software systems;modeling language;formal method;category theory;interactive system;emergent behavior;power modeling	1 Abstract. Formal methods are proven approaches to ensure the correct operation of complex interacting systems. However, current formal methods do not address well problems of verifying emergent behavior and evolution, which are two of the most important characteristics of complex software systems. A subset of the Category Theory has been proposed in this paper to specify such systems. The categorical modeling language depicted here is the first step towards a powerful modeling paradigm capable of modeling emerging and evolving behavior of complex software. The approach is illustrated with a case study of Prospecting Asteroid Mission (PAM) from the NASA.	modeling language;software system	Noorulain Khurshid;Olga Ormandjieva;Stan Klasa	2010		10.1007/978-3-642-13273-5_9	formal methods;systems modeling;systems modeling language;computer science;artificial intelligence;theoretical computer science;service-oriented modeling;software engineering;modeling language;programming language;emergence;software system;category theory	SE	-44.40997312989364	27.512827239785725	183025
45c01a63aa887cbd01d5108eeed5c8f6f27013b0	application of formal methods to digital system design			digital electronics;formal methods;systems design	John M. J. Herbert	1986				EDA	-45.81156190761634	30.804992186452008	183062
8c6e7c216a60df74d512b93259c9154af1320d0e	a hierarchical variability model for software product lines	datavetenskap datalogi;computer science	A key challenge in software product line engineering is to represent solution space variability in an economic, yet easily understandable fashion. We introduce the notion of hierarchical variability models to describe families of products in a manner that facilitates their modular design and analysis. In this model, a family is represented by a common set of artifacts and a set of variation points with associated variants. A variant is again a hierarchical variability model, leading to a hierarchical structure. These models, however, are not unique with respect to the families they define. We therefore propose a quantitative measure on hierarchical variability models that expresses the degree to which a variability model captures commonality and variability in a family. Further, by imposing well-formedness constraints, we identify a class of variability models that, by construction, have maximal measure and are unique for the families they define. For this class of simple families, we provide a procedure that reconstructs their hierarchical variability model. The reconstructed model can be used to drive various static analyses by divide-and-conquer reasoning. Hierarchical variability models strike a balance between the formalism’s expressiveness and the desirable property of model uniqueness. We illustrate the approach by a small product line of Java classes.	artifact (software development);feasible region;heart rate variability;java;maximal set;modular design;semantics (computer science);software product line;spatial variability;static program analysis	Dilian Gurov;Bjarte M. Østvold;Ina Schaefer	2011		10.1007/978-3-642-34781-8_15	simulation;operations management;mathematics;algorithm	SE	-45.275611121367206	25.723332093897977	183460
64e06d707ebf2bf02a45c0304af1847967078251	coloured petri nets and graphical animation: a proposal for a means to address problem frame concerns	coloured petri nets;coloured petri net;executable models;problem frame;problem frames;correctness arguments	Abstract: To address a frame concern in Jackson's problem frames, we must make appropriate descriptions of (1) the problem domain; (2) the requirements; (3) the specification of the machine. Based on these descriptions, we must give a convincing argument that the given domain properties and the machine specification together entail that the requirements are fulfilled. In this paper, we demonstrate how to address certain frame concerns with the use of the formal modelling language coloured Petri nets (CPN). Problem domain description and machine specification are brought together in a CPN model, which is augmented with a graphical animation. The CPN model is executable and we simulate it to address frame concerns. We illustrate the approach on the elevator controller example.	coloured petri net;graphical user interface	Jens Bæk Jørgensen	2008	Expert Systems	10.1111/j.1468-0394.2008.00454.x	simulation;computer science;theoretical computer science;petri net;algorithm	HCI	-41.24667187988079	29.204716623501625	183722
c3dcfb58c174671f413b2eaadbb87272b1e4f8b2	legacy component integration by the fujaba real-time tool suite	legacy component;software tools learning artificial intelligence object oriented programming;behavior modeling;real time;object oriented programming;learning automata;integration;automata;formal verification;unified modeling language real time systems mathematical model context learning automata context modeling automata;unified modeling language;model driven engineering;safety critical system;mathematical model;learning approach fujaba realtime tool suite legacy component;software tools;safety critical systems formal verification integration legacy system model driven engineering;learning artificial intelligence;legacy system;context modeling;context;safety critical systems;real time systems;learning approach;fujaba realtime tool suite	We present a Tool Suite which supports the (re-)construction of a behavioral model of a legacy component based on a learning approach by exploiting knowledge of known models of the existing component environment. This in turn enables to check whether the legacy component can be integrated correctly into its environment.	behavioral modeling;real-time clock	Stefan Henkler;Jan Meyer;Wilhelm Schäfer;Markus von Detten;Ulrich Nickel	2010	2010 ACM/IEEE 32nd International Conference on Software Engineering	10.1145/1810295.1810349	behavioral modeling;unified modeling language;model-driven architecture;formal verification;computer science;systems engineering;theoretical computer science;mathematical model;automaton;context model;life-critical system;programming language;object-oriented programming;legacy system	SE	-44.64481350961636	32.10327361685884	183848
020661392d1fdcf59d0ed9a6da979bb7c7186ea9	rigorous approach for representation and measurement of structural properties of concurrent computer programs	computer program;structural properties	Abstract   The paper describes a systematic approach for measuring software products. The flowgraph model is presented as a basis for conducting such measurement, and in particular measurement of structure. A proposal for describing concurrency in the flowgraph model is proffered. It is the method and the way in which the notation is used for measurement that seems the significant contribution to software engineering practice.	computer program;concurrency (computer science)	Jonathan Rose	1992	Information & Software Technology	10.1016/0950-5849(92)90062-T	computer science;systems engineering;theoretical computer science	SE	-45.50077945829834	28.822862143674534	184027
944a4373dcbc9c6dc53ba8003a0d691f6bcee2d8	model checking by generating observers from an interface specification between components	model cheking;uml;timing diagram;model checking;communication protocol;design verification;short period;software design;cost model;embedded software	In the field of embedded software systems where many kinds of systems must be developed in a short period of time and at low cost, model checking, which is one of the automatic design verification tech- niques, is expected to become easy for software designers to use. The difficulties of model checking include the describing of queries or ob- servers as the system property to be verified, and the analyzing of a counterexample in order to find the cause of a fault. There are meth- ods to solve these problems such as generating observers from ordinary software design formats describing system behavior rules, and comparing that behavior with a counterexample to locate a reason for the fault. In this paper, a method generating observers from a timing diagram that describes an interface specification between two components is proposed. The purpose is to make it possible for designers to describe queries of verification easily and also analyze counterexamples easily. In addition, the result of applying this method to a communication protocol applica- tion is reported.	model checking	Tetsuo Hasegawa;Yoshiaki Fukazawa	2009		10.1007/978-3-642-01112-2_53	timing diagram;model checking;unified modeling language;communications protocol;real-time computing;embedded software;software verification;computer science;software design;theoretical computer science;operating system;database;distributed computing;programming language	SE	-43.546195024049936	30.77411248098458	184076
492671aea3b0eedfdb8a3e241670809e2b7ea0f1	a relational model for formal object-oriented requirement analysis in uml	developpement logiciel;class diagram;proceso concepcion;design process;formal specification;formal model;behavioral analysis;semantica formal;lenguaje uml;metodo formal;methode formelle;conceptual model;software development process;langage modelisation unifie;formal semantics;formal method;specification formelle;semantique formelle;requirement analysis;especificacion formal;semantic model;object oriented;desarrollo logicial;unified modelling language;analyse comportementale;software development;unified modeling language;relational model;object oriented software development;oriente objet;analisis conductual;orientado objeto;requirement specification;use case;processus conception	This paper is towards the development of a methodology for object-oriented software development. The intention is to support effective use of a formal model for specifying and r easoning during the requirements analysis and design of a software development process. The overall p urpose is to enhance the application of the Unified Modelling Language (UML) with a formal semantics in the Rational Un ified Software Development Process (RUP). The semantic framework defines the meaning of some U ML submodels. It identifies both thestatic anddynamicrelationships among these submodels. Thus, the focus of this paper is the de velopment of a semantic model to consistently combine a use-case model and aconceptual class diagramto form a system specification.	mathematical model;relational model;requirement;requirements analysis;semantics (computer science);software development process;unified modeling language	Zhiming Liu;Jifeng He;Xiaoshan Li;Yifeng Chen	2003		10.1007/978-3-540-39893-6_36	unified modeling language;p-modeling framework;formal methods;uml tool;computer science;software engineering;applications of uml;class diagram;programming language;rational unified process;use case points;algorithm	SE	-42.471098739043036	25.921871121066562	184413
18cc2164ec6274ca8f904b25a6c6b9d7390319ef	a knowledge-based prototyping environment for construction of scientific modeling software	software tool;ordinary differential equation;software engineering;domain knowledge;first order;model building;numerical computation;model development;graphic user interface;software development tools;simultaneous equations;formal language;knowledge base	Over the past 30 years, scientific software models have played an increasingly prominent role in the conduct of science. Unfortunately, scientific models can be difficult and time-consuming to implement, and there is little software engineering support specifically available for constructing scientific models. Because these models are not easily specified to scientifically-naive programmers, and because the scientist requires intimate knowledge of the code to conduct experiments, many scientists implement their own models. This coding activity takes valuable time away from their primary scientific mission. We have developed a knowledge-based software development tool that assists scientists in prototyping scientific models. With a specialized graphical user interface, the scientist constructs a high-level visual specification that captures the essential computational dependencies in the desired model. The system uses its scientific domain knowledge to ensure that the model being built is consistent and coherent. The final product is an executable prototype of a scientific model. Our tool accelerates the model-building process and eliminates the scientist's need to program in a formal language. Furthermore, the models developed with this tool are easier to understand and reuse than typical low-level scientific modeling code. At present, models developed with our system are restricted to those involving non-coupled algebraic and first order ordinary differential equations. Research is ongoing to lessen this restriction and support models with simultaneous equations.	coherence (physics);computation;executable;experiment;formal language;graphical user interface;high- and low-level;knowledge-based systems;linear algebra;programmer;programming tool;prototype;software development;software engineering	Richard M. Keller;Michal Rimon;Aseem Das	1994	Automated Software Engineering	10.1007/BF00871693	domain analysis;ordinary differential equation;knowledge base;formal language;scientific modelling;model building;simultaneous equations;computer science;systems engineering;engineering;artificial intelligence;theoretical computer science;software development;software engineering;domain engineering;software construction;first-order logic;graphical user interface;programming language;domain knowledge	SE	-45.045012559100286	27.665154196607208	186191
52a884d4b2dc757fa20ad26557d9845d7a1b6d39	making metamodels aware of concrete syntax	developpement logiciel;modelizacion;representation graphique;uml;diagramme etat;semantics;semantica;semantique;specification language;modeling language;langage dedie;modelisation;visual languages;metamodel;diagrama estado;metamodele;metamodelo;desarrollo logicial;abstract syntax;graphical representation;ocl;software development;case tool;visual language;domain specific language;state diagram;grafo curva;mof;architecture basee modele;concrete syntax description;lenguaje especificacion;metamodeling;modeling;langage specification;lenguaje formal;model driven architecture;graphics;formal language;arquitectura basada modelo;lenguaje dedicado;langage formel	Language-centric methodologies, triggered by the success of Domain Specific Languages, rely on precise specifications of modeling languages. While the definition of the abstract syntax is standardized by the 4-layer metamodel architecture of the OMG, most language specifications are held informally for the description of the semantics and the (graphical) concrete syntax. This paper is tackling the problem of specifying the concrete syntax of a language in a formal and non-ambiguous way. We propose to define the concrete syntax by an extension of the already existing metamodel of the abstract syntax, which describes the concepts of the language, with a second layer describing the graphical representation of concepts by visual elements. In addition, an intermediate layer defines how elements of both layers are related to each other. Unlike similar approaches that became the basis of some CASE tools, the intermediate layer is not a pure mapping from abstract to concrete syntax but connects both layers in a flexible, declarative way. We illustrate our approach with a simplified form of statecharts.	abstract syntax;computer-aided software engineering;domain-specific language;graphical user interface;metaclass;metamodeling;modeling language;object constraint language;parse tree;reference implementation;sms language;state diagram	Frédéric Fondement;Thomas Baar	2005		10.1007/11581741_15	natural language processing;metamodeling;abstract syntax;computer science;syntax;abstract semantic graph;semantics;programming language;homoiconicity;algorithm;abstract syntax tree;syntax error	SE	-42.01482419053059	25.59988643973236	186417
bd647cd00e767c6984fa82e6c0cf5cfe5249ef80	systematic generation of standard compliant tool support of diagrammatic modeling languages	grammar;standards;uml;diagrammatic languages;visualization;mde;shape;syntactics;unified modeling language;standard compliance;unified modeling language syntactics standards concrete visualization shape grammar;uml diagrammatic languages standard compliance tooling support mde;tooling support;concrete	In the Model-Driven Engineering community, the abstract syntax of modeling languages is usually defined and implemented using metamodeling techniques. However, it is not the case for the concrete syntax of graphical modeling languages. Indeed, this concern is mostly specified by informal means. This practice leaves considerable leeway in the implementation and raises several standards compliance issues. Hence, toolsmiths can only rely on their interpretation of the standard and lack of systematic way to build conforming tool support. In this context, a first normative specification of the concrete syntax of UML 2.5 has been recently released using Diagram Definition. In this paper, we propose an approach that uses those formal specifications to systematically generate modeling language tool support that guarantees compliance to standard notation. We assess the approach on a subset of the UML class diagram implemented within the open-source Papyrus tool.	abstract syntax;class diagram;conformity;formal specification;graphical user interface;metamodeling;model-driven engineering;model-driven integration;open-source software;papyrus;parse tree;standards-compliant;unified modeling language	Alexis Fouche;Florian Noyrit;Sébastien Gérard;Maged Elaasar	2015	2015 ACM/IEEE 18th International Conference on Model Driven Engineering Languages and Systems (MODELS)	10.1109/MODELS.2015.7338266	natural language processing;unified modeling language;uml tool;computer science;applications of uml;class diagram;programming language;engineering drawing	SE	-47.59578735736875	26.086634573644513	187308
100491469ed274b5105ec8f10e6ec8505f3418ef	viewpoints in the smart home product line	software;domain specific langauges;system engineering;intelligent actuators;dsl;smart home;model system;software maintenance;probability density function;systems engineering;smart home product line;distributed computing;code generation;model transformation;maintenance engineering;product line;data mining;software engineering;systems analysis home automation;smart homes maintenance engineering systems engineering and theory intelligent sensors buildings software maintenance hardware costs intelligent actuators distributed computing;systems engineering and theory;model driven development;building automation;computational modeling;systems analysis;product line engineering;code generators;building automation smart home product line systems engineering code generators software engineering;smart home product line engineering model driven development domain specific langauges;intelligent sensors;buildings;domain specificity;smart homes;home automation;hardware	In product lines for systems engineering a number of different viewpoints on the modeled system have to maintained, comprising both software-related viewpoints and domain-specific views on hardware and environment. A major engineering challenge is to maintain model transformations and code generators working on these viewpoints. This paper proposes an engineering approach that explicitly describes the relation between viewpoints. We use these descriptions to better modularize transformations and thus improve the maintainability of MDD tool chains. This is shown within a smart home case study, which combines building automation and software engineering.	code generation (compiler);home automation;model transformation;model-driven engineering;network switch;sensor;software engineering;systems engineering	Michael C. Jäger;Ludger Fiege	2009	2009 16th Annual IEEE International Conference and Workshop on the Engineering of Computer Based Systems	10.1109/ECBS.2009.39	maintenance engineering;embedded system;home automation;computer science;systems engineering;engineering;operating system;software engineering;computer engineering	SE	-48.24726125652711	31.277680583047026	187653
38b7555183e273b77da0b595ec1a52677545d8e3	object based software engineering with hidden sorted ecatnets and hidden labeled rewriting logic	software engineering logic prototypes software prototyping petri nets concurrent computing protocols computer science design engineering solids;distributed system;protocols;high level petri net;formal specification;concurrent computing;observational equivalence;requirements validation;life cycle;efficient prototyping;design engineering;software prototyping;software prototyping object oriented programming rewriting systems formal logic petri nets bisimulation equivalence formal specification;prototypes;logic;and phrases object based software engineering;object oriented programming;software engineering;prototyping;concurrent systems;requirements specification;hidden sorted ecatnets;rewriting systems;rewriting logic;high level petri nets;formal logic;correct incorrect refinement;concurrent bisimulation;communication protocol;petri nets object based software engineering hidden sorted ecatnets hidden labeled rewriting logic logic of concurrency concurrent systems distributed systems requirements specification requirements validation concurrent bisimulation observational equivalence prototyping communication protocols;computer science;petri nets;distributed systems;logic of concurrency;bisimulation equivalence;requirement specification;object based software engineering;communication protocols;hidden labeled rewriting logic;solids	Hidden sorted ECATNets and hidden labeled rewriting logic were introduced independently from each other. Hidden sorted ECATNets were developed to meet the objectives of object based software engineering. Their semantics in terms of logic of concurrency allows them to be used in the life cycle of sequential as well as concurrent and distributed systems. They are mainly useful in the earliest stages of the life cycle, i.e., for system requirements specification and validation through prototyping. Hidden labeled rewriting logic was introduced to deal with concurrent bisimulation, a concept that is essentially equivalent to observational equivalence useful for comparing different concurrent systems and proving their correctness. We first state under which conditions hidden sorted ECATNets may be interpreted in terms of hidden labeled rewriting logic, then we show how both formalisms may be associated for efficient prototyping and correct (or incorrect) refinement of system specification. Our exposition is illustrated by a known example from the area of communication protocols.	object-based language;rewriting;software engineering	Mohamed Bettaz	2001		10.1109/AICCSA.2001.934020	communications protocol;concurrent computing;computer science;theoretical computer science;database;programming language;logic;algorithm	SE	-42.796687139118845	30.12062910830033	187814
79a32d6f6e5fd1cd4944d0319d6324abb069b583	combining fuml and profiles for non-functional analysis based on model execution traces	fuml;uml profiles;model based analysis	For developing software systems it is crucial to consider non-functional properties already in an early development stage to guarantee that the system will satisfy its non-functional requirements. Following the model-based engineering paradigm facilitates an early analysis of non-functional properties of the system being developed based on the elaborated design models. Although UML is widely used in model-based engineering, it is not suitable for model-based analysis directly due to its lack of formal semantics. Thus, current model-based analysis approaches transform UML models into formal languages dedicated for analyses purpose, which may introduce accidental complexity of implementing the required model transformations.  The recently introduced fUML standard provides a formal semantics of a subset of UML enabling the execution of UML models. In this paper, we show how fUML can be utilized for analyzing UML models directly without having to transform them. We present a reusable framework for performing model-based analyses leveraging execution traces of UML models and integrating UML profiles heretofore unsupported by fUML. A case study in the performance analysis domain is used to illustrate the benefits of our framework.	error-tolerant design;executable uml;formal language;functional requirement;no silver bullet;non-functional requirement;profile (uml);profiling (computer programming);programming paradigm;semantics (computer science);software release life cycle;software system;tracing (software);unified modeling language	Luca Berardinelli;Philip Langer;Tanja Mayerhofer	2013		10.1145/2465478.2465493	real-time computing;uml tool;computer science;systems engineering;applications of uml;data mining	SE	-44.34910767884351	31.814326355146225	188000
58f9aa265c369a0626b9a0b0aa08bd35ddd562f7	a formal method for analyzing software architecture models in sam	verification;electronic commerce;formal model;temporal logic;inference mechanisms;electronic commerce software architecture model petri net temporal logic formal verification formal method deductive reasoning model checking;formal method;software architecture connectors logic helium computer science petri nets electronic commerce nasa space technology costs;software architecture;formal verification;model checking;software architecture model;inference mechanisms software architecture temporal logic petri nets formal verification electronic commerce;transition systems;petri nets;petri net;sam	The Software Architecture Model (SAM) is a general software architecture model basedon a dual formalism combiningPetri netsand temporal logic. A SAM model containsa hierarchical setof compositions,each of which consistsof a setof components, a setof connector s, anda setof constraints.Thispaperproposesa formalmethodfor analyzingSAMmodelsin both element(either component or connector)level and compositionlevel. Thebasicidea is to simulatePetri netbehaviors in termsof fair transition systems. The properties of individual componentsand connector s are verified either by deductivereasoningor model checking. The properties of the entire systemis inferred from the propertiesof its constituents.A detailed casestudy of an electronic commer ce systemshowsour approach to formally modeling, refining and analyzing softwarearchitecturemodels.	fits;formal methods;model checking;semantics (computer science);software architecture;temporal logic	Huiqun Yu;Xudong He;Yi Deng;Lian Mo	2002		10.1109/CMPSAC.2002.1045076	e-commerce;reference architecture;real-time computing;formal methods;computer science;theoretical computer science;software engineering;database;programming language;petri net;systems architecture	SE	-42.99412691467128	30.891574295636644	189075
0a220aa5efc8ee4f7e3892410f0e3eaaca364570	data modeling in uml and orm: a comparison	data model	The Unified Modeling Language (UML) is becoming widely used for software and database modeling, and has been accepted by the Object Management Group as a standard language for object-oriented analysis and design. For data modeling purposes, UML includes class diagrams, that may be annotated with expressions in a textual constraint language. Although facilitating the transition to object-oriented code, UML’s implementation concerns render it less suitable for developing and validating a conceptual model with domain experts. This defect can be remedied by using a fact-oriented approach for the conceptual modeling, from which UML class diagrams may be derived. ObjectRole Modeling (ORM) is currently the most popular fact-oriented approach to data modeling. This paper examines the relative strengths and weaknesses of ORM and UML for data modeling, and indicates how models in one notation can be translated into the other.	class diagram;data modeling;software bug;unified modeling language	Terry A. Halpin;Anthony C. Bloesch	1999	J. Database Manag.	10.4018/jdm.1999100101	natural language processing;data modeling;uml state machine;communication diagram;data model;systems modeling language;uml tool;computer science;element;applications of uml;class diagram;object-role modeling;database;shlaer–mellor method;modeling language;programming language;story-driven modeling;node;object constraint language	SE	-47.784926514703145	26.363456430155463	190354
461cda18dec4b6c35e7a71f1ab73feb445cf1736	aspect oriented region analysis for efficient grid application reasoning	reliability;grid applications;gridpianalyzer;regional analysis;object oriented programming;formal verification aspect oriented region analysis efficient grid application reasoning reliability temporal reasoning gridpianalyzer;temporal reasoning grid computing object oriented programming;aspect oriented region analysis;formal verification;assembly costs formal verification material storage manufacturing automation laboratories manufacturing systems reliability engineering systems engineering and theory state space methods;state space;temporal properties;aspect oriented;grid computing;temporal reasoning;efficient grid application reasoning	With the development of grid techniques and the growing complexity of grid applications, reasoning the temporal properties of grid application to ensure its reliability is becoming more and more critical. In this work, two decomposition approaches are proposed to improve the performance of the temporal reasoning of complex grid applications. The proposed approaches are implemented in our GridPiAnalyzer for equipment grid. Results show that our approach can reduce both CPU time and memory cost compared to using traditional formal verification algorithm alone due to the exponential reduction of system state space	algorithm;aspect-oriented programming;central processing unit;formal verification;state space;time complexity	Ke Xu;Yuexuan Wang;Cheng Wu	2006	2006 Fifth International Conference on Grid and Cooperative Computing (GCC'06)	10.1109/GCC.2006.31	aspect-oriented programming;formal verification;computer science;state space;theoretical computer science;reliability;database;programming language;object-oriented programming;grid computing	HPC	-42.85640722195419	31.415720364333893	190458
b2badf61af1ba6b557defea344e4bc291d6c7da6	functional hybrid modeling	langage fonctionnel;lenguaje programacion;outil logiciel;software tool;simulation systeme;langage simulation;programming language;modeling and simulation;lenguaje simulacion;simulacion hibrida;modelo hibrido;lenguaje funcional;langage declaratif;simulation hybride;modele hybride;functional programming;modeling language;hybrid model;herramienta controlada por logicial;declarative language;langage programmation;simulation language;programmation fonctionnelle;functional language;causal models;hybrid simulation;system simulation;programacion funcional;simulacion sistema;qualite logiciel;software quality	The modeling and simulation of physical systems is of key importance in many areas of science and engineering, and thus can benefit from high-quality software tools. In previous research we have demonstrated how functional programming can form the basis of an expressive language for causal hybrid modeling and simulation. There is a growing realization, however, that a move toward non-causal modeling is necessary for coping with the ever increasing size and complexity of modeling problems. Our goal is to combine the strengths of functional programming and non-causal modeling to create a powerful, strongly typed fully declarative modeling language that provides modeling and simulation capabilities beyond the current state of the art. Although our work is still in its very early stages, we believe that this paper clearly articulates the need for improved modeling languages and shows how functional programming techniques can play a pivotal role in meeting this need.	causal filter;causality;declarative programming;functional programming;hybrid system;map;modeling language;programming language;simulation	Henrik Nilsson;John Peterson;Paul Hudak	2003		10.1007/3-540-36388-2_25	declarative programming;simulation;computer science;artificial intelligence;modeling language;programming language;functional programming;modeling perspective;algorithm;software quality;simulation language;causal model	PL	-42.69029624436101	26.57180700959642	191465
16e9d95ab44b781b2cf8c5b7cd6e53bcb911e061	transformations of software product lines: a generalizing framework based on category theory		Software product lines are used to manage the development of highly complex software with many variants. In the literature, various forms of rule-based product line modifications have been considered. However, when considered in isolation, their expressiveness for specifying combined modifications of feature models and domain models is limited. In this paper, we present a formal framework for product line transformations that is able to combine several kinds of product line modifications presented in the literature. Moreover, it defines new forms of product line modifications supporting various forms of product lines and transformation rules. Our formalization of product line transformations is based on category theory, and concentrates on properties of product line relations instead of their single elements. Our framework provides improved expressiveness and flexibility of software product line transformations while abstracting from the considered type of model.	category theory;feature model;logic programming;software product line	Gabriele Taentzer;Rick Salay;Daniel Strüber;Marsha Chechik	2017	2017 ACM/IEEE 20th International Conference on Model Driven Engineering Languages and Systems (MODELS)	10.1109/MODELS.2017.22	feature model;product type;theoretical computer science;domain model;systems engineering;category theory;software;unified modeling language;computer science;software product line;generalization	SE	-45.14473503309598	25.966800649808494	191825
fff6e7fe2d7a8c9d3e8de2b33112e982468efe2f	towards ontouml for software engineering: transformation of rigid sortal types into relational databases	software;computational modeling;unified modeling language;relational databases;context;object oriented modeling;data models	OntoUML is an ontologically well-founded conceptual modelling language that distinguishes various types of classifiers and relations providing precise meaning to the modelled entities. Efforts arise to incorporate OntoUML into the Model-Driven Development approach as a conceptual modelling language for the PIM of application data. In a prequel paper, we have introduced and outlined our approach for a transformation of OntoUML PIM into a PSM of a relational database. In this paper, we discuss the details of various variants of the transformation of Rigid Sortal types of OntoUML.	entity;experiment;implicit shape model;mixin;model-driven architecture;model-driven engineering;ontouml;relation (database);relational database;software engineering;system f;unified modeling language	Zdenek Rybola;Robert Pergl	2016	2016 Federated Conference on Computer Science and Information Systems (FedCSIS)	10.1007/978-3-319-45547-1_1	natural language processing;unified modeling language;data modeling;relational database;computer science;data mining;database;computational model	SE	-45.33365350859822	26.506404645729045	191990
b4f917f94a7776247039055b9a3e975f08060bbd	atomic use case: a concept for precise modelling of object-oriented information systems	object oriented information systems;interfase usuario;interfaz grafica;object oriented model;the australian standard research classification 210000 science general;graphical interface;user interface;analyse fonctionnelle;conceptual analysis;object database;analisis conceptual;input output;functional analysis;object oriented;graphic user interface;oriente objet;interface utilisateur;information system;functional requirement;object oriented analysis;analyse conceptuelle;orientado objeto;interface graphique;use case;systeme information;sistema informacion;analisis funcional	We propose the concept of atomic use case and demonstrate how this concept can be used to bring the analysis of functional requirements of information systems to a much deeper level than usual, and ultimately to construct a precise specification of the system's functionality. Specifically, the complete functionality of an information system is defined by a set of atomic use cases, which are consistently specified in terms of their input, output, pre- and postcondition. We also show that the usefulness of the atomic use case concept goes beyond analysis. With this concept, a characterization of the business logic layer can be clearly formulated, and this layer can be systematically extended to effectively support the construction of graphical user interface.		Kinh Nguyen;Tharam S. Dillon	2003		10.1007/978-3-540-45242-3_41	functional analysis;computer science;operating system;data mining;graphical user interface;database	PL	-41.63234577154743	25.7958497375362	192238
b0c7184dd7ca3ce64d658339e7a7ab70522a1c4a	combining model-driven and schema-based program synthesis	kalman filters;model transformation;program synthesis;mathematical models;signal processing;input output routines;computer systems programs;algorithms;kalman lter;architecture computers;model driven architecture	We describe ongoing work which aims to extend the schema-based program synthesis paradigm with explicit models. In this context, schemas can be considered as model-to-model transformations. The combination of schemas with explicit models offers a number of advantages, namely, that building synthesis systems becomes much easier since the models can be used in verification and in adaptation of the synthesis systems. We illustrate our approach using an example from signal processing.	aggregate function;comment (computer programming);correctness (computer science);database schema;domain model;filter (software);model-driven integration;modeling language;postcondition;program synthesis;programming paradigm;scope (computer science);signal processing;whole earth 'lectronic link	Ewen Denney;Jon Whittle	2004			simulation;computer science;theoretical computer science	Logic	-44.34217974508906	27.085410042925933	192397
72de27fa93f1943eb25bfeccbb464134e2a4977a	an algebraic formalization of the gof design patterns	software engineering;category theory;design pattern;sequence diagram	Abstract This document reports on the use of an algebraic, visual, formal approach to the specification of patterns for the formalization of the GoF design patterns. The approach is based on graphs, morphisms and operations from category theory and exploits triple graphs to annotate model elements with pattern roles. Being based on category theory, the approach can be applied to formalize patterns in different domains. Novel in our proposal is the possibility of describing (nested) variable submodels, inter-pattern synchronization across several diagrams (e.g. class and sequence diagrams for UML design patterns), pattern composition, and conflict analysis.	category theory;design pattern;linear algebra;pattern language;sequence diagram;unified modeling language	Paolo Bottoni;Esther Guerra;Juan de Lara	2010	CoRR		sequence diagram;engineering;theoretical computer science;software engineering;design pattern;structural pattern;category theory	SE	-44.758708029066355	27.089845638928423	192648
6d33017eedb368c030afcfd775b28fb58246ef85	towards the systematic generation of channelling constraints	generic model;model generation	The automatic modelling tool Conjure generates CSP models from problem specifications. The generated models may contain multiple alternative (redundant) representations of the same variable. However, the combined models generated by Conjure do not include the channelling constraints needed to maintain the consistency between the alternative representations. In this paper we show that by using only the tools already provided by the Conjure system we can generate correct channelling constraints.	communicating sequential processes	Bernadette Martínez Hernández;Alan M. Frisch	2005		10.1007/11564751_97	computer science	SE	-43.60710145501155	29.855405046852017	193056
bb394b7c1b8e5b750543c3863692f0af2ebfd2f9	ontology-based checking method of requirements specification	checking requirements specification;requirements verification;requirements ontology			Dang Viet Dzung;Atsushi Ohnishi	2014	IEICE Transactions	10.1587/transinf.E97.D.1028	software requirements specification;verification;requirement;system requirements specification;functional specification;non-functional testing;non-functional requirement;requirements traceability	SE	-45.52198511740148	30.899706844936812	193555
a7ff68fd2e04036e71f916e90525360965660cc1	formal specification of a generic separation kernel		Intransitive noninterference has been a widely studied topic in the last few decades. Several well-established methodologies apply interactive theorem proving to formulate a noninterference theorem over abstract academic models. In joint work with several industrial and academic partners throughout Europe, we are helping in the certification process of PikeOS, an industrial separation kernel developed at SYSGO. In this process, established theories could not be applied. We present a new generic model of separation kernels and a new theory of intransitive noninterference. The model is rich in detail, making it suitable for formal verification of realistic and industrial systems such as PikeOS. Using a refinement-based theorem proving approach, we ensure that proofs remain manageable.		Freek Verbeek;Sergey Tverdyshev;Oto Havle;Holger Blasum;Bruno Langenstein;Werner Stephan;Yakoub Nemouchi;Abderrahmane Feliachi;Burkhart Wolff;Julien Schmaltz	2014	Archive of Formal Proofs		computer science;database;programming language;algorithm	PL	-45.056635223187406	29.307575971827045	193864
0158a90238eee84d175373c8d991a969f28a6165	tool support for aspect-oriented design	lenguaje uml;langage modelisation unifie;feasibility;unified modelling language;aspect oriented;practicabilidad;faisabilite;oriente aspect	In this paper, we describe the tool we plan to build in order to show the feasibility of aspect-oriented design, and demonstrate the advantages that it implies. This technique allows one to independently specify cross-cutting concerns and functionnal features of a system. The tool would then allow the weaving of the aspects on the model one after the other, creating a design model that would comply to all speciications, with additionally a high-quality a r c hitecture.	aspect-oriented programming;aspect-oriented software development;cross-cutting concern;interpreter (computing)	François Mekerke;Geri Georg;Robert B. France	2002		10.1007/3-540-46105-1_32	unified modeling language;feasibility study;simulation;aspect-oriented programming;computer science;programming language	EDA	-42.36073308791518	25.768459946372833	195293
d3bacda2cca7f95102d522f9d62a191693b5fd9b	enhancing xtext for general purpose languages		Xtext is a popular language workbench conceived to support development of tooling (e.g. parsers and editors) for textual languages. Although Xtext offers strong support for source code generation when building tooling for Domain Specific Languages (DSL), the amount of hand-written source code required to give support to complex General Purpose Languages (GPL) is still significant. This research investigates techniques for reducing the amount of hand-written source code for supporting GPLs, via the development of new DSLs from which source code can be automatically generated. In particular, these techniques will be researched in the context of the OCL and QVT Operational languages.	automatic programming;code generation (compiler);digital subscriber line;domain-specific language;eclipse xtext;language workbench;object constraint language;parsing;qvt	Adolfo Sánchez-Barbudo Herrera	2014			programming language;language workbench;parsing;digital subscriber line;source code;domain-specific language;computer science	PL	-47.74931496030157	26.05920132399928	195654
427c1346bf42a0c1d012644cb0a4f8a0e9f49bc4	from scenario modeling to scenario programming for reactive systems with dynamic topology		Software-intensive systems often consist of cooperating reactive components. In mobile and reconfigurable systems, their topology changes at run-time, which influences how the components must cooperate. The Scenario Modeling Language (SML) offers a formal approach for specifying the reactive behavior such systems that aligns with how humans conceive and communicate behavioral requirements. Simulation and formal checks can find specification flaws early. We present a framework for the Scenario-based Programming (SBP) that reflects the concepts of SML in Java and makes the scenario modeling approach available for programming. SBP code can also be generated from SML and extended with platform-specific code, thus streamlining the transition from design to implementation. As an example serves a car-to-x communication system. Demo video and artifact: http://scenariotools.org/esecfse-2017-tool-demo/	java;modeling language;platform-specific model;programmer;requirement;sbp;simulation	Joel Greenyer;Daniel Gritzner;Florian König;Jannik Dahlke;Jianwei Shi;Eric Wete	2017		10.1145/3106237.3122827	computer science;modeling language;theoretical computer science;communications system;real-time computing;topology;reactive system;java;distributed computing	Embedded	-41.687290218380795	29.8123881020817	195781
059eeeeaef83743f338dc410640583e7dc8ea215	an open environment for the integration of hetereogenous modelling techniques and tools	modelizacion;logica temporal;formalization;tool;tool support;document specification compose;temporal logic;methode formelle;herramienta;integration;formal method;tool environment;modelisation;heterogeneidad;integracion;formalizacion;integration donnee;formalisation;modeling;outil;logique temporelle;heterogeneity;heterogeneite	Even though the development of formal methods makes steady progress with respect to techniques and tool support, their acceptance in industry is still relatively low. One reason for this probably stems from the fact that most formal approaches require users to forget about their conventional techniques and tools, and to relearn in a new environment. What makes this switch even harder to accept: due to their research character, tools for formal methods can usually not compete w.r.t. convenience, stability, and degree of integration to conventional, state-of-the-art commercial tools. Applying modern repository-based integration techniques to tools for formal methods can overcome some of these drawbacks. Moreover, an incremental migration, in which users can continue to apply their established conventional techniques and tools, adding formal support in degrees as desired, seems to be promising for bringing formal methods to practice. A framework based on the idea of combining established modelling techniques and tools with formal ones has been developed in the context of the Espress project: among others, Statecharts [8], a widely used graphical notation for reactive behavior, are combined with the formal notation Z [20], and with temporal logic [3, 2]. The resulting combined notation is supported by a speci cation methodology [7] and, last but not least, by an open and scalable tool integration environment { the design principles of which will be sketched in this paper. The applicability of our approach has been demonstrated in two reference case-studies of the Espress project that where provided by the industrial partners. One case-study is the specici cation of a tra c light system [1], the second [7] is the speci cation of an intelligent cruise control.	formal methods;graphical user interface;scalability;temporal logic	Robert Büssow;Wolfgang Grieskamp;Winfried Heicking;Stephan Herrmann	1998		10.1007/3-540-48257-1_11	formal methods;systems modeling;temporal logic;computer science;artificial intelligence;heterogeneity;algorithm	SE	-42.73325559798907	26.240337756063568	196641
7664461f6b87c4c5d46fa1a0d269b1ad22bbefeb	partial order semantics for use case and task models	formal framework;partial order semantics;task models;user interface;task model;partially ordered sets;semantics;formal semantics;semantic model;semantic mapping;partially ordered set;use case models;functional requirement;use case	Use case models are the specification medium of choice for functional requirements, while task models are employed to capture User Interface (UI) requirements and design information. In current practice, both entities are treated independently and are often developed by different teams, which have their own philosophies and lifecycles. This lack of integration is problematic and often results in inconsistent functional and UI design specifications causing duplication of effort while increasing the maintenance overhead. To address these shortcomings, we propose a formal semantic framework for the integrated development of use case and task models. The semantic mapping is defined in a two step manner from a particular use case or task model notation to the common semantic domain of sets of partially ordered sets. This two-step mapping results in a semantic framework that can be more easily reused and extended. The intermediate semantic domains have been carefully chosen by taking into consideration the intrinsic characteristics of use case and task models. As a concrete example, we provide a semantics for our own DSRG use case formalism and an extended version of ConcurTaskTrees, one of the most popular task model notations. Furthermore, we use the common semantic model to formally define a set of refinement relations for use case and task models.	concurtasktrees;encapsulation (networking);entity;functional requirement;hol (proof assistant);isabelle;overhead (computing);precondition;refinement (computing);s-expression;semantic mapper;semantics (computer science);software propagation;top-down and bottom-up design;transition system;tree structure;turing completeness;uc browser;user interface design	Daniel Sinnig;Ferhat Khendek;Patrice Chalin	2010	Formal Aspects of Computing	10.1007/s00165-010-0158-z	partially ordered set;semantic computing;computer science;data mining;task analysis;database;semantics;programming language	SE	-43.02505689445244	27.856685825746887	196933
c1771220e6f7efb14bf99bae0bb8b7c6de7dd3c3	the partial metrics system: modeling the stepwise refinement process using partial metrics	partial metrics system;partial metric term;refinement process;stepwise refinement process;pseudocode refinement process;partial metrics system design;partial metrics	The Partial Metrics System design is explained, with an emphasis on the refinement process. A model, with its three phases, shows that the pseudocode refinement process can be monitored in partial metric terms.	pseudocode;refinement (computing);stepwise regression;top-down and bottom-up design	Robert G. Reynolds	1987	Commun. ACM	10.1145/32206.32211	mathematical optimization	Networks	-45.67138848938119	29.044714468779468	197094
1553d422dc55500dab302b18c68beb6d70ec72a7	application invariants: design by contract augmented with deployment correctness logic	design by contract;defensive programming;embedded correctness checking;application invariants	methods, class inheritance and late binding. As a result, the application invariants technique is inherently dependent on, and applicable to, object-oriented languages. The discussion continues with a detailed account of related work. Then the implementation pattern for application invariants is incrementally introduced, starting with an outline of the subject abstract data type. Next, the way application invariants can be used in client programs is shown followed by a discussion on consolidated experience for defect detection using the proposed technique. Finally, some additional extensions of Design by Contract are introduced, closing with a brief summary and the key technical conclusions.	abstract data type;application programming interface;bilateral filter;client honeypot;closing (morphology);coexist (image);computable function;conformance testing;correctness (computer science);defensive programming;design by contract;embedded system;emoticon;formal verification;interrupt;john d. wiley;late binding;method (computer programming);norm (social);precondition;programming complexity;robustness (computer science);run time (program lifecycle phase);software bug;software deployment;software design pattern;software development process;software engineering;software propagation;software quality;test case;unit testing;well-formed petri net	Anthony Savidis	2006	Softw., Pract. Exper.	10.1002/spe.695	computer science;design by contract;theoretical computer science;operating system;database;distributed computing;programming language;satisfiability;defensive programming	PL	-41.96082449715711	30.680707790271263	197098
eac015ad4c5796beaea713bffb213c58221c15cb	experiences with colored predicate-transition nets for specifying and prototyping embedded systems	distributed system;system engineering;formal specification;large distributed systems colored predicate transition nets embedded systems prototyping hardware systems software engineer software development process high order petri nets concurrent system specification systemspecs rapid system prototyping real time system prototype customer presentations industrial applications visual complexity;executable specification;software prototyping;complex structure;software development process;parallel programming;indexing terms;software engineering;embedded system;concurrent systems;complexity reduction;system analysis;industrial application;petri nets;petri net;parallel programming real time systems formal specification software prototyping graph colouring petri nets;prototypes embedded computing embedded software hardware application software power engineering and energy programming power engineering computing petri nets software prototyping;embedded software;graph colouring;real time systems	Computer systems in today's society require an increasing amount of embedded software and hardware systems. Their application has introduced new problems for the software engineer combined with the complexity of such systems. In particular, the early stages of the software development process are vital for the successful implementation of computer systems. High order Petri nets are introduced and extended as a powerful formalism for the specification and analysis of concurrent systems. A tool called SystemSpecs has been applied that supports rapid system prototyping with such nets. This survey article provides techniques for early systems analysis that can be used as a real time system prototype for customer presentations. Small examples are extracted from industrial applications to indicate how the described techniques can be used. While the major disadvantage of typical net descriptions is their visual complexity that makes them useless for large distributed systems, the paper also describes how to find overly complex structures, and describes selected methods of how to refine such structures.	computer systems;concurrency (computer science);distributed computing;embedded software;embedded system;embedding;ephrin type-b receptor 1, human;experience;extraction;petri net;prototype;semantics (computer science);software development process;software engineer;specification	Christof Ebert	1998	IEEE transactions on systems, man, and cybernetics. Part B, Cybernetics : a publication of the IEEE Systems, Man, and Cybernetics Society	10.1109/3477.718515	real-time computing;system of systems;computer science;theoretical computer science;systems development life cycle;petri net;software system	Embedded	-43.4063579628128	30.658982211864608	197265
687010035d3895b5073ccaf799ed8c01d77458fd	modeling real-time communication systems: practices and experiences in motorola	structure methods;structured methods;uml modeling;tool support;design and development;wireless communication systems;real time;code generation;real time communication systems;model validation;visual modeling;model driven engineering;sdl modeling;real time communication;mde code generation;software specification;ttcn	Visual modeling languages and techniques have been increasingly adopted for software specification, design, development, and testing. With the major improvements of UML 2.0 and tools support, visual modeling technologies have significant potential for simplifying design, facilitating collaborations, and reducing development cost. In this paper, we describe our practices and experiences of applying visual modeling techniques to the design and development of real-time wireless communication systems within Motorola. A model-driven engineering approach of integrating visual modeling with development and validation is described. Results, issues, and our viewpoints are also discussed.	real-time locating system	Michael Jiang;Michael Groble;Andrij Neczwid;Allan Willey	2006	J. Vis. Lang. Comput.	10.1016/j.jvlc.2006.10.003	model-driven architecture;software requirements specification;real-time computing;simulation;computer science;operating system;software engineering;database;regression model validation;programming language;code generation	Embedded	-48.00423097303615	30.45415684416173	197323
3b02d76fd7c49eb75afca82e8d773e53e97323c4	specification, validation, and synthesis of email agent controllers: a case study in function rich reactive system design	high availability;electronic mail;formal methods;formal method;expressive power;software architecture;complex data;lessons learned;requirement engineering;reactive system;reactive systems;finite state machine	With a few exceptions, previous formal methods for reactive system design have focused on finite state machines represented in terms of boolean states and boolean next-state functions.  By contrast, in many reactive system domains requirements engineers and developers think in terms of complex data types and expressive next-state functions. Formal methods for reactive system design must be extended to meet their needs as well.  I term a reactive system  function rich  if expressing its state, next-state function, or output function naturally requires this higher expressive power.  ISAT, a prototype formal-methods based tool environment, is intended to assist in the creation of function rich reactive systems.  This paper describes a case study I have carried out using ISAT to design, validate, synthesize, and evolve controllers for the email agent components making up a novel spam-free email system that I deployed in a user trial in July 1999. The trial has been running since, with high availability, through several evolutionary specification changes and resulting software releases.  In addition to summarizing ISAT and the trial, this paper discusses tool requirements placed by the domain and task, the simple and powerful platform/controller/pure-functions software architecture of the components, as well as lessons learned from the study.	email;systems design	Robert J. Hall	2000		10.1145/349360.351126	real-time computing;simulation;formal methods;reactive system;computer science;software engineering;programming language	Logic	-46.923705778235856	30.16848439820945	197398
455871ff4fa8e652ff1b73ce2a7dc1ad5603e776	specification and verification of uml2.0 sequence diagrams using event deterministic finite automata	deterministic automata;formal specification;temporal logic;uml2 0 sequence diagrams;unified modeling language automata object oriented modeling least squares approximation optimized production technology semantics software;model checking propositional projection temporal logic uml2 0 sequence diagram uml diagram specification uml diagram verification software development process event deterministic finite automata software life cycle sequence diagram;etdfa;formal verification;model checking;specification and verification;pptl;deterministic finite automata;unified modeling language;finite automata;pptl uml2 0 sequence diagrams model checking etdfa;unified modeling language deterministic automata finite automata formal specification formal verification temporal logic;sequence diagram	A key challenge in software development process is to detect errors in earlier phases of the software life cycle. For this purpose, the verification of UML diagrams plays an important role in detecting flaws at the analysis and design phase. To enhance the correctness of one of the most popular UML diagrams: sequence diagram (SD), model checking propositional projection temporal logic (PPTL) is adopted. With this method, event deterministic finite automata are used to describe the formal models of an SD, and PPTL is selected to describe a desired property. Experimental result shows that the proposed approach is useful for verifying the properties of SDs and hence for improving the correctness of SDs.	automata theory;correctness (computer science);deterministic finite automaton;finite-state machine;model checking;sensor;sequence diagram;software development process;software release life cycle;temporal logic;unified modeling language;verification and validation	Zhenhua Duan	2011	2011 Fifth International Conference on Secure Software Integration and Reliability Improvement - Companion	10.1109/SSIRI-C.2011.17	sequence diagram;model checking;unified modeling language;temporal logic;formal verification;computer science;theoretical computer science;deterministic finite automaton;formal specification;finite-state machine;programming language;algorithm	SE	-44.214571068343716	30.50907410996201	197472
2947c6311da03bede947adab7685aac226c7a8bb	monterey phoenix, or how to make software architecture executable	behavior model;behavior modeling;software systems;software architecture description language;software architecture;design and implementation;consistency checking	This paper suggests an approach to formal software system architecture specification based on behavior models. The behavior of the system is defined as a set of events (event trace) with two basic relations: precedence and inclusion. The structure of event trace is specified using event grammars and other constraints organized into schemas. The schema framework is amenable to stepwise architecture refinement up to executable design and implementation models, reuse, composition, visualization, and application of automated tools for consistency checks.	eventual consistency;executable;make;refinement (computing);software architecture;software system;stepwise regression;systems architecture	Mikhail Auguston	2009		10.1145/1639950.1640075	multilayered architecture;enterprise architecture framework;behavioral modeling;reference architecture;software visualization;software architecture;space-based architecture;model-driven architecture;real-time computing;database-centric architecture;computer science;applications architecture;software design;software development;software design description;service-oriented modeling;software construction;hardware architecture;database;software architecture description;programming language;resource-oriented architecture;data architecture;systems architecture;software system	SE	-42.24152933939834	30.257694579041445	198026
bd9cea335d5358473018f57346951acbef7c0869	transforming sa/rt graphical specifications into csp+t formalism - obtaining a formal specification from semi-formal sa/rt essential models	formal specification	A correct system specification is systematically obtained from the essential user requirements model by applying a set of rules, which give a formal semantics to the graphical analysis entities of SA/RT. The aim of the systematic procedure is to establish the methodological infrastructure necessary for deriving a complete system specification of a given real-time system in terms of CSP+T processes. A detailed complete solution to the Production Cell problem is discussed, showing how the method can be applied to solve a realworld industrial problem.	adaptive server enterprise;entity;formal specification;formal system;hoc (programming language);r language;real-time clock;real-time computing;real-time transcription;requirement;semantics (computer science);semiconductor industry;software engineering;systems design;user requirements document	Manuel I. Capel;Juan Antonio Holgado Terriza	2005			real-time computing;computer science;formal specification;programming language;algorithm	SE	-41.70591524690237	30.674585618044407	198457
de44b14e51c60dd88fde3864120a82d037f34bc9	specification and validation of dynamic systems using temporal logic	tableau method;dynamic modelling language;temporal logic;dynamic system;dynamic systems;half order dynamic temporal logic dynamic system validation dynamic system specification hdtl tableau method automatic analysis freeze quantifier correctness requirements operational language dynamic modelling language;half order dynamic temporal logic;object oriented systems;automatic analysis;hdtl;dynamic system specification;dynamic system validation;correctness requirements;dynamic characteristic;freeze quantifier;article;temporal logic formal specification program verification;operational language	A specification and validation technique for dynamic systems is proposed. In particular, a new temporal logic, called HDTL, is presented and the tableau method revised for automatic analysis. Using a freeze quantifier, HDTL with the revised tableau method makes it possible to specify the correctness requirements of dynamic systems and validate them. The proposed logic is rather generic, i.e. it has only a few assumptions on operational language. The authors introducc a simple dynamic modelling language and illustrate its experiment. The experiment shows that HDTL is suitable for specifying dynamic properties and the analysis technique is promising.	correctness (computer science);dynamical system;method of analytic tableaux;modeling language;quantifier (logic);requirement;temporal logic	Seung Mo Cho;H. H. Kim;Sung Deok Cha;Doo-Hwan Bae	2001	IEE Proceedings - Software	10.1049/ip-sen:20010558	computer science;theoretical computer science;dynamical system;programming language;algorithm	SE	-44.1381926051186	29.768541736068883	199344
c40547a07ec9a66ca96a92c2472bd2b436dad6ea	dynamic logic semantics for uml consistency	developpement logiciel;modelizacion;logica dynamica;consistencia semantica;soundness;lenguaje uml;book chapter;keywords computer programming languages;orientado aspecto;semantics;model transformation;langage modelisation unifie;state machine;object oriented programming;formal semantics;satisfiability;semantica;semantique;model driven development;uml diagrams;langage dedie;dynamic logic;modelisation;model transformations;formal verification;unified modelling language uml;mathematical models;desarrollo logicial;unified modelling language;software development;formal logic;consistance semantique;domain specific language;architecture basee modele;aspect oriented;logique dynamique;semantic space;information system;modeling;computer simulation;use case;sequence diagram;model driven architecture;systeme information;oriente aspect;domain specific languages;arquitectura basada modelo;lenguaje dedicado;sistema informacion	The Unified Modelling Language (UML) is intended to describe systems, but it is not clear what systems satisfy a given collection of UML diagrams. Stephen Mellor has described a small collection of diagrams which appear to be inconsistent, yet are “cool” according to UML. We describe an approach to defining semantics for UML diagrams using dynamic logic, and show that Mellor’s example is inconsistent, given a reasonable assumption. Our approach interprets all diagrams, static and dynamic, in a single semantic space. The modeller specifies how the meaning of a model is made up from the meanings of its diagrams, thus the “viewpoint” taken by each diagram is made explicit. This composition is achieved through formation of the dynamic logic formulae. It is therefore very flexible, and we propose it as a means for defining semantics for domain specific languages, and for specifying “bridges” or “weaving” model transformations used in aspect oriented modelling. One approach to modelling is to begin with use-cases, and aim to reproduce them as sequence diagrams executed by the model being developed. Whether or not a model can execute a sequence diagram is therefore a question which will be asked frequently when working this way. We want the question to have a definite answer, and we want our tools to give us that answer. Any multi-view approach to modelling will have similar questions about the relative consistency of its parts. The way to make these questions precise and amenable to automatic solution is by defining formal semantics for our language. Formal semantics are usually associated with formal verification for safety critical, or other trusted systems. Formal semantics are also usually associated with incomprehensible symbolic mumbo-jumbo. The ability to formally certify the products of model driven development would certainly be beneficial. However, if the semantics could be understood by at least some modelling practitioners, the result would be clearer thinking and greater consensus in the modelling community. Modelling of problem domains would produce better understanding, and hence better solutions. Although endowing parts of UML with formal semantics has become quite an industry, we do not know of any work that gives uniform semantics for class, state machine and sequence diagrams, as well as UML actions. Reggio and coworkers suggest an analogy between UML diagrams and logical axioms [13]. We promote the idea from analogy to practice, translating the diagrams and actions into formulae of dynamic logic [7]. Object diagrams can also be formalised, and adding OCL to the repetoire would be straightforward, following [3].	aspect-oriented programming;domain-specific language;dynamic logic (modal logic);finite-state machine;formal verification;free viewpoint television;modeller;model-driven engineering;problem domain;semantics (computer science);sequence diagram;trusted system;uml state machine;unified modeling language	Greg O'Keefe	2006		10.1007/11787044_10	computer simulation;natural language processing;unified modeling language;uml tool;computer science;domain-specific language;applications of uml;semantics;shlaer–mellor method;programming language;algorithm	AI	-41.373808105077394	25.360624550777967	199386
386e0b051dda0642cc843cb59b11f46e150ef65e	formal integration of inheritance with typed attributed graph transformation for efficient vl definition and model manipulation	formal specification;unified modeling language type theory inheritance graph grammars formal specification visual languages;model transformation;node type inheritance type attributed graph transformation visual language model manipulation metamodeling unified modeling language uml model transformation specification formal integration algebraic graph grammar;graph transformation;visual languages;graph grammar;type theory;unified modeling language;visual language;metamodeling unified modeling language production systems solids;graph grammars;inheritance;meta model	Several approaches exist to define a visual language (VL). Among those the meta-modeling approach used to define the Unified Modeling Language (UML), and the graph transformation approach are very popular. Especially the combination of both, using meta-modeling to define the syntax of a VL and graph transformation for specifying model transformations has been considered conceptually and explored in a number of applications. A formal integration of both approaches has just been started by integrating classical algebraic graph grammars with a node type inheritance concept. In this paper, the integration of inheritance is extending to attributed graph transformation. More precisely, we define attributed type graphs with inheritance leading to a formal integration of inheritance with typed attributed graph transformation.	attributed graph grammar;correctness (computer science);critical pair (logic);diagram;graph rewriting;metamodeling;model transformation;parsing;semantics (computer science);simulation;uml state machine;unified modeling language;visual language	Hartmut Ehrig;Karsten Ehrig;Ulrike Golas;Gabriele Taentzer	2005	2005 IEEE Symposium on Visual Languages and Human-Centric Computing (VL/HCC'05)	10.1109/VLHCC.2005.37	natural language processing;computer science;abstract semantic graph;graph algebra;programming language;algorithm;graph rewriting	PL	-45.0130835794251	26.73747494162931	199568
1d6f94a82c5fb76df1059c799e0003871b058019	maestro for let's dance: an environment for modeling service interactions	080000 information and computing sciences	In emerging web service development approaches, the description of interactions both from a global and from a local perspective plays an increasingly important role. In earlier work we presented a visual language (namely Let’s Dance) for modeling service interactions at different levels of abstraction. In this paper we present a modeling tool for Let’s Dance. The tool supports the static analysis of global models, the generation of local models from global ones, and the interactive simulation of both local and global models.	interaction;principle of abstraction;simulation;static program analysis;visual language;web service	Gero Decker;Margarit Kirov;Johannes Maria Zaha;Marlon Dumas	2006			simulation;human–computer interaction;computer science;multimedia	SE	-41.15565520669049	31.72657659914841	199759
62c6f5daf197f82d55699e70c1b956f41b6c612e	an experimental investigation of formality in uml-based development	formal specification;unified modeling language software engineering logic programming computer society contracts natural languages inspection context;learning curve;uml;index terms comprehension of software models;controlled experiment;natural languages;object oriented programming;indexing terms;software engineering;comprehension of software models;ocl index terms comprehension of software models software engineering experimentation uml;formal method;formal verification;impact analysis;natural language;ocl;unified modeling language;formal verification unified modeling language object oriented programming object oriented languages constraint handling natural languages formal specification;software engineering experimentation;constraint handling;object oriented languages;uml analysis model uml based development unified modeling language object constraint language statechart guard condition system logic system functionality;object constraint language	The object constraint language (OCL) was introduced as part of the Unified Modeling Language (UML). Its main purpose is to make UML models more precise and unambiguous by providing a constraint language describing constraints that the UML diagrams alone do not convey, including class invariants, operation contracts, and statechart guard conditions. There is an ongoing debate regarding the usefulness of using OCL in UML-based development, questioning whether the additional effort and formality is worth the benefit. It is argued that natural language may be sufficient, and using OCL may not bring any tangible benefits. This debate is in fact similar to the discussion about the effectiveness of formal methods in software engineering, but in a much more specific context. This paper presents the results of two controlled experiments that investigate the impact of using OCL on three software engineering activities using UML analysis models: detection of model defects through inspections, comprehension of the system logic and functionality, and impact analysis of changes. The results show that, once past an initial learning curve, significant benefits can be obtained by using OCL in combination with UML analysis diagrams to form a precise UML analysis model. But, this result is however conditioned on providing substantial, thorough training to the experiment participants.	agile software development;class invariant;experiment;formal methods;guard (computer science);natural language;object constraint language;software engineering;state diagram;unified modeling language	Lionel C. Briand;Yvan Labiche;Massimiliano Di Penta;Han Yan-Bondoc	2005	IEEE Transactions on Software Engineering	10.1109/TSE.2005.105	unified modeling language;formal methods;uml tool;computer science;systems engineering;applications of uml;database;shlaer–mellor method;natural language;programming language;object-oriented programming;object constraint language	SE	-47.01255634901685	28.400063382437796	199894
