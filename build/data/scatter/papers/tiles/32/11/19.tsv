id	title	keywords	abstract	entities	authors	year	journal	doi	fos	area	x	y	ix
352e7dc3646aba691bacfd3eeec11e3ebb5f4401	tag machines for modeling heterogeneous systems	prototype tool tag machines heterogeneous systems embedded systems heterogeneous components denotational mathematical frameworks heterogeneous composition;prototypes;simulation;vectors tagging context indexes interoperability prototypes embedded systems;tag machines;embedded systems;indexes;formal verification;vectors;simulation heterogeneity tag machines;interoperability;context;heterogeneity;tagging;formal verification embedded systems	Embedded systems are often composed from components of very different natures, e.g., mechanical and electronic. Composition of heterogeneous components is generally not well-defined, making design and verification difficult. Denotational mathematical frameworks for reasoning effectively on heterogeneous composition have recently been made available. In this work, we propose an operational version of this formalism, based on tag machines, that can represent heterogeneous composition, and we provide conditions under which the heterogeneous composition can be captured soundly and completely. We have implemented our operational framework in a prototype tool which we use for experimental evaluation.		Thi Thieu Hoa Le;Roberto Passerone;Ulrich Fahrenberg;Axel Legay	2013	2013 13th International Conference on Application of Concurrency to System Design	10.1109/ACSD.2013.23	database index;interoperability;formal verification;computer science;theoretical computer science;heterogeneity;data mining;database;prototype;programming language	Embedded	-40.33140899965635	30.76989059804126	168529
cf0990ade6aadaa351c6bafff63e3f4e0cc0863d	introduction of gate types into sdl	reference model	Objects are dually characterized by their state and their behaviour. They are always encapsulated, that is, changes in an object‘s state can only occur as a result of an internal action or an interaction with its environment. Interfaces again are abstractions of the behaviour of an object consisting of a subset of the object‘s interactions and constraints on their occurence. An object may support multiple occurences of interfaces (of the same or different types). In order for two objects to interact, they have first to obtain references to the respective interface instances, what is supported by the infrastructure.	encapsulation (networking);interaction;simple directmedia layer	Eckhardt Holz;Joachim Fischer	1998			reference model;distributed computing;computer science	SE	-38.21334318593305	29.969336862911753	169257
1705b26d34baa3536228d7e7f713dbed36699b5d	using lotos patterns to characterize architectural styles	software architecture;architectural style	We show how the formal description language LOTOS can be used to deene software architectures and how patterns over LOTOS can serve to characterize architectural styles. We characterize styles by giving characteristics of the involved processes, a top-level communication pattern, and constraints that are suucient conditions for a concrete architectural description to be an instance of a given style. Three style characterizations are presented and illustrated by an example.		Maritta Heisel;Nicole Lévy	1997		10.1007/BFb0030643	computer architecture;architectural pattern;computer science;software engineering;programming language	SE	-38.87153968372321	28.448902371414274	169804
16e69827d21b8d93fa9dec87858cc33e61feb0b2	modeling and testing object-oriented distributed systems with linear-time temporal logic	linear time temporal logic;distributed system;formal model;temporal logic;event based behavioral abstraction;formal method;object oriented systems;procedural dependencies;design and implementation;object oriented;object orientation	Numerous proposals for applying temporal logic to the speci cation and veri cation of object-oriented systems have appeared in the past several years. Although various temporal models have been proposed for the requirements analysis of object-oriented distributed systems, there is no similar amount of work for the designand implementation phase. We present a formal model for the designand implementation stage which re ects practical requirements and is yet su ciently general to be applied to a wide range of systems. In our model, which relies on event-based behavioral abstraction, we use linear-time temporal logic as the underlying formalism for the speci cation of behavioral constraints. We show that although temporal logic is a powerful tool for behavior speci cations, it does not have the expressive power required for non-trivial object systems. Speci cally, in an object-system it is often essential to express procedural dependencies rather than simple temporal relationships for which we introduce two novel operators. In a case study we demonstrate the practical relevance and applicability of our model.	distributed computing;formal language;formal system;linear temporal logic;relevance;requirement;requirements analysis	Falk Dietrich;Xavier Logean;Jean-Pierre Hubaux	2001	Concurrency and Computation: Practice and Experience	10.1002/cpe.571	linear temporal logic;real-time computing;description logic;formal methods;temporal logic;interval temporal logic;computation tree logic;computer science;theoretical computer science;programming language;object-oriented programming;object-orientation;algorithm;temporal logic of actions	PL	-39.91813213687453	29.063873865137456	169883
cabc35576f68181097574464feb18c5338775905	φdevs: phase based discrete event modeling	discrete event modeling;equation based modeling;devs	Even though DEVS provides a convenient framework for discrete event modeling, it can be observed that there is a large difference between the abstraction levels of conceptual models and their specifications in DEVS. Equation based modeling is a declarative modeling style that has become popular for describing continuous dynamic systems in a way that is conceptually closer to conceptual models. Although equation based modeling languages usually include the notion of a discrete event, they are not a natural choice for discrete event modeling. This paper combines equation based modeling with constraint solving in order to create a fully equation based discrete event modeling style. The approach centers around phases, which are described by a constraint (an inequality) and behavior (a set of equations). The resulting models are fully compliant with DEVS: phase descriptions are transformed to internal transitions and time advance. The main contribution of this paper is the adoption of constraints and relations as the sole mechanism to specify models and using an algebraic solver to infer transitions and time advance. Compared to equation based systems, the contribution is to make constraint inequations first-class citizens and to use them symbolically to determine events.		H. Job Honig;Mamadou D. Seck	2012			discrete mathematics;simulation;discrete event dynamic system;computer science;theoretical computer science;devs	EDA	-37.19098247184204	29.135552613475927	171096
6675364e4da8a8319b27032130a2304e27d6ac88	a computer-aided protocol design by production systems approach	ops5 production system approach;modelizacion;concepcion asistida;external procedure calls;computer aided design;protocols;formal specification;etude theorique;implementation phase;cad;generic specification;rule based;performance;production system;simulation;protocol design;simulacion;data type;data templates;rule based computations;algorithme;modelisation;algorithm;automata;virtual prototyping;computational modeling;telecommunications computing;telecomunicacion;pattern matching;computer aided protocol design;procedure based computations;telecommunication;state transitions;estudio teorico;incremental validation algorithm;conception assistee;working memory;generic specification formal specification rule based computations computer aided protocol design ops5 production system approach object attribute value state transitions incremental validation algorithm globally shared dataspace procedure based computations external procedure calls implementation phase pattern matching data templates;production systems;software tools;object attribute value;rendimiento;theoretical study;protocols production systems reachability analysis software tools algorithm design and analysis pattern matching virtual prototyping computational modeling computer simulation automata;modeling;computer simulation;telecommunications computing cad formal specification knowledge based systems protocols;algorithm design and analysis;reachability analysis;knowledge based systems;state transition;production rule;algoritmo;globally shared dataspace	A computer-aided protocol design system based on the OPS5 production system approach is proposed. Communication rules (state transitions) are specified as triples of object-attribute-value and the modeling of state transitions is specified by production rules. An incremental validation algorithm to facilitate protocol design is also presented. Based on a globally shared dataspace (working memory) in which different types and levels of information are all represented in a uniform structure, the OPS5 production system integrates both rule-based and procedure-based computations. Using this characteristic, the machine-dependent part can be abstractly specified through external procedure calls, the details of which can be coded in a procedure language until the implementation phase. Since computations in OPS5 are based on pattern matching, all of the attributes of elements that are in production rules or in external procedure calls can act as data templates for generic data types. This capability enhances the generic specification that allows different realizations for various implementation environments. >		Chung-Ming Huang;Ye-In Chang;Ming T. Liu	1990	IEEE Journal on Selected Areas in Communications	10.1109/49.62860	computer simulation;computer science;theoretical computer science;database;distributed computing;production system	Embedded	-34.75956280693762	29.637841142132977	171179
28aff337bbf78401140dbba71520061454f7a6a6	modelling of emergency vehicle preemption systems using statecharts	analytical models;trees mathematics reachability analysis road traffic road vehicles;vehicles roads timing control systems analytical models transient analysis;control systems;intelligent transport system;statecharts;road traffic;emergency vehicle preemption;trees mathematics;reachability tree method emergency vehicle preemption system modelling control statecharts visual formalism complex system modelling causality property concurrency property traffic light behaviors light transition;transient analysis;roads;vehicles;intelligent transport system statecharts emergency vehicle preemption;reachability analysis;road vehicles;timing	Statechart has been utilized as a visual formalism for the modeling of complex systems. It illuminates the features on describing properties of causality and concurrency. This paper focuses on the use of statecharts to model the preemption of emergency vehicles system. The advantage of the proposed approach is the clear presentation of traffic lights' behaviors in terms of conditions and events that cause the preemption phase. Moreover, the paper also proposes a new emergency vehicle preemption policy that provides the emergency vehicles can pass through the intersections with minimal delay. The analysis of the control models is performed to demonstrate how the models enforce the lights' transitions by reachability tree method. And then the reachability and reversibility properties of the control statecharts will be obtained.	causality;complex systems;concurrency (computer science);finite-state machine;national supercomputer centre in sweden;preemption (computing);reachability;semantics (computer science);state diagram	Yi-Shun Weng;Yi-Sheng Huang;Shun-Feng Su;Chi-Shan Yu	2011	2011 IEEE International Conference on Systems, Man, and Cybernetics	10.1109/ICSMC.2011.6083742	real-time computing;simulation;control system;control theory	Robotics	-37.48057795406988	30.842515836520274	171985
eba7970d3d5970556e9cc0cdf689c5cef98416db	an abstract model for proving safety of multi-lane traffic manoeuvres	motorway traffic;spatial interval logic;abstract model;lane change;abstract modelling;modal logic;multi lane motorway traffic;lane change manoeuvre;collision freedom;timed automata	We present an approach to prove safety (collision freedom) of multi-lane motorway traffic with lane-change manoeuvres. This is ultimately a hybrid verification problem due to the continuous dynamics of the cars. We abstract from the dynamics by introducing a new spatial interval logic based on the view of each car. To guarantee safety, we present two variants of a lane-change controller, one with perfect knowledge of the safety envelopes of neighbouring cars and one which takes only the size of the neighbouring cars into account. Based on these controllers we provide a local safety proof for unboundedly many cars by showing that at any moment the reserved space of each car is disjoint from the reserved space of any other car.	hybrid kernel;interval temporal logic	Martin Hilscher;Sven Linker;Ernst-Rüdiger Olderog;Anders P. Ravn	2011		10.1007/978-3-642-24559-6_28	modal logic;simulation	AI	-37.475594566289644	30.72549933026038	172896
06339264f578916a9baca1464d04ae4bb2756d81	translating sequential function charts to the compositional interchange format for hybrid systems	visual languages programmable controllers;model design;programmable controllers;atomic clocks;semantics;programmable logic control hardware sequential function charts compositional interchange format hybrid systems logic controllers specification;automata;adaptation model;visual languages;monitoring;hybrid system;mathematical model;interchange format;sequential function chart;process simulation;programmable logic;automata semantics monitoring mathematical model adaptation model atomic clocks	Sequential Function Chart (SFC) is a powerful graphical formalism for the specification of logic controllers that is well recognized and very successful in industry. In this paper, a scheme for the automatic translation of SFCs into the Compositional Interchange Format (CIF) for hybrid systems is presented that enables the straightforward connection of SFC controllers to CIF models of the controlled system which enables the application of a wide range of modeling, design, and analysis tools that are currently connected to the CIF. The translation procedure is based on the reformulation of the SFC as a CIF automaton that explicitly considers the cyclic execution mode of programmable logic control (PLC) hardware and, thus, provides a realistic representation of the behavior of the logic controller on a PLC. The translation scheme is demonstrated on a two-tank system that is modeled in the gPROMS process simulation environment, automatically translated to the CIF, and simulated after the connection of a SFC controller.	automaton;crystallographic information file;hybrid system;logic control;logic programming;machine translation;programmable logic device;semantics (computer science);sequential function chart;server message block;simulation;space-filling curve;syntax-directed translation;visual programming language	Christian Sonntag;Stephan Fischer	2010	49th IEEE Conference on Decision and Control (CDC)	10.1109/CDC.2010.5718122	control engineering;atomic clock;real-time computing;process simulation;computer science;programmable logic controller;programmable logic device;mathematical model;control theory;mathematics;semantics;automaton;algorithm;hybrid system	Embedded	-36.30114351492082	29.947079715151286	173220
3312cace848e2ec77a1fa7be22c83217fe0fc146	synthesizing reactive systems from lsc requirements using the play-engine	live sequence charts;controller synthesis;reactive system;property a;reactive systems;live sequence chart	Live Sequence Charts (LSCs) is a scenario-based language for modeling object-based reactive systems with liveness properties. A tool called the Play-Engine allows users to create LSC requirements using a point-and-click interface and generate executable traces using features called play-out and smart play-out. Finite executable trace fragments called super-steps are generated by smart play-out in response to user inputs. Each super-step is guaranteed not to violate the LSC requirements, provided one exists. However, non-violation is not guaranteed beyond each individual super-step. In this work, we demonstrate a powerful extension to smart play-out which produces only traces that are guaranteed not to violate the LSC requirements, provided the requirements are realizable. Using this method, we may synthesize correct executable programs directly from LSC requirements.	executable;liveness;object-based language;point and click;requirement;semi-continuity;tracing (software)	Hillel Kugler;Cory Plock;Amir Pnueli	2007		10.1145/1297846.1297895	real-time computing;reactive system;computer science;distributed computing;algorithm	SE	-35.392643852589	31.48486634181824	173431
3c9388f36e911e2742c887a817b1955531a184db	generating vhdl-a - like models using absynth		A method for the graphical specification and the automatic generation of analogue behavioural models is pr esented. This method has been implemented as a new software tool called ABSynth. The behaviour of the component to model is described as a functional diagram, which is then automatically translated into a VHDL-A-like analogue har dware description language. No syntax knowledge is necessary and the modelling time is r duced.	diagram;falcon;hardware description language;interactive machine translation;linear algebra;list of graphical methods;lucas sequence;programming tool;simulation;vhdl;vhdl-ams	Vincent Moser;Hans Peter Amann;Pascal Nussbaum;Fausto Pellandini	1995				SE	-34.256927524094046	25.415009311890824	174015
79ad95df68f0be7e7caae3e6600e58af441487bc	a gpss model of a queueing problem with complex decision making behavior	experimental design;computer program;seasonality;queueing system;problem complexity;technical report;batch arrival;simulation model	This paper covers in detail the simulation model as well as the associated GPSS computer program of a complex queueing problem. Complexity is manifested in terms of the use of the model as well as the model itself. The former pertains to experimental design aspects. The latter, on the other hand, refers to structural considerations (i.e., parallel queueing systems sharing resources) as well as decision making behavior concerning the allocation of these scarce resources (i.e., a batch arrival and service queue with two different forms of balking and reneging).  Following a general description of the model and program, a detailed presentation of the segment of code which represents decision making is made. Then several significant program highlights are discussed. Finally the technical considerations of the use of the program in a research investigation are described.  The paper is intended for seasoned users of simulation. These may either be research investigators or simulation practitioners who at one time or another have been challenged to bring together the modeling requirements of their problem with the modeling capabilities of GPSS.	complexity;computer program;design of experiments;gpss;requirement;simulation	Leonidas C. Charalambides	1982			simulation;computer science;engineering;technical report;gpss;simulation modeling;mathematics;design of experiments;operations research;seasonality;statistics	Metrics	-35.45112695027675	27.0905277661132	174114
c916601e0c8b447194bb936b0abbf2d9d24ac28d	an executable formal framework for safety-critical human multitasking		When a person is concurrently interacting with different systems, the amount of cognitive resources required (cognitive load) could be too high and might prevent some tasks from being completed. When such human multitasking involves safety-critical tasks, for example in an airplane, a spacecraft, or a car, failure to devote sufficient attention to the different tasks could have serious consequences. To study this problem, we define an executable formal model of human attention and multitasking in Real-Time Maude. It includes a description of the human working memory and the cognitive processes involved in the interaction with a device. Our framework enables us to analyze human multitasking through simulation, reachability analysis, and LTL and timed CTL model checking, and we show how a number of prototypical multitasking problems can be analyzed in Real-Time Maude. We illustrate our modeling and analysis framework by studying the interaction with a GPS navigation system while driving, and apply model checking to show that in some cases the cognitive load of the navigation system could cause the driver to keep the focus away from driving for too long.	computer multitasking;executable	Giovanna Broccia;Paolo Milazzo;Peter Csaba Ölveczky	2018		10.1007/978-3-319-77935-5_4	ctl*;real-time computing;model checking;assisted gps;navigation system;executable;cognition;human multitasking;computer science;cognitive load	NLP	-40.389544403534444	29.59433527543356	176183
28652fa7a07bad743c69eeca1b64068595511107	consistent integration for sequential abstract state machines	machine abstraite;sequential machine;description systeme;multiagent system;system description;behavioral analysis;abstract state machine;maquina abstracta;machine sequentielle;abstract machine;maquina secuencial;analyse comportementale;analisis conductual;descripcion sistema;sistema multiagente;systeme multiagent	"""In this paper we deal with the problem of integrating components described as Sequential Abstract State Machines. Two operations are defined to compose sequential ASMs and returning a machine consistent with respect to updates. Due to their nature, such operations can be used to analyze and handle """"behavioral inconsistencies"""" and to prove component and system properties. The applicative aspects of the theoretical issues introduced in the paper are shown by means of three examples: the behavioral description of a telephone system presented in [7], the ASM specification of the Production Cell case study developed in [3], and the ASM solution of the railroad crossing problem given in [12]."""	abstract state machines;finite-state machine	Marianna Nicolosi Asmundo;Elvinia Riccobene	2003		10.1007/3-540-36498-6_19	simulation;computer science;artificial intelligence;abstract machine;programming language;algorithm;abstract state machines	Logic	-38.15678179280038	25.49869421161927	176418
47a02110d77e87bff1e7998b43dd7e3a6f92c8d3	a model-based approach for multi-device user interactions	multi device applications;task models;cross device ui;multi device ui;model based development and tools	This paper presents an approach for modeling multi-device user interactions, based on task models. We use Concur-TaskTrees (CTTs) as a domain-specific language, which we extend here by a labeling mechanism to model multi-device interactive applications. While CTTs are used to specify temporal and causal relations between tasks, we add operators to specify the device mapping in a flexible and expressive way. The main novelty is the introduction of the two new operators, Any and All, to specify if a task should be executed on any or on all of a set of devices. We show that this is applicable in scenarios of connected, smart devices where a task can be executed on a multitude of devices. We present formal semantics for our extension of CTTs as well as a tool chain based on the Qt toolkit for generating code for distributed UIs. This includes a mapping from high-level tasks to concrete UI controls and a distributed execution model based on state machines. The new concepts are validated in several case studies.	causal filter;domain-specific language;high- and low-level;interaction;qt (software);semantics (computer science);smart device;toolchain;user interface	Christian Prehofer;Andreas Wagner;Yucheng Jin	2016		10.1145/2976767.2976776	real-time computing;simulation;computer science;database;programming language	PL	-38.65256074715418	30.400091780826852	176455
54a3ff52450639e7adf538a0aad9246152428b12	an approach to cellular automata modelling in modelica	modelica;devslib;parallel devs;cellularpdevs;cellular automata	A new Modelica library, named CellularPDEVS, is introduced in this manuscript. This new library facilitates the description of oneand two-dimensional Cellular Automata (CA) models in Modelica. CellularPDEVS models have been specified using Parallel DEVS. The library has been implemented using the functionality of the DEVSLib library which supports the Parallel DEVS formalism in Modelica. CellularPDEVS allows the user to focus on describing the behavior of the cell and the characteristics of the cellular space. CellularPDEVS models are compatible with other DEVSLib models, facilitating the combination of CA, Parallel DEVS and other Modelica models. Three examples are presented: Wolfram’s rule 30 and 110, and the Conway’s Game of Life.	cellular automaton;conway's game of life;devs;formal system;rule 30	Victorino Sanz;Alfonso Urquia	2013			computer science;theoretical computer science;devs;modelica;programming language;algorithm	HPC	-36.149341926165526	27.122524431368582	176645
a6bfd0bac39342347fee94bb01383e78954e1bf4	kinetic modelling with the systems biology modelling environment sybme	system biology;modelling and simulation;kinetics;simulation model	Kinetic modelling and simulation is an important approach in systems biology. While the focus of current modelling tools is on simulation, model development is a highly iterative process which is currently only partly supported. To support the development of biochemical models, their simulation, and graphical understanding, we designed and implemented SyBME, the Systems Biology Modelling Environment. Here we present the architecture and the main components of SyBME and show its use by modelling sucrose breakdown in developing potato tubers.	copasi;canonical account;database;graphical user interface;iterative method;open-source software;sbml;simulation;systems biology;volume rendering	Björn H. Junker;Dirk Koschützki;Falk Schreiber	2006	J. Integrative Bioinformatics	10.2390/biecoll-jib-2006-18	computational science;simulation;computer science;bioinformatics;simulation modeling;systems biology;kinetics	SE	-34.78054205860527	26.18269571725788	176773
6cac560cfd4050853f805d45dd62688560374ab5	probabilistic programming for java using symbolic execution and model counting		In this paper we describe a probabilistic programming environment for Java that is based on symbolic execution and model counting. The novelty of the framework is that the probability distributions in the program can themselves be symbolic, which allows parametric probabilistic programming. The framework handles typical probabilistic programming features, such as observe statements, and can be used for the encoding and analysis of Discrete Time Markov Chains (DTMC), Bayesian Networks, etc. We show two examples of using the system: (1) analysis of bubble sort when using an unreliable comparison operation, and, (2) analysis of a simulation model of autonomous aircraft towing vehicles, to show whether plans generated for these vehicles are robust when probability distributions are changed from the ones used to generate the plans.	autonomous robot;bayesian network;bubble sort;integrated development environment;java;markov chain;sampling (signal processing);simulation;symbolic execution;unmanned aerial vehicle	Willem Visser;Corina S. Pasareanu	2017		10.1145/3129416.3129433	probability distribution;inductive programming;theoretical computer science;computer science;bayesian network;machine learning;parametric statistics;probabilistic logic;java;artificial intelligence;symbolic execution;markov chain	SE	-34.58240213564615	29.05178606284024	177669
29a8dbec7526b5b6c882a33b74f85007bb8fbe38	overview of thirty semantic formalisms for reo		Over the past decades, coordination languages have emerged for the specification and implementation of interaction protocols for communicating software components. This class of languages includes Reo, a platform for compositional construction of connectors. In recent years, many formalisms for describing the behavior of Reo connectors have emerged. In this paper, we give an overview of all these classes of semantic models. Furthermore, we investigate the expressiveness of two more prominent classes, constraint automata and coloring models, in detail.	automata theory;color;component-based software engineering;constraint automaton;dos;graph coloring;semantic data model;vereofy	Sung-Shik T. Q. Jongmans;Farhad Arbab	2012	Sci. Ann. Comp. Sci.	10.7561/SACS.2012.1.201	computer science;theoretical computer science;reo coordination language;programming language;algorithm	SE	-38.90051077034395	28.83222589499487	177709
b63441c56fa04a8a133f3da8cc0d1233a5f76e5f	sensoria process calculi for service-oriented computing	distributed system;process calculi;service orientation;e learning system;software systems;network performance;web service;software engineering;qa75 electronic computers computer science;integrated project;service oriented computing;quantitative analysis;process algebra;service engineering	The IST-FET Integrated Project SENSORIA aims at developing a novel comprehensive approach to the engineering of service-oriented software systems where foundational theories, techniques and methods are fully integrated in a pragmatic software engineering approach. Process calculi and logical methods serve as the main mathematical basis of the SENSORIA approach. In this paper we give first a short overview of SENSORIA and then focus on process calculi for service-oriented computing. The Service Centered Calculus SCC is a general purpose calculus which enriches traditional process calculi with an explicit notion of session; the Service Oriented Computing Kernel SOCK is inspired by the Web services protocol stack and consists of three layers for service description, service engines, and the service network; Performance Evaluation Process Algebra (PEPA) is an expressive formal language for modelling distributed systems which we use for quantitative analysis of services. The calculi and the analysis techniques are illustrated by a case study in the area of distributed e-learning systems.		Martin Wirsing;Rocco De Nicola;Stephen Gilmore;M. Hoelzl;Roberto Lucchi;Mirco Tribastone;Gianlugi Zavattaro	2006		10.1007/978-3-540-75336-0_3	web service;process calculus;computer science;quantitative analysis;theoretical computer science;distributed computing;network performance;programming language	SE	-38.45940835730448	28.32874666579818	178725
78ca915454ee9e5cda56283ba430121d15dc5e60	a behavioral model for composition of software components	modele comportement;modelizacion;distributed system;behavior model;movilidad;systeme reparti;components;formal specification;composition;componente logicial;mobility;reconfigurable architectures;behavior modeling;modelo comportamiento;semantics;reo;composant logiciel;coordination language;mobilite;semantica;semantique;software engineering;specification formelle;modelisation;especificacion formal;langage coordination;sistema repartido;lenguaje coordinacion;object oriented;abstract behavior types;software component;software package;genie logiciel;oriente objet;coordinacion;progiciel;exogenous coordination;modeling;orientado objeto;ingenieria informatica;architecture reconfigurable;paquete programa;coordination	Engineering of component based software systems requires a formal model for its foundation. Virtually all contemporary component models use some form of object oriented method invocation for their component composition semantics. In contrast, Abstract Behavior Types (ABT) offer a simpler model of components and their composition. Reo is an exogenous coordination language that provides a middleware for dynamically reconfigurable component composition on distributed, mobile platforms. The ABT model serves as a unifying formalism to express the behavior of Reo connectors, as well as that of components. By examples, we show the expressive power of Reo, and the applicability of the ABT model. RÉSUMÉ. L’ingénierie des systèmes logiciels à base de composants nécessite un modèle formel comme fondation. Virtuellement tous les modèles actuels de composants utilisent une forme particulière d’appel de méthode orienté-objet comme base de leur sémantique de composition. À l’opposé, les Abstract Behavior Types (ABT) offrent un modèle plus simple aux composants et à leur composition. Reo est un langage de coordination exogène qui fournit un intergiciel permettant la composition dynamiquement reconfigurable de composants sur les plates-formes distribuées et mobiles. Le modèle ABT sert de formalisme unificateur pour exprimer le comportement des connecteurs Reo ainsi que celui des composants. Au travers d’exemples, nous montrons le pouvoir d’expressivité de Reo et l’applicabilité du modèle ABT.	automata theory;autonomous robot;black box;complex systems;component-based software engineering;constraint automaton;floor and ceiling functions;formal system;geforce 6 series;integrated development environment;linear algebra;loose coupling;mathematical model;middleware;mobile device;model checking;reconfigurability;reo coordination language;scripting language;server efficiency rating tool;simulation;software system;subroutine;visual programming language	Farhad Arbab	2006	L'OBJET	10.3166/objet.12.1.33-76	behavioral modeling;real-time computing;simulation;computer science;semantics;programming language;algorithm	SE	-39.48173852363837	25.65373904809297	178970
459d7841d9497a06fca26effc7a822e8b7a2eba3	credible autocoding of fault detection observers	safety critical software fault diagnosis formal verification helicopters observers;3 degree of freedom helicopter control system domain specific process observer based fault detection software verification control systems quadratic type invariant properties software safety properties state boundedness correctness properties false alarms formal verification credible autocoding framework synchronous modeling environment simulink code annotation analysis output observer fault detector model;formal methods fault detection software verification credible autocoding aerospace systems;ellipsoids fault detection mathematical model observers semantics software equations	We present a domain specific process to enable the verification of observer-based fault detection software. Observer-based fault detection systems, like control systems, yield invariant properties of quadratic types. These quadratic invariants express both safety properties of the software, such as the boundedness of the states, and correctness properties, such as the absence of false alarms from the fault detector. We seek to leverage these quadratic invariants, in an automated way, for the formal verification of the fault detection software. The approach, named the credible autocoding framework, can be characterized as autocoding with proofs. The process starts with the fault detector model, along with its safety and correctness properties, all expressed formally in a synchronous modeling environment such as Simulink. The model is then transformed by a prototype credible autocoder into both code and analyzable annotations for the code. We demonstrate the credible autocoding process on a running example of an output observer fault detector for a 3 degree-of-freedom helicopter control system.	autocode;autocoder;automated theorem proving;control system;correctness (computer science);ellipsoid method;fault detection and isolation;formal verification;high- and low-level;petri net;prototype;semi-supervised learning;semiconductor industry;simulink	Timothy Wang;Alireza Esna Ashari;Romain Jobredeaux;Eric Feron	2014	2014 American Control Conference	10.1109/ACC.2014.6859131	control engineering;real-time computing;computer science;control theory;fault model	SE	-39.81997243335415	31.755314177674826	179073
bb8f3aaf4fdfce41251e4cd0a2fd1efb2e88fded	data-aware design and verification of service compositions with reo and mcrl2	verification;mcrl2;reo;service based systems	Service-based systems can be modeled as stand-alone services coordinated by external connectors. Reo is a channel-based coordination language with well-defined semantics that enables a compositional construction of complex connectors from a set of primitive channels. It has been successfully applied in the area of web service composition specification as well as in business process modeling. In this paper, we present a mapping from Reo to mCRL2, a specification language based on the process algebra ACP, extended with data and time. The mapping enables verification of Reo process models and service compositions using the mCRL2 model checking facilities. The supporting Eclipse Coordination Tools suite provides a user-friendly environment for the modeling and verification process.	business process;eclipse;mcrl2;model checking;process calculus;process modeling;service composability principle;specification language;usability;web service	Natallia Kokash;Christian Krause;Erik P. de Vink	2010		10.1145/1774088.1774590	real-time computing;verification;computer science;operating system;database;reo coordination language;programming language	SE	-40.96743217458377	31.339902641239853	180055
abddd372eacb4477a00675fa581fdeb222e2596c	x.500 directory service usage for x.400 e-mail	directory service usage;addressing;directory services;x 500;directory service	Abstract In the design of open distributed systems, architectural concepts play a crucial role. Because they are elementary notions, their clear and unambiguous understanding is essential for the understanding of the whole design. One of the key concepts of open systems is the interaction point which is used to conceptually model the boundaries between the system and its environment. In this paper, we investigate the interaction point concept and arrive at a list of properties which an interaction point could have. Most of these properties are formally defined, using a temporal first-order logic with operators for past, present, and future. Some interdependencies between these properties are pointed out and proved. Interaction points can be represented by concepts of formal description techniques (FDTs) or even by a piece of a formal description. In this paper, representations in Estelle, LOTOS, and SDL, which are FDTs specifically designed for the specification of open distributed systems, are studied. The semantics of each of these representations is captured (to some extent) in a unified way by subsets of the listed properties. This makes a limited comparison between them feasible.	directory service;x.500	Urs Eppenberger	1993	Computer Networks and ISDN Systems		directory service;telecommunications;computer science;theoretical computer science;database;programming language;law;world wide web;computer network	Networks	-38.6447054142312	28.36427407066546	180542
5afe031e21c9504645f80f221e697602857754ce	modular design of man-machine interfaces with larissa	concepcion modular;langage reactif;componente logicial;concepcion maquina;component based development;relacion hombre maquina;orientado aspecto;man machine relation;composant logiciel;automaton;sistema reactivo;man machine system;automata;machine design;reactive language;automate;conception machine;software component;reactive system;systeme reactif;modular design;sistema hombre maquina;aspect oriented;man machine interface;relation homme machine;lenguaje reactivo;oriente aspect;conception modulaire;systeme homme machine	The man-machine interface of a small electronic device like a wristwatch is a crucial component, as more and more functions have to be controlled using a small set of buttons. We propose to use Argos, an automaton-based language for reactive systems, and Larissa, its aspectoriented extension, to show that several interfaces can be obtained from the same set of basic components, assembled in various ways. This is the basis of a quite general component-based development method for man-machine interfaces.	automaton;component-based software engineering;human–computer interaction;modular design;user interface;watch	Karine Altisen;Florence Maraninchi;David Stauch	2006		10.1007/11821946_19	computer science;artificial intelligence;component-based software engineering;automaton;programming language;algorithm	SE	-38.880296138853375	26.07934482454164	181016
ff38f3f7dcf5ae080967ee84224e78633f4ac373	a (timed) state-transition semantics for reflective petri nets	symbolic state transition petri nets reflection dynamic systems;system lifecycle;dynamic discrete event systems;formal model;color;petri nets discrete event systems timing pollution discrete event simulation engines markov processes performance analysis stochastic processes scientific computing;markov processes discrete event simulation;dynamic system;dynamic systems;layout;discrete event simulation engine;data mining;state transition semantics;discrete event system;adaptation model;reflective petri nets;reflection model;markov process;discrete event systems;markov process state transition semantics reflective petri nets dynamic discrete event systems system lifecycle dynamic workflow management discrete event simulation engine;markov processes;petri nets;state transition graph;petri net;dynamic adaptation;symbolic state transition;reflection;discrete event;state transition;dynamic workflow management;discrete event simulation;timing	The design of dynamic (adaptable) discrete-event systems calls for adequate modeling formalisms and tools able to manage possible changes occurring during systempsilas lifecycle. A common approach is to pollute design with details that do not regard the current system behavior, rather its evolution. That hampers analysis, reuse and maintenance in general. A Petri net-based reflective model (based on classical Petri nets) was recently proposed to support dynamic discrete-event systempsilas design, and was applied to dynamic workflowpsilas management. Behind there is the idea that keeping functional aspects separated from evolutionary ones, and applying evolution to the (current) system only when necessary, results in a simple formal model on which the ability of verifying properties typical of Petri nets is preserved. On the perspective of implementing in the short time a discrete-event simulation engine, Reflective Petri nets are provided in this paper with a timed state-transition graph semantics, defined in terms of a Markov process.	formal language;high- and low-level;hoc (programming language);semantics (computer science);semiconductor industry;simulation;state diagram;stochastic petri net;verification and validation	Lorenzo Capra	2008	2008 10th International Symposium on Symbolic and Numeric Algorithms for Scientific Computing	10.1109/SYNASC.2008.65	real-time computing;simulation;computer science;theoretical computer science;dynamical system;process architecture;markov process;petri net;statistics	SE	-36.71853794949899	30.243287508329402	181341
f3228d2820bebd823578a9fb47a1cc319ec49886	hybrid dynamic systems: relating chi to hybrid automata	hybrid dynamical system;formal model;transition systems;hybrid system;differential algebraic equation;hybrid automata;model simulation	A hybrid automation is one of the most popular formal models for hybrid system specification. The Chi language is a hybrid formalism for modeling, simulation and verification. It consists of a number of operators that operate on all process terms, including differential algebraic equations. This paper relates the two formalisms by means of a formal translation from a hybrid automaton model to a Chi model, and a comparison of the semantics of the two models in terms of their respective transition systems. The comparison is illustrated by means of three examples: a thermostat, a railroad gate controller, and dry friction.	automata theory;chi;differential algebraic equation;dynamical system;formal verification;hybrid automaton;hybrid system;semantics (computer science);simulation	Dirk A. van Beek;Niek G. Jansen;J. E. Rooda;Ramon R. H. Schiffelers;Ka Lok Man;Michel A. Reniers	2003		10.1145/1030818.1030904	discrete mathematics;differential algebraic equation;theoretical computer science;mathematics;algorithm;hybrid system	Logic	-39.69213488402314	30.424456497209423	182708
61ed7a0a08b95fe5a3c347615d407961e9eea52e	formal verification of communication protocols	verification;formal verification;communication protocol;satisfiability;network protocols	This paper presents the modeling and formal verification of some communication protocols for Remote Procedure Call (RPC). These protocols include Request (R) Protocol, Request Reply (RR) Protocol and Request-Reply-Acknowledgement (RRA) Protocol. We have modeled the above-mentioned protocols in Symbolic Model Verifier (SMV), a formal verification tool. In modeling of each protocol, each of the two agents (Client and Server) is modeled as a finite state machine. The common channel between these agents is modeled as a bounded queue of message. Some important features of modeled protocols are then formal verified using the SMV tools.	communications protocol;computer science;corner case;finite-state machine;formal verification;network security;queue (abstract data type);rapid refresh;remote procedure call;spin;sensor	M. A. S. Smith	1996			communications protocol;formal methods;formal verification;computer science;theoretical computer science;distributed computing;runtime verification;programming language;intelligent verification;functional verification	Networks	-34.63985631264629	31.945404915058102	182932
91178092241f9d77df449f8ed48e6c9991e41d0d	formal reasoning for air traffic control system using event-b method		We present a formal modeling and verification of Air Traffic Control system (ATC) for airspace management. This system assists air traffic controllers by visualizing aircrafts in the airport vicinity. In such a critical-safety system, the use of robust formal methods that assure bugs absence is highly required. Therefore, we use a formalism of discrete transition systems based on abstraction and refinement along proof obligations. These proofs ensure the consistency of the system by mean of invariants preservation and deadlock freedom. The first guarantee that all invariants hold permanently and thus provide a handy solution for bugs absence verification. The second prove that the system runs forever to avoid deadlock. This modeling and proving enable us to establish that the system is, relatively to some criteria, correct by construction.	b-method;control system;reason	Abdessamad Jarrar;Youssef Balouki	2018		10.1007/978-3-319-95165-2_17	mathematical optimization;airspace class;real-time computing;air traffic management;computer science;mathematical proof;formal methods;b-method;air traffic control;deadlock;formalism (philosophy)	Robotics	-40.843225533820615	29.809070672830902	183000
c74799db68aaaafa5534dfc965ba94bb69898f87	petri nets with causal time for system verification	high level petri net;automated verification;timed automata;petri net;constrained system	We present a new approach to the modelling of time constrained systems. It is based on untimed high-level Petri nets using the concept of causal time. With this concept, the progression of time is modelled in the system by the occurrence of a distinguished event, tick , which serves as a reference to the rest of the system. In order to validate this approach as suitable for automated verification, a case study is provided and the results obtained using a model-checker on high-level Petri nets are compared with those obtained for timed automata using prominent tools. The comparison is encouraging and shows that the causal time approach is intuitive and modular. It also potentially allows for efficient verification.	automata theory;causal filter;color gradient;high- and low-level;model checking;petri net;timed automaton	Cécile Bui Thanh;Hanna Klaudel;Franck Pommereau	2002	Electr. Notes Theor. Comput. Sci.	10.1016/S1571-0661(04)80521-8	real-time computing;stochastic petri net;computer science;theoretical computer science;process architecture;petri net;algorithm	SE	-38.14199978628231	31.162505765114464	183646
0141f03da4b15c80231035dd39592bbc6062d44a	specification of a batch plant using process algebra and petri nets	text;high level languages;publikationer;resource allocation;individual object;konferensbidrag;indexing terms;automatic generation;production engineering computing;discrete event system batch plant process algebra petri nets general routing system resource allocation system high level language specification language;modelling framework;discrete event system;batch processing industrial;modelling language;specification languages;artiklar;discrete event systems;rapporter;algebra petri nets routing automatic control resource management high level languages automation laboratories signal processing automotive engineering;petri nets;production engineering computing process algebra petri nets resource allocation specification languages high level languages discrete event systems batch processing industrial;process algebra;petri net;high level language	A modelling framework for general routing and resource allocation systems is presented. The task is to specify desired routes for individual objects (products, data packets, vehicles), which are to be served by a number of shared resources (machines, computers, communication links). Based on simple booking models for the resources and routing specifications for the objects, a controller that synchronizes the objects utilization of the available resources is automatically generated. A high level language is presented in order to simplify the specification of desired routes. This modelling language combines Petri nets and process algebra. Process operators are introduced for specification of alternative, synchronization, start and stop process, and restriction, which are applied in order to model join and split operations. This language results in a compact and efficient representation of complex routing specifications.	automata theory;batch processing;computer;formal specification;high-level programming language;modeling language;network packet;petri net;process calculus;routing;synchronization (computer science)	Petter Falkman;Bengt Lennartson;Michael Tittus	2005	IEEE International Conference on Automation Science and Engineering, 2005.	10.1109/COASE.2005.1506792	real-time computing;computer science;theoretical computer science;distributed computing	Robotics	-35.13232898505472	30.18352357433013	183707
6b8f759cd8ae47fbc943ea8aa5cb52eb84c930db	object-oriented simulation with sml and silk in java and .net: object-oriented simulation with sml and silk in .net and java	simulation library;advanced simulation developer;object-oriented simulation;languages vb;object-oriented programming language;object-oriented simulation model;discrete-event simulation;simulation code;system behavior;simulation control;system controller	This tutorial is for advanced simulation developers engaged in the use of object-oriented programming languages and libraries that support object-oriented, discrete-event simulation. The tutorial is based on generic structures common to SML simulation libraries in the .Net languages VB.Net, C# and J# and the Silk libraries in Java. The focus of the tutorial is on the use of consistent design patterns that encourage usability, reusability and cross-language compatibility. Particular emphasis is placed on designing and coding object-oriented simulation models to properly transfer simulation control between entities, resources and system controllers, and on techniques for obtaining a one-to-one correspondence between simulation code and system behavior.	.net framework;design pattern;entity;java;library (computing);one-to-one (data model);programming language;silk;simulation;usability;visual basic[.net];visual j#	Richard A. Kilgore	2003		10.1145/1030818.1030849	computer science;theoretical computer science;programming language	PL	-34.05584169120802	26.264157905831887	184223
4066cb44247bf987eda9d8dc1a4a0dab3573512c	development of generic simulation models to evaluate wafer fabrication cluster tools	system performance;design evaluation;technical report;simulation model;analytical model;semiconductor manufacturing;discrete event simulation	This document presents the purpose, development and applications of generic simulation models used to design, evaluate and demonstrate the potential performance of semiconductor wafer fabrication cluster tools. The use of this type of highly integrated equipment is growing rapidly within the semiconductor manufacturing industry. Because of the complex interactions involved in cluster tools, analytical models and calculations have usually been inadequate for determining system performance. However, discrete-event simulation models have proven to be quite beneficial to cluster tool developers and owners. The models are used to simulate the performance of equipment integrating multiple process modules in a radial cont@ration. A menu-clrken interface permits analysts to customize, develop and exercise the model for a variety of cluster tools.	interaction;radial (radio);semiconductor device fabrication;simulation;wafer (electronics);wafer fabrication	Neal G. Pierce;Michael J. Drevna	1992		10.1145/167293.167757	simulation;computer science;systems engineering;engineering;technical report;discrete event simulation;simulation modeling;computer performance;semiconductor device fabrication;world wide web;manufacturing engineering	HPC	-35.41983729147468	26.127677959790148	184261
15789c4e5b44cebc627a2003627a6921b7057195	time considered irrelevant for real-time systems	systeme temps reel;distributed system;interfase usuario;systeme reparti;protocole transmission;user interface;mando numerico;sistema informatico;simulation;simulacion;computer system;commande numerique;protocolo transmision;sistema repartido;communication protocol;interface utilisateur;real time system;systeme informatique;sistema tiempo real;digital control;real time systems;transmission protocol	Various manifestations of the time-as-a-proxy phenomenon in specification of computing problems are considered. It is argued that unless the time-related considerations constitute an essential part of natural (physical) problems, safer specifications are obtained from avoiding short-cuts offered by introduction of time-related notions. This methodological principle is illustrated by examples from several fields: digital control and simulation, design of operator's interface and communication protocols.		Wladyslaw M. Turski	1988	BIT	10.1007/BF01941129	communications protocol;simulation;real-time operating system;digital control;telecommunications;user interface	Embedded	-33.944661431467885	30.3098767122957	185013
da2948dd087d9c18befd4957a208404a05c9987c	developments in dynamic and intelligent reconfiguration of industrial automation	reconfiguration;controleur logique programmable;controlador logica programable;componente logicial;reconfigurable architectures;automatisation;composant logiciel;automatizacion;commande industrielle;programmable logical controller;industrial control;software component;iec 61499;industrial automation;architecture reconfigurable;industrial automation and control;programmable logic controller;automation	This paper provides an overview of current techniques to allow the industrial systems to automatically adapt to change while maintaining predictable and stable system behaviour. This is performed along the dimensions of simple, dynamic and intelligent reconfiguration and focuses on the physical device and software component levels of the shop floor and in particular, on automatic reconfiguration of programmable logic controller systems. Through an analysis of recent work by the authors and others in this area, the paper identifies the basic requirements for intelligent reconfiguration and the outstanding issues in this area. # 2008 Elsevier B.V. All rights reserved.	automation;competitive analysis (online algorithm);component-based software engineering;control system;data recovery;distributed artificial intelligence;drag and drop;firewall (computing);intelligent control;interoperability;peripheral;programmable logic device;real-time computing;real-time transcription;refinement (computing);requirement;seamless3d;software architecture;tag (game);top-down and bottom-up design;usability;wizard (software)	Robert W. Brennan;Pavel Vrba;Pavel Tichý;Alois Zoitl;Christoph Sünder;Thomas I. Strasser;Vladimír Marík	2008	Computers in Industry	10.1016/j.compind.2008.02.001	control engineering;real-time computing;computer science;engineering;automation;computer engineering	Robotics	-34.597561813249925	30.667799365931113	185104
6fdae5281b792c9c9ec2b14b06e2e58274bb96d4	object oriented modelling and simulation of hydropower plants with run-of-river scheme: a new simulation tool	generic model;info eu repo semantics article;simulator;component library;operating characteristic;graphic user interface;object oriented modelling;water flow;hydropower plants;simulation tool	This paper presents the design of a component library for modelling hydropower plants, and describes the development of a new simulation tool for small hydropower plants with a run-of-river scheme. After reviewing the desirable features of simulation, an approach based on an object oriented modelling language, like EcosimPro, is presented. A general model of hydropower plant with run-of-river scheme is created with this component library. It provides the possibility of choosing a specific number of turbines and spillway gates. In this way, several hydropower stations of similar operating characteristics can be simulated using this same general model. It is expected to obtain interesting information in simulation like the reservoir level, water flows, turbine efficiencies, and so on. In addition, a graphical user interface has been designed in order to operate this general model more easily, to configure plant parameters and to simulate the plant behaviour under different conditions. Three real stations have been used as real examples for validating the model and testing the simulator: hydropower stations of Villafranca and El Carpio (Córdoba, Spain) and Marmolejo (Jaén, Spain).	graphical user interface;modeling language;simulation	Juan Garrido;Ángel Zafra;Francisco Vázquez	2009	Simulation Modelling Practice and Theory	10.1016/j.simpat.2009.08.007	simulation;computer science;systems engineering;engineering;graphical user interface	Robotics	-35.46609898182942	26.24294875626503	186257
61d23b34ac9414aa352df6913d0d435a47a05c5a	from formal specification of code mobility to design and implementation: an uml-based mobile agent approach	agent interaction;formal specification;uml sequence diagram;formal specifications mobile agents unified modeling language software agents code standards software engineering scientific computing application software prototypes algorithm design and analysis;agent interactions;client server code mobility;software agent;mobile agents;data mining;code mobility implementation;uml sequence diagrams;software agents;uml based mobile agent;client server;design and implementation;mobile software agents;client server code mobility formal specification uml based mobile agent code mobility design code mobility implementation mobile software agents uml sequence diagrams agent interactions agent migration;distributed programming;ovens;unified modeling language;mobile communication;agent migration;code mobility design;code mobility;mobile agent;programming;unified modeling language distributed programming formal specification mobile agents	The contribution of this paper is to propose a simple approach for the design and implementation of code mobility using mobile software agents. The approach is demonstrated by its application to standard code mobility paradigms. We start from existing formalizations of code mobility paradigms and show how they can be used to derive standard UML sequence diagrams that describe agent interactions and migration. Then we show how these diagrams can guide a prototype JADE-based implementation of the client-server code mobility paradigm.	client–server model;code mobility;formal specification;interaction;jade;mobile agent;programming paradigm;prototype;sequence diagram;server (computing);software agent;unified modeling language	Amelia Badica;Costin Badica	2008	2008 10th International Symposium on Symbolic and Numeric Algorithms for Scientific Computing	10.1109/SYNASC.2008.75	real-time computing;computer science;artificial intelligence;software agent;operating system;database;programming language	SE	-40.28561576039906	27.775965642623838	186609
60522816bd51a0a2b34545f15e7cba54da990fc2	a software architecture for knowledge-based systems	domain model;algebraic specification;knowledge based system;efficiency;karl;dynamic logic;article letter to editor;software architecture;assumptions;specification and verification;specification languages;acquisition;problem solving method;level;reusable component;architecture;problem solving methods;amenagement de l espace	The paper introduces a software architecture for the specification and verification of knowledge-based systems combining conceptual and formal techniques. Our focus is component-based specification enabling their reuse. We identify four elements of the specification of a knowledge-based system: a task definition, a problem-solving method, a domain model, and an adapter. We present algebraic specifications and a variant of dynamic logic as formal means to specify and verify these different elements. As a consequence of our architecture we can decompose the overall specification and verification task of the knowledge-based systems into subtasks. We identify different subcomponents for specification and different proof obligations for verification. The use of the architecture in specification and verification improves understandability and reduces the effort for both activities. In addition, its decomposition and modularisation enables reuse of components and proofs. Therefore, a knowledge-based system can be built by combining and adapting different reusable components.	abstract data type;automated theorem proving;cobham's thesis;component-based software engineering;computation;correctness (computer science);domain model;dynamic logic (modal logic);eddy willems;encapsulation (networking);first-order predicate;formal methods;formal specification;functional specification;java;john reif;knowledge engineer;knowledge-based systems;library (computing);parametric design;pile (abstract data type);problem solving;proof assistant;refinement (computing);software architecture;specification language;verification and validation	Dieter Fensel;Rix Groenboom	1999	Knowledge Eng. Review	10.1017/S0269888999142097	dynamic logic;software architecture;formal methods;specification language;computer science;artificial intelligence;theoretical computer science;architecture;knowledge-based systems;domain model;formal specification;efficiency;programming language;algorithm;functional verification;language of temporal ordering specification	SE	-40.12988481387231	26.460365711335992	186722
1a688b447cd90f0b6cd7817446b02f7a01fc106c	interface-based protocol specification of open systems using psl	three dimensions;functional properties;open system;protocol specification	PSL is a framework for describing dynamic and architectural properties of open systems. PSL extends established interface-based tactics for describing the functional properties of open systems to the realm of protocol description. PSL specifications consist of logical and temporal rules relating situations, each of which describes potential states with respect to instances of interfaces, their attributes, and the issuance and reception of events. PSL accommodates refinement and extensibility of specifications along the three dimensions of interfaces, situations, and orderings. A specialized form, PSL/IDL describes protocols in CORBA systems.	common object request broker architecture;extensibility;interface description language;refinement (computing)	Doug Lea;Jos Marlowe	1995		10.1007/3-540-49538-X_18	three-dimensional space;computer science;database;distributed computing;open system;programming language	SE	-38.64033368142495	28.445228762838976	187294
20f1df0ab5bf54bd706d923a43b1859de38cce0b	digital simulation of communication systems with topsim iii	computer languages;communication system;performance evaluation;building block;communication systems;satellite communications communication systems computer languages;satellite communications;analysis and design;digital simulation packaging communication systems software libraries computational modeling software packages computer aided manufacturing high level languages digital communication computer simulation;digital communication;time domain;fortran;high level language;digital simulation	TOPSIM III is a flexible, easy to use, stand-alone Fortran package for the digital simulation of communication systems in the time domain. TOPSIM III provides a simple high-level language for the description of the system. Programs can be written following the same structure used in drawing the system block diagram. The paper discusses the time domain simulation approach used in the design of the package and describes its capabilities. The contents of the subprogram libraries are presented, describing some of the building blocks that can be used in the simulation as well as the performance evaluation facilities available in the package. Some simple examples illustrate the use of TOPSIM III as a tool for analysis and design of digital communication systems.	simulation	Marco Ajmone Marsan;Sergio Benedetto;Ezio Biglieri;Valentino Castellani;Michele Elia;Letizia Lo Presti;Mario Pent	1984	IEEE Journal on Selected Areas in Communications	10.1109/JSAC.1984.1146036	telecommunications;computer science;theoretical computer science;communications system	Metrics	-34.7978991604229	26.841700568922604	188312
37b8551270e88fd341134ee59dbb6ba49be7b7b2	stateml+s: from graphical state machine models to thread-safe ada code	generacion de hilo seguro de codigo;plataforma eclipse;state machine;automatic generation;info eu repo semantics article;model to text transformation;finite state machines;lenguajes y sistemas informaticos;model driven engineering;eclipse;modelos de ingenieria de conduccion;model driven engineering mde;finite state machines fsm;model to text m2t transformation;maquinas de estado finito;meta model;thread safe code generation;eclipse platform;transformacion de modelo a texto	This paper presents the StateML tool aimed at designing statemachines and automatically generating thread-safe and multi-tasking modular Ada code from them, following a Model-Driven Engineering approach. The StateML meta-model is an extension of a previous version, and now it offers improved modeling capabilities, which include regions and macro-state definition. In this paper, a case study regarding the design of a robotic system will be used to demonstrate the benefits of the proposed approach.	abstraction layer;active object;ada;computer multitasking;concurrency (computer science);design pattern;embedded system;executable;finite-state machine;graphical user interface;machine code;metamodeling;model-driven architecture;model-driven engineering;multiversion concurrency control;reactor (software);robot;run to completion scheduling;software system;systems design;thread safety;uml state machine;unified modeling language	Diego Alonso;Cristina Vicente-Chicote;Juan Angel Pastor;Bárbara Álvarez	2008		10.1007/978-3-540-68624-8_12	metamodeling;eclipse;model-driven architecture;computer science;engineering;software engineering;finite-state machine;algorithm	SE	-39.01920868394839	26.65450624315748	188945
ed43a0a2d11b8166dc9f2a6491c8846fe82c847d	queueing structure modelling	structural modelling;simulation;manpower planning;q gert;technical report	"""A modelling scheme for simulation of queueing structures is proposed. After a general discussion about the special properties of queueing structures and how such usually are investigated, the scheme follows. The scheme makes use of three different concepts: Deterministic Analysis, Load Analysis and Balance Analysis. These concepts are explained and thereafter used in the modelling scheme. It is emphasised that complex models are difficult to handle and validate and that a simple model which comprises the important features of the """"real"""" system is to prefer. The paper discusses which these features can be and how to find them."""	simulation	Berth Eklundh	1982			simulation;computer science;engineering;technical report;operations research;world wide web	Web+IR	-35.465367330628666	27.197248733023166	190044
449c3c9a9a555a1b32eab798f847e7a835e6b21c	simulating set-valued transformations with algorithmic graph transformation languages	system modeling;product line;graph transformation;model complexity;control structure	PROGRES is one of the most mature graph transformation languages currently available. It offers many language features, also some for non-homomorphic transformations, e.g. set-nodes. Nevertheless, the language does not offer a comfortable possibility to work with complex set-valued structures. However, these are often useful when modeling complex systems, e.g. simulation systems, models-of-computation, or product lines using multiplicity variation points. We introduce the notion of set-valued transformations to PROGRES, define their syntax and semantics and show how they can be simulated using basic language constructs offered by most algorithmic graph transformation languages with a rich set of control structures.	transformation language	Christian Fuss;Verena Majuntke	2007		10.1007/978-3-540-89020-1_30	discrete mathematics;theoretical computer science;abstract semantic graph;mathematics;graph;algorithm;graph rewriting	PL	-39.699939196041846	29.807479926068613	192061
0a812f0c50e715a1e47e42ea564c42dbe12d6468	jeops - the java embedded object production system	production system;systeme production;langage java;sistema produccion;object oriented;agent intelligent;component reuse;intelligent agent;oriente objet;agente inteligente;orientado objeto;production rule;java language;programmation declarative	Although the concept of intelligent agents facilitates the development of systems which require intelligent behavior, the lack of standard tools to support the creation of agents is still an obstacle for the broad use of this paradigm. Agents can be created via the use of either specialized languages or generalpurpose ones. We claim that the latter is more suitable for complex applications where components reuse is highly demanded. In this case, the integration of production rules and objects is a promising approach. This article presents JEOPS, an inference engine that aims to provide reasoning capabilities to Java. JEOPS gives a special attention to the problem of the rule-object integration uniformity, because of its impact on the system reusability and readability. JEOPS has been used in different projects, and the results are very encouraging.	java;production system (computer science)	Carlos Santos da Figueira Filho;Geber Ramalho	2000		10.1007/3-540-44399-1_7	real-time computing;simulation;computer science;artificial intelligence;operating system;database;production system;programming language;object-oriented programming;intelligent agent;algorithm	HCI	-36.54973520890138	25.675872837733127	193045
cc7ddf4155346edfbcbe65945e543d348c0b4c8a	merging features in featured transition systems		Featured Transition Systems (FTSs) is a popular representation for software product lines: an entire product line is compactly represented as a single transition-machine model, in which feature-specific behaviour is guarded by feature expressions that are satisfied (or not) by the presence or absence of individual features. In previous work, FTS models were monolithic in the sense that the modeller had to construct the full FTS model of the product line in its entirety. To allow for modularity of FTS models, we propose here a language for extending an existing FTS model with new features. We demonstrate the language using a running example and present results about the language’s expressivity, commutativity of feature extensions, feature interactions, and resolution of such interactions.	fleet telematics system;formal methods europe;interaction;line level;modeller;modeling language;sensor;software product line;usability	Joanne M. Atlee;Sandy Beidu;Ulrich Fahrenberg;Axel Legay	2015			computer science;artificial intelligence;algorithm	AI	-38.270507173882606	30.059780240781826	193318
bf5796972083b5545fa9255ebace1162ba98f42b	a pictorial approach to the animation of process-oriented formal specifications	computer graphics software tools specification languages;formal specification;ada;modular multiprogramming language;pascal plus;formal languages;process oriented formal specifications;animation;peep;specification languages computer graphics software tools;csp;lotos animation process oriented formal specifications peep concurrent applications modular multiprogramming language ada pascal plus formal languages csp ccs sdl;concurrent applications;ccs;sdl;lotos	This paper considers how the meaning of process-oriented formal specifications might be made more apparent through the use of pictorial animation. The approach taken is based on techniques embodied in the software animation system PEEP. The PEEP system gives pictorial representations of the changing states of software as it is executed. It was designed for concurrent applications expressed in a modular multiprogramming language, such as Ada or Pascal Plus. Corresponding formal languages suitable for the specification of concurrent systems include CSP, CCS, SDL and LOTOS. The LOTOS language is used for illustration purposes in this paper, but the techniques discussed are equally applicable to the other languages.	formal specification;image	David W. Bustard;Mark T. Norris;Rodney A. Orr	1988	Software Engineering Journal	10.1049/sej.1988.0013	anime;computer architecture;formal language;real-time computing;ada;computer science;communicating sequential processes;formal specification;programming language	SE	-34.72282260119004	28.094972420565128	193584
1eab50ee722e4c01627fdeff1995b42d56c71212	distributed simulation of hybrid systems with hla support	machine abstraite;distributed system;continuous time;reponse temporelle;equation differentielle;metodo analisis;systeme reparti;simulation systeme;sistema hibrido;reseau interconnecte;systeme discret;lenguaje uml;ecuacion algebraica;maquina abstracta;differential equation;langage modelisation unifie;state machine;continuous system;sistema complejo;abstract machine;model complexity;ecuacion diferencial;systeme continu;synchronisation;methode analyse;sistema repartido;systeme complexe;time response;complex system;analysis method;synchronization;sistema continuo;unified modelling language;interconnected system;hybrid system;sistema interconectado;equation algebrique;sincronizacion;sistema discreto;systeme interconnecte;distributed simulation;respuesta temporal;red interconectada;hybrid simulation;system simulation;interconnected power system;high level architecture;simulacion sistema;algebraic equation;discrete system;systeme hybride;modeling and analysis	As engineers are confronted with designing increasingly complex systems composed of interconnected components of diverse nature, traditional methods of modeling and analysis become cumbersome and inefficient. In the paper we discuss one of the approaches to modeling and distributed simulation of hybrid (discrete/continuous) systems. We use hybrid state machines, where sets of algebraic-differential equations are assigned to states, to model complex interdependencies between discrete and continuous time behaviors. This framework is fully supported by UML-RT/Java tool AnyLogic developed at Experimental Object Technologies. We use High Level Architecture (HLA), a defacto standard for distributed simulation, as a communication and synchronization media for distributed hybrid simulation components. Integration of simulations developed with AnyLogic into HLA is considered.	anylogic;complex systems;distributed computing;hybrid system;interdependence;interoperability;java class library;linear algebra;semantics (computer science);simulation;systems modeling;uml tool;unified modeling language;world-system	Andrei Borshchev;Yuri Karpov;Pavel Lebedev	2001		10.1007/3-540-44743-1_42	synchronization;computer science;artificial intelligence;abstract machine;algorithm	Robotics	-37.10444072075248	26.49371214407534	194565
569d074198d8472af57d95a69824fed1418f4ed4	a petri net based supervisory control implementation	programmable controllers;control system analysis computing;mathematics computing;supervisory control;system modeling;programming environment;model based approach;feedback;supervisory control petri nets automatic control communication system control open loop systems programmable control feedback control safety manufacturing system recovery;mathematics computing petri nets discrete event systems control system analysis computing feedback programmable controllers digital simulation;discrete event systems;petri nets;programmable logic control petri nets offline supervisory control synthesis supervisory controller design compliant programming feedback controllers discrete event systems supervisor simulation matlab plc controller control system synthesis;petri net;time discretization;digital simulation	The paper presents an implementation of supervisory controllers in the IEC 61131-3 compliant programming environment. The implemented modelbased approaches provide particularly simple methods for constructing feedback controllers for untimed and timed discrete event systems modeled by Petri nets. Programs written in Matlab 5.3/6,1 have been used to solve the OFFLINE supervisoiy control synthesis and supervisor simulation. The implementation of the designed supervisay controller can be perjiarmed in an IEC 61 131-3 compliant programming environment with help of a quick PLC controller, or a quick dedicated controller.	iec 61131;iec 61131-3;integrated development environment;matlab;petri net;power-line communication;simulation	Jana Flochova	2003		10.1109/ICSMC.2003.1244549	real-time computing;computer science;control theory;supervisory control;petri net	Robotics	-35.39273345613528	29.60683150834327	196060
5444a68982b82ebf75a83f926b9e899ca631bf26	equivalent design representations and transformations for interactive scheduling	interactive scheduling;equivalent design representation;finite state machines;finite state machine;scheduling;high level synthesis	High-level synthesis (HLS) requires more designer interaction to better meet the needs of experienced designers. However, attempts to create a highly interactive synthesis process are hampered by incompatibility of various representations used during synthesis. To overcome this problem, equivalent representations are needed, as well as equivalence-preserving synthesis transformations. We present the Structured Finite State Machine (SFSM) design model for scheduled behavior, show its equivalence to the Control/Data Flow Graph (CDFG) model, and define primitive behavior-preserving transformations for scheduling. We have integrated this model and these transjormations into the BIF interactive environment to enable manual rescheduling of a design.	dataflow architecture;finite-state machine;format-preserving encryption;high-level synthesis;interactive design;scheduling (computing);software incompatibility;turing completeness	Roger P. Ang;Nikil D. Dutt	1992		10.1145/304032.304129	mathematical optimization;real-time computing;computer science;theoretical computer science;operating system;distributed computing;finite-state machine;high-level synthesis;scheduling;algorithm	EDA	-38.96040879850259	31.56328242769128	196948
5daa29bfbb00ce6984459615fbb45dfa55b8c33e	petri net based implementation of hierarchical and distributed control for discrete event robotic manufacturing systems	manufacturing systems;distributed system;machining;control systems;petri nets discrete event systems distributed control flexible manufacturing systems hierarchical systems industrial robots;flexible manufacturing systems;complex manufacturing system;hierarchical systems;hierarchical control;flexible manufacturing system petri net hierarchical control distributed control discrete event robotic manufacturing system task specification net representation distributed system complex manufacturing system;satisfiability;firing;net representation;flexible manufacturing system;robot kinematics manufacturing systems machining firing control systems petri nets;industrial robots;discrete event systems;task specification;petri nets;petri net;manufacturing system;distributed control;discrete event;discrete event robotic manufacturing system;model simulation;robot kinematics	The methods of modeling and control of discrete event robotic manufacturing systems using Petri nets are considered, and a methodology of decomposition and coordination is presented for hierarchical and distributed control. Based on a task specification, the conceptual Petri net model is designed and transformed to the detailed net representation of the subtasks. The overall net model is decomposed and the constituent subnets are assigned to local Petri net based controllers. The controllers are coordinated so that the aggregated behavior of the distributed system satisfies the task specification completely. By the proposed method, modeling, simulation and control of large and complex manufacturing systems can be performed consistently using Petri nets.	content-control software;distributed computing;distributed control system;experiment;interactivity;list of version control software;microcomputer;nondeterministic algorithm;petri net;real-time transcription;robot;shared memory;simulation;subnetwork	Gen'ichi Yasuda	2010	2010 IEEE International Conference on Control Applications	10.1109/CCA.2010.5611183	control engineering;real-time computing;stochastic petri net;engineering;operations management;process architecture;petri net	Robotics	-35.048606567080405	29.739757243347892	197014
e309080b5bde20e29018607ebec0244e60421c2b	hierarchical high level petri nets for complex system analysis	high level petri net;bottom up;top down;reachable set;concurrent systems;complex system;system analysis;divide and conquer	The class of Hierarchical High Level Petri Nets (HHPNs) is introduced. HHPNs provide a framework for a modular specification of complex parallel and concurrent systems which supports top-down and bottom-up design. Apart from specification convenience HHPNs can be analysed very efficiently according to functional aspects of the modelled system. Analysis is based on a divide and conquer approach combined with behaviour preserving reduction techniques on subsets of the reachability set. The complexity of an analysis on the reachability set of the net can often be reduced by several orders of a magnitude by considering only small parts of the complex reachability set in a single analysis step and performing behaviour preserving reductions before composing subsets of the reachability set.	complex system;petri net;system analysis	Peter Buchholz	1994		10.1007/3-540-58152-9_8	complex systems;real-time computing;computer science;top-down and bottom-up design;distributed computing;process architecture;petri net;algorithm	Robotics	-38.26442202826977	30.04360431201247	197486
e85426f79865af52c167a741b9373a930b8e1f9a	interaction patterns as composite connectors in component-based software development	composite connector;composition mechanism;interaction pattern;separation of computation and interaction;component model	In current component models, interaction aspects of system behaviour are mostly specified by components, rather than by composition mechanisms, due to the fact that most composition mechanisms cannot express complex interactions. Consequently current component models do not enjoy the benefits that arise from separating the specification of computation from the specification of interaction in software architecture.This thesis investigates the possibility of representing recurring patterns of interaction as composition mechanisms (and other associated component model entities), as distinct from components that define computation; these composition mechanisms would appear as first-class entities in architectures, and can be stored in and reused from repositories.To this end, we have defined a novel, control-driven and data-driven component model that strictly separates computation from interaction. To represent interaction patterns in this model, we have defined composite connectors that can encapsulate control flow and data flow and can be reused via repositories in different contexts. We have also developed a prototype implementation of the component model, and carried out a case study from the reactive control systems domain in order to evaluate the feasibility of our approach. Comparison with related work shows that our composite connectors improve the state of the art in component-based interaction modelling (i) by specifying control flow and data flow explicitly and separately in software architecture; and (ii) by increasing the reuse potential of interaction patterns compared to patterns that are represented by components only.	component-based software engineering;rca connector;software development	Petr Stepan	2014			real-time computing;simulation;engineering;engineering drawing	SE	-38.54274019807489	30.28000464309387	198508
4859fb813d38dc4708349a323fa50dc6b8d02063	recent developments in non-markovian stochastic petri nets	stochastic petri net;analysis and design;analytical model	Analytical modeling plays a crucial role in the analysis and design of computer systems. Stochastic Petri Nets represent a powerful paradigm, widely used for such modeling in the context of dependability, performance and performability. Many structural and stochastic extensions have been proposed in recent years to increase their modeling power, or their capability to handle large systems. This paper reviews recent developments by providing the theoretical background and the possible areas of application. Markovian Petri nets are rst considered together with very well established extensions known as Generalized Stochastic Petri nets and Stochastic Reward Nets. Key ideas for coping with large state spaces are then discussed. The challenging area of non-Markovian Petri nets is considered, and the related analysis techniques are surveyed together with the detailed elaboration of an example. Finally new models based on Continuous or Fluid Stochastic Petri Nets are brieey discussed.	dependability;programming paradigm;stochastic petri net	Andrea Bobbio;Antonio Puliafito;Miklós Telek;Kishor S. Trivedi	1998	Journal of Circuits, Systems, and Computers	10.1142/S0218126698000067	simulation;stochastic petri net;computer science;artificial intelligence;process architecture;petri net	EDA	-36.5848566439728	29.371631727161688	199013
d8fe7f581bf4f02a36d16cd184564491741fd355	codesim: a compact discrete event simulator	data collection;simulation;material handling system;automated storage and retrieval system;gpss;fortran;technical report;discrete event simulation	CODESIM is a compact software facility1 that supports discrete event simulation modeling. Written in Fortran, the CODESIM routines enable facile model construction with a maximum of modeler independence. CODESIM requires no inputs, handles queuing without buffer movement, provides built-in trace control, and permits arbitrary user naming and typing of entity attributes. Statistical routines for data collection and reporting are provided by the CODESIM software—all outputs are in the user domain, as are additional model input parameters, etc. Thus, CODESIM represents a no-frills tool for discrete event simulation. Its advantages include a free programmer structure, speed, size, interactive use, and potential for both machine and language portability.	fortran;programmer;simulation;software portability	Lawrence L. Rose	1983			real-time computing;simulation;computer science;technical report;gpss;theoretical computer science;discrete event simulation;world wide web;data collection	DB	-34.33760012062922	26.790557171691628	199516
f5e2d447042cc8a0c55698d21cf259c6cb4083b5	knowledge representation-oriented nets for discrete event system applications	high level petri net;object oriented methods;computer graphics;inference mechanisms;manufacturing systems knowledge representation oriented nets kron discrete event system applications des static structure high level petri nets frame based representation techniques object oriented paradigm inference engine rete matching algorithm frame object oriented representation schema simulation tool graphical display animation;discrete event system;object oriented;discrete event systems object oriented modeling petri nets knowledge representation engines inference algorithms virtual prototyping displays animation manufacturing systems;frame based representation;petri nets;knowledge representation;discrete event simulation modelling petri nets frame based representation object oriented methods inference mechanisms computer graphics;simulation tool;manufacturing system;object oriented paradigm;discrete event simulation	This paper presents knowledge representationoriented nets (KRON), a knowledge representation schema for discrete event systems (DES’s). KRON enables the representation and use of a variety of knowledge about a DES static structure and its dynamic states and behavior. It is based on the integration of high-level Petri nets with frame-based representation techniques and follows the object-oriented paradigm. The main objective considered in its definition is to obtain a comprehensive and powerful representation model for data and control of DES’s. The use of the DES behavioral knowledge is governed by a control mechanism stored in a separate inference engine. KRON provides an efficient execution mechanism to make the models evolve. This is an adaptation of the RETE matching algorithm in order to deal with the features provided by high-level Petri nets and it takes advantage of its integration with a frame/object-oriented representation schema. Moreover, KRON facilitates dealing with decision points in the execution of nondeterministic models. A prototype of a simulation tool with graphical display and animation facilities has been implemented for KRON and it has been used in several case studies in the manufacturing systems domain.	graphical user interface;high- and low-level;inference engine;infographic;knowledge representation and reasoning;petri net;programming paradigm;prototype;rete algorithm;simulation	Pedro R. Muro-Medrano;José A. Bañares;J. L. Villarroel	1998	IEEE Trans. Systems, Man, and Cybernetics, Part A	10.1109/3468.661146	knowledge representation and reasoning;computer vision;computer science;artificial intelligence;theoretical computer science;discrete event simulation;machine learning;computer graphics;object-oriented programming;petri net	AI	-36.57080950793846	28.09307350032316	199733
