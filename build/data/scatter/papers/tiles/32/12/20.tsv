id	title	keywords	abstract	entities	authors	year	journal	doi	fos	area	x	y	ix
15fd84d7afbc13ff0de0f536357e40a33b547d40	on combining functional verification and performance evaluation using cadp	concurrent;chaine markov;cadena markov;functional verification;performance evaluation;modelo markov;specification language;verification fonctionnelle;markov model;col;algebra proceso;simultaneo;algebre processus;simultane;lenguaje especificacion;modele markov;process algebra;langage specification;lotos;markov chain	Considering functional correctness and performance evaluation in a common framework is desirable, both for scientific and economic reasons. In this report, we describe how the Cadp toolbox, originally designed for verifying the functional correctness of Lotos specifications, can also be used for performance evaluation. We illustrate the proposed approach by the performance study of the Scsi-2 bus arbitration protocol. Key-words: bisimulation – bus arbitration – compositional verification – formal specification – labeled transition system – Lotos – Markov chain – minimisation – model checking – performance evaluation – process algebra – Scsi-2 A short version of this research report is also available as “On Combining Functional Verification and Performance Evaluation using CADP”, in Lars-Henrik Eriksson and Peter A. Lindsay, editors, Proceedings of the 11th International Symposium of Formal Methods Europe FME’2002 (Copenhagen, Denmark), July 22–24, 2002. ∗ INRIA Rhône-Alpes, E-mail: Hubert.Garavel@inria.fr † Formal Methods and Tools Group, University of Twente, P.O. Box 217, NL-7500 AE Enschede, The Netherlands, E-mail: hermanns@cs.utwente.nl Combiner vérification fonctionnelle et évaluation de performances avec CADP Résumé : Il est souhaitable, à la fois pour des raisons scientifiques et économiques, de considérer la correction fonctionnelle et l’évaluation de performances dans un même cadre conceptuel. Dans ce rapport, nous décrivons comment la bôıte à outils Cadp, initialement conçue pour vérifier la correction fonctionnelle de spécifications Lotos, peut aussi être utilisée pour l’évaluation de performances. Nous illustrons l’approche proposée par l’étude de performances du protocole d’arbitrage du bus Scsi-2. Mots-clés : algèbre de processus – arbitre de bus – bisimulation – châıne de Markov – évaluation de performances – Lotos – minimisation – model checking – Scsi-2 – spécification formelle – système de transitions étiquetées – vérification compositionnelle On Combining Functional Verification and Performance Evaluation using CADP 3	bisimulation;bus mastering;construction and analysis of distributed processes;correctness (computer science);formal methods europe;formal specification;language of temporal ordering specification;lars bak (computer programmer);linear algebra;markov chain;meme;model checking;performance evaluation;power dividers and directional couplers;process calculus;scsi;specification and description language;transition system;verification and validation	Hubert Garavel;Holger Hermanns	2002		10.1007/3-540-45614-7_23	markov chain;process calculus;specification language;computer science;theoretical computer science;database;markov model;programming language;algorithm;functional verification;statistics	Logic	-27.944025386457326	35.45163601120717	187242
382c63f136e77cb2a18b7c56e3d6fd4650687ea6	communication primitives for ubiquitous systems or rpc considered harmful	remote access;control systems communication system control streaming media skeleton intrusion detection pervasive computing laboratories next generation networking speech automatic control;control system;application program interfaces;distributed object management;application program interfaces remote procedure calls distributed object management;jini communication primitives ubiquitous systems rpc remote procedure call local access remote access ubiquitous device control systems synchronous blocking invocation statically typed interface comvets conditional mobility aware events rmi corba;remote procedure calls	RPC is widely used to access and modify remote state. Its procedural call semantics are argued as an efficient unifying paradigm for both local and remote access. Our experience with ubiquitous device control systems has shown otherwise. RPC semantics of a synchronous, blocking invocation on a statically typed interface are overly restrictive, inflexible, and fail to provide an efficient unifying abstraction for accessing and modifying state in ubiquitous systems. This position paper considers other alternatives and proposes the use of comvets (conditional, mobility aware events) as the unifying generic communication paradigm for such systems.	blocking (computing);control system;interface description language;jean;multithreading (computer architecture);programming paradigm;prototype;requirement;thread (computing);type system	Umar Saif;David J. Greaves	2001		10.1109/CDCS.2001.918712	dce/rpc;real-time computing;computer science;control system;operating system;database;distributed computing;programming language;remote procedure call;computer security;computer network	Security	-30.98537147174879	39.32151726242949	187654
ba52f433f881cf957f05b31c087ef78cf71d683e	composite replicated data types		Modern large-scale distributed systems often rely on eventually consistent replicated stores, which achieve scalability in exchange for providing weak semantic guarantees. To compensate for this weakness, researchers have proposed various abstractions for programming on eventual consistency, such as replicated data types for resolving conflicting updates at different replicas and weak forms of transactions for maintaining relationships among objects. However, the subtle semantics of these abstractions makes using them correctly far from trivial. To address this challenge, we propose composite replicated data types, which formalise a common way of organising applications on top of eventually consistent stores. Similarly to an abstract data type, a composite data type encapsulates objects of replicated data types and operations used to access them, implemented using transactions. We develop a method for reasoning about programs with composite data types that reflects their modularity: the method allows abstracting away the internals of composite data type implementations when reasoning about their clients. We express the method as a denotational semantics for a programming language with composite data types. We demonstrate the effectiveness of our semantics by applying it to verify subtle data type examples and prove that it is sound and complete with respect to a standard non-compositional semantics.	apl;abstract data type;composite data type;denotational semantics;distributed computing;eventual consistency;programming language;scalability	Alexey Gotsman;Hongseok Yang	2015		10.1007/978-3-662-46669-8_24	theoretical computer science;data type;scalability;semantics;computer science;abstraction;eventual consistency;composite number	PL	-27.070839944815663	35.01213596872745	187973
b1206fe3b8b0b21ce93211eeb01a3c5311d631be	signal pre-processing subsystem for the purpose of industrial control		Commonly used methods of signal processing are often too complex and many of them induce time delay between the original and processed signal. A problem arises how to supply the controller with quality input signals without substantial delay taking limited computing power of the controller's hardware into account. A possible solution based on a signal pre-processing subsystem (SPS) delivering quality input signals to the controller is described in this paper. Concept of the SPS is based on a hardware unit with a real-time operating system managing a composition of application tasks. Hardware and software structure of the SPS is composed to enable to utilize the following specific signal processing strategy. Different signal processing methods process a particular signal simultaneously and an algorithm of continuous decision making provides the momentary best possible result in the form of a weighted combination of outputs generated by single signal processing methods. Solution is intended for enhancement of the automatic thickness/gauge control (AGC) for cold rolling mills.	algorithm;automatic gain control;broadcast delay;controller (computing);ibm 1401 symbolic programming system;preprocessor;real-time operating system;real-time transcription;signal processing;thickness (graph theory)	Ivan Puchr;Pavel Herout	2011			control engineering;embedded system;computer engineering	EDA	-30.828128702086364	37.81720107754869	188279
aca983d28192e8a25b6b1cb6100d178a583bfc3e	a lightweight data interchange format for internet of things with applications in the palcom middleware framework	efficient binary handling;json;data interchange format;pon;datavetenskap datalogi;lightweight protocol;palcom;textual format;java	We present the PalCom Object Notation, a textual data representation format for communication between internet of things which support binary and textual data. The format does not require parsing of user data (or the ‘‘payload’’) and is thus efficient to use also for large binary values such as digital images, audio and video as well as for short textual values. These can be mixed in the same messages and thus transported over the same communication link. Its structure is influenced by JSON, making it easy to translate between the two formats. We show how it fits seamlessly into the common situation with JavaScript on a client side and Java on a server side, combined by a HTTP-server. The performance evaluation shows that the size of the representation and the time needed to generate and parse it is comparable to that of JSON for small data sizes, but becomes both smaller than JSON and faster to process as data sizes grows, and can yield a tenfold performance increase for binary payloads.	bitwise operation;client-side;data (computing);data interchange format;decade (log scale);digital image;fits;human-readable medium;hypertext transfer protocol;internet of things;json;java;javascript;middleware;parsing;passive optical network;performance evaluation;programming language;server (computing);server-side;test data;text corpus	Mattias Nordahl;Boris Magnusson	2016	J. Ambient Intelligence and Humanized Computing	10.1007/s12652-016-0382-3	embedded system;computer science;operating system;database;java;world wide web;json-ld;computer network	Web+IR	-30.398903403443622	36.3744642604927	189271
d8fb0dd514a3921a19482e2f482d9b0ed5d4161c	multi-level locks to control collaborative modeling sessions	multi level locking mechanism collaborative modeling sessions collaborative editing systems uml diagrams;collaborative modeling sessions;groupware;prototypes;data collection;collaboration;collaborative editing;controlled experiment;unified modeling language groupware;uml diagrams;consistency model;computational modeling;system recovery;synchronous collaboration;collaborative editing systems;unified modeling language;concurrency control;multi level locking mechanism;collaboration collaborative work concurrency control unified modeling language collaborative tools automatic control radiofrequency interference graphics concurrent computing switches;data models	Collaborative editing systems require mechanisms of control in order to make the collaboration more effective. The synchronous collaboration allows the notion of simultaneity; however, it demands more adequate perception elements. In the collaborative edition of UML diagrams where dependencies between their modeling elements do exist, it is necessary to apply a mechanism of control to support the edition of consistent models. In this work, we present a multi-level locking mechanism that automatically manages locks in the modeling elements of UML diagrams during a collaborative session. This paper also describes a controlled experiment conducted to study the use of the multi-level locking mechanism during collaborative modeling sessions, and the observations from the empirical data collected.	concurrency (computer science);deadlock;diagram;lock (computer science);multi-level governance;prototype;uml state machine;uml tool;unified modeling language;usability	Mauro Carlos Pichiliani;Celso Massaki Hirata	2007	2007 International Conference on Collaborative Computing: Networking, Applications and Worksharing (CollaborateCom 2007)	10.1109/COLCOM.2007.4553847	unified modeling language;real-time computing;computer science;operating system;database;distributed computing;programming language;management;world wide web	SE	-32.39741104342393	35.55249069822621	190544
8d177331e3554bacbd9125f080a9d9bce22b842d	distributed control, modularity and data types in a simple parallel language	data type;parallel languages;distributed control		distributed control system;parallel language	Marco Bellia;Giorgio Levi	1977			distributed algorithm;computer science;theoretical computer science;distributed computing;distributed design patterns;programming language;distributed concurrency control	PL	-27.893838686253243	32.562680555364395	190737
ddaa5116595ba444304d0accb9247bdcbc38939e	on the deadlock analysis of multithreaded control software	multi threading;flexible manufacturing systems;theorem proving;concurrent control software production deadlock analysis multithreaded control software resource sharing petri net based correction techniques flexible manufacturing systems gadara nets s 4 pr theorem proof;flexible manufacturing system;resource sharing;concurrency control;software petri nets resource management system recovery context veins syntactics;theorem proving concurrency control flexible manufacturing systems multi threading petri nets;petri nets;petri net	The long interest in finding efficient solutions to deadlock occurrence induced by resource sharing is persistent in the context of concurrent control software production. Petri net-based correction techniques which were traditionally applied in the context of flexible manufacturing systems (FMS) constitute a promising new approach. In this vein, Gadara nets were introduced as an attempt to import the strengths of these techniques into the software domain. In this paper, we prove that these Petri nets are close to a subclass of S4PR (a widely-exploited class in the context of FMS) and provide some related equivalence results. Some limitations which Gadara nets present for the modelling and automated correction of software are also unveiled. Last but no least, we present formal proofs of the theorems characterising non-liveness in Gadara nets. To our knowledge, no such proofs were published before.	content-control software;deadlock;liveness;persistent data structure;petri net;software system;state space;structural analysis;thread (computing);turing completeness;whole earth 'lectronic link	Juan-Pablo López-Grao;José Manuel Colom	2011	ETFA2011	10.1109/ETFA.2011.6059039	real-time computing;computer science;database;distributed computing;process architecture;programming language;petri net	SE	-26.408535652603035	34.5626647278821	191200
0926c8de5afc80ace1b65fd0418d0876f1db7644	extending the service domain of interactive components	program diagnostics;formal specification;fault tolerant;interactive component;software fault tolerance;object oriented programming;function;service;formal method;input output;regular state space;erroneous input stream;finite state machines;input output behaviour;fault sensitive behaviour;state space;error handling;fault tolerant behaviour;error handling interactive software component input output behaviour service domain erroneous input stream fault sensitive behaviour fault tolerant behaviour fault correcting behaviour state transition machine regular state space formal specification;service interactive component input output behaviour stream function state transition machine;service domain;history computational modeling communication system control software engineering conference management technology management engineering management application software computer languages fault tolerant systems;fault correcting behaviour;software fault tolerance error handling finite state machines formal specification object oriented programming program diagnostics;service provision;stream function;state transition;stream;interactive software component;state transition machine	An interactive component consumes a stream of input messages and produces a stream of output messages. The input/output behaviour describes the service offered by the component without disclosing the implementation. In general, an interactive component provides the contracted service only for a subset of input histories, called its service domain. We investigate the input/output behaviour of interactive components for erroneous input streams outside the service domain. We specify a fault sensitive behaviour, a fault tolerant behaviour, a robust behaviour, and a fault correcting behaviour by enlarging the regular behaviour in a systematic way. We implement the different behaviours by state transition machines where we enlarge the regular state space by additional information. Altogether we provide schematic transformations both on the specification and on the implementation level how to extend the regular behaviour of an interactive component to input streams outside the service domain. The resulting formal method separates the aspects of service provision and error handling in an orthogonal way.	exception handling;fault tolerance;formal methods;input/output;schematic;state space;state transition table;uml state machine	Walter Dosch	2007	5th ACIS International Conference on Software Engineering Research, Management & Applications (SERA 2007)	10.1109/SERA.2007.87	exception handling;input/output;fault tolerance;real-time computing;service;formal methods;computer science;state space;theoretical computer science;operating system;formal specification;distributed computing;finite-state machine;programming language;object-oriented programming;stream;stream function;function;software fault tolerance	SE	-32.293444720078675	33.8920646281424	191372
952fc3016b92f4a47ca848560f792e5e056dcedf	mocs: an object-oriented programming model for multimedia object communication and synchronization	encapsulation;mirrors;formal specification;object oriented programming object oriented modeling multimedia communication streaming media programming profession application software software architecture multimedia systems mirrors software prototyping;software prototyping;application software;network operating systems;data stream;distributed multimedia;declarative synchronization specification;application program interface;object oriented programming;multimedia systems;distributed multimedia programs mocs object oriented programming model multimedia object communication synchronization playback high level programming support mirror object composite object encapsulation multiple data streams declarative synchronization specification samocs software architecture application programming interface;synchronisation;software architecture;samocs;object oriented programming model;streaming media;synchronization;programming profession;software tools synchronisation multimedia systems object oriented programming formal specification network operating systems utility programs;multimedia communication;utility programs;high level programming support;multimedia object communication;software tools;mocs;composite object;distributed multimedia programs;multiple data streams;object oriented modeling;application programming interface;mirror object;playback	To support the presentation requirements of distributed multimedia information, synchronization of multimedia objects must be achieved. To this end, system resource scheduling and resource reservation for object pre-fetch, network bandwidth and buffer occupancy must be determined prior to the time the presentation is initiated. This paper proposes an object-oriented model to handle the temporal relationship for all of the multimedia objects at the presentation platform and study the related problems of resource allocation. Synchronization of the composite media objects is achieved by ensuring that all objects presented in the upcoming “manageable” period must be ready for execution. To this end, the nature of overlap is first examined for various types of objects. The importance of critical overlap and critical point that are vital to synchronization is addressed and taken into account in this research. The concept of manageable presentation interval and the irreducible media group are also introduced and defined. Analysis of resource allocation among pre-fetch time of media object, network bandwidth and buffer occupancy is also examined. Accordingly, a new model called group cascade object composition Petri-net (GCOCPN) is proposed and an algorithm to implement this temporal synchronization scheme is presented.	algorithm;critical point (network science);data synchronization;executable;irreducibility;media object server;object composition;petri net;programming model;quality of service;requirement;scheduling (computing);temporal logic;z/tpf	Chi-Leung Fung;Man-Chi Pong	1994		10.1109/ICDCS.1994.302460	synchronization;real-time computing;application programming interface;computer science;operating system;database;distributed computing;data synchronization;synchronization;programming language	DB	-33.04167709233686	35.475062047975335	191513
ccca63feebfb1dc5fe1d10e446f2477edcd4e1b4	object design for communication protocol software	design method;communication protocol;finite state machine	In this paper, an object design method for communication protocol software, which is specified based on a finite state machine, is presented. In our method, an object class is defined for each state of the finite state machine. The objects designed in our method have freer granularity than that in conventional approaches. Inheritance is used in our method as a program structuring mechanism to allow incremental design. A real example is given for demonstration.	communications protocol;continuous design;finite-state machine;multiple granularity locking	Chung-Shyan Liu	1995	OOPS Messenger	10.1145/209866.209870	communications protocol;general inter-orb protocol;richards controller;method;real-time computing;design methods;computer science;theoretical computer science;object-oriented design;distributed computing;finite-state machine;virtual finite-state machine	EDA	-32.007209264115126	33.86145419861284	192458
75905dec0e912f2810ad4f86bc7e22094f4e9a90	formal specification and compositional verification of an atomic broadcast protocol	formal specification;fault tolerant;protocol verification;real time;compositional verification;broadcast;formal method;formal verification;fault tolerance;atomic broadcast	We apply a formal method based on assertions to specify and verify an atomic broadcast protocol. The protocol is implemented by replicating a server process on all processors in a network. We show that the verification of the protocol can be done compositionally by using specifications in which timing is expressed by local clock values. First the requirements of the protocol are formally described. Next the underlying communication mechanism, the assumptions about local clocks, and the failure assumptions are axiomatized. Also the server process is represented by a formal specification. Then we verify that parallel execution of the server processes leads to the desired properties by proving that the conjunction of all server specifications and the axioms about the system implies the requirements of the protocol.		Ping Zhou;Jozef Hooman	1995	Real-Time Systems	10.1007/BF01088854	fault tolerance;real-time computing;formal methods;formal verification;computer science;formal specification;database;distributed computing;runtime verification;programming language	Embedded	-27.38901179153937	33.165515060351936	192974
e8ee29a5be0da62baf48e035b98bf1f6a4e3cf29	dpl-82: a language for distributed processing	data acquisition;distributed processing;programming languages;language	DPL-82 is a language for composing programs of concurrently-executing processes. Processes may be all on a single machine or may be distributed over a set of processors connected to a network. The semantics of the language is derived from the underlying interprocess communication facility (IPC) and from the dataflow model of computation. This paper discusses the major concepts of the language, namely nodes, arcs, connections, tokens, signals, and activations, and presents examples which illustrate the construction of distributed programs in DPL-82 with internal arcs, external arcs and child arcs. Features for process-toprocessor mapping and dead process restart are mentioned. The paper concludes with some ideas for future research. Copyright © 1982 by the Institute of Electrical and Electronic Engineers This research was sponsored by the Defense Advanced Research Projects Agency (DOD), ARPA Order No. 3597, monitored by the Air Force Avionics Laboratory under Contract F33615-78-C-1551. The views and conclusions contained in this document arc those of the author and should not be interpreted as representing official policies, cither expressed or implied, of the Defense Advanced Research Projects Agency or the US Government	arcs (computing);avionics;central processing unit;dataflow;distributed computing;inter-process communication;model of computation;process state	L. W. Ericson	1982				DB	-27.677522564136705	36.681020748670825	193546
9cea4919fe0f5a6db394a7e8d33668d2e101ad58	the reconstruction of a mobile agent computation and its validation	diffusing computation;mobile agents;reconstruction;distributed processing;distributed computing;mobile agents distributed computing concurrent computing computational modeling mobile computing reconstruction algorithms cloning yarn labeling internet;refinement;labeling termination events mobile agent computation control structures diffusing computations control tree;internet;control structure;validation;internet mobile agents distributed processing;mobile agent;reconstruction algorithm	We propose a new representation to describe mobile agents computations, where the underlying control structures are diffusing computations. Usually, distributed computations are abstracted as sets of receiving, sending and internal events. Instead of using this representation, we consider a diffusing computation as a set of leaves of a control tree associated to the different threads of control generated by the computation. We introduce so-called “Visit tags” to capture such a representation. These tags exhibit several nice properties, in particular, the whole computation tree can be reconstructed from the knowledge of tags labeling termination events. This tree is useful to assess global properties or evaluate state predicates, as well as to replay the computation. We present a formal development of the reconstruction algorithm as a sequence of refinement steps. keywords: diffusing computation, reconstruction, validation, refinement.	algorithm;computation tree;control flow;data validation;formal methods;mobile agent;refinement (computing);thread (computing);visit	Mamoun Filali;Philippe Mauran;Gérard Padiou;Philippe Quéinnec	2003		10.1109/IPDPS.2003.1213429	parallel computing;real-time computing;the internet;computer science;theoretical computer science;operating system;mobile agent;distributed computing;refinement;programming language;control flow;algorithm;computer network	AI	-27.86479197109211	35.58937345150354	194716
a5ba572d2ef84bf49ea7185e5369719460a5b76b	splitting mobility and communication in boxed ambients	computing models;access control list;mobility;separation of concern;mobile computer;mobility control;local community;safe ambients;ambient calculus;communication channels;type safety;ambients	Stemming from our previous work on BACI, a boxed ambient calculus with communication interfaces, we define a new calculus that further enhances communication mechanisms and mobility control by introducing multiple communication ports, access control lists, and port hiding. The development of the calculus is mainly focused on three objectives: separation of concerns between mobility and communication, fine-grained controls, and locality. Communication primitives use ports to establish communication channels between ambients, while ambient names are only used for mobility. In order to achieve a better control over mobility, the calculus includes co-capabilities à la Safe Ambients, but with the addition of access control lists. These lists contain the names of the ambients that are allowed to enter or exit the ambient with that co-capability. The resulting calculus not only provides more flexibility and expressiveness than Boxed Ambients, but also enables simpler implementations using more powerful constructs for communication and mobility. We establish the basic meta-theory of the calculus by providing rules for type safety and showing that typing is preserved during execution.	access control list;ambient calculus;linear algebra;locality of reference;name binding;rendering (computer graphics);separation of concerns;stemming;type safety;type system	Pablo Garralda;Adriana B. Compagnoni	2006	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2005.09.021	ambient calculus;real-time computing;type safety;separation of concerns;computer science;distributed computing;programming language;mobile computing;algorithm;channel	PL	-28.745301594388486	32.3704699396295	197235
3dfda4d04caf716e26d8f66e1fbd66dbe179ddce	petri nets and self-stabilization of communication protocols	communication protocol;petri net		petri net;self-stabilization	Wuxu Peng;Kia Makki	1996	Informatica (Slovenia)		self-stabilization;communications protocol;petri net;distributed computing;computer science	EDA	-29.295511359774995	35.23151724004618	197807
52e64077e0b4cdcb187ad02b02258e993fca03dd	a broadcast-based calculus for communicating systems	automatic control;communication system;concurrent computing;operational semantics;calculus carbon capture and storage mobile communication automatic control communication system control radio broadcasting telephony concurrent computing parallel processing algebra;telephony;process calculus;radio broadcasting;algebra;calculus;carbon capture and storage;mobile communication;communication system control;parallel processing	This paper presents a process calculus for reconfigurable communicating systems which has broadcast as basic communication primitive, and we provide an operational semantics for this calculus. We illustrate the calculus through some examples, and we propose three behavioural equivalences for reasoning about systems of broadcasting processes, namely, barbed equivalence, step-equivalence and labelled bisimilarity. An important result, is that all these relations coincide, providing different ways to study the equivalence/non-equivalence of two systems. Then, we provide a direct characterization for the strong congruence relation induced by these equivalences. Finally, we give a complete axiomatisation for strong congruence.	axiomatic system;bisimulation;congruence of squares;operational semantics;process calculus;turing completeness	Cristian Ene;Traian Muntean	2001	Proceedings 15th International Parallel and Distributed Processing Symposium. IPDPS 2001	10.1109/IPDPS.2001.925136	radio broadcasting;ambient calculus;parallel processing;process calculus;parallel computing;real-time computing;carbon capture and storage;mobile telephony;concurrent computing;computer science;theoretical computer science;automatic control;distributed computing;telephony;programming language;operational semantics;calculus of communicating systems;algorithm;communications system	Logic	-30.58745195936825	32.62619038295313	197986
03f9ff760ca5cf1a52126b0ac648f39ed7364af3	formal techniques for distributed objects, components, and systems		We present the first session typing system guaranteeing response liveness properties for possibly non-terminating communicating processes. The types augment the branch and select types of the standard binary session types with a set of required responses, indicating that whenever a particular label is selected, a set of other labels, its responses, must eventually also be selected. We prove that these extended types are strictly more expressive than standard session types. We provide a type system for a process calculus similar to a subset of collaborative BPMN processes with internal (data-based) and external (event-based) branching, message passing, bounded and unbounded looping. We prove that this type system is sound, i.e., it guarantees request-response liveness for dead-lock free processes. We exemplify the use of the calculus and type system on a concrete example of an infinite state system.	abstract rewriting system;business process model and notation;distributed object;divergence (computer science);exemplification;liveness;message passing;non-blocking algorithm;process calculus;request–response;type system	Josef Kittler	2014		10.1007/978-3-662-43613-4		Logic	-29.47405918749163	32.921697400034816	198477
38225a6caf4dbc87d8828a797700cb9e3e75d154	an application for a distributed computer architecture-realtime data processing in an autonomous mobile robot	vehicles distributed processing real time systems robots;processing capacity distributed computer architecture realtime data processing autonomous mobile robot real time systems sensory feedback independent processing modules transport unit common memory point to point connection sensor data broadcasting adjustable timetable;point to point;distributed processing;distributed computing;data processing;sensory feedback;autonomous mobile robot;robots;vehicles;application software distributed computing transportation real time systems feedback computer architecture mobile robots mobile communication broadcasting communication system control;real time systems	This paper describes a data processing structure for realtime sytems with sensory feedback and a distributed computer architecture which supports it. The computer system is implemented within an autonomous mobile robot and is based on a set of independent processing modules, each of which consists of a processing core, a transport unit and a common memory between them. Communication between modules is done in two ways:. For command transportation, a direct point-to-point connection is used and transport of raw and processed sensor data is done by broadcasting. Transportation is controlled by an adjustable time table, which is maintained by the supervisor. If he detects that a module does not process the given task in time, he slows down driving speed and adjusts the time table. This facility allows to adapt the action speed to the current processing capacity and finally to the complexity of the environment.	autonomous robot;computer architecture;feedback;mobile robot;point-to-point protocol	Ralf Hinkel;Thomas Knieriemen;Ewald von Puttkamer	1988		10.1109/DCS.1988.12543	robot;embedded system;real-time computing;data processing;point-to-point;computer science;distributed computing	Robotics	-32.038743285560564	38.25834525485403	198672
075e4a7fd9c161181ba3bf6fdba4cc1d15e9ab7e	a computational model for a distributed object-oriented operating system based on a reflective abstract machine	reflective abstract machine;object-oriented operating system;computational model	The design of an object-oriented operating system (OOOS) involves the design of a model that governs the objects method execution. In this paper we show the design of an OOOS based in an OO abstract machine: specifically, the design of the computational model. We propose the adoption of an active object model and we think reflectivity is a helpful tool to achieve a flexible OO computational system.	abstract machine;active object;computation;computational model;distributed object;operating system	Lourdes Tajes Martínez;Fernando Álvarez García;María Ángeles Díaz Fondón;Darío Álvarez Gutiérrez;Juan Manuel Cueva Lovelle	1998		10.1007/3-540-49255-0_112	real-time computing;simulation;computer science;distributed computing	PL	-31.11062794510851	36.43500992403608	198839
221c81a555f2891d2c1b829b7d715bb38025d936	a lan based pc interactive embedded system formonitoring and controlling temperature	embedded system		embedded system	S. Barua;A. Kakoty Mahanta;K. Sarma	2008			embedded system;computer science	Robotics	-29.92012632612782	38.736561816387066	198892
31bad12190490b829f09ea94169dcfc00ec2b45c	dependent and-parallelism revisited (poster abstract)		• Programming Languages: Implementation, Semantics, and Applications, Constraint Programming, Logic Programming, Object-oriented Programming, Compilers, Compile-time Analysis. • Software Engineering: Software Verification, Real-time Systems, Domain Specific Languages, Executable Specifications, Agent/Web based Computing, Interoperability. • Parallel and Distributed Processing: High Performance AI and Constraint Logic Programming Systems, Automatic Parallelization and Parallelizing Compilers, Parallel Architectures, Applications.	automatic parallelization;compiler;constraint logic programming;constraint programming;domain-specific language;executable;interoperability;real-time operating system;real-time transcription;software engineering;software verification	Enrico Pontelli;Gopal Gupta	1996				PL	-27.752032901352376	36.24250343295925	199640
