id	title	keywords	abstract	entities	authors	year	journal	doi	fos	area	x	y	ix
a5f3da2cc9da9bd74c3ecdfd2b561b8920960df9	a survey of quantum programming languages: history, methods, and tools	quantum programming languages;programming language;programming tools;lambda calculus;indexing terms;functional programming;computer languages history quantum computing quantum mechanics logic programming computer simulation quantum entanglement computational modeling military computing functional programming;computer programming;symposia;quantum logic;quantum computer;systems analysis;lambda calculus quantum computing functional programming imperative programming linear logic;imperative programming;quantum computing;quantum computing quantum programming languages programming tools functional programming;linear logic;programming tool;systems analysis functional programming programming languages quantum computing;programming languages	Quantum computer programming is emerging as a new subject domain from multidisciplinary research in quantum computing, computer science, mathematics (especially quantum logic, lambda calculi, and linear logic), and engineering attempts to build the first non-trivial quantum computer. This paper briefly surveys the history, methods, and proposed tools for programming quantum computers circa late 2007. It is intended to provide an extensive but non-exhaustive look at work leading up to the current state-of-the-art in quantum computer programming. Further, it is an attempt to analyze the needed programming tools for quantum programmers, to use this analysis to predict the direction in which the field is moving, and to make recommendations for further development of quantum programming language tools.	circa;computer programming;computer science;lambda calculus;linear logic;programmer;programming language;programming tool;quantum computing;quantum logic;quantum programming	Donald A. Sofge	2008	Second International Conference on Quantum, Nano and Micro Technologies (ICQNM 2008)	10.1109/ICQNM.2008.15	quantum information science;programming domain;reactive programming;computer science;theoretical computer science;lambda calculus;computer programming;programming paradigm;procedural programming;symbolic programming;inductive programming;fifth-generation programming language;programming language theory;programming language;quantum computer;functional programming;algorithm	Theory	-28.254343373097836	21.999968029961384	160350
0c0af66c6c10207d6ca0b534636f5f50edbd88ca	praxis: a program for reproducing proforma design calculations	praxis;engineering;software;lenguaje programacion;programmation;programming language;logiciel;conception;proforma;ingenierie;programacion;calcul construction;diseno;langage programmation;logicial;design;ingenieria;fortran;structural analysis;programming;calculo construccion	PRAXIS embodies a computer language for reproducing design calculations in a paginated and tidy layout suitable for submission to a checking authority. Some calculations reproduced by PRAXIS are illustrated in Fig. 1. From the calculations alone it would be impossible to tell whether the page came from a typewriter (being copied from a designer's hand-written calculations) or from a computer, because the calculation is self-descriptive. Every line is checkable. Every formula is shown in symbolic form before specific values are substituted. The only thing suggesting the involvement of a computer is the consistent neatness, and absence of arithmetical mistakes. Although Fig. 1 shows a calculation for a brick wall, PRAXIS itself knows nothing about walls; it is independent of any particular engineering discipline. In order to reproduce calculations for a wall PRAXIS must be given a 'proforma' calculation for a wall. Such a proforma is shown in Fig. 2. This is the proforma from which the calculations shown in Fig. 1 were generated. The proforma corresponds directly to the finished calculations, groups of question marks in the proforma being replaced by parameters of a particular wall. The function of PRAXIS is to substitute these parameters, then resolve arithmetically the expressions in the proforma which were given algebraically. Fig. 3a illustrates another proforma, details of which are explained more fully later in this paper. The resulting set of calculations in Fig. 3c shows extra lines generated from those in the proforma. Nevertheless the calculations in Fig. 3c remain self-descriptive and not evidently the product of a computer program. During the last twenty-five years many design programs have been written to produce, as a by-product, calculations similar to those illustrated in Figs 1 and 3c. But these programs were written specifically to design beams or slabs or whatever the structural entities concerned. PRAXIS is a program which knows nothing about beams or slabs; such knowledge is embodied only in the proforma. Thus the proforma is analogous to a computer program for which PRAXIS is the interpreter (or processor). In this respect PRAXIS offers a novel approach to the reproduction of . designers' calculations at least as far as the authors are aware. A proforma, being analogous to a computer program, need be composed only once for each problem. When a satisfactory proforma has been developed for the design of a rectangular column, say, then that proforma may be stored on disc to be recalled whenever a rectangular column is to be designed. An ever-growing library of proformas may be stored on disc in this way. The rest of this paper explains the principles of processing a proforma, concentrates on certain features of the 'language' in which proformas are composed and describes the operation of PRAXIS on a computer. Finally this paper discusses the current scope and possible future of PRAXIS in structural engineering.	altran praxis;computer language;computer program;entity;html tidy;xfig	D. Alcock;Deborah Brown	1990	Comput. J.	10.1093/comjnl/33.4.337	programming;design;computer science;artificial intelligence;structural analysis;algorithm	PL	-30.50207452002939	22.212526740154818	160425
1fe241c64a8091ec0c6879bdfdc4b9d15f82402f	scalable visualizations of object-oriented systems with ownership trees	program visualization;complex structure;object oriented programming;power method;object oriented systems;corpus analysis;levels of abstraction;data structure;software visualization	Executing object-oriented programs have a complex structure consisting of numerous objects connected by interobject references.This structure, called the program’s object graph, is hard to understand, and this complicates learning, teaching, debugging and maintaining object-oriented programs.While visualization can be used to display object graphs, the size and complexity of typical object graphs also makes visualization di⁄cult.We have developed ownershiptrees as a simple yet powerful method of extracting a program’s implicit encapsulation structure from its object graph.We have developed a programvisualization tool thatmakes use ofownership trees to display the structure of object-oriented programs. Because ownership trees are independent of scaleFthe relationship between a whole object-oriented system and its top-level components is the same as the relationship between a low-level data structure and the objects that implement itFour software visualization is applicable at all levels of abstraction within a program’s design. r 2002 Published by Elsevier Science Ltd.	data structure;debugging;decision tree;encapsulation (networking);high- and low-level;object graph;principle of abstraction;software visualization	Trent Hill;James W Noble;John Potter	2002	J. Vis. Lang. Comput.	10.1006/jvlc.2002.0238	software visualization;method;data structure;power iteration;computer science;theoretical computer science;operating system;generalized complex structure;database;programming language;object-oriented programming	PL	-30.203987998318485	24.397830075858458	160990
c595d71c5a538e8e596c9c75189e890c0a6c216e	sur les graphes infinis possedant un groupe d'automorphismes primitif	primitive automorphisms;infinite graph	On se bornera dans cet article aux graphes non orient& et sans boucle dont les a&es sont simples. Ces graphes peuvent ktre finis ou infinis. Un graphe infini est dit localementJini si le dkgrt de chaque sommet est fini. On rtservera les let&es grecques majuscules aux graphes. Pour un graphe r, on krit V(T), E(T), A(T), et K(T) pour indiquer, rtspectivement, son ensemble de sommets, son ensemble d’argtes, son groupe d’automorphismes, et sa connectivitt. Pour XE V(T), le dtgrt de x est nott p(x). Si tous les sommets de Iposskdent le mcme dCgrt, cette valeur s’tcrit p(T). S’il n’y a pas de risque d’ambiguitk, on supprimera l’argument r. Un graphe primitif est un graphe r tel que A(T) soit un groupe primitif de permutations de V(T), c’est A dire, tel que A(T) soit un groupe transitif sur V(T) et que pour toute partie B de V od IBI > 1 et B # V, il existe C(EA tel que 0 # cr[B] n B # B. kvidemment, aucun graphe r non connexe 06 E(T) # 0 ni aucun graphe biparti n’est primitif. Par contre, les graphes complets, les graphes sommettransitifs ayant un nombre premier de sommets, et le graphe de Petersen sont des exemples de graphes primitifs. On peut trouver d’autres exemples dans le contexte des graphes distance-transitifs. Des graphes primitifs proviennent Cgalement de certains	java platform, standard edition;julius petersen;sans institute	Mark E. Watkins	1994	Discrete Mathematics	10.1016/0012-365X(92)00529-Z	algorithm	Crypto	-32.1101116856918	21.148650951125653	162454
4fcff3172fa1cae75a77c706d4da49ca57fdf3f2	an introduction to ms-windows software development (abstract)	anchored instruction;optimal solutions;software development kit;software development;control flow;intelligent learning environments;macrocontext microworlds;heuristic techniques;trip planning	This is an introductory class that covers the basic concepts of Micro.saft@ WindowsTM sotlware development. These include eventdriven programming, message routing and message handling, and screen management issues. The class provides an overview of the Windows functional library (the Software Development Kit) and how it is used to handle menu selections, paint the screen, and display, update and read dialog boxes. A simple program is analyzed to demonstrate these concepts. OVERVIEW There is a large demand for people able to program in Microsoft Windows. In addition, the concepts necessary to develop for Windows are readily transferable to other environments such as Mats and X. These concepts include eventdriven programming, user-defined control flow, as well as screen features such as menus, lists, edit fields and pushbuttons. This seminar will focus on these basic topics and how to implement them in Microsoft Windows. Windows is examined from the point of view of the underlying Applications Programmer's Interface (API), because this most clearly demonstrates these concepts. Many tools exist that hide these details fkom you. However to successfully evaluate these tools, this understanding is necessary. At the conclusion of the seminar, we will use what we have learned to examine the different types of tools that are on the market. This will include evaluating the tradeoffs involved in choosing the right tool for your projeet and your company. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of ACM. To copy otherwise, or to republish, requires a fee and/or specific permission. Major topics to be covered include:. Event driven programming. Common Windows Messages. How to specify screen appearance. Implementing basic window styles q Screen management issues. Linking screen appearance to code A sample program will be analyzed to demonstrate each concept. In the tools section, we will examine code generators and multi-platform tools. At the end of this seminar you will have stilcient knowledge to make self-study a manageable task. If you are considering a Windows project for your company, you will be aware of the scope of the task and the best ways of approaching it.	a new kind of science;application programming interface;control flow;event-driven programming;microsoft windows;point of view (computer hardware company);programmer;routing;software development kit;dialog	Linda R. Jacobson	1995		10.1145/223355.223736	simulation;software project management;computer science;social software engineering;software framework;software development;software construction;control flow;software analytics;resource-oriented architecture;software deployment;goal-driven software development process;software development process;software system	HCI	-30.23919583631715	25.104326923428996	163151
4651ec1590d7ba587cb97e3d736f962055d8bc20	managing cscw’s users in scripting language	collaboration programming servers java prototypes computers;computers;briefness behavior preservation cscw users management computer supported cooperative work abstract scripting language role transition process programming language role transition management system development role user assignment collaborative monopoly game language constructs jacie language programming codes;prototypes;collaboration;servers;abstract programming language cscw role transition easy programming socio technical approach;programming;program interpreters authoring languages computer games groupware java;java	In computer supported cooperative work (CSCW), users work together from remote locations where each of them performs specific roles. However, their roles are dynamic and they change their roles more often as compare to co-located environments. The process of changing roles is known as role transition. Role transition process basically determines who is authorized to trigger for changes, who is mandated to perform assignment, who is the best fitted candidate for the roles and what are the constraints imposed to the users. Rarely, the role transitions are translated into a programming language to support easy development of role transition management system. Currently, development of such system is mainly done by experts due to the nature complexity of CSCW. Thus, this research is intended to develop a set of highly abstract scripting language to support role-user assignment for easy development. To achieve the objective, a collaborative Monopoly game has been developed as a simulation to extract various parameters that are needed for role-user assignment. Then, their relationships are established. Based on the relationships, a new set of language constructs are designed and developed. Then, the language constructs are embedded via internal extension into JACIE language. JACIE is a dedicated scripting language focusing on speed development of CSCW application systems. Finally, the new set of language constructs is tested by developing a prototype of a call center that supports various role-user assignments. This research has successfully reduced lines of programming codes (as compared to Java) while preserving the briefness behavior of a scripting language.	apl;authorization;code;computer-supported cooperative work;embedded system;java;monopoly;programmer;programming language;prototype;scripting language;simulation	Zainura Idrus;Siti Zaleha Zainal Abidin;N. Omar	2015	2015 Fourth International Conference on Future Generation Communication Technology (FGCT)	10.1109/FGCT.2015.7300238	fourth-generation programming language;first-generation programming language;natural language programming;very high-level programming language;simulation;language primitive;human–computer interaction;programming domain;data control language;computer science;programming language implementation;domain-specific language;scripting language;compiled language;low-level programming language;fifth-generation programming language;programming language;programming language specification;high-level programming language	HCI	-30.936022607975993	24.152029615938197	165743
a944a0486257afc63c127f0804b0ec66091b8ab9	from the paper to the tablet: on the design of an ar-based tool for the inspection of pre-fab buildings. preliminary results of the sirae project	augmented reality;energy efficiency;inspection;pre-fab buildings	Energy-efficient Buildings (EeB) are demanded in today’s constructions, fulfilling the requirements for green cities. Pre-fab buildings, which are modularly fully-built in factories, are a good example of this. Although this kind of building is quite new, the in situ inspection is documented using traditional tools, mainly based on paper annotations. Thus, the inspection process is not taking advantage of new technologies. In this paper, we present the preliminary results of the SIRAE project that aims to provide an Augmented Reality (AR) tool that can seamlessly aid in the regular processes of pre-fab building inspections to detect and eliminate the possible existing quality and energy efficiency deviations. In this regards, we show a description of the current inspection process and how an interactive tool can be designed and adapted to it. Our first results show the design and implementation of our tool, which is highly interactive and involves AR visualizations and 3D data-gathering, allowing the inspectors to quickly manage it without altering the way the inspection process is done. First trials on a real environment show that the tool is promising for massive inspection processes.	augmented reality;customize;document completion status - documented;extrapolation;generic drugs;modular programming;requirement;semiconductor fabrication plant;tablet computer	Cristina Portalés;Sergio Casas;Jesús Gimeno;Marcos Fernández;Montse Poza	2018		10.3390/s18041262	engineering;electronic engineering;efficient energy use;systems engineering;augmented reality;in situ	HCI	-31.82354199980533	20.46784154297636	166725
1541f6eb92af317400bb4b063bb8a91e1231c6c8	the provision of procedural and functional interfaces for the maintenance of program design language and program language notations	programming language;program design	Although there is a growing literature on the process of software maintenance, there is, as yet, very little evidence of tools and methods being developed to specifically aid maintenance staff. This paper describes a technique for providing maintenance information which is both applicable to program design language and program language notations. The technique enables maintenance information to be stored in such a way that it can be interrogated by means of both simple procedural and functional interfaces.	procedural programming;program design language;software maintenance	Darrel C. Ince	1984	SIGPLAN Notices	10.1145/948566.948571	natural language processing;cognitive dimensions of notations;first-generation programming language;natural language programming;language primitive;data manipulation language;specification language;computer science;programming language implementation;program design language;design language;fifth-generation programming language;programming language;programming language specification;high-level programming language;semantics	SE	-28.09286735091468	23.122750045597332	166879
18093d85b4975a98ea8e7e66877ac4159a3545b7	using ada-based robotics to teach computer science	high level language;lego mindstorms;construction;computer technology	We present an Ada-based interface to Lego Mindstorms TM, a programmable robotics kit that has attracted considerable attention in the computing community. We discuss our motivations for choosing Ada over other high-level languages, and our particular implementation over possible alternatives. Robotics and Ada combine very nicely, for teaching basic computing concepts to both technical and non-technical majors, as shown with several examples.	ada;computer science;high- and low-level;lego mindstorms;robotics	Barry S. Fagin	2000		10.1145/343048.343150	computational science;computing;construction;human–computer interaction;computer science;programming language;high-level programming language	Robotics	-29.286136998721094	22.733833603660344	167028
07d6f0c0f97491271506e681fb6dc24b5fed4e22	"""meaningful modeling: what's the semantics of """"semantics""""?"""	programming language semantics;formal specification;modeling language;grammars;specification languages;unified modeling language	The Unified Modeling Language (UML) is a complex collection of mostly diagrammatic notations for software modeling, and its standardization has prompted an animated discussion about UML's semantics and how to represent it. We have thus set out to clarify some of the notions involved in defining modeling languages, with an eye toward the particular difficulties arising in defining UML. We are primarily interested in distinguishing a language's notation, or syntax, from its meaning, or semantics, as well as recognizing the differences between variants of syntax and semantics in their nature, purpose, style, and use.	diagram;unified modeling language	David Harel;Bernhard Rumpe	2004	Computer	10.1109/MC.2004.172	natural language processing;unified modeling language;lexicology;formal semantics;action semantics;uml tool;computer science;applications of uml;formal semantics;syntax;formal specification;semantics;modeling language;programming language;well-founded semantics;operational semantics;denotational semantics;object constraint language;semantics;computational semantics	PL	-26.785446788753113	18.884909554205947	167156
70e8665a4ffc8087ab5ffa6c8fea4f9efbbc3df7	towards in the field fast pathogens detection using fpgas		"""The rapid detection and identification of infectious pathogens are a critical need for healthcare in both developed and developing countries. There is a need for portable diagnostics and epidemiological surveillance systems that can be deployed in remote field settings for infectious diseases testing, such as pandemic """"hotspots"""" in Africa or southeast Asia. Together with the Vital-IT and Swiss-Prot groups, we developed a fast pathogen detection embedded hardware accelerator (no bigger than 75x50mm) capable of analyzing up to 250Mnt/s of DNA sequence. To deploy this solution, an embedded DNA Next Generation Sequencer (NGS) is used for retrieving the genetic material from patient's sample at the point of care (e.g., the Oxford Nanopore Technologies MinION). Successively, the collected DNA sequences are analized in order to detect the presence of known pathogen patterns. Currently, up to 100 different pathogens can be analized at the same time using one single embedded accelerator. Due to the low-power consumption of this hardware accelerator, it is possible to give access to worldwide health organizations and local administrations to a complete real-time embedded and battery powered surveillance solution. Moreover, this solution can greatly scale to big computing clusters, where a larger pathogens number can be analized in parallel, outperforming current state of art computationally expensive solutions."""		Simone Casale-Brunet;Thierry Schüpbach;Nicolas Guex;Christian Iseli;Alan Bridge;Dmitry Kuznetsov;Christian J. A. Sigrist;Phillippe Lemercier;Ioannis Xenarios;Endri Bezati	2018	2018 28th International Conference on Field Programmable Logic and Applications (FPL)	10.1109/FPL.2018.00091	field-programmable gate array;real-time computing;nanopore sequencing;computer science;epidemiological surveillance;hardware acceleration;minion	EDA	-33.56023188409286	18.624141697655606	167337
796258c13a3cbde0df3ed4d1f8a76dcd7b425e83	a multi-purpose language processing laboratory	compiler construction;design and implementation;language processing;product quality	This paper describes the design and implementation of a tool for creating language processors, in particular, translator generators. The purpose of this tool is to allow the fast implementation of (non-production quality) translators for any language, however exotic, for which a grammar can be written, and to generate compiler phases with “hooks” which show the compiling process in action for use in compiler construction courses. The emphasis is on a user-friendly metalanguage which is consistent for the various phases of the parameterized tool. Use of the tool in a graduate compiler construction course revealed the strengths of this metalanguage as well as providing a test site for other improvements and further development of the tool.	central processing unit;compiler;multi-purpose viewer;usability	Karen A. Lemone	1987		10.1145/31820.31803	compiler;compiler correctness;computer science;theoretical computer science;software engineering;compiler construction;metacompiler;programming language;functional compiler	PL	-27.82077324523785	23.88186461977068	168927
0d1b63a397e64abed55ad6d5434c87958e929520	programmable restoration granularity in constraint programming		In most constraint programming systems, a limited number of search engines is offered while the programming of user-customized search algorithms requires low-level efforts, which complicates the deployment of such algorithms. To alleviate this limitation, concepts such as computation spaces have been developed. Computation spaces provide a coarse-grained restoration mechanism, because they store all information contained in a search tree node. Other granularities are possible, and in this paper we make the case for dynamically adapting the restoration granularity during search. In order to elucidate programmable restoration granularity, we present restoration as an aspect of a constraint programming system, using the model of aspect-oriented programming. A proof-of-concept implementation using Gecode shows promising results.	admissible numbering;aspect-oriented programming;circuit restoration;code segment;computation;constraint programming;data structure;gecode;high- and low-level;prospective search;prototype;search algorithm;search tree;software deployment;web search engine	Yong Lin	2016	CoRR		constraint programming;constraint satisfaction;reactive programming;computer science;theoretical computer science;distributed computing;inductive programming;algorithm	AI	-28.8843868509933	18.253959063882625	168933
4fe9281bb9b72ae97ca0cc404272606d68498764	modularization in the pilot compiler and its effect on the length	program proving;symbolic interpretation;program verification;compilers;correctness;program testing;lisp;machine description languages	The length equation for programs, initially suggested by M.H. Halstead, has been studied and experimentally verified by several independent investigators. The sets of programs tested have ranged over a variety of programming languages and program sizes. While such studies have tested the equation for programs taken as a whole, there have been no studies on the length equation when applied to individual modules within a program. This paper provides such a study for a compiler composed of fourteen modules. The length equation is shown to hold for program parts (modules) as well as for program wholes (the total program).	compiler;experiment;programming language	Jose C. Ingojo	1976		10.1145/800191.805665	program analysis;computer science;theoretical computer science;programming language;algorithm	PL	-27.188951799891907	23.850479555955918	170221
d53787c12a0b6c210a51df20669e21abef3f83d5	smart waste collection platform based on wsn and route optimization		In this paper, we present the design and implementation of a novel agent-based platform to collect waste on cities and villages. A low cost sensor prototype is developed to measure the fulfilling level of the containers, a route system is developed to optimize the routes of the trucks and a mobile application has been developed to help drivers in their work. In order to evaluate and validate the proposed platform, a practical case study in a real city environment is modeled using open data available and with the purpose of identifying limitations of the platform.	program optimization	Álvaro Lozano Murciego;Gabriel Villarrubia;Alberto López Barriuso;Daniel Hernández de La Iglesia;Jorge Revuelta Herrero;Juan Francisco de Paz	2016		10.1007/978-3-319-40159-1_11	open data;database;waste collection;truck;city environment;computer science;internet of things	EDA	-30.055895742769206	18.472614818005304	170920
3003866a05fc32704317b2c0143aad01a75f4dd4	a pragmatic carbon tax billing regime	software global warming carbon tax computer applications microcontrollers bluetooth analog digital conversion;software;microcontrollers;environmental legislation;taxation air pollution control environmental economics environmental legislation environmental science computing invoicing;analog digital conversion;environmental science computing;computer applications;air pollution control;environmental economics;software bluetooth temperature sensors hardware wireless sensor networks wireless communication;taxation;invoicing;bluetooth;global warming;chemical plants pragmatic carbon tax billing regime green house gas regulation uno united nation organization regulatory authorities low cost feasible carbon tax billing regime hardware technologies software technologies computational responsibilities automobiles;carbon tax	Regulation of green house gases is now among major concerns of UNO (United Nation Organization). With this concern different regulatory authorities in different regions of world are working at their very best. These regulatory authorities need a low cost feasible carbon tax billing regime which could be easily employed in industries, vehicles, standalone motors, chemical plants etc. This paper presents a regime which is a combination of dedicated hardware and dedicated software to fulfill the required demands of regulatory authorities. Regime presented in this paper uses existing hardware and software technologies that do not have any extra maintenance and setup cost associated with them. Software portion of regime takes all the computational responsibilities in order to make hardware as simple and less costly as possible. Best possible efforts are made to meet design challenges associated with feasibility of this regime on target units like industries, automobiles and chemical plants.	computation;electronic billing;embedded system;general data protection regulation;mobile payment;overhead (computing)	Nakul Vyas	2012	2012 Ninth International Conference on Wireless and Optical Communications Networks (WOCN)	10.1109/WOCN.2012.6335515	microcontroller;simulation;global warming;telecommunications;computer science;operating system;computer applications;bluetooth;computer security	Arch	-33.22166433499875	21.719480012231458	171364
115fe9ecb65bcd81d40f57c33e821ea369c8c3d8	a memory-based approach to recognizing programing plans	engineering;memoire;tecnologia electronica telecomunicaciones;plane;computacion informatica;metodologia;reconocimiento;plan;grupo de excelencia;ingenieria logiciel;object oriented programming;software engineering;methodologie;ingenierie;recognition;memoria;end users;reengineering management;ingenierie inverse;ciencias basicas y experimentales;comprension;plano;genie logiciel;ingenieria;code;c programming language;tecnologias;methodology;reconnaissance;codigo;memory;comprehension;reverse engineering	utomated Program understanding can be viewed as the process of automatically extracting design knowledge from source code. Past research efforts have automatically extracted and used this knowledge to restructure programs [4], to tutor novice programmen [5, lo], to ~generate documentation [15, 161, and to locate reusable components [ti, 111. Our interest lies in automatically extracting object-oriented design knowlrdge to support translating C programs to C ++. In particular, we are interested in recognizing common ol$xts and operations in C programs and replacing them with libraries containing human-generated object-oriented code written in C ++. This is an appealing task for automated program understanding for several reasons. First, even if it is possible only to automatically recognize and replace a small portion of the many objects and operations implicitly present in a set of real-world programs , it is a win over attempting to revise these programs entirely by hand. Second, hand translation of C to C ++ requires constructing replacement C ++ classes, so it is not unreasonable to assume that information about C implementations of these classes can be provided while constructing the replacement classes. As an example, consider the problem of translating the C program in Figure 1 into its ot$xt-oriented C ++counterpart in Figure 2. Translating even this simple C program requires understanding its purpose, its design, and the mapping between its design and its implementation. Its purpose is to print the average distance between a set of x, y points. Its design divides into two pieces. One reads pairs of points, computes the distance between them, adds this distance to a running total, and updates a running count. The other calculates the average and prints the result. Its implementation stores point coordinates as separate variables, combines a while loop and a scanf to read the input points, computes the distance using a series of arithmetic operations and assignments, and prints the average using printf and an expression which provides an average of 0 if no values are read. All of this design information is necessary to translate Figure 1 into Figure 2, as the C ++ program has the same general design, but makes explicit that the program is manipulating points, calculating distances, computing averages, and so on. The difficulty is that this design must be inferred from relationships between elements of the source code, as the program is poorly documented and uses uninformative variable names. Our …	documentation;library (computing);printf format string;program comprehension;scanf format string;while loop	Alex Quilici	1994	Commun. ACM	10.1145/175290.175301	comprehension;end user;computer science;artificial intelligence;operating system;plane;methodology;programming paradigm;inductive programming;memory;plan;programming language;object-oriented programming;code;reverse engineering	PL	-26.960513079535303	25.004600487242016	172149
41518d08325832f8341fdba4956346a4d30cf0a6	update on the qualification of the hakuto micro-rover for the google lunar x-prize		In the past several years, due to the proliferation of cubesat and micro-satellite missions, several companies have started offering off-the-shelf space-ready hardware[3]. These products offer a welcome reduction in cost but do not solve a major problem for space robotics designers: available space-ready controllers are years behind COTS microprocessors and microcontrollers in terms of performance and power consumption. For applications involving human safety or critical timing, the extra cost and difficulty of using certified space-ready hardware is justifiable. But for some low-cost missions that require high performance, terrestrial components are increasingly being qualified and integrated. The University of Tokyo’s HODOYOSHI 3 and 4 satellites have integrated readily available COTS FPGAs and microcontrollers and protected them with safeguards against Single Event Latch-up (SEL)[9]. This paper presets a lunar rover architecture that uses many COTS parts, with a focus on electrical parts and their function in and survival of various tests.	arm architecture;debug;design review (u.s. government);electronic component;field-programmable gate array;google lunar xprize;hakuto;latch-up;marginal model;memory controller;microcontroller;microelectromechanical systems;microprocessor;network switch;on-board data handling;robotic spacecraft;robotics;rover (the prisoner);spec#;terrestrial television;unmanned aerial vehicle;wheels;wiring	John Walker;Nathan Britton;Kazuya Yoshida;Toshiro Shimizu;Louis-Jerome Burtz;Alperen Pala	2015		10.1007/978-3-319-27702-8_21	commercial off-the-shelf;simulation;architecture;computer science;cruise;skylight;radiation	Robotics	-31.700892608750532	21.89177413634761	172453
3071ae26725c7c6cb1ee6f26777427712076ba58	augmented bnf for syntax specifications: abnf		Internet technical specifications often need to define a formal#N#syntax. Over the years, a modified version of Backus-Naur Form (BNF),#N#called Augmented BNF (ABNF), has been popular among many Internet#N#specifications. The current specification documents ABNF. It balances#N#compactness and simplicity with reasonable representational power. The#N#differences between standard BNF and ABNF involve naming rules,#N#repetition, alternatives, order-independence, and value ranges. This#N#specification also supplies additional rule definitions and encoding#N#for a core lexical analyzer of the type common to several Internet#N#specifications. [STANDARDS-TRACK]	beta normal form	Dave Crocker;Paul Overell	2005	RFC	10.17487/RFC4234	computer science;programming language;algorithm	SE	-27.118621896142677	20.07426828859189	172508
4f75a992146b852bf879e85c7cb67402c794260d	genged - a generic graphical editor for visual languages based on algebraic graph grammars	generation of syntax directed graphical editors;visual specification of vls by algebraic graph grammars;unified modeling language layout computer science computer graphics read only memory application software education software standards standards development graphical user interfaces;graph transformation;visual languages;graph grammar;abstract syntax;visual language;graphical constraint solver genged generic graphical editor visual languages algebraic graph grammars graphical definition alphabet syntax directed graphical editor graphical structure abstract syntax visual level syntax layout operations visual language rules graph grammar rules logical structure formal presentation;graph grammars;computational linguistics;graphical definition of vls;computational linguistics visual languages graph grammars	GENGED is a generic graphical editor supporting the graphical definition of visual languages. Given an alphabet and rules of a specific visual language GENGED generates a syntax-directed graphical editor for this languag e. GENGED as well as each visual language defined using GENGED is based on algebraic graph grammars. A sentence is given by a graphical structure consisting of a logical (abstract syntax) and a visual level (concrete syntax). Both levels are connected by layout operations. Visual language rules are defined by graph grammar rules. The underlying logical structure, however, is hidden from the user, but it is essential for a formal presentation and manipulation of graphical structures on both levels. The manipulations are performed by a graph transformation machine working on the logical level, whereas a graphical constraint solver manages the layout the user works with.	abstract syntax;anti-grain geometry;automaton;boolean algebra;component-based software engineering;diagram;graph rewriting;graphical user interface;interaction;java version history;linear algebra;objective-c;parse tree;petri net;prototype;server (computing);solver;string (computer science);visual language	Roswitha Bardohl	1998		10.1109/VL.1998.706133	natural language processing;computer science;theoretical computer science;syntax;abstract semantic graph;programming language	AI	-31.50830891983268	23.710918027237643	172554
24bd4fda5091211987973ca3b5943bc13e6a37d5	liberate computer user from programming	virtual machine;computer program;software tool;computer network;natural language;human brain;problem solving	This paper is about computer-based problem solving methodology. The issue addressed is: can we develop a computer-based problem-solving methodology which is not based on computer programming? The answer we provide to this question is YES. This raises the next question: if we do not use programming how do we communicate problem solving algorithms to the computer? The answer to this question is: (1) develop software tools that support domain algorithm execution in the problem domain environment (no programming as usual) and (2) allow problem-domain experts to express their problem-solving algorithms using the natural language of their problem domains. We achieve this computer-based problem solving methodology by computational emancipation of the application domain, which consists of: 1 Characterize the application domain in terms of concepts that are universal in the domain, have standalone computing meaning, and are composable.rn 1 Structure the application domain using an ontology where terms denoting domain characteristic concepts are associated with computer artifacts implementing them.rn 1 Develop a domain-dedicated virtual machine that executes domain algorithms expressed in the natural language of the domain (without asking to encode them into programs) and implement it on the physical computers existent in the computer-network.rn With this methodology computers execute algorithms whose expressions are conceptual, similar to the way human brain would execute them.		Teodor Rus	2008		10.1007/978-3-540-79980-1_3	domain analysis;computing;domain;business domain;programming domain;computer science;virtual machine;theoretical computer science;problem domain;domain engineering;natural language;programming language;computer network programming;algorithm	Graphics	-29.080069035858635	19.99306827440689	173114
6a428788065409f2e4f6bbf779b0cb9dd76d128d	mobile application to support community health workers using genexus smart devices	pronto system;ios platform mobile application community health workers genexus smart devices public health actions public healthcare system pronto health facility geographically distributed healthcare units municipality health network chw module symbian java j2me technology android based devices smart devices technology android platform;servers mobile applications mobile communication public healthcare synchronization smart phones;mobile computing android operating system health care;community health workers;genexus smart device;pronto system community health workers genexus smart device	The role of community health workers (CHW) in promoting the results of public health actions have been recognized worldwide. This work describes the development stage of a CHW's mobile application that is part of a public healthcare system called PRONTO (means READY in English). The system development started in 2011 and in the middle of 2012 the first health facility was operational. Since then 38 geographically distributed healthcare units were deployed achieving about one third of the municipality health network. The first version of the CHW module was developed to be used in an old cell phone based on Symbian and was based on java J2ME technology. The second version of the app was developed to android based devices and was written in java. The third version of the app was developed using GeneXus to Smart Devices technology and is addressed to both Android and iOS platforms. This paper discusses about the use of this technology and shows the advantages in adopting it.	android;genexus;java platform, micro edition;mobile app;mobile phone;smart device;software release life cycle;symbian;ios	Mauro Marcelo Mattos;Simone Erbs da Costa;Luciana Pereira de Araujo;Shaiane Mafra Casa;Eric Boeing	2015	2015 9th International Conference on Innovative Mobile and Internet Services in Ubiquitous Computing	10.1109/IMIS.2015.14	embedded system;simulation;computer security	HCI	-33.003483464712204	21.315026876876082	174296
3935f4d2e158a294e066726f249d91f15243ac90	structured programming: retrospect and prospect	automatic control;computer aided instruction;automatic programming;software engineering;logic programming;mathematical programming;programming profession;milling machines;writing;software engineering humans logic programming automatic programming mathematical programming programming profession milling machines writing computer aided instruction automatic control;humans	Structured programming has changed how programs are written since its introduction two decades ago. However, it still has a lot of potential for more change.	retrospect (software);structured programming	Harlan D. Mills	1986	IEEE Software	10.1109/MS.1986.229478	first-generation programming language;declarative programming;very high-level programming language;programming domain;reactive programming;functional reactive programming;computer science;engineering;extensible programming;software engineering;functional logic programming;automatic control;computer programming;programming paradigm;procedural programming;symbolic programming;inductive programming;fifth-generation programming language;programming language theory;programming language;logic programming;writing;programming in the large and programming in the small;computer engineering	SE	-28.18724050967822	22.29589886211719	175005
15d593b5966b9b50fbe506cb4c64c8557421fa62	semiotic engineering to define a declarative citizen language		The Brazilian Public Administration (PA) intends to turn its business process transparent, but the language choice was BPMN. Current research observes that the declarative language can partially fit the PA’s constraints. However declarative language is not easy for the citizen to understand. In our case study, we found evidence of it by using the Communicability Evaluation Method. Thus, in this paper, we propose a preliminary version of a new declarative language.	declarative programming;semiotic engineering	Lilian Mendes Cunha;Claudia Cappelli;Flávia Maria Santoro	2017		10.1007/978-3-319-58524-6_40	semiotics;business process;semiotic engineering;business process model and notation;declarative programming;natural language processing;user friendly;artificial intelligence;computer science	DB	-27.68030432398577	18.798126513997964	175053
348cb8168d56654972ce2881712f1195bac636a0	formalisation of haskell refactorings.	qa 76 software;computer programming	Refactoring is a technique for improving the design of existing programs without changing their external behaviour. HaRe is the refactoring tool we have built to support refactoring Haskell 98 programs. Along with the development of HaRe, we have also investigated the formal specification and proof of validity of refactorings. This formalisation process helps to clarify the meaning of refactorings, improves our confidence in the behaviour-preservation of refactorings, and reduces the need for testing. This paper gives an overview of HaRe, and shows our approach to the formalisation of refactorings.	code refactoring;formal specification;haskell;lambda calculus;lambda lifting;modular programming	Huiqing Li;Simon J. Thompson	2005			computer science;computer programming;programming language;algorithm	PL	-27.34238560591449	25.187669543738124	176302
4062215d0d8259193c626fdcce71e09aaf7559df	a program development environment based on persistence and abstract data types	abstract data type;program development	This paper describes the design of a program development system used for teaching undergraduate students. The system started life as an experiment with ideas associated with a type domain designed as part of a persistent [1] programming environment [11]. The aim of the experiment was to apply these ideas to the description of facilities usually associated with file-based operating systems, and to find out how well ideas designed to cope with “fine grain” persistent objects, would cope with the kind of “coarse grain” persistent objects usually represented by “files”.		Malcolm S. Powell	1989		10.1007/978-1-4471-3173-1_3	abstract data type;theoretical computer science;abstract syntax;persistence (computer science);development environment;object type;computer science	SE	-28.021134369824107	24.81659796048678	176361
e858009b2c651e7c6ba50f94406324c6d55b79cc	a modern beginning programming course	programming language;teaching programming;fortran	"""This paper describes a beginning programming course. It represents an approach to the """"right way"""" to teach programming independent of any programming language. This is accomplished by thinking of programming as a two part process---(1) constructing an algorithm and (2) translating the algorithm into a program in some chosen programming language. Basic structured programming constructs are used for constructing an algorithm and translation is demonstrated by translation of control constructs into FORTRAN."""	algorithm;control flow;fortran;programming language;structured programming	Roy F. Keller	1976		10.1145/1499799.1499824	first-generation programming language;constraint programming;protocol;declarative programming;very high-level programming language;programming domain;reactive programming;functional reactive programming;computer science;extensible programming;third-generation programming language;functional logic programming;programming paradigm;procedural programming;symbolic programming;inductive programming;fifth-generation programming language;programming language theory;programming language;high-level programming language;algorithm;concurrent object-oriented programming	PL	-26.813281251862584	24.07739154726228	176609
3ccb7975c893eb33461fb0c169b8780d3c1f875d	language design and analyzability: a retrospective	programming language design;program checkers;control flow;static analysis;data flow	There is tension between programming language design for modularity and flexibility of programming and the amenability of the resulting programs to static analysis. At the start of Software Practice and Experience in 1971, most languages in commercial use were procedural (e.g., FORTRAN, ALGOL, PL/I) and on the whole were easier to analyze than languages of today such as JavaScript and Python. Modern languages include dynamic features, which enhance prototyping of approaches, often resulting in programs that are difficult for software tools or humans to understand. Starting with this perspective, we explore the relationship between language features and the ability of static analysis to precisely determine control flow and data flow in programs, thus enabling program optimization, transformation and understanding.		Barbara G. Ryder;Ben Wiedermann	2012	Softw., Pract. Exper.	10.1002/spe.1133	fourth-generation programming language;data flow diagram;first-generation programming language;very high-level programming language;language primitive;computer science;theoretical computer science;operating system;third-generation programming language;computer programming;programming paradigm;low-level programming language;fifth-generation programming language;programming language theory;programming language;control flow;second-generation programming language;high-level programming language;static analysis;control flow analysis	HCI	-27.700748913930017	25.000501284413495	176739
3a2df2ab7d4a4b5f8aa2de3d6b56f88b671fa37d	a formal specification of appearance and behaviour of visual environments	formal specification;visual environment process algebra formal specification visual languages icons data algebra;software requirements and specifications graphical user interfaces visual languages;visual languages formal specification graphical user interfaces;visual environment;visual languages;icons;process algebra;data algebra	The problem of a formal specification of visual languages has been addressed in several works. Most of these approaches only describe the correct placement of graphic objects on a screen. Icons are not, however, static elements. They behave dynamically in order to interact with the user, other icons and application processes. In order to make a complete specification of icons, it is important to have a formal approach which can describe the graphical status and the reactive behaviour depending on the generated events. A combination of process and data algebra for this purpose is proposed. This approach was applied to describe a visual environment dewloped by a set of common interaction techniques.	formal specification;graphical user interface;interaction technique	Fabio Paternò	1993	Software Engineering Journal	10.1049/sej.1993.0020	process calculus;computer science;theoretical computer science;formal specification;programming language	SE	-32.11800063381205	23.54197935162824	176903
d37074470721629c73ec0b501276bbc49aec2d55	a visual system for the generation of banking legacy system gateways	programming environments;programming environments visual programming bank data processing visual languages;cobol;bank data processing;visual programming language;visual programming;visual languages;visual programming language uvg visual system banking legacy system gateways electronic format interbanking network information system visual programming environment message handling functions;information system;visual system banking computer languages information systems programming environments us department of transportation resists application software communication system software displays;legacy system;visual system	Banking legacy systems intensively exchange messages in electronic format. Such systems are, for their nature, difficult to update and maintain. As a consequence, the introduction of new types of messages is a hard task. In this paper we describe the architecture and part of the implementation of the SI.RE. Visual System, an Interbanking Network Information System that lets us generate gateways for the exchange of electronic messages among banking legacy systems. In particular, the SIRE visual system contains a Visual Programming Environment (VPE) that allows us to obtain a rapid and secure development of the message handling functions. VPE implements a Visual Programming Language UVG that supports reuse of COBOL routines. Such a UVG language has been developed following a methodology here described that presents the great advantage to be, mostly, performed in automatic way.	legacy system	Andrea Bianchi;Gennaro Costagliola;Pietro D'Ambrosio;Rita Francese;Giuseppe Scanniello	2001		10.1109/HCC.2001.995291	first-generation programming language;reactive programming;computer science;third-generation programming language;computer programming;database;multimedia;programming paradigm;inductive programming;fifth-generation programming language;visual programming language;human visual system model;programming language;system programming;second-generation programming language;high-level programming language	EDA	-30.879614813113886	23.791226991659883	177141
0d63df1a73ee85d668025f181512cbf3c939442f	mpl: a multiprecision matlab - like environment	multiprotocolo;outil logiciel;software tool;generacion automatica;generation code;generacion codigo;code generation;arithmetique;automatic generation;generation automatique;aritmetica;arithmetics;automatic differentiation;analizador sintaxico;multiprotocol;parser;multiprotocole;herramienta software;analyseur syntaxique	A number of generic tools, some developed by the authors, some developed in cooperation with other teams and others available freely, are combined into an environment, called MPL from Multi Precision Lab, which offers a cross-platform variable precision alternative to Matlab. Among the tools we mention for instance our C/C++ precompiler for type conversion, the GMP arithmetic library complemented with our own IEEE-854 compliant multi-radix multiprecision MpIeee library, the Boost matrix library, our own Matlab parser, the libraries FFCall and GNU Libtool. The functionality of the well-known Matlab toolboxes is available through the multiprecision equivalent of one’s library of choice, generated using the same tools. We mention, among others, GSL, Numerical Recipes, an automatic differentiation toolkit [1], a hybrid polynomial solver [2] and so on.	arbitrary-precision arithmetic;automatic differentiation;c++;gnu libtool;gnu multiple precision arithmetic library;gnu scientific library;library (computing);matlab;multiphoton lithography;numerical recipes;polynomial;preprocessor;solver;type conversion;whole earth 'lectronic link	Walter Schreppers;Franky Backeljauw;Annie A. M. Cuyt	2005		10.1007/11428831_37	automatic differentiation;computer science;theoretical computer science;operating system;database;programming language;algorithm;code generation	Logic	-33.408694558805394	25.20163362829758	177235
e5f358ab509f46a021e2ab57092d07620887c0f4	visual zero: a persistent and interactive object-oriented programming environment	virtual machine;programming language;object oriented programming;input output;visual programming;object oriented;learning object;object oriented paradigm	In this article, an ongoing research project held in the Computer Science department of the University of Vigo is described. Its main objective is to develop an interactive object-oriented environment, serving as a vehicle for learning object-oriented programming. It currently consists of a virtual machine, an assembler, compilers for two high-level programming languages, and an educational visual programming environment. Its main characteristics are (a) the support of prototype-based object orientation, which is a model of object orientation that actually wraps the class-based model; (b) the support for object persistence, which simplifies all input/output issues to the minimum, and (c) the availability of a new visual programming environment is an invaluable help. We the authors think that the combination of all of these possibilities, will lead to an interesting, useful tool that would be recommended for object-oriented teaching. The whole system has been successfully employed in a number of different courses, allowing students to concentrate on objects and their relationships from the very beginning, and thus helping them to achieve a high degree of knowledge about the objectoriented programming paradigm. r 2007 Elsevier Ltd. All rights reserved.	admissible numbering;assembly language;business logic;compiler;computer science;database;emoticon;high- and low-level;high-level programming language;input/output;integrated development environment;interactivity;linux;microsoft windows;persistence (computer science);persistent data structure;programmer;programming paradigm;prototype;user interface toolkit;vanish (computer science);virtual machine;visual programming language;z/vm	J. Baltasar García Pérez-Schofield;Emilio García Roselló;Francisco Ortin;Manuel Pérez Cota	2008	J. Vis. Lang. Comput.	10.1016/j.jvlc.2007.11.002	protocol;method;simulation;programming domain;reactive programming;functional reactive programming;computer science;object;object-relational mapping;extensible programming;machine learning;database;programming paradigm;event-driven programming;procedural programming;symbolic programming;inductive programming;fifth-generation programming language;visual programming language;programming language;object-oriented programming;cloning;god object;concurrent object-oriented programming	PL	-29.859960737384966	25.104007972878787	178183
445c3206674d3b95c62f66a9f0ecf93ff1bb0983	dynacargo: the evaluation results of a dynamic waste collection management system based on real-time and forecasted data	graph routing algorithms;urban solid waste collection;intelligent transportation systems;data mining	Dynacargo is a project that aims at developing a near real-time monitoring system for waste bins' fill level. This data is used to predict the fill-level of waste bins and dynamically manage the waste collection procedure. This leads to truck distance minimization by utilizing routing algorithms. Dynacargo adds a set of durable, low cost sensors and RFID tags to existing waste bins. The tags store the fill-level measures by sensors, which is communicated through a variety of communication means and reaches a central information management system. Along with this real time data collection and transmission, data mining techniques are executed on older data collected prior to Dynagargo implementation, in order to forecast future waste bins fill levels. In this paper we present and discuss the promising evaluation results of the project on the case study of Nafpaktia municipality.	algorithm;data mining;information management system (ims);radio-frequency identification;real-time clock;real-time computing;real-time transcription;routing;sensor	George Asimakopoulos;Sotiris P. Christodoulou;Panayiotis Alefragis;Andreas Gizas;Vassilis Triantafillou	2016		10.1145/3003733.3003804	intelligent transportation system;computer science;data mining;database;computer security	DB	-30.15170847786432	18.513840079140035	178341
9a5e0f873f879b2c96fb2a6882d2b6bb24ee82d9	visualized and modeless programming environment for form manipulation language	programming environments;programming language;programming environment;computer graphics;visual programming;user interfaces computer graphics programming environments;visualization programming environments visual databases programming profession productivity usability runtime information processing user interfaces out of order;application programs modeless programming environment form manipulation language vpf iconic language form oriented operations hierarchical views abstract levels program specification execution visualization run time behavior graphical representation program development productivity reliability;graphical representation;program specification;user interfaces;program development	A visualized and modeless programming environment VPF is presented in this paper. The VPF supports the development of programs written in a programming language, called a form manipulation language. The language is a so-called iconic language, and provides not only programming facilities but also form-oriented operations. The VPF provides the following features: (1) hierarchical views that support views for various abstract levels of program specification and execution. (2) visualization of program itself and its run-time behavior with graphical representation, and (3) modeless operations that enable us to develop a program under only one execution mode. These features give the programmers good comprehension of program development, and enhance productivity and reliability of the application programs.	apl;formal specification;graphical user interface;integrated development environment;mode (computer interface);programmer;programming language;vector product format	Jun'ichi Miyao;Shin'ichi Wakabayashi;Noriyoshi Yoshida;Yasushi Ohtahara	1989		10.1109/WVL.1989.77049	fourth-generation programming language;first-generation programming language;natural language programming;very high-level programming language;language primitive;human–computer interaction;programming domain;reactive programming;functional reactive programming;computer science;programming language implementation;theoretical computer science;extensible programming;functional logic programming;programming paradigm;event-driven programming;procedural programming;symbolic programming;inductive programming;fifth-generation programming language;visual programming language;programming language;programming language specification;high-level programming language	PL	-30.523321021761788	24.24581363235173	179282
a80fcb8996b33c475da36c7200840552366accde	an on-line handwritten mathematical equation recognition system that can process matrix expressions by referring to the relative positions of matrix elements	handwriting recognition	In this paper we describe a method for performing recognition of matrix expressions in an on-line handwritten mathematical equation recognition system. This system incrementally performs recognition of numerical expressions and text input as handwriting and outputs the recognition results as LATEX source code. In previous work we developed the functionality of the system to make it capable of recognizing other two-dimensional structures including subscripts, square root symbols, summation notation, and fractions, but we had not previously been able to deal with matrix structures. We believe that a specialized recognition system is necessary for dealing with matrix structures because they are not expressed using any declarative symbols and involve numerical elements positioned vertically on the page. In this paper we add matrix expression recognition functionality that can be used in real time to the system; this implementation makes use of both geometric features and the relative positions of numerical elements. We performed recognition experiments using the expanded system with input containing matrix expressions and confirmed the effectiveness of the proposed method. © 2006 Wiley Periodicals, Inc. Syst Comp Jpn, 37(14): 87–96, 2006; Published online in Wiley InterScience (www.interscience. wiley.com). DOI 10.1002/scj.10684	digi-comp i;experiment;john d. wiley;latex;lazy evaluation;mathematical structure;numerical analysis;online and offline	Kenichi Toyozumi;Takahiro Suzuki;Kensaku Mori;Yasuhito Suenaga	2006	Systems and Computers in Japan	10.1002/scj.10684	speech recognition;computer science;artificial intelligence;machine learning;handwriting recognition;algorithm	AI	-28.823102150712607	21.57538392310706	179328
42cd198f6697c55c9348d2e76d465051286398de	programming languages-comparatively speaking	programming language	Assignments in an upperlevel undergraduate programming languages course should require students to do more than write elementary programs in several languages. Assignments for this course should allow students to explore alternative programming language paradigms and require critical written evaluation of their strengths and weaknesses. Course assignments can help students develop their research skills by requiring students to make use of the professional literature and by providing them with experiences in designing experiments. This paper describes four assignments which require students to utilize these skills.	design of experiments;experience;experiment;programming language	Bruce R. Maxim	1993		10.1145/169070.169092	natural language processing;greenspun's tenth rule;first-generation programming language;natural language programming;very high-level programming language;language primitive;programming domain;computer science;extensible programming;functional logic programming;programming paradigm;symbolic programming;inductive programming;fifth-generation programming language;programming language theory;programming language;programming language specification;second-generation programming language;high-level programming language	HCI	-28.082870458414444	23.357178515169867	179704
88327bc92bf03512af60996d48f14c26a03ddc16	very-high-level programming of knowledge representation schemes	automatic;high level languages;knowledge based system;maintenance;specifications;specification language;computer programming;language;knowledge representation;high level language;knowledge based systems;buildings;knowledge base	This paper proposes building knowledge-based systems using a programming system based on a very-high-level language. It gives an overview of such a programming system, BC, and shows how BC can be used to implement knowledge representation features, providing as examples, automatic maintenance of inverse links and property inheritance. The specification language of BC can be extended to include a knowledge representation language by describing its knowledge representation features. This permits a knowledge-based program and its knowledge base to be written in the same very-high-level language which allows the knowledge to be more efficiently incorporated into the program as well as making the system as a whole easier to understand and extend.	admissible numbering;high- and low-level;high-level programming language;knowledge base;knowledge representation and reasoning;knowledge-based systems;specification language	Stephen J. Westfold	1984			natural language processing;knowledge representation and reasoning;first-generation programming language;knowledge base;universal networking language;question answering;specification language;computer science;knowledge management;artificial intelligence;body of knowledge;knowledge-based systems;open knowledge base connectivity;procedural knowledge;knowledge extraction;fifth-generation programming language;programming language;commonsense knowledge;programming language specification;high-level programming language;domain knowledge	AI	-26.735542293414774	20.687643773085195	180976
0db9b6d30e8486cfe24b803500b9f8decbd9ecd6	context of problem-solving systems	libraries;power supplies;computer languages;mathematics;output feedback;operator complexity;data structures;programming profession;operator complexity data complexity language complexity language level;data complexity;councils;computer science;language level;problem solving libraries computer languages mathematics power supplies programming profession councils computer science data structures output feedback;problem solving;language complexity	Considerable effort has been expanded in attempts to combine the power found in algorithmic languages with the power found in program libraries. However, most of these attempts to construct problem-solving systems for a particular class of users have failed to achieve their objective of providing the user with the potential benefits inherent in such systems. This paper attempts to define and place problem-solving systems in a general context, and thereby shows when the potential for failure or success is high.	library (computing);problem solving;programming language	Lawrence R. Symes;R. R. Oldehoeft	1977	IEEE Transactions on Software Engineering	10.1109/TSE.1977.231149	data structure;computer science;engineering;theoretical computer science;software engineering;programming language;algorithm	SE	-28.043156554804845	22.309469103570006	181857
6b47266cc12202b1ef2d0eb801de14555b58cbe5	parsing excel formulas: a grammar and its application on 4 large datasets		Spreadsheets are popular end user programming tools, especially in the industrial world. This makes them interesting research targets. However, there does not exist a reliable grammar that is concise enough to facilitate formula parsing and analysis and to support research on spreadsheet codebases. This paper presents a grammar for spreadsheet formulas that can successfully parse 99.99% of more than 8 million unique formulas extracted from 4 spreadsheet datasets. Our grammar is compatible with the spreadsheet formula language, recognizes the spreadsheet formula elements that are required for supporting spreadsheets research, and produces parse trees aimed at further manipulation and analysis. Additionally, we use the grammar to analyze the characteristics of the formulas of the 4 datasets in 3 different dimensions: complexity, functionality, and data utilization. Our results show that (1) most Excel formulas are simple, however formulas with more than 50 functions or operations exist, (2) almost all formulas use data from other cells, which is often not local, and (3) a surprising number of referring mechanisms are used by less than 1% of the formulas.	parsing expression grammar	Efthimia Aivaloglou;David Hoepelman;Felienne Hermans	2017	Journal of Software: Evolution and Process	10.1002/smr.1895	programming language;end user;syntax;parsing;grammar;computer science	Vision	-27.498329726412873	21.904775006726112	182202
e06cccfeea0de3f31b1fb0420f14f7488e3617b0	visualization vs. specification in diagrammatic notations: a case study with the uml	metodo diagramatico;visualizacion;semantica formal;user interface;lenguaje uml;specification;langage modelisation unifie;formal semantics;semantique formelle;uml class diagram;visualization;methode diagrammatique;category theory;diagram method;visualisation;especificacion;estudio caso;unified modelling language;etude cas;formal language	It is useful to see a notation as a visualization on the top of specification core. The latter deals with semantic meaning of notational constructs while the former is about its presentation (a user interface to specification). In the paper, this general paradigm is applied to a few major constructs used in the UML class diagrams: various sorts of associations between classes, including multi-ary and qualified. A key peculiarity of the approach is that semantic meaning of notational constructs is also specified in a graphical (yet formal) language – the language of generalized sketches adapted from category theory. Then an UML class diagram appears as a visual abbreviation of semantic sketch hidden in it. By comparing two graphical images – the diagram and the sketch – one can analyze the UML notational mechanism and correct it towards better presentation of the intended semantic meaning.	approximation algorithm;category theory;class diagram;computational semiotics;data structure;error-tolerant design;formal language;graphical user interface;linear algebra;predicate (mathematical logic);programming paradigm;refinement (computing);semantic similarity;sign system;situation calculus;visual instruction set	Zinovy Diskin	2002		10.1007/3-540-46037-3_15	natural language processing;visualization;computer science;applications of uml;programming language;algorithm	SE	-27.878859898769363	18.412724570522364	183552
55636f2cd2de7c44ade0a1a20733ccec89300cfb	implementation of a multimodal dialog system using extended markup languages	extensible markup language;xml schema;domain knowledge;intelligent system;logic programs;markup language	In this paper, we describe an implementation of a plan-based multimodal dialog system using the extensible markup language (XML). The dialog manager receives semantic objects representing the user’s utterance at the end of each user’s turn. We define a semantic markup language (SML), based on XML, to describe these semantic objects. Following the principles of XML Schema, we define the schema of SML in another XML called semantic definition language (SDL). In addition to supporting many discourse and dialog features, SDL is also designed to represent the domain knowledge via the application schema and the hierarchy of the semantic objects. We show that, with a thoughtful design in SDL, SML can be expressive enough that the behavior of a dialog planner can be fully specified in the extensible stylesheet language (XSL), a standardized language with a logical programming model that is most popular for implementing intelligent systems.	dialog manager;dialog system;logic programming;markup language;multimodal interaction;programming model;semantic html;xml schema	Kuansan Wang	2000			ruleml;data exchange;natural language processing;xhtml;xml;semantic web rule language;synchronized multimedia integration language;html;collaborative application markup language;computer science;document type definition;document definition markup language;xml schema;pcdata;database;schematron;markup language;programming language;page description language;wireless markup language;domain knowledge;sgml	Web+IR	-27.079028633950294	18.776847405362357	183654
00b29c94eb1b222a9206e014dd592910a7af44d0	social roles, from agents back to objects	object oriented programming languages	In this paper we introduce a new view on roles in Object Oriented programming languages. This view is based on an ontological analysis of roles and attributes to roles the following properties: first, a role is always associated not only with an object instance playing the role, but also to another object instance which constitutes the context of the role and which we call institution. Second, the definition of a role depends on the definition of the institution which constitutes its context. Third, this second property allows to endow players of roles with powers to modify the state of the institution and of the other roles of the same institution. As an example of this model of roles in Object Oriented programming languages, we introduce a role construct in Java. We interpret these three features of roles in Java as the fact that, first, roles are implemented as classes which can be instantiated only in presence of an instance of the player of the role and of an instance of the class representing the institution. Second, the definition of a class implementing a role is included in the class definition of the institution the role belongs to. Thirdly, powers are methods of roles which can access private fields and methods of the institution they belong to and of the other roles of the same institution.	java;programming language	Matteo Baldoni;Guido Boella;Leon van der Torre	2005			computer science;knowledge management;artificial intelligence;social psychology	PL	-28.629010583308528	19.359150666539847	184428
6d9c618417c02f38cf57980732e4bfe8f73fefcd	formal specification of interactive languages using definite clause grammars	language use;human computer interaction;formal specification;expressive power;rapid prototyping;definite clause grammar;dialogue manager;human computer interface	Modelling human-computer interaction in interactive computer systems through languages i$ one the of main approaches for the construction of human-computer interfaces. The work presented here describes first how Definite Clause Grammars can be used to formally specify this type of languages. Compared with previous work using BNF etc, this formalism has more expressive pOwer and is easier for rapid prototyping. With this modelling, the user-machine dialogue design becomes a DCG specification process, and the dialogae i~anagement becomes a parsing problem. Detailed examples and our experiences are given to demonstrate the interest of such a modelling.	beta normal form;definite clause grammar;formal specification;human–computer interaction;parsing;rapid prototyping;semantics (computer science)	Weidong Dang	1988		10.1007/3-540-50820-1_53	grammar systems theory;natural language processing;computer science;formal specification;linguistics;definite clause grammar;programming language;language of temporal ordering specification	HCI	-26.822687067171078	19.492232513364396	185146
45ca6b03ba0c71bdee01745a8510ee3324f5ba4d	object-oriented design patterns in fortran 90/95: mazev1, mazev2 and mazev3	factorial design;programming language;object oriented design;object oriented software;distributed programs;keywords distributed computer systems;plasma physics;journal article;operating system;object oriented;fortran software;07 05 wr;design pattern;pattern recognition;scientific programming;object oriented design patterns;design patterns;fortran;software design pattern;software design;particle in cell;problem solving;89 80;object oriented programming design patterns;fortran programming language	This paper discusses the concept, application, and usefulness of software design patterns for scientific programming in Fortran 90/95. An example from the discipline of object-oriented design patterns, that of a game based on navigation through a maze, is used to describe how some important patterns can be implemented in Fortran 90/95 and how the progressive introduction of design patterns can usefully restructure Fortran software as it evolves. This example is complemented by a discussion of how design patterns have been used in a real-life simulation of Particle-in-Cell plasma physics. The following patterns are mentioned in this paper: Factory, Strategy, Template, Abstract Factory and Facade.	design pattern;fortran	Viktor K. Decyk;Henry J. Gardner	2008	Computer Physics Communications	10.1016/j.cpc.2007.11.013	software design pattern;computer science;theoretical computer science;programming language;structural pattern	EDA	-29.284038068122218	24.709012077040676	185238
2d4900a63ea916e68a66acc861fb2797b5b96573	smalltalk: the leading language to learn object-oriented programming	libraries;software design course object oriented programming learning java computing courses computer science courses smalltalk programming language object oriented mentality;object oriented programming;software engineering;computer science education;educational courses;communities;java object oriented programming libraries software design communities;software design;software engineering computer science education educational courses java object oriented programming;java	The use of Java in the first courses of Computing, Computer Sciences and similar degrees is widely accepted. However, many programming professors realize that while is possible for students to use an Object-Oriented language, is also possible to program with them without applying an Object-Oriented mentality. This paper defends the use of Smalltalk programming language as the best option for students to learn Object-Oriented programming and acquiring an Object-Oriented mentality at the same time. This study is based on three years of experience in a course on Software Design.	java;programming language;smalltalk;software design	José A. Gallud;Pedro González Villanueva	2012	2012 Federated Conference on Computer Science and Information Systems (FedCSIS)		fourth-generation programming language;first-generation programming language;computing;very high-level programming language;application programming interface;programming domain;computer science;programming language implementation;software design;component-based software engineering;software development;extensible programming;computer programming;real time java;programming paradigm;symbolic programming;inductive programming;programming language theory;programming language;object-oriented programming;java	PL	-28.584105606941154	24.248571711513897	185827
e15a47755bf798d33d656d831585cc2914cc7ef3	introduction to simulation languages	language use;simulation study;technical report;discrete simulation	The purpose of this paper is to give a brief introduction to simulation languages. The paper contains a discussion on the hierarchy of computer languages and their relation to simulation, the advantages and disadvantages of using simulation languages, factors to consider when selecting a language, and some of the characteristics of the three most popular discrete simulation languages. A more thorough treatment of simulation languages and their use are contained in [2], [4], and [10].  A significant portion of the effort in any simulation study is in programming the model to run on a digital computer. This programming occurs after the model has been defined. The selection of the language should, in general, be done prior to developing the model to be programmed because (i) there must be a comptibility between how the system is modeled and the computer language used and (ii) some simulation languages aid in the modelling process. The language selected is usually a general purpose language (higher level language) or a simulation language.	advanced continuous simulation language;computer language	Robert G. Sargent	1978			natural language processing;fourth-generation programming language;simulation;language primitive;specification language;computer science;domain-specific language;technical report;gpss;discrete event simulation;third-generation programming language;syntax;ontology language;low-level programming language;modeling language;fifth-generation programming language;programming language theory;programming language;world wide web;second-generation programming language;high-level programming language;comparison of multi-paradigm programming languages;simulation language	PL	-28.258014392180897	23.795923042052472	186000
d82b7d5d7b915d5690c54f6280171d1b56c28999	a brief account: implementation and applications of a pascal program verifier (position statement)	representation of solids;computer graphics;geometric data bases;computational geometry;geometric modelling;cad cam	The Stanford Pascal verifier is an interactive program verification system. It automates much of the work necessary to analyze a program for consistency with its documentation, and to give a rigorous mathematical proof of such consistency or to pin-point areas of inconsistency. It has been shown to have applications as an aid to programming, and to have potential for development as a new and useful tool in the production of reliable software.  This verifier is a prototype system. It has inadequacies and shortcomings. It is undergoing continuous improvement, and is expected to be used eventually in conjunction with other kinds of program analyzers. In this talk we shall describe the verifier and some of the results that have been obtained using it. We shall discuss some of the problems that still stand in the way of developing verifiers to a stage where they are part of the programmer's normal working environment.	documentation;formal verification;interactive computing;pascal;programmer;prototype	David C. Luckham	1978		10.1145/800178.810136	computer science;theoretical computer science;algorithm	SE	-29.827418280537213	21.431481975029282	186956
29f56b57c8a9790f05b09bd71dda09a18a4a2d07	sbml level 3 package: hierarchical model composition, version 1 release 3		"""Constructing a model in a hierarchical fashion is a natural approach to managing model complexity, and offers additional opportunities such as the potential to re-use model components. The SBML Level 3 Version 1 Core specification does not directly provide a mechanism for defining hierarchical models, but it does provide a mechanism for SBML packages to extend the Core specification and add additional syntactical constructs. The SBML Hierarchical Model Composition package for SBML Level 3 adds the necessary features to SBML to support hierarchical modeling. The package enables a modeler to include submodels within an enclosing SBML model, delete unneeded or redundant elements of that submodel, replace elements of that submodel with element of the containing model, and replace elements of the containing model with elements of the submodel. In addition, the package defines an optional """"port"""" construct, allowing a model to be defined with suggested interfaces between hierarchical components; modelers can chose to use these interfaces, but they are not required to do so and can still interact directly with model elements if they so chose. Finally, the SBML Hierarchical Model Composition package is defined in such a way that a hierarchical model can be """"flattened"""" to an equivalent, non-hierarchical version that uses only plain SBML constructs, thus enabling software tools that do not yet support hierarchy to nevertheless work with SBML hierarchical models."""	choose (action);hierarchical database model;sbml;specification	Lucian Paul Smith;Michael Hucka;Stefan Hoops;Andrew Finney;Martin Ginkel;Chris J. Myers;Ion I. Moraru;Wolfram Liebermeister	2015		10.2390/biecoll-jib-2015-268	computer science;data science;database;programming language	SE	-32.0308990670298	25.230255772631185	187461
3d6ba98623a83d4b404e8232fdcfa08ca846c2e0	an enhanced l-diversity privacy preservation	databases;measurement data privacy privacy clustering algorithms databases publishing data models;execution time enhanced l diversity privacy preservation data publishing data analysis anonymity models individual privacy protection superabundance information loss data utility diversity model clustering data quality cluster size sensitive attribute values privacy preserving degree;measurement;publishing;clustering data publishing privacy preservation k anonymity l diversity;data privacy;pattern clustering data analysis data privacy;clustering algorithms;privacy;data models	As a serious concern in data publishing and analysis, privacy preservation of individuals has received much attentions. Anonymity models via generalization can protect individual privacy, but often lead to superabundance information loss. Therefore, privacy preserving data publishing needs a careful balance between privacy protection and data utility. The challenge is how to lessen the information loss during anonymity. This paper presents a (k, l, θ)-diversity model base on clustering to minimize the information loss as well as assure data quality. We take into accounts the cluster size, the distinct sensitive attribute values and the privacy preserving degree for this model. Besides, we account for the complexity of our algorithm. Extensive experimental evaluation shows that our techniques clearly outperform the existing approaches in terms of execution time and data utility.	algorithm;cluster analysis;data quality;experiment;privacy;run time (program lifecycle phase)	Gaoming Yang;Jingzhao Li;Shunxiang Zhang;Li Yu	2013	2013 10th International Conference on Fuzzy Systems and Knowledge Discovery (FSKD)	10.1109/FSKD.2013.6816364	data modeling;privacy software;information privacy;computer science;data mining;publishing;internet privacy;cluster analysis;privacy;world wide web;measurement	DB	-30.626850811274622	20.36577516754873	187528
0e684b16f4a2f955bc267f292b7cec9a709d9bb3	specific features of the control structure in the programming language markiz	complex objects;programming language;control structure;object oriented programming languages	Specific features of the control structure in the object-oriented programming language MARKIZ are described. This language is designed for programming problems with a complex object structure, for example, compilers that have programs as their objects. A fundamental feature of this language is the ability to write such objects in the form of a sequence of symbols representing an image of the object and the ability to construct objects in the process of a program operation from subobject components.	actionscript;compiler;computer;control flow;internet;programming language;string (computer science);world wide web	V. M. Mikhelev	2005	Programming and Computer Software	10.1007/s11086-005-0031-7	natural language processing;fourth-generation programming language;first-generation programming language;natural language programming;protocol;very high-level programming language;language primitive;object language;programming domain;computer science;programming language implementation;object;theoretical computer science;third-generation programming language;functional logic programming;programming paradigm;symbolic programming;low-level programming language;fifth-generation programming language;visual programming language;programming language;object-oriented programming;control flow;programming language specification;second-generation programming language;high-level programming language	PL	-26.904686655810217	23.858772610736523	188866
483ccfd99d922e7f06f88b639d745e501f0cd2b4	configurable applications for satellite graphics	computer graphics;software systems;data structures;mathematical model;application programming;relational data base;division of labor;interactive systems	This paper advocates a configurable approach to software for satellite graphics in which the division of labor between the host and satellite computers can be easily changed after an application program has been written. A software system, CAGES (Configurable Applications for Graphics Employing Satellites), implements this approach. CAGES can substantially simplify the application programmer's task of programming a host and satellite computer by making the intercomputer interface relatively invisible to him, while at the same time allowing him the efficiency and flexibility that can result from direct application programming of the satellite computer.Proper design of configurable programs is facilitated by a mathematical model defining a pairwise measure of program module inter-dependence. Experience with this model has resulted in a set of programming guidelines that further aid the application programmer in producing a suitable program structure.	computer performance;fixed-function;graphics;level of detail;mathematical model;programmer;software system;structured programming	Griffith Hamlin	1976		10.1145/563274.563311	simulation;division of labour;data structure;relational database;computer science;theoretical computer science;operating system;mathematical model;graphics software;programming language;computer graphics;software system;computer graphics (images)	SE	-32.49805706452505	25.087099965506315	189031
63a4a8c27690d9162c6d2f875740c4047f8bf395	analytics in/for cloud-an interdependence: a review		Cloud computing has brought a paradigmatic shift in providing data storage as well as computing resources. With the ever-increasing demand for cloud computing, the number of cloud providers is also increasing evidently, which poses challenges as well as opportunities for consumers and providers. From a consumer point of view, efficient selection of cloud resources at a minimum cost is a big challenge. On the other hand, a provider has to meet consumers’ requirements with sufficient profit in the fiercely competitive market. The relationship between cloud computing is truly symbiotic in the sense that cloud computing makes the practice of analytics more pervasive while analytics makes cloud computing more efficient and optimal in a lot of ways. In addressing these issues, analytics plays an important role. In this paper, we reviewed some important research articles, which focus on cloud computing from the viewpoint of analytics. Analytics and cloud computing are found to be quite interdependent. From analytics perspective, cloud computing makes available high-end computing resources even to an individual customer at an affordable price. We call this thread “Analytics in Cloud”. From the point of view of cloud computing, efficient management, allocation, and demand prediction can be performed using analytics. We call this thread “Analytics for Cloud”. This review paper is mainly based on these two threads of thought process. In this regard, we reviewed eighty-eight research articles published during 2003–2017 related to the formidable duo of cloud computing and analytics.	interdependence	Kumar Ravi;Yogesh Khandelwal;Boora Shiva Krishna;Vadlamani Ravi	2018	J. Network and Computer Applications	10.1016/j.jnca.2017.11.006	interdependence;thread (computing);utility computing;data mining;cloud computing;computer science;business intelligence;cloud testing;cloud computing security;analytics	Networks	-33.29575761426671	20.45333681690502	189667
2c4bcfdfecd354789f5581e15364766abed3e1d0	sensor network architecture for soil and weather data extraction and database generation	weather;database;sensor network;data extraction;soil	In this paper, the authors design a sensor network architecture for soil and weather data collection and database generation. A multi-sensor device containing sensors for extracting soil characteristics operates as the first component of this architecture. It connects to a mobile phone which further connects to a base server system. An XML file containing location and time specific data travels through the network with soil information. At the base server, the system fetches weather information based on location parameters and a database is created where XML files provide values for every entry. The authors describe few potential applications of this architecture and express how this database can grow more with continuous participation.	mobile phone;network architecture;sensor;server (computing);xml	Rakshit Agrawal;Mridu Atray;S. Krishna Sundari	2012		10.1145/2426656.2426696	climate;embedded system;wireless sensor network;computer science;data mining;database;world wide web;database design	DB	-30.992785703276173	18.417341663492742	192368
1b24c76c56038c02c14662e4806eafec78eeb7b1	correction to: predictive intelligence to the edge: impact on edge analytics		We rest on the edge computing paradigm where pushing processing and inference to the edge of the Internet of Things (IoT) allows the complexity of predictive analytics to be distributed into smaller pieces physically located at the source of the contextual information. This enables a huge amount of rich contextual data to be processed in real time that would be prohibitively complex and costly to deliver on a traditional centralized Cloud. We propose a lightweight, distributed, predictive intelligence mechanism that supports communication efficient aggregation and predictive modeling within the edge network. Our idea is based on the capability of the edge nodes to (1) monitor the evolution of the sensed time series contextual data, (2) locally determine (through prediction) whether to disseminate contextual data in the edge network or not, and (3) locally re-construct undelivered contextual data in light of minimizing the required communication interaction at the expense of accurate analytics tasks. Based on this on-line decision making, we eliminate data transfer at the edge of the network, thus saving network resources by exploiting the evolving nature of the captured contextual data. We provide comprehensive analytical, experimental and comparative evaluation of the proposed mechanism with other mechanisms found in the literature over real contextual datasets and show the benefits stemmed from its adoption in edge computing environments.	baseline (configuration management);centralized computing;cloud computing;data quality;display resolution;edge computing;internet of things;nonlinear system;online and offline;overhead (computing);predictive modelling;programming paradigm;smoothing;time complexity;time series	Natascha Harth;Christos Anagnostopoulos;Dimitrios Pezaros	2018	Evolving Systems	10.1007/s12530-017-9210-z	machine learning;artificial intelligence;data science;computer science;analytics	HPC	-32.20482495100527	18.367587175383466	192829
4166c17d0c65dbb8e7ddd937ef4f4eeabb116b75	mepids: multi-expression programming for intrusion detection system	genetique;systeme temps reel;genetica;linear genetic programming;ingenierie connaissances;perforation;real time;securite informatique;intelligence artificielle;genetics;genetic program ming;computer security;programacion lineal;multi expression programming;seguridad informatica;cognition;intrusion detection systems;linear programming;programmation lineaire;cognicion;artificial intelligence;real time system;sistema tiempo real;inteligencia artificial;systeme detection intrusion;intrusion detection system;knowledge engineering	An Intrusion Detection System (IDS) is a program that analyzes what happens or has happened during an execution and tries to find indications that the computer has been misused. An IDS does not eliminate the use of preventive mechanism but it works as the last defensive mechanism in securing the system. This paper evaluates the performances of Multi-Expression Programming (MEP) to detect intrusions in a network. Results are then compared with Linear Genetic Programming (LGP) approach. Empirical results clearly show that genetic programming could play an important role in designing light weight, real time intrusion detection systems.	intrusion detection system;linear genetic programming;media-embedded processor;performance;windows 95	Crina Grosan;Ajith Abraham;Sang-Yong Han	2005		10.1007/11499305_17	anomaly-based intrusion detection system;intrusion detection system;computer science;linear programming;artificial intelligence;knowledge engineering;computer security;intrusion prevention system;algorithm	Security	-32.44999214860971	21.365380356319086	193755
9e528ff81969781cdb12430790b02203526ea5f8	architecture to an interactive migration system (aims)	interactive conversion;data restructuring;application migration;conversion aids;data translation;data base;application conversion;high level language;data reorganization;data definition	Growth in the computer industry produces a need to convert data and/or programs from one system to another from time to time. While this process has been going on for years, the techniques used to execute this task have been ad hoc and expensive. Very few aids exist on the market today to help this process.  Examination into the conversion scenario reveals that the structure of a system to aid conversion should have the following features:  (1) ability to extract pertinent information from high level source application programs and source systems environment.  (2) interactive facility where users and the conversion aid system can work together to make the decisions.  (3) ability to carry out the translation process automatically after directions are given from a high level language.  This paper describes the architecture of such a system and gives the motivations which lead to such conclusions.	high-level programming language;hoc (programming language);relevance	Barron C. Housel;Vincent Y. Lum;Nan C. Shu	1974		10.1145/800296.811510	data definition language;real-time computing;simulation;computer science;data mining;database;programming language;high-level programming language	SE	-28.739158511289837	22.952772794213704	195217
b57ab062fe2d91b094f9bfa17956b10b9f83de54	teaching linked lists: influence of language on instruction		Basic to any data structures course is the introduction of linked lists, their applications and implementations. In this paper we trace the evolution of the exposition of linked lists, as influenced by the language of instruction. We found that while the node pool implementation of linked lists was originally prominently discussed, the current trend is to present only the pointer-based implementation. We feel that the shift toward object-oriented programming should not preclude a presentation of various implementations. We present our own approach to introducing linked list implementations, in which the pointer-based implementation is used to motivate the node pool approach, using pointers to implement the node pool.	linked list	Chaya Gurwitz	1999	Computer Science Education	10.1076/csed.9.1.36.3814	computer science;theoretical computer science;software engineering;programming language;algorithm	Theory	-29.20176289630005	24.531187627941076	195309
ecfd7122f3aa99f3bc393927b83dc03b2e075352	towards automated student programming homework plagiarism detection		In the emerging world of information technologies, a growing number of students is choosing this specialization for their education. Therefore, the number of homework and laboratory research assignments that should be tested is also growing. The majority of these tasks is based on the necessity to implement some algorithm as a small program. This article discusses the possible solutions to the problem of automated testing of programming laboratory research	abstract syntax tree;algorithm;canonical account;code refactoring;comparison of file comparison tools;compiler;data-flow analysis;high- and low-level;inline expansion;metamodeling;partial template specialization;test automation	Aleksejs Grocevs;Natalija Prokofjeva	2018			information retrieval;plagiarism detection;computer science	SE	-28.29167393069694	23.69326388432865	196663
23c48e76798d5b46d91bf1799a749931976506c3	visual programming for animation in user interfaces	classical interface builder;interface builder;art;instruments;formal specification;event based synchronisation;application software;animation user interfaces layout art runtime application software programming profession time factors instruments joining processes;user interface;direct manipulation;position attribute constraints;layout;runtime;application values;visual programming;interactive animation specification visual programming animation user interfaces handmove system classical interface builder path oriented animation time signals application values user input event based synchronisation position attribute constraints;user input;time factors;graphical user interfaces;handmove system;programming profession;graphical user interfaces visual programming computer animation formal specification user interface management systems;animation;joining processes;time signals;path oriented animation;user interface management systems;computer animation;interactive animation specification;user interfaces	We present the visual programming techniques used by the HandMove system, which creates animated scenes based on a path-oriented model (described in [4]). Resulting animation modules are integrated in user interfaces created with a classical interface builder (XFaceMaker, produced by Non Standard Logics). We present the visual programming features of the HandMove system, which creates independent animated elements to be integrated in user interfaces constructed with a classical interface builder. Its underlying model is based on path-oriented animation, driven by time signals, application values or user input and supports advanced features such as position/attribute constraints and eventbased synchronisation. HandMove exclusively uses interactive animation specification and defines a concise but meaningful visual representation of animation. 2. The HandMove underlying model HandMove scenes consist of a set of two-dimensional graphical objects, which may be either primitive elements (e.g. lines, rectangles) or groups of other graphical objects. Actors are graphical objects with dynamic evolution. Decor elements are motionless objects which may have attached actors during scene evolution. Actor-decor attachment is useful to indirectly address an actor through a decor element. Collections of actors (or decor elements) group similar objects with similar behavior.	attachments;graphical user interface;interface builder;visual programming language	Dan Vodislav	1995		10.1109/VL.1995.520800	simulation;computer facial animation;human–computer interaction;skeletal animation;computer science;computer animation;multimedia	Graphics	-32.13119743325411	23.493823929492454	197824
88b7aac230af7790688bcb1cb75b56d78a73aa00	a meta-language for specification of evolving class and object lattices in oodb		The purpose of the paper is to describe the design of logic-based meta-language for representing constraints on managing evolution of class and object lattices in OODB. It will be prototypically incorporated to the object-oriented environment and language NUT. One of the goals of the paper is also to propose clean solutions to the integration of the procedural object-oriented programming language and declarative logic based language for representing evolution in OODB.		Hele-Mai Haav	1994		10.1007/978-1-4471-3577-7_11	theoretical computer science;database;programming language	Theory	-26.662540693692975	21.21878629712957	197981
49317a450c87e9fccb5249f3e78f8958f82cfcbf	motorola 68040 microprocessor simulation for the sun workstation	computer aided instruction;microprocessr simulators	The goal of the 68040 simulator project is to provide an excellent software development tool for the Multi-drip Module (MCM) research effort[l] and for future educational purposes at the Universizy of Arkansas at Fayetteville. In addition, it will provide the programming community with a powerful, userfriendly, public domain 68040 simulator. Architectural research efforts tha t use a microprocessor, such as the Motorola 68040, would benefit from a simulation of the microprocessor. With a microprocessor simulator, the initial work of software development of the research effort can begin before any hardware is actually assembled. The overall research effort is aided since some problems can be worked ou; of an initial architectural design through the microprocessor simulator before the hardware is actually built. In ~tddition to research specific apphcations, the developed simulation can provide an excellent learning environment. The X Windows user interface, as shown in the Example Session Section, provides a comfortable, friendly look at the inside of the 68040 microprocessor• Students can load 68040 assembly programs which have been compiled to S-record format into the simulation. The student can then vi.,w his/her program in simulation memory and step through one or all of its instructions. As the program is executed, all ~egisters and memory locations are updated on the screen. Pemaission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and ils date appear, and notice is given that copying is by pcrtnission of the Association for Computing Machinery. To copy o ~ v i s e , or to republish, requires a fee and/or specific portal.ion. O 1994 ACM 089791-647-6/ 94/ 0003 $3.50 ging tool. P ro jec t D e s c r i p t i o n Simulat ion Design Design of this simulation began with the acquisition of a Motorola 68000 microprocessor simulation that was suitable for ,.~xpansion. After two weeks of searching the Internet, a simulation with an X Windows interface was obtained from North Carolina State University. This simulation, named 6$KSIM[6], was chosen for several reasons. The most persuasive reason was its capability of being easily modified to run on a Sun Workstation platform since it ran on a DEC T M workstation platform. Another reason was its reputation as a thoroughly tested program. In addition to these factors, it provided an easily modifiable program structure. After extensively testing and examining the code, the decision was made to rebuild completely the user interface[3] and to use some of the existing simulation code as a base for constructing a 68040 simulation. Several bugs were discovered during exam2nation of the 68KSIM simulation code. The severity of the errors encountered demanded that major sections of the 68000 simulator be completely rewritten. These errors were corrected before work began on expanding the simulation. Expansion of the simulation consisted of several steps: adding addressing modes and registers, implementing simulation memory and breakpoints, adding additional instructions and their routing, adding exception processing, and performing testing and verification of code. These steps are detailed in the following sections.	addressing mode;breakpoint;compiler;gnu variants;microprocessor;microsoft windows;motorola 68000;multi-chip module;programming tool;routing;row (database);sun workstation;simulation;software bug;software development;structured programming;user interface;x window system	Trey Grubbs;Bill Herring;Richard Tan;Susan Mengel	1994		10.1145/326619.326650	computer architecture;computer hardware;computer science;motorola 68851	Arch	-30.865420552982854	22.650257757760343	199936
ffc9a02e7e7c8e7c35b4cd3fce602657ccbddd3a	web system development using polymorphic widgets and generic schemas		Current tools allow non-technical users to create systems to store, display, and analyze their data on their own using whatever schema they choose. At the same time, developers of these systems can create generic widgets that may work across any number of domains. Unfortunately, to use a generic widget an end-user (the domain expert) must make their data conform to the schema of the widgets, possibly losing meaningful schema names. This paper presents a solution to this problem in the form of generic widget models (canonical structures), local schemas for domain experts, and an intermediate model (domain structures) that—through the use of mappings between the different models—allows generic functionality while preserving local schema.We present the three user roles in our system: widget developers, domain experts, and domain developers (people who develop and map domain structures). We introduce the concept of canonical structures and show how they are mapped to domain structures. We introduce a new relational query operator for writing queries against canonical structures and show how those queries are rewritten against the domain structures. We also provide an evaluation of the overhead of our system compared to custom code solutions and a modern web development framework.		Scott Britell;Lois M. L. Delcambre;Paolo Atzeni	2017		10.1007/978-3-319-67271-7_9	operator (computer programming);web development;subject-matter expert;programming language;schema (psychology);computer science	SE	-31.034806869055195	21.053101365188294	199958
