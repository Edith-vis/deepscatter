id	title	keywords	abstract	entities	authors	year	journal	doi	fos	area	x	y	ix
5c02ddcfcbb7f6c083f9c07c7ae3dfedd8409487	automatic generation of editors for higher-order data structures	langage fonctionnel;lenguaje programacion;outil logiciel;interfase usuario;software tool;programming language;user interface;generacion automatica;lenguaje funcional;programmation generique;functional programming;automatic generation;higher order;data model;expressive power;generation automatique;first order;polymorphism;estructura datos;langage programmation;generating function;interface utilisateur;polymorphisme;structure donnee;programmation fonctionnelle;modele donnee;polimorfismo;programacion generica;herramienta software;functional language;programacion funcional;data structure;article in monograph or in proceedings;functional programming language;data models;generic programming	With generic functional programming techniques, we have eased GUI programming by constructing a programming toolkit with which one can create GUIs in an abstract and compositional way, using type-directed Graphical Editor Components (GECs). In this toolkit, the programmer specifies a GUI by means of a data model instead of lowlevel GUI programming. In earlier versions of this toolkit, the data model must have a first-order type. In this paper we show that the programming toolkit can be extended in two ways, such that the data model can contain higher-order types. We added support for dynamic polymorphic higher-order editors using the functional shell Esther. By combining the earlier developed techniques of generic GECs, abstract editors, we also added statically typed higher-order editors. In principle this solution extends our GUI programming toolkit with the full expressive power of functional programming languages.	compile time;compiler;correctness (computer science);data model;first-order predicate;functional programming;graphical user interface;high-level programming language;motif;operator overloading;programmer;programming language;run time (program lifecycle phase);type safety;type system	Peter Achten;Marko C. J. D. van Eekelen;Marinus J. Plasmeijer;Arjen van Weelden	2004		10.1007/978-3-540-30477-7_18	data modeling;polymorphism;generating function;higher-order logic;reactive programming;data model;computer science;artificial intelligence;operating system;functional logic programming;first-order logic;database;programming paradigm;programming language;functional programming;user interface;generic programming;expressive power;algorithm	PL	-28.614523004820974	27.79357216833587	158902
06412be717b5c8d6a6260599adc5603413f90630	scientific visualization in a supercomputer network at rus	distributed system;interfase usuario;systeme reparti;project;visualizacion;proyecto;programming environment;user interface;computer graphics;supercomputer;scientific visualization;supercomputador;medio ambiente programacion;visualization;sistema repartido;visualisation;interface utilisateur;projet;grafico computadora;materiel informatique;infographie;material informatica;environnement programmation;superordinateur;hardware	Abstract   The implementation of RSYST, a scientific software application environment at the University of Stuttgart is described. The architecture of the software system matches well with the hardware configuration of the University Computer Center, and the environment aspires to transparently integrate users, who are distributed all over the country, into a consistent software and hardware environment. The visualization concept at RUS is explained, together with some distributed visualization packages implemented at RUS and our own visualization development activities. Finally, the aims and characteristics of a European sponsored project, PAGEIN, are explained, which fits perfectly into the line of developments at RUS. The goal of this project is to experiment with future cooperative working modes of aerospace scientists in a high speed distributed supercomputing environment. Project results will have an impact on the development of real future scientific application environments.	scientific visualization;supercomputer	Ulrich Lang;Ruth E. Lang;Roland Rühle	1993	Computers & Graphics	10.1016/0097-8493(93)90047-D	supercomputer;scientific visualization;simulation;visualization;human–computer interaction;computer science;operating system;computer graphics (images);mechanical engineering	HPC	-32.15500306338738	28.598405411566606	159140
d21c56af629435a7c74265455f600fc34a86e622	the integration of a layout constraint language with an object-oriented user interface management system	layout constraint language;user interface layout;constraints;object-oriented user interface management;user interface management systems;user interface;object oriented	In this paper we present the C OMPASS constraint language which integrates high-level layout specifications with the D IWA user interface management system. The general concept of the C OMPASS system is the automatic adjustment of constraints according to their high-level specification such that a programming interface to explicitly add, remove or modify constraints is unnecessary. In particular, Compass provides the following features to support modular and declarative specifications of changing constraints: association of constraints with classes, a limited reach of constraints by imposing rules on the set of variables which may be used as source or target of a constraint, temporary and conditional constraints, and finally, the concept of a constraint schema which specifies a bundle of similar constraints. At runtime the number of constraints contained in such a bundle varies, i.e. constraints are automatically created or deleted, and each constraint can change its source variables. Declarativeness of constraint schema specifications is achieved by the use of high-level object expressions.	application programming interface;compass;constraint logic programming;high- and low-level;integrated windows authentication;object-oriented user interface;user interface management systems	K. Korfmacher;Hans-Werner Six;Josef Voss	1995			constraint programming;constraint satisfaction;computer science;theoretical computer science;database;engineering drawing	DB	-27.53380466056296	27.33495797536926	160063
f94638cea35faec3a91eb92e0b9d83f0a8c633f0	siren: software for music composition and performance in squeak	arte	Squeak is a new implementation of the Smalltalk programming environment. It was developed at Apple Labs, and has been ported to a variety of computers. Compared to other Smalltalk systems, Squeak has four important features: (1) portability (to the Macintosh, Windows PCs, and many flavors of UNIX); (2) speed (it uses native C for computeintensive code); (3) price (free, including all source code!); and (4) sophistication (full Smalltalk-80 language, libraries, and tools, with many useful extensions). The Siren system is a new object-oriented (OO) software tool kit for music applications. Siren's design was derived from the author's 14-years of experience building Smalltalk-based music tools. The intention is to support music composition, digital sound synthesis and processing, and live performance within a free, portable, high-level software tool kit. This paper will briefly introduce the Squeak system, and then discuss the design of Siren. An on-line demonstration of Siren running on a lap-top computer is planned for the presentation at ICMC. Both Squeak and Siren are available in source code free via Internet ftp from the site ftp://ftp.create.ucsb.edu/pub/Smalltalk/Squeak/.		Stephen Travis Pope	1997			embedded system;speech recognition;engineering;world wide web	PL	-31.15410394523567	27.97041475879012	161007
6709ad83e3f744aa8962562d164a761a4b5b43dc	what's in a name?		Feature interaction may arise in many different ways, but one of the core topics is the issue of name binding: When two or more entities are composed, say A and B, and they provide more than one declaration of the same name, say n, should the composed entity contain one subentity under that name n, or should it contain several? If one, how should it be selected or constructed? If several, how could a client choose the appropriate one amongst them? This paper surveys the treatment of various problems in this area in several programming languages, thereby establishing a framework for the discussion.	client (computing);compile time;compiler;declaration (computer programming);entity;feature interaction problem;name binding;programmer;programming languages;programming language	Erik Ernst	2001	JAMA	10.1001/jama.2014.11958		PL	-26.4852805700651	28.634357575789778	161117
3dd8d08739a44ecc387bc6752220bac06b5e9832	generic pickling and minimization	persistence;distributed programs;marshalling;garbage collection;serialization;distributed programming;graph minimization;pickling;data structure	This paper presents generic pickling and minimization mechanisms that are provided as services similar to garbage collection. Pickling is used to externalize and internalize data. Minimization means to maximize the sharing in arbitrary data structures. The paper introduces the notion of an abstract store as a formal basis for the algorithms, and analyzes design decisions for the implementation aspects of pickling and minimization. The mechanisms presented here are fully implemented in the Alice programming system.	admissible numbering;algorithm;data structure;garbage collection (computer science)	Guido Tack;Leif Kornstaedt;Gert Smolka	2006	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2005.11.041	persistence;data structure;serialization;computer science;marshalling;database;distributed computing;garbage collection;programming language	PL	-28.113772008878637	31.711363677251313	161637
34001d4af6ab3b07a785fdcfc3ae64cf2bb5807c	tatoo: an innovative parser generator	error recovery;bottom up;parser generator	This paper presents Tatoo, a new parser generator. This tool, written in Java 1.5, produces lexer and bottom-up parsers. Its design has been driven by three main concerns: the ability to use the parser with the non-blocking IO API; the possibility to simply deal with several language versions; a clean separation between the lexer definition, the parser definition and the semantics. Moreover, Tatoo integrates several other interesting features such as lookahead-based rule selection, pluggable error recovery mechanism, multiple character sets optimized support.	application programming interface;benchmark (computing);blocking (computing);bottom-up parsing;c++;character encoding;compiler;compiler-compiler;documentation;java bytecode;javadoc;lexical analysis;non-blocking algorithm;sablecc;usability;world wide web	Julien Cervelle;Rémi Forax;Gilles Roussel	2006		10.1145/1168054.1168057	natural language processing;parser combinator;compiler-compiler;lalr parser;canonical lr parser;lexical analysis;computer science;glr parser;top-down and bottom-up design;database;programming language;recursive descent parser;ll parser;lr parser;simple lr parser	PL	-27.159434031736172	27.465080997332375	162152
0839a75e8fccac2e88be6e9b88a477db5e7adc26	local++: a c++ framework for local search algorithms	neighborhood relations;debugging;combinatorial search problems;local search algorithm;object oriented modeling simulated annealing concrete search problems debugging scheduling algorithm;search space;abstract data types;combinatorial problems;object oriented framework;local;object oriented programming;simulated annealing;debugging phase;scheduling problems local object oriented framework c framework local search algorithms abstract template classes concrete class problem dependent part neighborhood relations architecture combinatorial search problems debugging phase development phase;scheduling algorithm;c language;problem dependent part;concrete class;development phase;scheduling;abstract template classes;local search algorithms;c framework;software tools;frameworks and patterns;search problems;program debugging;scheduling problems;software tools search problems c language object oriented programming abstract data types combinatorial mathematics program debugging scheduling simulated annealing;architecture;combinatorial mathematics;local search;object oriented modeling;applications;search algorithms;concrete	Local search is an emerging paradigm for combinatorial search which has been recently shown to be very e ective for a large number of combinatorial problems. It is based on the idea of navigating the search space by iteratively stepping from one solution to one of its neighbors, which are obtained by applying a simple local change to it. In this paper we present Local++, an object-oriented framework to be used as a general tool for the development and the implementation of local search algorithms in C++. The framework comprises a hierarchy of abstract template classes, one for each local search technique taken into account (i.e., hill-climbing, simulated annealing, and tabu search). Each class speci es and implements the invariant part of the algorithm built according to the technique, and is supposed to be specialized by a concrete class once a given search problem is considered, so as to implement the problem-dependent part of the algorithm. Local++ comprises also a set of abstract classes for creating new techniques by combining di erent search techniques and di erent neighborhood relations. The architecture of Local++ provides a principled modularization for the solution of combinatorial search problems, and helps the designer deriving a neat 1 conceptual scheme of the application, thus facilitating the development and debugging phases. Local++ proved to be exible enough for the implementation of the algorithms solving various scheduling problems.	c++;combinatorial search;debugging;hill climbing;local search (constraint satisfaction);local search (optimization);programming paradigm;scheduling (computing);search algorithm;search problem;simulated annealing;stepping level;tabu search	Andrea Schaerf;Maurizio Lenzerini;Marco Cadoli	1999		10.1109/TOOLS.1999.779008	real-time computing;computer science;local search;theoretical computer science;machine learning;iterated local search;policy-based design;guided local search	AI	-29.973944231519457	29.881674161085122	163733
4bda9283ecd6ec4208744ba2dee7de62bec432eb	the token-oriented approach to program editing				G. Brun;A. Businger;R. Schoenberger	1985	SIGPLAN Notices	10.1145/988304.988307	computer science;theoretical computer science;programming language;security token	PL	-28.860800074947473	26.344039975813978	163968
50ba37f9888f74699fa138f26c687b3ad23ce9cb	a template-based approach for the generation of abstractable and reducible models of featured networks	communication process;permutation group;interaccion de rasgo;group structure;specification;abstraction;service telecommunication;feature interaction;proceso comunicacion;qa75 electronic computers computer science;processus communication;symmetry reduction;interaction service;model checking;induction;inductive reasoning;especificacion;community structure;graphical representation;state space;addition;telecommunication services;groupe permutation;structure groupe;state space explosion;grupo permutacion;estructura grupo;adiccion	We investigate the relationship between symmetry reduction and inductive reasoning when applied to model checking networks of featured components. Popular reduction techniques for combatting state space explosion in model checking, like abstraction and symmetry reduction, can only be applied effectively when the natural symmetry of a system is not destroyed during specification. We introduce a property which ensures this is preserved, open symmetry. We describe a template-based approach for the construction of open symmetric Promela specifications of featured systems. For certain systems (safely featured parameterised systems) our generated specifications are suitable for conversion to abstract specifications representing any size of network. This enables feature interaction analysis to be carried out, via model checking and induction, for systems of any number of featured components. In addition, we show how, for any balanced network of components, by using a graphical representation of the features and the process communication structure, a group of permutations of the underlying state space of the generated specification can be determined easily. Due to the open symmetry of our Promela specifications, this group of permutations can be used directly for symmetry reduced model checking. The main contributions of this paper are an automatic method for developing open symmetric specifications which can be used for generic feature interaction analysis, and the novel application of symmetry detection and reduction in the context of model checking featured networks. We apply our techniques to a well known example of a featured network – an email system. 2006 Elsevier B.V. All rights reserved.	email;feature interaction problem;graphical user interface;inductive reasoning;mathematical induction;model checking;promela;state space	Alice Miller;Muffy Calder;Alastair F. Donaldson	2007	Computer Networks	10.1016/j.comnet.2006.08.009	model checking;telecommunications;computer science;state space;theoretical computer science;inductive reasoning;operating system;abstraction;permutation group;addition;computer security;specification;community structure;algorithm;statistics	AI	-32.291245057598815	30.12233356903484	164230
4214d28f43227e78e5d5bc8b8470bc7ccc1e0ab3	integttcn, a ttcn language extension for protocol integrated testing	protocols;formal languages;formal languages protocols conformance testing formal verification;system testing routing protocols computer science telecommunication services information processing standardization computer networks laboratories atherosclerosis internet;formal verification;conformance testing;formal description techniques integttcn ttcn language extension protocol integrated testing test data test behaviour dynamic data statistical data test components timer operations operational semantics input output transition system test suite notations conformance testing tree and tabular combined notation	This paper proposes an extension to TTCN to meet the requirements of protocol integrated testing. Compared with TTCN, the extension of IntegTTCN consists of test data and test behaviour. To test data, IntegTTCN can describe dynamic data and statistical data in addition to static data. To test behaviour, IntegTTCN extends test components, adds concurrent operation statements, and reinforces timer operations. After specifying the syntax of IntegTTCN, its operational semantics is defined in terms of an Input-Output Transition System. Finally, IntegTTCN is compared with other test suite notations.	dynamic data;operational semantics;requirement;test data;test suite;timer;transition system	Xia Yin;Yixin Zhao;Jianping Wu	2001		10.1109/ICC.2001.937022	communications protocol;formal language;model-based testing;formal verification;computer science;conformance testing;test suite;database;programming language;test management approach	SE	-32.42905077395903	31.775043086673822	164749
a780c81034405dbb5c2f6120a3250e8f92e190b0	type analysis of logic programs in the presence of type definitions	reconfiguration;multimedia;user interface management system;direct manipulation;distributed computing;multiple program specialization;graphical user interfaces;logic programming;optimization;logic programs;abstract interpretation;compile time analysis	This paper presents an abstract domain and an abstract unification function for type an al:ysis of logic programs with type definitions. Type information is inferred together with sharing and aliasing information. Aliasing information is used to improve the precision of type analysis.	aliasing;logic programming;unification (computer science)	Lunjin Lu	1995		10.1145/215465.215597	real-time computing;magic pushbutton;computer science;control reconfiguration;theoretical computer science;graphical user interface;programming language;prolog;logic programming	PL	-26.90742618287224	26.89444206451458	167041
3f0f5de7243a45813812f6a47524927b0e7d3e74	semantics-driven interoperability between scala.js and javascript	language interoperability;functional;object oriented	Hundreds of programming languages compile to JavaScript. Yet, most of them fail, at one level or another, to provide satisfactory interoperability with JavaScript APIs. This is limiting, as interoperability is at least required to manipulate web pages through the DOM API, but also to use the eco-system of existing JavaScript libraries. This paper presents the interoperability features of Scala.js, which solves the shortcomings of previous approaches. Scala.js offers a separate hierarchy of JavaScript types, whose operations have semantics borrowed from ECMAScript 2015. The interoperability features are complete with respect to ECMAScript 2015, save for two exceptions which are still being worked on. This allows Scala.js programs to perform any operation that an ECMAScript program could do, thereby guaranteeing that they can talk to any JavaScript library.	application programming interface;compiler;document object model;ecmascript;ecosystem;interoperability;javascript library;library (computing);programming language;scala;web page	Sébastien Doeraene;Tobias Schlatter;Nicolas Stucki	2016		10.1145/2998392.2998404	semantic interoperability;language interoperability;computer science;unobtrusive javascript;database;dynamic html;javascript;programming language;world wide web	PL	-27.32787216270907	28.025235328850815	167675
07676a524d920dfa2166adc8cb5f7590460e8bf6	implementation of an interpreter for a parallel language in centaur	non disponible sur le pdf;parallel languages	This paper presents the implementation of an interpreter for the parallel language Esterel in the Centaur system. The dynamic semantics of the language is described and completed with two modules providing a graphical visualization of the execution and a graphical execution controller. The problems of implementing a parallel language using natural semantics and of providing a visualization for a parallel language are especially addressed. 1. The Logical Kernel of the Interpreter Esterel [esterel] is a language involving parallelism and broadcast signal communication used for the description of reactive systems, i.e., systems that react to successions of events [reactive]. The command system for an airplane or the man-machine interface [gfxobj] for an interactive system like Centaur are two examples of such reactive systems. The interpreter described in this paper is based on a description of the dynamic semantics of Esterel written in natural semantics by the designers of the language [design]. We focus on the implementation of this dynamic semantics within Centaur [centaur], using the Typol formalism [typol]. We rst give a short description of the language and the constructs it contains. Then we give an overview of the semantics' organization. Finally, we concentrate on the key points of the semantics: the use of a rewriting system to express parallelism in the execution of an Esterel program. 1.1. The Esterel Language In [design], Berry and Gonthier give a schematic presentation of reactive systems. Such systems are composed of three layers: { An interface with the environment, in charge of receiving input and producing output. { A reactive kernel that contains the logic of the system. It decides the computations and outputs that must be generated in answer to inputs. { A data handling layer that performs classical computations requested by the logical kernel. Esterel is used to program the reactive kernel. It is not a fulledged programming language but rather a program generator used to produce a reactive system written in Ada, C, or Le Lisp 1 . The interface and data handling layer are speci ed in the host language. The data handling is integrated using abstract data type facilities. 1 Ada is a trademark of the U. S. DoD, Le Lisp is a trademark of INRIA. The basic data manipulated in Esterel are signals. they correspond to stimuli that can be emitted and listened in the di erent parallel processes. Signals can carry additional values. Their communication is conceptually instantaneous and broadcasted. The basic constructs are the following instructions: { emit S or emit S(exp): emit the signal S or emit the signal S with the value of exp. { present S then stat 1 else stat 2 end: execute stat 1 if S is present or stat 2 otherwise. { do stat watching S: execute stat until the signal S appears. { stat 1 ; stat 2 : execute stat 1 and stat 2 in sequence, i.e, execute stat 2 only when stat 1 is terminated. { stat 1 || stat 2 : execute stat 1 and stat 2 in parallel. { X := exp: assign the value of exp to the variable X. variables can be used in expressions as in any imperative language. They cannot be shared between parallel processes. The basic concepts of the language are the synchrony hypothesis, parallelism, and broadcast signal communication. The synchrony hypothesis is based on the assumption that each reaction to an input is conceptually instantaneous. The reception of an input event and the emission of the corresponding reaction take place at the same time and de ne an Esterel instant. The parallelism permits to enhance the modularity of the program. It gives an opportunity to design complicated reactive systems by breaking them down into simpler ones that communicate through broadcasted signals. When one of the processes wants to communicate a value, it only emits a signal. This signal is simultaneously received by whichever process is currently listening this channel. Every correct Esterel program describes a relation between an in nite sequence of input events and an in nite sequence of reactions, each event being a collection of present signals, optionally carrying values. This relation can also be easily represented by a deterministic nite state automaton, receiving an input event, changing its state, and emitting the reaction. Naturally, the transition of an automaton is instantaneous. This justi es the synchrony hypothesis. 2. Natural Semantics We use natural semantics to present the di erent aspects of a language in a uni ed manner. A natural semantics de nition is an unordered collection of rules. A rule has two parts, a numerator and a denominator. Variables may occur in the numerator and the denominator. These variables allow a rule to be instantiated. The numerator of a rule is again an unordered collection of formulae, the premises. The denominator is a single formula, the conclusion. Intuitively, if all premises hold, then the denominator holds. Formally, from proof-trees yielding the premises, we can derive a proof-tree yielding the conclusion. The formulae may have several form depending on the meaning they are given by the programmer. A very frequent form is the sequent form. A sequent has two parts, and antecedent (on the left) and a consequent (on the right), and we use the turnstile symbol ` to separate these parts. The consequent is a predicate. Predicates come in several forms indicated by various in x symbols. These in x symbols have no reserved meaning, they just help in memorizing what is being de ned. The antecedent usually contains information on results that are assumed, whereas the consequent represents the information that is being described. For example, the formula: ` exp : expresses that in the context (giving e.g. the types of identi ers) the expression exp has the type . Some structure is introduced in the collection of rules. To this end, rules may be grouped into sets, with a given name. Formulae that are provable by a speci c set of rules are usually denoted by placing the set's name on top of the turnstile (`), as in the following example:	abstract data type;ada;automaton;computation;exptime;esterel;graphical user interface;imperative programming;interactivity;le lisp;loadable kernel module;natural language;operational semantics;parallel computing;parallel language;programmer;programming language;provable security;rewriting;schematic;semantics (computer science);turnstile	Yves Bertot	1990		10.1007/3-540-52592-0_55	computer architecture;parallel computing;computer science;programming language	PL	-26.780763724602796	31.683582703741482	168619
c2636cf2380606bb1acc28be116298206bbadc11	efficient, compiler-agnostic and platform-independent labeling of functions in executable programs			compiler;executable	Sebastian Eschweiler	2017				PL	-30.006851631810658	27.279872301784106	168976
a61e1aec8b01195d5787dd96cea6acb350314de5	"""""""what programmers do with inheritance in java"""" - replicated on source code"""		1 3 1 4 1 6 1 7 2 0 2 0 2 0 2 1 2 2 2 5 2 7 3 6 3 7 3 9 4 0 4 9 5 5 6 0 6 0 6 1 6 5 7 1 7 6 9 2 9 4 1 0 1 1 0 3 1 0 5 1 0 7 1 0 8 1 1 4 1 1 5 1 2 2 1 3 3 1 3 7 1 4 9 1 5 4 1 5 6 1 6 1 1 6 4 1 7 1 1 7 8 1 8 5 1 9 1 2 0 5 2 1 1 2 1 7 2 2 0 2 2 6 2 3 0 2 3 1 2 5 7 2 8 6 2 9 2 3 0 5 3 1 0 3 1 3 3 3 9 3 4 8 3 6 4 3 7 7 4 3 4 4 5 3 4 5 9 4 6 0 4 7 4 4 9 5 4 9 8 5 2 8 6 3 6 6 3 7 6 4 4 7 1 2 7 5 5 7 6 1 8 0 6 8 1 1 8 6 8 9 8 2	java;programmer	Çigdem Aytekin	2014				ML	-29.6437499696448	28.22724750648883	169680
12f20f3dc474dd49e5936e3956e480a119c1c51a	modeling erlang in the pi-calculus	functional programming languages;formal model;pi calculus;mobile systems;process algebra;functional programming language	This paper provides a contribution to the formal modeling and verification of programs written in the concurrent functional programming language Erlang, which is designed for telecommunication applications. It presents a mapping of Core Erlang programs into the π--calculus, a process algebra whose name--passing feature allows to represent the mobile aspects of Erlang software in a natural way.	erlang (programming language);functional programming;process calculus;programming language;π-calculus	Thomas Noll;Chanchal Kumar Roy	2005		10.1145/1088361.1088375	erlang;higher-order programming;process calculus;declarative programming;π-calculus;elixir;computer science;theoretical computer science;programming language;functional programming;join-pattern;algorithm	PL	-32.58562749517082	31.955003541159392	170092
b7de711e1228012098f9422bf9948a36fa3022ef	practical aspects of bidirectional graph transformations	bidirectional graph transformation	Bidirectional transformation consists of a pair of transformations, describing not only a forward transformation from a source to a view, but also a backward transformation showing how to reflect the changes in the view to the source. Bidirectional transformation provides a novel mechanism for synchronizing and maintaining the consistency of information between input and output, and has many potential applications in software development, including model synchronization, round-trip engineering, software evolution, multiple-view software development, reverse software engineering, as well as the well-known view updating mechanism which has been intensively studied in the database community for decades.  To support systematical development of well-behaved bidirectional transformations, much research has been devoted to design of bidirectional languages that can be interpreted both forwardly and backwardly while guaranteeing the roundtrip property between the forward and the backward transformations. Despite many promising results, most of them are limited to lists and trees. In fact, there are challenges in designing a language for bidirectional transformation on graphs. First, unlike lists and trees, there is no unique way to represent, construct, and decompose a general graph, which requires more precise definition of equivalence between two graphs. Second, graphs have sharing nodes and cycles, which makes forward computation much more complicated than that on trees (let alone to say about backward computation), where naive computation on graphs would visit the same nodes many times and possibly infinitely often.  We have challenged the problem of bidirectional transformations on graphs, and succeeded in bidirectionalizing graph queries (in UnQL) and implementing a bidirectional graph transformation engine called GRoundTram. In GRoundTram, graphs are treated as regular trees and manipulated by structural recursion that enjoys a nice bulk and bidirectional semantics. Although GRoundTram has been successfully applied to nontrivial model-code co-evolution, there are still many practical issues that should be addressed to make it be more useful.  In this talk, I shall briefly explain our solution to the problem of bidirectional graph transformation and demonstrate some applications in bidirectional model-driven software development, and focus on discussing practical issues in manipulating various graphs (such as unordered, ordered, and probability graphs), determining backward transformation, and improving efficiency and scalability.	bidirectional search;bidirectional transformation;computation;graph rewriting;input/output;model-driven architecture;model-driven engineering;recursion;reverse engineering;round-trip engineering;scalability;software development;software engineering;software evolution;structural induction;turing completeness;whole earth 'lectronic link	Zhenjiang Hu	2013		10.1145/2426890.2426892	computer science;theoretical computer science;algorithm	PL	-32.67921758502942	28.86032169377803	171860
308a15815c6d03634d12cc72754715b6b65d06d9	modeling class loaders in java pathfinder version 7	verification;distributed system;canonical order;model checking	The class loading mechanism is one of the essential components of the Java runtime environment. Java class loading is performed on-demand, allows multiple, user extensible class loaders, and can associate a separate type namespace with each class loader. Previous versions of the Java Pathfinder (JPF) model checker only provided a single, hardcoded class loading mechanism. As one of the cornerstones of the upcoming JPF version 7 (JPF v7), we have implemented a standard Java conforming class loader infrastructure. Our implementation does not only support different class loaders and type namespaces, but also allows explicit instantiation of multiple bootstrap class loaders which is essential for model checking of distributed applications - the primary motivation for our work. With the new class loading mechanism, such applications can be mapped to threads using different bootstrap class loaders, thus effectively separating all static fields between application threads. In addition, the JPF v7 class loading is considered to be the basis for future verification of Java security properties.	distributed computing;hard coding;java classloader;java pathfinder;java virtual machine;model checking;runtime system;universal instantiation;version 7 unix	Nastaran Shafiei;Peter C. Mehlitz	2012	ACM SIGSOFT Software Engineering Notes	10.1145/2382756.2382800	model checking;real-time computing;verification;computer science;distributed computing;programming language;java annotation	PL	-26.89288969726367	29.641981959820317	172789
8d54922946544742600a1255011c4d7febaec959	an automatic and optimized test generation technique applying to tcp/ip protocol	optimized test generation technique;protocols;sdl language;formal specification;circuit faults;automatic test generation technique;switching circuits;optimization technique;client layer part;automatic testing;tcp ip protocol;tcpip;automatic testing tcpip protocols circuit testing system testing circuit faults automata communication system control specification languages switching circuits;communication protocol data portion;transport protocols;algorithm;automata;conformance testing;program testing;specification languages;automatic test software;optimization techniques;tcp reno;system testing;test generation;communication protocol;fault coverage;circuit testing;communication system control;guaranteed coverage;communication protocol control;formal specification transport protocols program testing automatic test software;communication protocol data portion automatic test generation technique optimized test generation technique tcp ip protocol communication protocol control guaranteed coverage client layer part tcp reno sdl language algorithm	In this paper an automatic and optimized technique for test generation for communication protocol control and data portion is described; the goal is to minimize the number of tests with a guaranteed coverage. The test generation algorithm is applied to the Client Layer part of the TCP/IP protocol. The protocol used for the experiment is TCP-Reno, which is specified in the SDL language and is one of the commonly referenced implementations. For such a sophisticated protocol, the algorithm efficiently constructs22 tests that cover all the required portions of the protocol.	algorithm;communications protocol;fault coverage;internet protocol suite;mathematical optimization;reachability;simple directmedia layer;whole earth 'lectronic link	Cédric Besse;Ana R. Cavalli;David Lee	1999		10.1109/ASE.1999.802094	reverse address resolution protocol;communications protocol;bootstrap protocol;real-time computing;user datagram protocol;internet protocol control protocol;computer science;transmission control protocol;tunneling protocol;distributed computing;serial line internet protocol;port control protocol;virtual router redundancy protocol;osi model;computer network;internetwork protocol	Embedded	-31.97825070434779	31.998306445519844	173040
9cf9ced8abeaf3801ec152da7acfdbec1f3cbf35	translating chemical scripting languages to unified job-description language on chemical-grid	chemical scripting language;chemical engineering computing;grid services chemical scripting language translation unified job description language chemical grid domain specific language full function chemical jobs csl runtime platform middleware udlc jobs;language translation;authoring languages;udlc;udlc antlr chemical scripting language grid computing language translation;specification languages;middleware;antlr;grammar java syntactics semantics chemistry software generators;grid computing;specification languages authoring languages chemical engineering computing grid computing language translation middleware	Unified Job-Description Language on Chemical-Grid (UDLC) is a domain-specific language designed to write full-function chemical jobs on Chemical-Grid quickly by providing a common language. It frees chemists to focus on problem-solving rather than on the details of various chemical scripting languages (CSLs) and the target runtime platform and associated middleware. UDLC jobs can directly invoke grid services without dealing with interaction with grid, such as job submission, job monitoring. Thus, it is interesting and meaningful for chemists to translate scripts in other CSLs to UDLC. The system architecture of the translators is presented, translation strategies and several key issues are discussed, and two specific translators are described in detail. The translators translating the scripts, especially a large number of well-tested scripts, to UDLC can help chemists carry out their research based on grid platforms.	amiga walker;computational chemistry;domain-specific language;finite-state machine;goto;middleware;problem solving;prototype;rewriting;scripting language;systems architecture;tree structure	Min Zhang;Ruisheng Zhang;Jiajun Xie;Shuping Li;Rongjing Hu;Jingfei Hou;Shuyi Zhang	2012	2012 Seventh ChinaGrid Annual Conference	10.1109/ChinaGrid.2012.30	natural language processing;computer science;domain-specific language;database;scripting language;programming language	HPC	-32.00355379087845	26.690985658741656	173527
1bb7c09fefae7c88e45e134e5c667a440b852e59	the iwim model for coordination of concurrent activities	programming model	Exploiting the full potential of massively parallel systems requires programming models that explicitly deal with the concurrency of cooperation among very large numbers of active entities that comprise a single application. In practice, the concurrent applications of today essentially use a set of ad hoc templates to coordinate the cooperation of their active components. This shows the lack of proper coordination languages that can be used to explicitly describe complex cooperation protocols in terms of simple primitives and structuring constructs. In this paper we present a generic model of communication and describe a speciic control-oriented coordination language based on this model. The important characteristics of this model include compositionality, which it inherits from the data-ow model, anonymous communication, and separation of computation concerns from communication concerns. These characteristics lead to clear advantages in large concurrent applications.	computation;concurrency (computer science);entity;hoc (programming language);language primitive	Farhad Arbab	1996		10.1007/3-540-61052-9_38	computer science;programming paradigm;programming language	SE	-29.94854492042934	31.99206893855375	173955
1712f1429433746228d01f5194cb1988af980930	extensions of grapes/4gl for windows style input/output	input output		input/output;microsoft windows	Audris Kalnins	1994			data mining;simulation;computer science;input/output;theoretical computer science	DB	-29.985353412347873	27.204541588512146	174210
cc4abcfba6c3945735b7a35325706d55175dcdff	using an apl approach with java	new apl class;java programming;apl approach;linux paradigm;new java class;appropriate apl primitive function;java example;apl primitive function;key part;conceptual intricacy	Three Java examples are developed to advance an APL approach in reducing conceptual intricacies in Java programming. The key part of these examples is a new Java class named APL. By making an instance of this class, a programmer is in a position to call appropriate APL primitive functions and operators to process data. In other words, a programmer is able to think in terms of arrays while programming in Java. All sample code is written in Java. The goal is to eventually implement all APL primitive functions and operators in this new APL class following the Linux paradigm of contributions from many authors.	apl;adobe streamline;java;linux;programmer;programming language;programming paradigm;software development process	Joseph Burchfield;Samir Lipovaca	2002		10.1145/602231.602239	java api for xml-based rpc;parallel computing;jsr 94;java concurrency;computer science;operating system;java modeling language;interface;strictfp;real time java;programming language;java;generics in java;scala;java applet;java annotation	PL	-28.57141191977585	27.115898905374394	174217
9e9475c02f4658509696ed95db7d8a640ae3fda4	l: context-oriented programming with only layers	context oriented programming;modularity;sideways composition;software composition;layers	Most if not all extensions to object-oriented languages that allow for context-oriented programming (COP) are asymmetric in the sense that they assume a base implementation of a system to be composed into classes and a set of layers to provide behavioral variations applied to those classes at run-time. We propose L as an experimental language to further explore the design space for COP languages. In this position paper we talk about first steps towards the unification of classes and layers and with that the removal of the asymmetry in composition mechanisms of contemporary COP implementations.	unification (computer science)	Robert Hirschfeld;Hidehiko Masuhara;Atsushi Igarashi	2013		10.1145/2489793.2489797	computer science;programming language;engineering drawing;algorithm	PL	-27.247791611113605	29.437290625237615	174536
ed4f3b654599a3e53e4f65f182b5da0f9941c8e6	lispview: leverage through integration	rapid prototyping;object oriented;graphic user interface;common lisp	Although Lisp was the host for many of the first graphical user interface (GUI) packages, popular activity in this area has shifted to more primitive but widely used languages such as C and C++. One explanation for this shift is that while Lisp's strength in rapid prototyping and development led to the initial progress, it also tended to inspire an imperialist attitude: applications were often crafted exclusively in Lisp, even when part of the application could make use of an existing conventional language library. We believe the ideal way to construct a CommonLisp GUI package today is to integrate proven C libraries with an object-oriented Lisp framework.	c++;graphical user interface;library (computing);lisp;rapid prototyping	Hans Muller	1991	Commun. ACM	10.1145/114669.126333	read–eval–print loop;computer science;operating system;graphical user interface;programming language;object-oriented programming;preprocessor;algorithm	PL	-28.68776657369715	27.16482284208818	174794
67f37b71004ace4bf47463526c6f8ab7307bdbfd	rapid prototyping of specification language implementations	prototypes specification languages logic concurrent computing electrical capacitance tomography system testing process design instruments application software software engineering;distributed system;programming language semantics;software prototyping;compiler generators;distributed systems rapid prototyping specification language implementations distributed systems design formal syntax semantics compiler generator verification tools rewriting logic formalism concurrency system specification parsing labelled transition system meta prototyping specification formalism testing;specification language;automatic generation;rapid prototyping;formal verification;design and implementation;rewriting systems;specification languages;rewriting logic;transition systems;programming language semantics specification languages software prototyping compiler generators formal verification rewriting systems concurrency theory;concurrency theory	Specification languages such as LOTOS and SDL play an important rôle in the design and implementation of distributed systems. Their formal syntax and semantics supports the development of compilers and of verification tools. This paper introduces a generic and uniform approach to support such languages in verification tools. We present a compiler generator which, given the description of a specification language, automatically generates a corresponding implementation. More specifically, the syntax and semantics of the specification language has to be defined using Meseguer’s Rewriting Logic formalism, a unified semantic framework for concurrency. From this description a compiler is derived which parses a given system specification and computes the corresponding semantic object, such as a labelled transition system. The latter can be processed further in subsequent analysis and verifica-	compiler;compiler-compiler;concurrency (computer science);distributed computing;elan;erlang (programming language);formal grammar;haskell;language of temporal ordering specification;modulo operation;operational semantics;parsing;process calculus;programming language;prototype;rapid prototyping;rewrite (programming);rewriting;semantics (computer science);simple directmedia layer;specification language;state space;transition system	Martin Leucker;Thomas Noll	1999		10.1109/IWRSP.1999.779032	computer architecture;formal methods;specification language;formal verification;rewriting;computer science;theoretical computer science;formal specification;programming language;programming language specification;language of temporal ordering specification	PL	-33.2656672519666	32.000472419686844	175497
eec49e931d41ea3902bbd54f96622cc4c7b8c7de	how to create a web service with .net		"""You hear all about Web Services but do you know how to create one? In this simple """"How To"""" paper, we will try to demonstrate how to write and deploy a simple Web Service using Microsoft’s .NET environment with Visual Basic attend this session, and go back home very dangerous! 1. What is a Web Service? Simply stated, a Web Service offers a method (or methods) that can be invoked using open standards (including HTTP and XML) for communication. For those readers who are not up to speed on object-oriented programming, a method is just a function or procedure that is associated with an object. In other words, when a method is invoked, it simply executes an action of some kind. Web services are interesting because they offer a way to create programs that are platform-independent. These programs are accessed over the Web independent of the tools used to create them and the operating system they run on. Another characteristic of a Web service is that it must supply discovery information about itself. This means that you can query a Web service and have it tell you the names of the methods it provides, the arguments accepted by each method, and the return values for the methods. In other words, you don’t have to know very much about a Web service other that it exists to be able to use it in your programs. The driving force is that Web services are to provide components that can communicate with each other regardless of the language they were written in, and regardless of the operating system on which they run. Web services make their methods available for use or consumption, by other programs. To consume a Web service, a program makes a request running over HTTP to use the methods available via HTTP GET and HTTP POST – or more commonly – Simple Object Access Protocol (SOAP). Microsoft’s .NET environment insulates the Web service developer from the coding details of SOAP. With respect to the universal discovery mechanism provided by Web services, .NET automatically creates a Web Services Discovery Language (WSDL) document, which other applications (or people!) can read to understand how to use the Web service. Again, .NET insulates the developer from the details of creating the WSDL document, so it is important to know that it exists. Web services also make use of Universal Description, Discovery, and Integration (UDDI). UDDI is a kind of Yellow Pages for Web services, and you need to use UDDI to find a Web service, or if you want to make sure that your Web service can be found."""	hypertext transfer protocol;operating system;post (http);soap;visual basic;web services description language;web services discovery;web service;world wide web;xml	Bernard Domanski	2003			web api;world wide web;web standards;web development;web page;web service;data web;web navigation;web application security;computer science	Web+IR	-31.309672725164276	26.079798347360054	176423
1ff800d112eec4633a65f441e5e99fdb11b5d621	safely creating correct subclasses without seeing superclass code		A major problem for object-oriented frameworks and class libraries is how to provide enough information about an extensible superclass so that programmers can safely create new subclasses without studying superclass code. The goal of my work is to determine what information is needed so library providers do not have to give away the code of library superclasses. A closely related goal is to provide guidelines that simplify reasoning about classes that inherit from such frameworks and class libraries. The long-term goal of my research is to develop tool support to automatically generate some of the necessary documentation and to assist programmers in reasoning about how to create correct subclasses.	documentation;library (computing);programmer	Clyde Ruby	2000		10.1145/367845.368062	computer science;element;database;programming language;algorithm	PL	-27.506022721167778	26.624528241319574	177446
a46cd9efe2145ff9a644d5bdc3f58afe604c6bc1	communication mechanism independent protocol specification based on csp: a case study	alternating bit protocol;protocols;formal specification;communicating sequential process;specification;formal specifications;communication mechanism;telephony;computer network;wire;asynchronous communication mechanisms;transport protocols;computer aided software engineering;communicating sequential processes;abstract synchronous communication mechanism;specification languages;asynchronous communication;carbon capture and storage;safety;sun;protocols computer aided software engineering computer science carbon capture and storage wire formal specifications sun specification languages safety telephony;protocol specification;alternating bit protocol communication mechanism independent protocol specification abstract synchronous communication mechanism asynchronous communication mechanisms communicating sequential processes specification computer network protocols communication mechanism;computer science;synchronous communication;computer network protocols;communication mechanism independent protocol specification	When specifying and designing computer network protocols, it is convenient to use an abstract synchronous communication mechanism. In practice, however, asynchronous communication mechanisms cannot be avoided. This paper presents a formal approach, based on Hoare’s Communicating Sequential Processes (CSP) [9, 101 and some other theoretical results on the specification and design of protocols which ensure the correctness of the protocols regardless of the communication mechanism used in implementation. The Alternating Bit (AB) protocol is used to illustrate our results.	communicating sequential processes;communications protocol;correctness (computer science);hoare logic;nx bit	Yong Sun;Hongji Yang	1996		10.1109/EURMIC.1996.546395	universal composability;real-time computing;computer science;theoretical computer science;distributed computing	Embedded	-32.75082037250478	31.82770145374437	178487
e6b457a2cb2d2cb63cc7e6337064c90ee658863c	design and implementation of a web portal for a neocortical simulator.	network simulator;ease of use;large scale;design and implementation;web portal	Over the last several years of research, we have developed a large-scale biologically realistic neocortical neural network simulator. The simulator's eeective-ness as a research tool has been limited due to accessibility and ease of use. The web portal for the neocortical simulator provides online access from anywhere in the world at any time. Its GUI interface allows users to build and simulate networks in a very short period of time. This portal was built using PHP, Mysql, and a back-end running Apache on a Red Hat Linux machine.	accessibility;artificial neural network;earthbound;graphical user interface;linux;mysql;neural network software;php;simulation;usability;world wide web	Kishor K. Waikul;Lianjun Jiang;E. Courtenay Wilson;Frederick C. Harris;Philip H. Goodman	2002			usability;human–computer interaction;computer science;database;network simulation;world wide web	OS	-32.6623543577137	27.765214914338987	180811
6eea0b31013e6c7fee3408e142cb7fbf4e6eacdd	writing systems software in a functional language: an experience report	explicit memory;programming language;experience report;operating system;functional language;data structure;device driver	Current practices for developing systems software usually rely on fairly low-level programming languages and tools. As an alternative, our group has been investigating the possibility of using a high-level functional language, Haskell, for kernel and device driver construction, with the hope that it will allow us to produce more reliable and secure software. In this paper, we describe our experience developing a prototype operating system, House, in which the kernel, device drivers, and even a simple GUI, are all written in Haskell. The House system demonstrates that it is indeed possible to construct systems software in a functional language. However, it also suggests some ideas for a new Haskell dialect with features that target specific needs in this domain, including strongly typed support for low-level data structures and facilities for explicit memory accounting.	data structure;device driver;functional programming;graphical user interface;haskell;high- and low-level;kernel (operating system);low-level programming language;operating system;prototype	Iavor S. Diatchki;Thomas Hallgren;Mark P. Jones;Rebekah Leslie;Andrew Tolmach	2007		10.1145/1376789.1376791	computer science;software development;database;programming language	PL	-28.425000630446217	28.64962886713323	180879
25e2d5bf09d25f463f17aed663d4692f583d4b2f	directing javascript with arrows	arrows;developpement logiciel;site web;lenguaje programacion;sequencage;red www;programming language;programmation modulaire;gestion evenement;branching;reseau web;state machine;programacion modular;sistema reactivo;sequencing;web programming;internet;desarrollo logicial;ramificacion;events;event management;software development;reactive system;langage programmation;systeme reactif;ramification;modular programming;world wide web;design;sitio web;gestion aconticimiento;javascript;drag and drop;arrowlets;languages;web site	JavaScript programmers make extensive use of event-driven programming to help build responsive web applications. However, standard approaches to sequencing events are messy, and often lead to code that is difficult to understand and maintain. We have found that arrows, a generalization of monads, are an elegant solution to this problem. Arrows allow us to easily write asynchronous programs in small, modular units of code, and flexibly compose them in many different ways, while nicely abstracting the details of asynchronous program composition. In this paper, we present Arrowlets, a new JavaScript library that offers arrows to the everyday JavaScript programmer. We show how to use Arrowlets to construct a variety of state machines, including state machines that branch and loop. We also demonstrate how Arrowlets separate computation from composition with examples such as a drag-and-drop handler and a bubblesort animation.	bubble sort;computation;drag and drop;event-driven programming;javascript library;monad (functional programming);programmer;web application	Yit Phang Khoo;Michael Hicks;Jeffrey S. Foster;Vibha Sazawal	2009		10.1145/1640134.1640143	design;branching;reactive system;computer science;software development;operating system;modular programming;sequencing;ramification;finite-state machine;javascript;programming language;world wide web	PL	-26.495853226186526	27.146949200484066	182193
f1d5c6221de45c0241434605dd7e2c78bd1374b8	2nd workshop on free composition (freeco)	open composition mechanisms;decomposition;programming language;composition;free composition;design languages;programming languages	The history of programming languages shows a continuous search for new composition mechanisms, which are better suited for structuring increasingly complex software systems into modules that can be developed and reused independently. Well-known examples are procedure calls, object aggregation, function composition, inheritance, delegation, mix-ins, aspects, andsoforth. Composition mechanisms can address various forms of composition of objects or components at the level of their behavior or interactions, e.g., by design patterns, contracts or explicit protocols. They can be general-purpose, but there is also a wide variety of domain-specific compositions, which are applicable for certain categories of applications. However, most languages adopt a very small and fixed set of composition mechanisms, usually with explicit notation and predefined semantics. If a language does not provide any mechanisms with the required compositional behavior, programmers need to write workarounds in the application program, which typically have a negative impact on the quality of the software. Alternatively they may introduce the new composition mechanisms through macros, libraries, frameworks or language extensions, which also negatively affects the application if it is not well-integrated with the application program. In this workshop we want to investigate composition techniques that are “free” in the sense that they are not fixed and limited by specific language or system designs. Instead we intend to explore the notion that languages should not offer a limited set of fixed composition mechanisms, but allow for flexibility, a wide variety of compositions, domain-specific and tailored compositions, or programmable compositions of various program artifacts. Examples of topics targeted by this workshop include, but are not limited to:	design pattern;general-purpose markup language;history of programming languages;interaction;library (computing);object composition;programmer;programming language;software framework;software system;workaround	Christoph Bockisch;Lodewijk Bergmans;Dean Wampler	2011		10.1145/2048237.2048257	natural language processing;computer science;functional logic programming;database;fifth-generation programming language;programming language;second-generation programming language;comparison of multi-paradigm programming languages	PL	-27.607522554193483	28.64705926536357	182315
7bb5b87b8613456c151cad241ca3ffeea31446f7	the unix system and software reusability	libraries;software;systeme unix;computer languages;programming language;software libraries;pipe;building block;probability density function;filters;program library;data mining;software engineering;functional programming;i o redirection;program generation;generator;operating system;filter;software reusability;scholarships;dictionaries;bibliotheque programme;genie logiciel;filtre;writing;unix filter generator library i o redirection pipe;algorithms;systeme exploitation;reutilisabilite;source code;software reusability software libraries operating systems writing functional programming filters algorithms scholarships dictionaries computer languages;integrated circuits;library;unix;operating systems	The Unix system contains a variety of facilities that enhance the reuse of software. These vary from the utterly conventional, such as function libraries, to basic architectural mechanisms, such as the Unix pipe. The Unix pipe, which makes whole programs building blocks of larger computational structures, has been the primary reason for the development of a literature of useful, but specialized programs-programs that would be too costly to write in a conventional programming language such as C. It has led to high levels of program reuse both by the nature of its operation and through its effect on programming conventions (e.g., programs structured as simple filters). Another facility enhancing reuse on Unix is the on-line C source code for Unix system programs. This has led to a shared style of programming in which existing programs are used as models for new programs, allowing the reuse of ideas, algorithms and source code. Finally, the Unix system contains many other reuse enhancing facilities, such as generic facilities for screen management (curses and termcap) and program generators (lex and yacc).	algorithm;computation;curses (programming library);lex (software);library (computing);online and offline;pipeline (unix);programming language;termcap;unix;yacc	Brian W. Kernighan	1984	IEEE Transactions on Software Engineering	10.1109/TSE.1984.5010275	unix architecture;probability density function;library;filter;computer science;operating system;software engineering;pipe;unix;programming language;functional programming;writing;tmpdir;electric generator;computer engineering;source code	SE	-28.719380396304455	26.413334658670575	182400
b69500327baa6cd4070e1daf1cde300fea702694	coordination models and languages	theoretical computer science;operational semantics;formal methods;computer science all;internet of things;behavioural semantics	We review work over the last thirty years on simple, formal models capturing the essence of (realistic) views of distributed coordination. We trace a path through work on concurrent constraint programming, its linear version, connections with the asynchronous pi-calculus, and, more recently, through the imperative resilient X10. As always, the virtue of clean and powerful abstractions is that they can ease design of real systems that address tricky technical concerns. We illustrate with the calculus for resilient X10, designing which forced us to a semantic principle, Happens Before Invariance, which is useful in practice.	concurrent constraint logic programming;constraint programming;imperative programming;x10;π-calculus	Josef Kittler;John C. Mitchell;Moni Naor	2016		10.1007/978-3-319-39519-7	formal methods;web of things;formal semantics;action semantics;computer science;theoretical computer science;formal semantics;database;programming language;operational semantics;internet of things;denotational semantics	PL	-32.571354540052255	29.03240576742485	182913
21d6d95ed64f97ae31334f3f7a86e4e57107c764	a system for example-based programming	programming environment;software reuse	We present an approach to programming environments that integrates syntax-directed editors with concepts borrowed from software reuse. We call our approach example-based programming, and we define it as programming using examples as visual aids or to fully or partially copy into programs. To implement an example-based programming environment, we augmented a syntax-directed editor with a window for example programs. The example programs, which are easily accessible, can be used as examples of language constructs, thus providing syntactic information through instantiations of templates, or as examples of algorithms or programs. The code in the example window can be viewed, totally or partially copied, or run. We discuss the motivation for example-based programming, describe our system implementing example-based programming in greater depth, and report on the results of an experiment to see how the system is used by programmers.	algorithm;code reuse;integrated development environment;programmer;structure editor	Lisa Rubin Neal	1989		10.1145/67449.67464	intentional programming;first-generation programming language;constraint programming;protocol;real-time computing;declarative programming;n-version programming;programming domain;reactive programming;functional reactive programming;computer science;theoretical computer science;extensible programming;operating system;functional logic programming;computer programming;programming paradigm;procedural programming;symbolic programming;inductive programming;visual programming language;programming language;system programming;concurrent object-oriented programming;copy and paste programming	PL	-26.418449112749087	26.598352881396043	183529
6bb9a71e06bfceb9b608f74b257b3887ce5daede	migrating legacy engineering applications to java	object oriented programming;portability;object oriented;lessons learned;surface model;legacy;graphic user interface;source code;fortran;c;conversion;java	The Boeing Company, like many other engineering-centric companies, has a large base of legacy applications written in FORTRAN and C. In today's computing environment, maintaining and evolving these applications is becoming difficult. One such Boeing application, the Aero Grid and Paneling System (AGPS), is a 3D-geometry surface modeling tool. In the fall of 2001 we completed the migration of the AGPS source code from 300,000 lines of mixed C and FORTRAN to 150,000 lines of 100% Java. The migration resulted in many benefits; some anticipated and some unexpected. The benefits include widespread portability of AGPS on engineering workstations and PC-class machines, allowing AGPS to embrace many modern programming capabilities readily available in Java, greatly improving the maintainability and enhanceability of the AGPS source code, and an increased robustness of the AGPS code. During the migration we also took the opportunity to rearchitect major areas of the code using object-oriented techniques, to modernize the graphical user interface, and to implement a significant number of pending enhancements from our backlog.This paper looks into the details of the AGPS migration to Java, discussing our observations, lessons learned, migration techniques, and what we see in the future computing environment. Data are presented and discussed to substantiate our conclusions that Java is well-suited for compute-intensive engineering applications, Java portability is a reality, Java performance is no longer a problem, and that embracing object-oriented programming techniques produces a much superior product with less effort.	fortran;graphical user interface;java performance;programming language;windows aero;workstation	Tom Dickens	2002		10.1145/604251.604260	real-time computing;computer science;strictfp;real time java;programming language;object-oriented programming;java;java annotation	PL	-31.23492364618947	28.554632658738296	183778
ee205a8411cdc0b45dfa569ce31bd6a713cbf85a	static analysis of xml programs	static analysis		static program analysis;xml	Pierre Genevès;Nabil Layaïda	2008	ERCIM News		xml;programming language;database;static analysis;computer science	SE	-29.728486515200466	27.713281151892236	184159
b5964d2c83b6ac650cf7cd359361ec51d3d979b9	dynamic simulations in sixtrack		The DYNK module allows element settings in SixTrack to be changed on a turn-by-turn basis. This document contains a technical description of the DYNK module in SixTrack. It is mainly intended for a developer or advanced user who wants to modify the DYNK module, for example by adding more functions that can be used to calculate new element settings, or to add support for new elements that can be used with DYNK.	application checkpointing;cache (computing);duplicate code;microsoft outlook for mac;simulation;subroutine	K. Sjobak;V. K. Berglyd Olsen;R. De Maria;M. Fitterer;A. Santamaría García;H. Garcia-Morales;A. Mereghetti;J. F. Wagner;S. J. Wretborn	2018	CoRR		computational physics;physics;optics	Security	-31.010247437906248	29.171138014882025	184759
7728ab86317cd4ba9e426f3f427c3f8572710715	efficient language implementation with alia4j and emftext: forum demonstration	advanced dispatching;language implementation;modular optimization	Developing extensions to general-purpose langauges or domain-specific languages with support for new kinds of abstractions is an ongoing trend. Modern language workbenches, such as EMFText of Xtext, support this trend and facilitate implementing langauges in terms of transformations from the new language into an established (intermediate) language. Often, however, the implementation of one element in the source language becomes scattered and tangled in the target language, which makes transformations complex. Furthermore, even though many languages share core concepts, current approaches do not support sharing transformations that implement their semantics; the only possibility of re-using transformations from a language is to extend it syntactically. We have identified dispatching as fundamental to most abstraction mechanisms. With the ALIA4J approach, we provide a meta-model of dispatching to act as rich and extensible intermediate language that allows more direct transformation. The semantics of core language concepts can be modularly implemented as extension of the meta-model. For the execution of the intermediate language, we provide both platform-independent and platform-dependent Java Virtual Machine extensions, the latter of which even allows the modular implementation of machine code optimizations.  In this demo, participants get an overview of advanced dispatching and the ALIA4J approach. By the example of a language for text-based adventure games, they will see the usage of ALIA4J as back-end for a language developed in EMFText. Finally, the implementation of new atomic language concepts and their optimization is demonstrated.	compiler;domain-specific language;eclipse xtext;general-purpose markup language;java virtual machine;machine code;mathematical optimization;metamodeling;metaobject;modular programming;text-based (computing);x86 virtualization	Christoph Bockisch;Andreas Sewe	2013		10.1145/2457392.2457398	natural language processing;first-generation programming language;very high-level programming language;universal networking language;language primitive;object language;specification language;data control language;computer science;programming language implementation;theoretical computer science;common intermediate language;compiled language;low-level programming language;modeling language;programming language;language technology;high-level programming language	PL	-27.96440230395596	28.62499220739338	185134
d8568f0b53f4b736e042c0b3a525446ebb17e2a2	from global choreography to efficient distributed implementation		We define a methodology to automatically synthesize efficient distributed implementation starting from highlevel global choreography. A global choreography describes the communication logic between the interfaces of a set of predefined processes. The operations provided by the choreography (e.g., multiparty, choice, loop, branching) are master-triggered and conflict-free by construction (no conflict parallel interleaving), which permits the generation of fully distributed implementations (i.e., no need for controllers). We apply our methodology by automatically synthesizing micro-services architectures.	forward error correction;microservices	Rayan Hallal;Mohamad Jaber;Rasha Abdallah	2018	2018 International Conference on High Performance Computing & Simulation (HPCS)	10.1109/HPCS.2018.00122		HPC	-32.68664258296191	32.27462586573811	185834
2c15facd84bec02b274da83acaf5abf6e88580a1	reflections on metaprogramming	performance measure;encapsulation;protocols;design automation;computer languages;object oriented language;persistence;helium;implementation;software performance evaluation;semantics;object oriented programming;semantica;semantique;software engineering;software performance evaluation object oriented languages lisp object oriented programming data encapsulation;data encapsulation;ejecucion;language semantics;open implementation;performance measurements;computer programming languages;object oriented;common lisp object system;programming profession;object oriented programming languages;genie logiciel;metaobject protocol;metaprogrammation;electronic switching systems;cities and towns;oriente objet;lisp;computer science;metaprogramming;object oriented programming metaprogramming language semantics encapsulation default classes object oriented languages persistence common lisp object system metaobject protocol reflection performance penalty performance measurements;clos;orientado objeto;metaprogramacion;object oriented languages;reflection;default classes;object persistence;reflection protocols programming profession computer science object oriented programming computer languages electronic switching systems design automation cities and towns;performance penalty;langage programmation ordinateur	By encapsulating aspects of language semantics within a set of default classes and allowing the programmer to derive new versions, object-oriented languages whose semantics can be tailored to the needs of individual programmers have been provided. The degree to which such languages are simultaneously flexible and efficient is an open question. We describe our experience with using this technique to incorporate transparent support for persistence into the Common Lisp Object System via its metaobject protocol, an open implementation based on reflection. For many aspects of our implementation the metaobject protocol was perfectly suitable. In other cases we had to choose between extending the protocol, requiring the application programmer to employ special idioms, and tolerating a large performance penalty. Based on our experience we evaluate the metaobject protocol, propose some improvements and extensions, and present performance measurements that reveal the need for improved language implementation techniques. >	metaprogramming;reflection (computer graphics)	Arthur H. Lee;Joseph L. Zachary	1995	IEEE Trans. Software Eng.	10.1109/32.473217	computer science;theoretical computer science;operating system;software engineering;database;semantics;programming language;object-oriented programming	SE	-27.11308836929242	30.305381153925104	185863
4f53ea375ac15cd96846a1c41126b94be3626c30	remote pointcut: a language construct for distributed aop	aspectj;distributed software;distributed computing;distributed programs;crosscutting concerns;language design	This paper presents our extension to AspectJ for distributed computing. Although AspectJ allows Java developers to modularize a crosscutting concern as an aspect, this paper shows that some crosscutting concerns in distributed computing are not modularized in AspectJ as simple aspects. Rather, aspects modularizing such a concern tend to be in code spread over multiple hosts and explicitly communicated across the network. This paper illustrates this fact with an example of testing a distributed program written in AspectJ with Java RMI. To address this complexity caused by network communication, this paper proposes an extension to AspectJ for distributed computing. The language construct that we call remote pointcut enables developers to write a simple aspect to modularize crosscutting concerns distributed on multiple hosts. This paper presents DJcutter, which is our AspectJ-like language supporting remote pointcuts.	aspectj;cross-cutting concern;distributed aop;distributed computing;java remote method invocation;language construct;pointcut	Muga Nishizawa;Shigeru Chiba;Michiaki Tatsubori	2004		10.1145/976270.976274	real-time computing;aspect-oriented programming;computer science;distributed computing;programming language	PL	-27.404472198308707	30.595273835055583	187870
97149cb0c4c31c36bcc074c5779597101c79b180	functional specification of time-sensitive communicating systems	parallel composition;communication system;functional system models;logical framework;formal model;system modeling;specification;real time systems	A formal model and a logical framework for the functional specification of time-sensitive communicating systems and their interacting components are outlined. The specification method is modular with respect to sequential composition, parallel composition, and communication feedback. Nondeterminism is included by underspecification. The application of the specification method to timed communicating functions is demonstrated. Abstractions from time are studied. In particular, a rational is given for the chosen concepts of the functional specification technique. The relationship between system models based on nondeterminism and system models based on explicit time notions is investigated. Forms of reasoning are considered. The alternating bit protocol is used as a running example.	alternating bit protocol;functional specification;interaction;logical framework;mathematical model;nondeterministic algorithm;process calculus	Manfred Broy	1993	ACM Trans. Softw. Eng. Methodol.	10.1145/151299.151302	real-time computing;systems modeling;logical framework;specification language;computer science;theoretical computer science;formal specification;functional specification;programming language;specification;algorithm;communications system;language of temporal ordering specification	SE	-31.061095862582334	32.257879167398364	188506
be344bfa29f3722587c1e8deaff1ff0623467302	embedded, hard, real-time systems with ada	real time;ada;programming language;systems;programming;languages;software systems;real time systems	Development of real-time systems is expensive and difficult, in part because of low-level languages that force developers to use facilities that are ad hoc, incomplete, and not portable. The Real-Time Systems Annex of Ada 2005 (along with the language core) represents the state-of-the-art in realtime programming languages and offers an extensive set of standardized packages and facilities for this domain. In addition, the language-defined Ravenscar profile describes a tasking subset that is analyzable for both high-integrity and hard real-time applications, and is small enough for very tightly resource-constrained applications as well. This tutorial examines the packages and pragmas defined by the annex for direct application use, examines the Ravenscar profile, and provides detailed examples of how they both are meant to be applied.	ada;embedded system;high- and low-level;hoc (programming language);programming language;ravenscar profile;real-time clock;real-time computing;real-time transcription	Pat Rogers	2009		10.1145/1647420.1647430	programming;real-time computing;ada;computer science;operating system;system;programming language;software system	Embedded	-29.72914282871072	29.348626410892184	189544
f9733329880d770567b9f5b52b35d9a37dc3a219	a computational geometry workbench	object oriented model;geometric data structure;programming environment;user interface;storage management;computational geometry;device independence;three dimensional;design and implementation;data abstraction;smalltalk;interactive graphics;convex hull;algorithms and data structure;voronoi diagram;dynamic optimization	We are constructing a workbench for computational geometry. This is intended to provide a framework for the implementation, testing, demonstration and application of algorithms in computational geometry. The workbench is being written in Smalltalk/V using an Apple Macintosh II. The object-oriented model used in Smalltalk is well-suited to algorithms manipulating geometric objects. In addition, the programming environment can be easily extended, and provides excellent graphics facilities, data abstraction, encapsulation, and incremental modification. We have completed the design and implementation of the workbench platform, insofar as such a system can ever be considered complete. Among the features of the system are:an interactive graphical environment, including operations for creation and editing of geometric figures, and for the operation of algorithm on these figures the system supports:high-level representation-independent geometric objects (points, lines, polygons,…) geometric data structures (segment trees, range trees,…) non-geometric data structures (finger trees, splay trees, heaps, …) “standard” algorithmic tools in as general a form as possible. Algorithms currently available in the system include Tarjan and van Wyk's triangulation of a simple polygon, Fortune's Voronoi diagram, Preparata's chain decomposition, and Melkman's convex hull algorithm.   tools for the animation of geometric algorithms high-level graphical and symbolic debugging facilities portability, due to the separation of the machine-independent code and the machine-dependent user-interface. automatic handling of basic operations (device-independent graphics, storage management) allowing the implementor to focus on algorithmic issues  Our group is currently working on extensions in two directions:implementing additional algorithms from two-dimensional computational geometry providing the framework for implementations of three-dimensional algorithms  We are also conducting comparison studies of different algorithms and data structures, including a comparison of different triangulation and convex hull algorithms for large input sizes and an empirical test of the dynamic optimality conjecture of Sleator and Tarjan using both Splay and Finger trees in the Tarjan and van Wyk triangulation. The workbench is being demonstrated during this symposium.	abstraction (software engineering);algorithm;computation;computational geometry;convex hull algorithms;data structure;debug symbol;debugging;encapsulation (networking);finger tree;graphical user interface;graphics;heap (data structure);high- and low-level;integrated development environment;machine-dependent software;preparata code;range tree;segment tree;smalltalk;software portability;splay tree;voronoi diagram;workbench	Andrew M. Knight;J. May;Jeff McAffer;T. Nguyen;Jörg-Rüdiger Sack	1990		10.1145/98524.98602	three-dimensional space;combinatorics;voronoi diagram;computational geometry;computer science;theoretical computer science;convex hull;mathematics;geometry;user interface;algorithm	Graphics	-29.62731556771036	25.775797542669164	190781
689ee3e2508a0d5695ae1e135d602f856ee18116	aop as a first class reflective mechanism	aspect oriented programming;aspect oriented programming aop;reflection	AOP is often perceived as a second class reflective mechanism, whereas reflection in OOP is considered first class. However, perceiving AOP as a first class language mechanism is conductive to developing a general AOP model, which can be a basis for an overall theory of AOP. We illustrate this view by comparing AOP with reflection and illustrating that both mechanisms are conceptually at the same level.	british undergraduate degree classification;first-class function;reflection (computer programming)	Sergei Kojarski;David H. Lorenz	2004		10.1145/1028664.1028757	real-time computing;reflection;aspect-oriented programming;computer science;programming language;algorithm	SE	-27.197751718163207	29.79749131483302	190935
5f256f7f1fec4654d9043b0e0557e29dc381f86b	wrap your objects safely	distributed system;components;object oriented language;programming language;wrappers;asynchronous communication;objects;security	Despite the effort of researchers on distributed systems, programming languages, and security, there is still no good solution offering basic constructs for guaranteeing minimal security at the programming language level. In particular, the notion of a wrapper around an object or component controlling its interaction with the environment has not properly been addressed. This kind of “local firewall” may play two different roles: (1) The untrusted part is what is inside the wrapper; (2) The untrusted part is the environment. In this paper we propose the addition of a language primitive for creating wrapped objects and components, and sketch a formalization based on a minimal object-oriented language for distributed systems using asynchronous communication.	automaton;distributed computing;firewall (computing);functional programming;identifier;language primitive;programming language;separation of concerns;smart card;wrapper library	Olaf Owe;Gerardo Schneider	2009	Electr. Notes Theor. Comput. Sci.	10.1016/j.entcs.2009.09.032	language primitive;computer science;information security;object;theoretical computer science;asynchronous communication;distributed computing;distributed object;programming language;object-oriented programming;high-level programming language	PL	-28.632981175231976	32.212817615104846	191308
209d6f6309b4160a97ff5f5c7788c3f0db363dc2	cachesim: a graphical software environment to support the teaching of computer systems with cache memories	personal computer;user interface;teaching tool;cache memory;system performance;educational software;software package	We present an educational software package (Cachesim) used as a teaching tool to study and analyse computer with cache memory. Cachesim allows students to execute step-by-step a program, to observe the cache activity needed for a memory operation, to evaluate the system performance by varying the program and/or the cache parameters and, finally, to analyse the program behaviour by the memory references. The user interface is fully graphic: Architectural modules of the simulated computer are managed as graphical objects and the main actions on them can be made by mouse clicks. The environment is based on VGA card and can be used on both MS-DOS and Windows platforms. This paper describes the software package and the simulated computer features by examining a student's exercise.	cpu cache;dos;graphical user interface;ms-dos;microsoft windows	Cosimo Antonio Prete	1994		10.1007/BFb0017623	long-term support;computer architecture;computing;computer science;package development process;software framework;component-based software engineering;software development;operating system;software construction;educational software;software walkthrough;software deployment;software system;computer engineering	PL	-32.46261312560744	27.6815649598724	191327
164861d28909f2da43eb2daa20d4e892ac1d8f9d	analysis and verification of multi-agent interaction protocols	formal specification;multi agent system;software verification;protocol design;multi agent systems;model checking;agent protocols;agent interaction protocol	This paper describes a case study on analysis and verification of agent interaction protocols. A concurrent FSM model is constructed using a formal specification of the protocol. A subset of requirements specified in the protocol design were checked using a model checker. We compare the verification results of model checking with those of belief logic based and specification based verification methods. Our verification results identify some inadequacies in the original proof. The case study suggest that model checking complement other methods for verification of commercial multi-agent systems.	communications protocol;formal specification;model checking;multi-agent system;requirement	Wu Wen;Fumio Mizoguchi	1999		10.1145/301136.301240	model checking;computer science;artificial intelligence;multi-agent system;formal specification	SE	-33.63508008212747	30.656486760559584	192880
c446f75fc6a3960db58b07af81f6f6c99d4a2106	martta: a c++ language workbench		Language-orientated programming promises to elevate programmer productivity through increased abstraction capabilities. Structural programming environments provide apparatus to reduce the difficulties with syntax. The language workbench, a conceptual combination of these two approaches, is a comparatively novel approach to software development and has so far been attempted only in dynamic-dispatch, run-time-compiled languages (e.g. Java). However, it must be remembered that several fields of engineering exist, each having their own priorities. In the video games industry, where large, complex and diverse projects are routinely developed, efficiency is paramount and as such C++, as a development platform, is widely used. I explore the possibility of a language workbench capable of a gradual transition in both skills and code from the traditional C++ development environment. This article is the design for a language workbench. It uses novel techniques including a context-sensitive eventdriven input system and a hybrid single/multiple-inherited class model and through a prototype implementation demonstrates that is both concise and practical for C++. I refute the hitherto implicit hypothesis that the language workbench paradigm is not applicable to the C++ language, showing that C++ can be used for creating an effective development framework usable in otherwise pure-C++ programming environments.	c++;compiled language;compiler;context-sensitive grammar;dynamic dispatch;java;language workbench;middleware;multiple inheritance;open-source software;programmer;programming paradigm;programming productivity;prototype;software development;user interface	Gavin Wood	2014	CoRR		programming language;language workbench;syntax;conceptual combination;computer science;usable;software development;development environment;programmer;java	PL	-27.658755371309713	26.90322698871423	193284
fe107c7c51b69b57deacbcc644a9420c200a5ca4	towards automated management of compiler assignments		We have implemented two software systems for managing compiler assignments in computer science. The first system is a graphical environment on the Web for doing home assignments related to finite state automata and parsers. It also includes an automatic assessment system for the assignments. The second system manages compiler projects. It generates a personalized language for each student and provides a testing tool for the student’s compiler. We introduce the main features of the systems and review some experiences.	automata theory;compiler;computer science;finite-state machine;graphical user interface;parsing;personalization;software system;test automation;world wide web	Leena Salmela;Jorma Tarhio;Timo Montonen	2009			computer architecture;parallel computing;programming language	PL	-31.08732560108649	26.706934847767034	193583
399af3768e1b2a2efd53fc9910090182739d5242	prototyping of hybrid systems - from hycharts to hybrid data-flow graphs	data flow graph;control flow;hybrid system;data flow	In this paper a translation of the visual description technique HyCharts to Hybrid Data Flow Graphs HDFG is given While HyCharts combine a data ow and a control ow oriented formalism for the speci cation of the architecture and the behavior of hybrid systems HDFG allow the e cient and homogeneous internal representation of hybrid systems in computers and their automatic manipulation HDFG represent a system as a data ow network built from a set of fundamental functions The translation permits to combine the advantages of the di erent description techniques The use of HyCharts for speci cation supports the abstract and for mal interactive speci cation of hybrid systems while HDFG permit the tool based optimization of hybrid systems and the synthesis of mixed signal prototypes	computer;dataflow architecture;hybrid system;mathematical optimization;mixed-signal integrated circuit;semantics (computer science)	Thomas Stauner;Christoph Grimm	1999	Electr. Notes Theor. Comput. Sci.	10.1016/S1571-0661(05)80631-0	data flow diagram;computer science;theoretical computer science;data-flow analysis;distributed computing;programming language;control flow;hybrid system	Embedded	-30.48500471200647	30.985949522385393	194023
b5cc9164824aa6443b768eeed38a571edc2e6562	scalalab: an effective scala-based scientific programming environment for java	dynamic languages;class loaders;groovy;programming environments;programming environment;interpreters;authoring languages;binding java scala groovy functional languages dynamic languages scripting interpreters matlab scientific programming class loaders;scala;public domain software;functional languages;pattern recognition;scientific programming;informatics;societies;open source packages scala based scientific programming environment java scalalab scalasci mathematical scripting framework;functional language;software packages authoring languages java public domain software;scripting;binding;matlab;programming languages;software packages;programming environments java pattern recognition matlab informatics scientific computing dynamic programming;java	Scala offers many benefits for constructing scientific programming environments. Extending Scala with Matlab-like constructs enabled the creation of ScalaSci, a compiled mathematical scripting framework, and ScalaLab, an efficient integrated scientific programming environment. ScalaLab offers an interesting open source alternative to commercial packages, especially for the scientific community familiar with Java.	compiler;integrated development environment;java;matlab;open-source software;scala	Stergios Papadimitriou;Constantinos Terzidis;Seferina Mavroudi;Spiridon D. Likothanassis	2011	Computing in Science & Engineering	10.1109/MCSE.2010.77	interpreter;computer science;theoretical computer science;scripting language;real time java;programming language;functional programming;java;informatics;public domain software;scala	PL	-30.618284139739707	25.664273336259114	195115
45bf706d2d089734c1138a3e990d6ecc2d89e64c	typing component-based communication systems	communication system;programming language;component based software;qa75 electronic computers computer science;type inference;type system	Building complex component-based software systems, for instance communication systems based on the Click, Coyote, Appia, or Dream frameworks, can lead to subtle assemblage errors. We present a novel type system and type inference algorithm that prevent interconnection and message-handling errors when assembling component-based communication systems. These errors are typically not captured by classical type systems of host programming languages such as Java or ML. We have implemented our approach by extending the architecture description language (ADL) toolset used by the Dream framework, and used it to check Dream-based communication systems.	algorithm;appia framework;architecture description language;component-based software engineering;domain-specific language;experiment;functional programming;interconnection;java;model checking;programming language;software system;type inference;type system;typing	Michael Lienhardt;Claudio Antares Mezzina;Alan Schmitt;Jean-Bernard Stefani	2009		10.1007/978-3-642-02138-1_11	real-time computing;type system;computer science;theoretical computer science;type inference;distributed computing;programming language;algorithm;communications system	PL	-27.706739015566512	30.7728115342861	195407
3780cc105308f2c3510d13ee95b91034a810e122	protocol conversion - correctness problems	logical channel;largest protocol;stepwise refinement rule;protocol conversion;correctness property;user process;different protocol;image protocol;correctness problem;protocol verification;necessary image protocol	Consider the problem of providing a logical channel for message exchange between two user processes in a network environment. When is protocol conversion needed? To answer this question, we first define a model of layered architectures. Specifically, three stepwise refinement rules are given. Any architecture that can be obtained by a sequence of applications of the stepwise refinement rules is said to be well-structured. We show that this class of well-structured architectures has several correctness properties. It is also very general and includes many well-known networking and internetworking architectures in the literature. Logical connectivity in such an architecture is defined recursively. As a result, to determine if a logical channel can be provided between two user processes, it is sufficient to examine peer protocols specified for each level of the architecture's hierarchy of processes one at a time. Thus the original problem reduces to the problem of determining if a set of processes will interoperate. When protocol conversion is needed to achieve interoperability between processes that implement different protocols, how should it be done? How does one prove that a conversion is correct? What is meant by a correct conversion? We propose the use of projections and image protocols (previously developed by Lam and Shankar for protocol verification [10]) for specifying conversions and for reasoning about the correctness of conversions. Given two processes implementing different protocols P and Q, our objective is to find the largest protocol that is an image protocol of P as well as Q. The correctness of the conversion is a consequence of the correctness properties of image protocols. There are several open problems. Most importantly, heuristics are used for finding the necessary image protocol for conversion. Although, an image protocol common to both P and Q can always be found, it may not be easy to find one with useful functionality. There are also some implementation and design issues to be addressed, such as: the construction of converters that are transparent and converters that add functionality to an image protocol common to P and Q.	communications protocol;correctness (computer science);graph coloring;heuristic (computer science);internetworking;interoperability;lam/mpi;lambda calculus;p (complexity);recursion;refinement (computing);stepwise regression;top-down and bottom-up design;well-formed formula	Simon S. Lam	1986		10.1145/18172.18175	universal composability;two-phase commit protocol;computer science;theoretical computer science;operating system;distributed computing;computer security;algorithm;computer network	Networks	-29.432369401572405	31.78890380735322	196055
2c5c546ddd499bf1aa7f2141aedddd2c73a52167	structured synchronous reactive programming with cýu	imperative;synchronous;esterel;concurrency;structured programming;determinism;reactivity	Structured synchronous reactive programming (SSRP) augments classical structured programming (SP) with continuous interaction with the environment. We advocate SSRP as viable in multiple domains of reactive applications and propose a new abstraction mechanism for the synchronous language Céu: Organisms extend objects with an execution body that composes multiple lines of execution to react to the environment independently. Compositions bring structured reasoning to concurrency and can better describe state machines typical of reactive applications. Organisms are subject to lexical scope and automatic memory management similar to stack-based allocation for local variables in SP. We show that this model does not require garbage collection or a free primitive in the language, eliminating memory leaks for organisms by design.	concurrency (computer science);garbage collection (computer science);local variable;memory leak;memory management;reactive programming;scope (computer science);stack-oriented programming language;structured programming;synchronous programming language	Francisco Sant'Anna;Roberto Ierusalimschy;Noemi de La Rocque Rodriguez	2015		10.1145/2724525.2724571	real-time computing;reactive programming;computer science;distributed computing;programming language	PL	-27.440687588263135	32.066648376632024	197403
64ec89d2f00ac5ad05fa6475bc2877ee8519e7e2	rapidly implementing languages to compile as c++ without crafting a compiler	heuristic development paradigm;native language;comprehensive host language and-or;multiple language;high-level imperative language;functional language;programming language;event language;assembly language;domain-specific language	We present a heuristic implementation method for programming languages that is appropriate when the following requirements or conditions are met: (a) there is a need for very rapid development of a language with significant performance demands, while exploiting a comprehensive host language and/or library; (b) need of customized runtime execution environment supporting of execution tracing and visualization instruments; (c) the facilitation of hybrid code exists, such as mixing with the native language, and there is the potential for allowing multiple languages to be deployed concurrently in the same program. This may account for a wide range of domain-specific languages such as learning-oriented, scripting, assembly style, data manipulation, rule-based, or event languages. The proposed technique is presented for the C++ language, supporting the development of languages whose source programs compile as C++ code. The software architecture shifts from the tradition of lexical analysis, syntax-directed translation and code generation, and we propose a complementary, conditionally advantageous, heuristic development paradigm. The method has been applied to the development of a high-level imperative language, an assembly language and a functional language, which are all currently deployed for teaching purposes. Copyright c © 2007 John Wiley & Sons, Ltd.	assembly language;c++;code generation (compiler);compiler;domain-specific language;emoticon;functional programming;heuristic;high- and low-level;imperative programming;john d. wiley;lexical analysis;logic programming;mixing (mathematics);programming language;programming paradigm;requirement;scripting language;software architecture;syntax-directed translation	Anthony Savidis	2007	Softw., Pract. Exper.	10.1002/spe.818	natural language processing;fourth-generation programming language;compile time;language primitive;object-based language;computer science;programming language generations;domain-specific language;theoretical computer science;operating system;third-generation programming language;syntax;common intermediate language;computer programming;scripting language;programming paradigm;low-level programming language;fifth-generation programming language;programming language;second-generation programming language;high-level programming language;comparison of multi-paradigm programming languages;assembly language	PL	-28.00519573301371	28.231929936320785	197475
4fa24d30abc056e113331bfacf5ee6fcccfc3518	scoop, structured concurrent object-oriented prolog	dynamical processes;structural dynamics;object oriented;concurrent programs;discrete simulation;structural design;parallel processing	SCOOP is an experimental language implemented in Prolog that mes to combine the best of logic, object-oriented and concurrent programming in a structured, natural and efficient manner. SCOOP provides hierarchies of object classes. These objects behave as independent Prolog programs with private databases which can execute goals within other objects. SCOOP also supports parallel processes, synchronised by the exchange of messages. For simulation, a sequencing set and primitives concerned with simulated time are provided. Thus, SCOOP has the ability to describe structured dynamic systems and to encode knowledge. The important features of SCOOP are 1) its lexical block structure designed to promote and enforce modularity and to allow verification and optimisation via a compiler, 2) its combination of familiar programming cliches: the concepts of Simula67 for macrostructuring of entities and those of standard Prolog (unification & backtracking) for local behaviour, 3) its provision for parallel activity with a clear distinction between static objects and dynamic processes and 4) its discrete simulation capability.	backtracking;compiler;concurrent computing;database;dynamical system;encode;entity;mathematical optimization;prolog;scoop;simula;simulation;unification (computer science)	Jean G. Vaucher;Guy Lapalme;Jacques Malenfant	1988		10.1007/3-540-45910-3_12	parallel processing;structural dynamics;computer science;theoretical computer science;discrete event simulation;distributed computing;programming language;object-oriented programming	PL	-27.461173420410887	32.058471731158825	197816
298f279fe70ccf47dec1062f9a37d5466bd369fa	a formal specification technique and implementation method for protocols	formal specification	In this paper we describe a formal technique for specifying computer communication protocols as well as a method for automatically producing partial implementations from protocol specifications. After presenting a state machine model for protocols we describe a formal protocol specification language, along with a brief example of a formal specification. Finally we discuss an implementation model, and we present several software tools that help with the automatic processing of the specification.	finite-state machine;formal specification;specification language	Thomas P. Blumer;Richard L. Tenney	1982	Computer Networks	10.1016/0376-5075(82)90098-8	b-method;formal methods;specification language;formal verification;computer science;formal specification;database;refinement;programming language;programming language specification;language of temporal ordering specification	Networks	-33.49908336625327	31.842170092238874	198815
5c16a5ccf759a26ecdf759ced563dafb0bd2d8f0	a structured apl system	structured apl system;additional key words and phrases: workspace	A structured APL system introducing several interesting features is described. The APL group concept has been considerably extended to yield a new type of APL object called a segment. Segments constitute the basic building blocks used to manage memory and to build up the workspace and the user's library. The encapsulation capability provides a unified scheme for handling variables, functions, and other APL objects, including fries. A new structured user library is proposed. The dynamic call of objects during a terminal session links the user library to the workspace. New types of variables are described along with solutions to interesting problems based on them.	apl;directory (computing);encapsulation (networking);library (computing);workspace	J. Bergeron;A. Dubuque	1982	ACM Trans. Program. Lang. Syst.	10.1145/69622.357185	programming language;computer science	PL	-28.35261799311505	25.742341077710257	199190
d70574458e1e6c8a34cee3a61ebfd277abf36234	a model to design reusable parallel software components	concurrent constraint;abstract data type;expressive power;software component	The definition of objects in a parallel environment can be viewed as that of classes, devoted to the construction of objects, which are composed of two kind of ancestors. A first kind contains the basic elements necessary for the definition of an abstract data type. A second is devoted to handling constraints resulting from the parallel execution of methods. These constraints are called concurrency constraints. Each component of ancestor can be viewed as a reusable software component. In this paper, we focus on class extension which deals with interference problems which are provoked by the above class composition. In this proposal, we aim to implement synchronization and inheritance without decreasing the expressive power of concurrency constraints.	component-based software engineering	Jean Paul Bahsoun;Louis Féraud	1992		10.1007/3-540-55599-4_92	computer architecture;real-time computing;software sizing;computer science;software design;software framework;component-based software engineering;software development;software construction;programming language;resource-oriented architecture;software system	SE	-28.60394427790097	30.959203027387666	199248
9751045f91dca2c0e03a557d1ed02fa5e626a914	a professional graphics controller	input output controller;representation graphique;input output equipment;controleur entree sortie;equipement entree sortie;graphics	The IBM Professional Graphics Controller and Display were developed to meet the needs of engineers and scientists for an improved graphics capability int he Personal Computer environment. These units provide graphics systems with improved function, resolution, and color range, and at he same time they allow existing productivity software to be executed in an emula tion mode. This paper describes the function and discusses the design of the Professional Graphics Controller.	professional graphics controller	Keith A. Duke;W. Alan Wall	1985	IBM Systems Journal	10.1147/sj.241.0014	simulation;computer hardware;computer science;electrical engineering;graphics;operating system;software engineering;computer graphics (images)	Logic	-32.17661041618411	28.630406302587115	199831
