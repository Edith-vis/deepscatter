id	title	keywords	abstract	entities	authors	year	journal	doi	fos	area	x	y	ix
98df65269ea87768dc92d8338b3d009368cb10af	a scalable hardware architecture for retinal blood vessel detection in high resolution fundus images	hardware acceleration;retinal recognition blood vessels field programmable gate arrays image resolution matched filters parallel processing;fpga platform scalable hardware architecture automatic retinal blood vessel detection high resolution fundus images accelerated hardware architectures scalable hardware architecture matched filter mf parallel processing resource sharing real time performances automatic hdl description generation parameter selection problem area utilization maximum frequency;scalable hardware architectures retinal blood vessels detection hardware acceleration;kernel matched filters retina blood vessels biomedical imaging hardware field programmable gate arrays;retinal blood vessels detection;scalable hardware architectures	Blood vessel detection from high resolution fundus images is a necessary step in several medical applications. Automatic blood vessels detection is a computing intensive task which raises the need for accelerated hardware architectures. In this paper, we propose a scalable hardware architecture for blood vessel detection using a matched filter (MF). The algorithm is made hardware friendly using parallel processing and efficient resources sharing to achieve real-time performances. The paper also introduces a tool for the automatic generation of an HDL description based on the proposed architecture as a template. The tool takes as input the parameters of the filter to deal with the parameter selection problem and to make their choice more flexible. Performances in terms of area utilization and maximum frequency are reported. Several designs were verified and implemented on an FPGA platform. The results show significant improvements over the state of the art implementations, up to a factor of 10× for high resolution fundus images.	clock rate;field-programmable gate array;hand coding;hardware description language;image resolution;matched filter;parallel computing;performance;peterson's algorithm;programming tool;real-time clock;real-time transcription;scalability;selection algorithm;video post-processing	Hamza Bendaoudi;Farida Cheriet;Houssem Ben Tahar;J. M. Pierre Langlois	2014	Proceedings of the 2014 Conference on Design and Architectures for Signal and Image Processing	10.1109/DASIP.2014.7115619	embedded system;computer vision;computer hardware;computer science	EDA	3.007584148421326	46.68642240394846	163419
d91b158e97bb9407aedfa5f3736941b330cfb15b	knowledge transfer in automatic optimisation of reconfigurable designs	integrated circuit design automatic optimisation transfer knowledge reconfigurable designs fpga gaussian process automatic ip parameter tuning;support vector machines;bayes methods;conference paper;knowledge transfer;optimization;correlation;optimisation knowledge based systems;seismic imaging knowledge transfer automatic optimisation reconfigurable design parameters computational finance;optimization algorithm design and analysis knowledge transfer benchmark testing support vector machines correlation bayes methods;algorithm design and analysis;benchmark testing	This paper presents a novel approach for automatic optimisation of reconfigurable design parameters based on knowledge transfer. The key idea is to make use of insights derived from optimising related designs to benefit future optimisations. We show how to use designs targeting one device to speed up optimisation of another device. The proposed approach is evaluated based on various applications including computational finance and seismic imaging. It is capable of achieving up to 35% reduction in optimisation time in producing designs with similar performance, compared to alternative optimisation methods.	algorithm;computation;computational finance;mathematical optimization;speedup	Maciej Kurek;Marc Peter Deisenroth;Wayne Luk;Tim Todman	2016	2016 IEEE 24th Annual International Symposium on Field-Programmable Custom Computing Machines (FCCM)	10.1109/FCCM.2016.29	support vector machine;algorithm design;benchmark;computer science;theoretical computer science;machine learning;data mining;correlation	Arch	2.7949883192703915	50.36625874198356	164089
d41d3d06717925083f6398bc74ad12d90fbc4c67	designing and implementing an embedded linux for limited resource devices	libraries;analytical models;microprocessors;kernel;limited resource devices;history;limited resource device;linux embedded system operating systems analytical models hardware embedded computing personal digital assistants computational modeling history microprocessors;embedded system;simulator;personal digital assistants;computational modeling;embedded linux;linux;uclinux;read only memory;uclinux embedded linux embedded system limited resource devices simulator;limited resource device embedded linux;embedded computing;device simulation;operating systems;hardware	In this paper, the implementation details of an embedded Linux for limited resource devices are provided. Due to lack of an actual hardware to test the implemented embedded Linux, a simulator for development work had to be built. Thus, the implementation details of the simulator as well as an analysis of simulation results are described. Moreover, some new ideas that will be used in our future research work are proposed.	busybox;electronic circuit simulation;embedded system;execute in place;kernel (operating system);library (computing);linux on embedded systems;microcontroller;operating system;random-access memory;software prototyping;subroutine;toolchain	Hannu Lyytinen;Keijo Haataja;Pekka Toivanen	2009	2009 Eighth International Conference on Networks	10.1109/ICN.2009.27	embedded system;kernel;real-time computing;computer science;operating system;linux unified key setup;computational model;read-only memory;linux kernel	EDA	3.9788587094726067	50.519744515250046	165096
95dd37d9c4b860a6bf89817cefd04045cb3181d7	dynamically reconfigurable hardware - a new perspective for neural network implementations	prototipificacion rapida;modelo dinamico;field programmable gate array;estacion trabajo;computadora personal;ordinateur personnel;integrated circuit;personal computer;dynamic reconfiguration;reconfigurable architectures;station travail;systeme modulaire;dynamic model;circuito integrado;sistema modular;hardware accelerator;red puerta programable;reseau porte programmable;ordinateur hote;workstation;rapid prototyping;host computer;self organized feature map;modele dynamique;modular system;utilisabilite;autoorganizacion;computador huesped;self organization;self organized map;usabilidad;reseau neuronal;usability;architecture reconfigurable;hardware implementation;red neuronal;autoorganisation;circuit integre;software implementation;prototypage rapide;neural network	In this paper we discuss the usability of dynamic hardware reconfiguration for the simulation of neural networks. A dynamically reconfigurable hardware accelerator for self-organizing feature maps is presented. The system is based on the universal rapid prototyping system RAPTOR2000 that has been developed by the authors. The modular prototyping system is based on XILINX FPGAs and is capable of emulating hardware implementations with a complexity of more than 24 million system gates. RAPTOR2000 is linked to its host - a standard personal computer or workstation - via the PCI bus. For the simulation of self-organizing maps a module has been designed for the RAPTOR2000 system, that embodies an FPGA of the Xilinx Virtex (-E) series and optionally up to 128 MBytes of SDRAM. A speed-up of about 50 is achieved with five FPGA modules on the RAPTOR2000 system compared to a software implementation on a state of the art personal computer for typical applications of self-organizing maps.	artificial neural network;reconfigurability;reconfigurable computing	Mario Porrmann;Ulf Witkowski;Heiko Kalte;Ulrich Rückert	2002		10.1007/3-540-46117-5_107	embedded system;computer architecture;real-time computing;self-organization;workstation;usability;hardware acceleration;reconfigurable computing;computer science;operating system;integrated circuit;host;artificial neural network;field-programmable gate array	ML	6.794485801470747	47.64580332295606	165163
39d2230c4e270f54919f366d5014b3d2464e902c	overview of powerpctm 620 multiprocessor verification strategy	powerpc 620;debugging;microprocessors;cache storage computer testing integrated circuit testing logic testing reduced instruction set computing formal verification virtual machines performance evaluation automatic test software computer architecture;cache storage;multiprocessor verification strategy;random test program generator;protocols;performance evaluation;reduced instruction set computing;testing;automatic programming;coherency monitor;out of order;alternate master;cache coherency;configuration parameters file;computer architecture;formal verification;test case generation;computer testing;virtual machines;behavioral models;automatic test software;implementation verification program;logic testing;testing power generation reduced instruction set computing microprocessors automatic programming out of order protocols delay debugging computer bugs;integrated circuit testing;functional model;bus interface unit;risc microprocessor;power generation;configuration testing;l2 sram model;rtx simulation executor;data colouring;computer bugs;simulation environment;functional model level;data colouring powerpc 620 multiprocessor verification strategy simulation environment test case generation functional model level risc microprocessor bus interface unit behavioral models arbiter model memory model l2 sram model alternate master coherency monitor random test program generator rtx simulation executor implementation verification program configuration parameters file cache coherency configuration testing;arbiter model;memory model	A comprehensive approach which includes both creation of the simulation environment and generation of the test cases is presented for multiprocessor verification of PowerPC 620m at the functional model level.	function model;multiprocessing;powerpc 600;simulation;test case	Jen-Tien Yen;Marie Sullivan;Carlos Montemayor;Pete Wilson;Richard Evers	1995		10.1109/TEST.1995.529830	memory model;electricity generation;embedded system;communications protocol;cache coherence;reduced instruction set computing;computer architecture;parallel computing;real-time computing;software bug;formal verification;computer science;virtual machine;out-of-order execution;function model;operating system;software testing;debugging	EDA	7.802372100954718	52.4405591415692	165228
488766714f423bb89e12472e5f9f2321dc674a2a	a scalable cnn architecture and its application to short exposure stellar images processing on a hprc	hls;hdl;fpga;hprc;hw sw co execution;cnn	A CNN-based algorithm for short exposure image processing and an application-specific computing architecture developed to accelerate its execution are presented. Algorithm is based on a flexible and scalable Cellular Neural Networks (CNN) architecture specifically designed to optimize the projection of CNN kernels on a programmable circuit. The objective of the proposed algorithm is to minimize the adverse effect that atmospheric disturbance has on the images obtained by terrestrial telescopes. Algorithm main features are that it can be adapted to the detection of several astronomical objects and it supports multi-stellar images. The implementation platform made use of a High Performance Reconfigurable Computer (HPRC) combining general purpose standard microprocessors with custom hardware accelerators based on FPGAs, to speed up execution time. The hardware/software partitioning and co-design process have been carried out using high level design tools, instead of traditional Hardware Description Languages (HDLs). Results are presented in terms of circuit area/speed, processing performance and output quality.	reconfigurable computing;scalability;stellar (payment network)	J. Javier Martínez-Álvarez;F. Javier Garrigós;F. Javier Toledo-Moreo;Carlos Colodro-Conde;Isidro Villó-Pérez;José Manuel Ferrández	2015	Neurocomputing	10.1016/j.neucom.2014.09.071	embedded system;parallel computing;real-time computing;computer science;field-programmable gate array	Vision	2.8161883865574984	46.549758250841265	165991
63f508e15e91976bb2f54e0175ef33294c733ea2	a high-level synthesis algorithm with inter-island distance based operation chainings for rdr architectures			algorithm;high-level synthesis;restrictive design rules	Kotaro Terada;Masao Yanagisawa;Nozomu Togawa	2015	IEICE Transactions		floorplan;computer architecture;real-time computing;computer science;high-level synthesis	EDA	5.225271533221929	50.476305670811485	166130
e80a7bcbf79b68ec38c40ac34f9b533b53eb7248	a microarchitecture for a superconducting quantum processor		This article proposes a quantum microarchitecture, QuMA. Flexible programmability of a quantum processor is achieved by multilevel instructions decoding, abstracting analog control into digital control, and translating instruction execution with non-deterministic timing into event trigger with precise timing. QuMA is validated by several single-qubit experiments on a superconducting qubit.	experiment;microarchitecture;qubit;superconducting quantum computing	Xiang Fu;M. A. Rol;C. C. Bultink;J. van Someren;Nader Khammassi;Imran Ashraf;R. F. L. Vermeulen;J. C. de Sterke;W. J. Vlothuizen;R. N. Schouten;Carmen G. Almudéver;L. DiCarlo;Koen Bertels	2018	IEEE Micro	10.1109/MM.2018.032271060	parallel computing;qubit;process control;computer science;decoding methods;quantum computer;coprocessor;quantum;digital control;microarchitecture	Arch	9.904257175021696	48.12820534556706	166240
beee1414ed543f1f8334ea3c3b994c0cceb01404	hardware prototyping through programmable gate arrays	logic arrays;logic design;chip;hardware prototypes integrated circuit interconnections field programmable gate arrays computer aided manufacturing printed circuits wiring read write memory wire computer errors;logic design logic arrays;prototype model field programmable gate arrays large computer systems fpgas large gate array chips ram chips prototype hardware system printed circuit card wired connections soft wiring pluggable interconnections physical correctness	A method o f p r o t o t y p i n g l a r g e computer systems w i t h FPGA's has been deve loped . The computer sys tem b e i n g m o d e l l e d i s assumed t o be composed o f a number o f l a r g e g a t e a r r a y c h i p s and ram c h i p s i n t e r c o n n e c t e d t o form a comp e t e system. Each g a t e a r r a y c h i p i n t h e p r o t o t y p e hardware system i s mode led by a p r i n t e d c i r c u i t c a r d c o n t a i n i n g a number o f FPGA's by i n d i v i d u a l w i r e d c o n n e c t i o n s . The main advantage o f t h e p r o t o t y p e hardware i s t h a t c u r r e n t l y a v a i l a b l e FPGA p a r t s a r e used and t h a t t h e e n t i r e d e s i g n o f t h e computer system i s c o n t a i n e d e i t h e r i n t h e s o f t w i r i n g o f t h e FPGA's, t h e w i r i n g on t h e c a r d s o r t h e p l u g g a b l e i n t e r c o n n e c t i o n s between t h e c a r d s . Methods have been deve loped so t h a t each e l e m e n t o f t h e p r o t o t y p e can be changed r a p i d y , f o l l o w i n g changes i n t h e d e s i g n . C o n s i d e r a b l e a t t e n t i o n has a l s o been g i v e n t o v e r i f y i n g t h e l o g i c a l and p h y s i c a l c o r r e c t n e s s o f t h e p r o t o t y p e mode l . The c a r d s a r e t h e n i n t e r c o n n e c t e d	artificial intelligence;computer;emoticon;field-programmable gate array;ibm system i;random-access memory	Walter Kleinfelder;Leon I. Maissel;C. J. Tan;L. Travillyan	1991		10.1109/IWRSP.1991.218629	chip;embedded system;electronic engineering;logic synthesis;computer hardware;telecommunications;reconfigurable computing;computer science;engineering	AI	7.083730196548925	49.46678362414855	166259
7133774d38af396baeff5ab18ea01ce10745f765	real-time speech coder implementation at 9.6 and 16 kb/s	debugging;system reliability;array processing;baseband;reliability;real time;speech processing;speech coding;array signal processing;linear predictive;speech coding real time systems software design debugging reliability array signal processing parallel architectures speech processing adaptive arrays baseband;parallel architectures;adaptive arrays;real time implementation;parallel architecture;software design;real time systems	The practical feasibility of a speech coding algorithm is most effectively indicated by its successful real-time implementation. The implementation effort presents issues distinct from those related to the development of the algorithm. Problems of real-time software design and debugging, system reliability, and implementation correctness must be addressed. In addition, the power of a special purpose array processing computer is generally required to accomplish the real-time aspect of the implementation. The unique, often highly parallel architecture of available array processors can present the additional issues of multi-processor intercommunication and control. This paper considers successful approaches to these issues in the context of two real-time speech coder algorithms implemented on an array processor (a linear predictive baseband coder operating at 9.6 kb/s, and an adaptive predictive coder operating at 16 kb/s).	data rate units;real-time transcription;speech coding	Jared J. Wolf;Kenneth D. Field	1981		10.1109/ICASSP.1981.1171222	parallel computing;real-time computing;speech recognition;computer science;software design;speech coding;baseband;reliability;speech processing;debugging	Crypto	5.2007011815773465	47.178928552839764	166536
ab1ab10cd032fe216f1b34d53f06355da167fadf	nicarus: a distributed verilog compiler	software system;circuit complexity;parallel virtual machine;compiler result;software design tool;communications overhead;verilog compiler;faster tool;compilation process;very large scale integration;integrated circuit;hardware description language;software design;testing;process design;concurrent computing;computer networks;computational modeling;computer languages;software systems	Software design tools, such as compilers and simulators, are widely used in the integrated circuits (IC) industry. As the circuit complexity grows, better and faster tools are required. One way to speed up a software system is to parallelize it and execute it on multiple CPUs. This idea is particularly appealing when it comes to the compilers for hardware description languages (HDL). In this paper, we explore the parallelization of a Verilog compiler on a network of computers using Parallel Virtual Machine (PVM). Our design parallelizes the three most important and time-consuming phases of the compilation process while minimizing the communications overhead. Experimental results reveal that the algorithms used for parallelizing the compiler results in a speedup of the compilation process.	algorithm;automatic parallelization;central processing unit;circuit complexity;code generation (compiler);compiler;computer;hardware description language;integrated circuit;overhead (computing);parallel virtual machine;parallel computing;parsing;programming language;simulation;software design;software system;speedup;verilog	Carl Tropper	2004	Workshops on Mobile and Wireless Networking/High Performance Scientific, Engineering Computing/Network Design and Architecture/Optical Networks Control and Management/Ad Hoc and Sensor Networks/Compil	10.1109/ICPPW.2004.1328063	circuit complexity;process design;computer architecture;parallel computing;concurrent computing;compiler correctness;computer science;software design;operating system;integrated circuit;compiler construction;software testing;very-large-scale integration;hardware description language;programming language;computational model;functional compiler;software system	HPC	6.807996987218468	51.77760507239067	166579
37421761dabd6eb82fe0bb0a076010ea8ae1cef9	efficient fpga implementation of equalizer for finite interval constant modulus algorithm		This paper deals with the optimization of iterative algorithms with matrix operations or nested loops for hardware implementation in Field Programmable Gate Arrays (FPGA), using Integer Linear Programming (ILP). The method is demonstrated on an implementation of the Finite Interval Constant Modulus Algorithm, proposed for 4G communication systems. We used two pipelined arithmetic ibraries based on the logarithmic number system or the floating-point number system, using the widely known IEEE format for the floating-point calculations required in the algorithm. Traditional approaches to the scheduling of nested loops lead to a relatively large code, which is unsuitable for FPGA implementation. This paper presents a new high-level synthesis methodology, which models both, iterative loops and imperfectly nested loops, by means of the system of linear inequalities. Moreover, memory access is considered as an additional resource constraint. Since the solutionns of ILP formulated problems are known to be computationally intensive, important part of the article is devoted to the reduction of the problem size.	academy;algorithm;analysis of algorithms;cma-es;central processing unit;computation;control flow;equalization (communications);field-programmable gate array;high- and low-level;high-level synthesis;integer programming;iteration;iterative method;library (computing);linear inequality;linear programming;logarithmic number system;mathematical optimization;modulus of continuity;multiprocessing;real-time transcription;scheduling (computing);speedup	Premysl Sucha;Zdenek Hanzálek;Antonin Hermanek;Jan Schier	2006	2006 International Symposium on Industrial Embedded Systems	10.1109/IES.2006.357480	embedded system;parallel computing;real-time computing;integer programming;computer science;floating point;theoretical computer science;operating system;field-programmable gate array	EDA	9.534233658920636	47.20167999984579	166934
ab9fdf72e98962ed98e417169ff5dd08a3f29bc1	lsi modular computers, systems, and networks	minimization;economic forecasting;network organization;large scale integration computer networks minimization integrated circuit technology vacuum technology electron tubes economic forecasting;computer networks;large scale integration;integrated circuit technology;vacuum technology;electron tubes	Modular LSI-based design makes possible new patterns of computer and network organization, providing greater computational power and flexibility.	computation;network governance	Steven I. Kartashev;Svetlana P. Kartashev	1978	Computer	10.1109/C-M.1978.218259	computer science;economic forecasting;minification	Arch	8.913634584000313	50.31431299564605	167287
6b97b78084c98ab958b49e4eb3c1eeacdda6f95b	power-aware architectures and circuits for fpga-based signal processing	configurable logic block;leakage current;performance estimation;circuit design;fft;fpga;system design;signal processing;fpga architecture;distributed arithmetic;matrix multiplicaiton;power reduction;energy efficient design techniques;reconfigurable hardware;steady state	This work showcases a power-aware system design methodology for DSP applications on reconfigurable hardware platforms. In particular, an enhanced FPGA architecture is proposed and analyzed for a deep submicron process technology. These enhancements reduce Configurable Logic Block (CLB) usage for distributed arithmetic implementations of signal processing applications by 50% or more thereby reducing the load on interconnect resources. Multi-Threshold CMOS (MTCMOS) circuit design techniques are aggressively applied to reduce subthreshold leakage using an auto power-down feature for unused logic. Results show a 14x reduction in leakage current for unused CLBs or CLBs in deep sleep mode. CLBs in active mode see up to 2.8x steady-state power reduction. A testchip demonstrating these techniques in 0.13 micron technology has been sent out for fabrication.	circuit design;digital signal processor;field-programmable gate array;logic block;multi-threshold cmos;signal processing;sleep mode;spectral leakage;steady state;systems design;very-large-scale integration	Frank Honoré;Benton H. Calhoun;Anantha Chandrakasan	2003		10.1145/611817.611872	embedded system;fast fourier transform;parallel computing;real-time computing;reconfigurable computing;matrix multiplication;computer science;circuit design;signal processing;leakage;steady state;field-programmable gate array;systems design	EDA	5.605875121786213	50.35773967697741	167809
63fc83e4261d75d1aae2a36bd1562438519287db	reconfigurable machine and its application to logic diagnosis	sram chips;logic cad;logic arrays;logic testing;reconfigurable architectures;rams;sram memory banks;field-programmable gate arrays;gate-level programmability;highly flexible architecture;logic diagnosis;logic simulator;parallel processing;reconfigurable machine	In this paper, we present a Reconfigurable Machine (RM). Its highly flexible architecture combining FPGA’s with RAM’s supports a wide range of applications. Since its “gate-level programmability” allows us to implement various kinds of parallel processing techniques, RM provides a performance comparable to existing “special-purpose” engines. A Reconfigurable Machine Prototype (RMP) has been built as the first prototype incorporating five FPGA’s and four SRAM memory banks. RMI’ has been applied to logic diagnosis and logic simulator. The concept of RM may be the best solution to the trade-offs between general-purpose machines and special-purpose ones. RM will be a hardware platform accelerating a wide range of applications, also offering an interesting problem in highlevel synthesis.	computer-aided design;field-programmable gate array;general-purpose modeling;high- and low-level;high-level synthesis;logic simulation;memory bank;parallel computing;prototype;risk management plan;static random-access memory	Naoaki Suganuma;Yukihiro Murata;Satoru Nakata;Shinichi Nagata;Masahiro Tomita;Kotaro Hirano	1992		10.1145/304032.304136	embedded system;parallel processing;computer architecture;electronic engineering;parallel computing;logic synthesis;macrocell array;logic optimization;diode–transistor logic;logic gate;logic family;reconfigurable computing;programmable logic array;computer science;programmable logic device;pass transistor logic;complex programmable logic device;simple programmable logic device;high-level synthesis;programmable array logic;register-transfer level;field-programmable gate array;resistor–transistor logic	Arch	6.20183774224249	47.198523973806054	167842
e8ee0bc9173058f28b514de4cc5d67a155b6d42c	microsystems minimal storage sorting and searching techniques for ram applications: a tutorial	sorting;tutorials sorting read write memory;tutorials;read write memory	A large number of sorting and searching techniques, covering a variety of applications, are dealt with in computer science literature. The classical problem associated with these methods has been determining which set of algorithms is most appropriate for a given application. With the recent advances in LSI technology and the assured proliferation of microprocessors and RAM memory, yet another application has evolved. Memory address widths associated with microprocessor systems are limited, in many cases, to a maximum of 16 bits, severely restricting maximum memory size. Minimal storage implementation techniques, characterized by the optimal use of the data space associated with an algorithm, therefore, are most appropriate for these restricted address space environments common to microprocessor systems.	acm siggraph;address space;algorithm;computational complexity theory;computer data storage;computer science;dataspaces;fastest;graphics;harris affine region detector;heapsort;insertion sort;memory address;microprocessor;overhead (computing);performance engineering;printer (computing);random-access memory;requirement;search algorithm;shellsort;software system;sorting;systems engineering;yet another	Kurt A. Schember;John R. Rumsey	1977	Computer	10.1109/C-M.1977.217752	semiconductor memory;parallel computing;computer hardware;computer science;sorting;theoretical computer science;operating system;external sorting;computer memory;memory map;memory management	Theory	5.918917194621448	49.91949082111242	168300
2d7ebd7188a802a470d253cc44381de3431e3b0a	a synthesis algorithm for modular design of pipelined circuits	pipelined circuits;modular design;synthesis algorithm	This paper presents a synthesis algorithm for pipelined circuits. The circuit is specified as a collection of independent, looselycoupled modules connected by queues. The synthesis algorithm transforms this asynchronous, modular specification into a synchronous, tightlycoupled, and fully pipelined circuit in which queues are implemented as finite buffers. Data is read from the buffers at the begining of each clock cycle, new values are computed, then the new results are written back into the buffers at the end of each clock cycle. We have implemented a prototype synthesizer that is capable of automatically generating synchronous, fully pipelined implementations of modular specifications. This paper presents experimental results from this synthesizer.	algorithm;clock signal;modular design;prototype	Maria-Cristina V. Marinescu;Martin C. Rinard	1999			computer architecture;computer science;operating system;modular design	EDA	6.184159510078956	51.256570009637365	168323
966eca7a83440839daee548420a4f4f44e00b73e	microcode development for microprogrammed processors	efficient microprogam;microprogrammed processor;instruction set processor;functional simulator module;top-down design automation tool;microcode development module;digital system design;hardware description language;microcode development;interactive computer-aided design environment;design automation;computer aided design;top down	The aim of this paper is to develop a top-down design automation tool for digital system design such as microprogrammed processors. The package contains a hardware description language to specify the design, a microcode development module to generate an efficient microprogam for the microprogrammed processor's control, and a functional simulator module to verify the validity of the design. The goal of this project is to develop an interactive computer-aided design environment for specification, design and verification of instruction set processors.	central processing unit;computer-aided design;digital electronics;hardware description language;microcode;systems design;top-down and bottom-up design	Jerry P.-C. Hwang;Christos A. Papachristou;Danny D. Cornett	1985		10.1145/18927.18921	computer architecture;parallel computing;electronic design automation;computer science;computer aided design;top-down and bottom-up design;hardware description language;programming language	EDA	7.535116689621957	51.46368477747547	168663
a019cfd3c18f7cdd75ba55ca13a3104f31155229	hardware prototype to emulate the dynamics of power system generators with field programmable analog arrays	generators;power system dynamics hardware prototypes power generation field programmable analog arrays power system analysis computing space technology analog computers graphical user interfaces application software;power system generators;field programmable analog arrays;prototypes;power systems;power system dynamics;vlsi design;power systems electric generators field programmable analogue arrays;field programmable analogue arrays;fpaa;computational modeling;field programmable analog array;fpaa hardware prototype power system generators field programmable analog arrays dynamic behavior vlsi;power system;hardware prototype;vlsi;electric generators;hardware;dynamic behavior	This paper is an extension of the authors' previous works in the area of field programmable analog arrays (FPAA). It presents the design, construction, and testing of an FPAA-based hardware prototype to emulate the dynamic behavior of a basic power system generator. The programmable nature of the FPAA is key — significantly reducing the effort and time required to develop a working prototype and VLSI design.	field-programmable analog array;prototype;very-large-scale integration	Anthony S. Deese;Juan C. Jiménez;Jon Berardino;Chika O. Nwankpa	2010	Proceedings of 2010 IEEE International Symposium on Circuits and Systems	10.1109/ISCAS.2010.5537072	embedded system;electronic engineering;computer science;engineering;electrical engineering;very-large-scale integration;electric power system;computer engineering;field-programmable analog array	Arch	9.212941809056986	51.31285189988182	169031
5ffb56b26a7d6cd833310437b655347bc6bdcffc	energy advantages of microprocessor platforms with on-chip configurable logic	energy conservation;microprocessors hardware logic design decoding system on a chip benchmark testing logic testing field programmable gate arrays logic gates cyclic redundancy check;chip;embedded systems;system on chip;microprocessor platforms on chip configurable logic fpga system chips energy consumption executing software performance critical loops energy savings embedded system benchmarks;field programmable gate arrays system on chip energy conservation embedded systems microprocessor chips;power consumption;field programmable gate arrays;microprocessor chips	forms is the integration of on-chip, configurable logic (also known as FPGAs) with a microprocessor. Examples include 8-bit platforms, such as Triscend’s E5 and Atmel’s FPSLIC (FieldProgrammable System-Level IC); and 32-bit platforms, such as Triscend’s A7, Xilinx’s Virtex II Pro, and Altera’s Excalibur. A main benefit of on-chip configurable logic is that it supports the incorporation of different peripherals in the design; rather than having a different chip for each of various sets of peripherals, vendors can offer a single chip. Designers can also use configurable logic to implement coprocessors that would otherwise require a separate ASIC chip. We propose yet another use of configurable logic: reducing the energy consumed by the microprocessor in executing software. With the rapid increase in battery-operated systems, low energy consumption is becoming increasingly important. Our partitioning approach involves profiling an application to identify the critical loops— those that contribute the most to an application’s execution time. Instead of allowing these loops to execute in software, we reimplement them in hardware, using the configurable logic. We modify the original software by replacing the loop with code to enable the configurable logic, and to stall the microprocessor and put it into a power-down sleep mode. When the configurable logic finishes execution, it signals an interrupt that causes the microprocessor to resume normal execution. This approach speeds up an application’s execution time, meaning we can put the microprocessor in an inactive, low-power state for longer periods of time. Alternatively, we can execute the loop in the same amount of time with the same performance by slowing down the clock and reducing the microprocessor’s supply voltage. Lower voltage results in less energy. Using an ASIC coprocessor to reduce energy consumption is common.1,2 But, because of configurable logic’s high power consumption, partitioning that uses configurable logic has mainly targeted speedup.3-5 Energy is the product of power and time, so the power increase from using configurable logic could outweigh the time savings. In this article, derived from a paper presented at the 2002 IEEE Symposium on Field-Programmable Custom Computing Energy Advantages of Microprocessor Platforms with On-Chip Configurable Logic Platform-Based Design of SoCs	32-bit;8-bit;application-specific integrated circuit;coprocessor;field-programmable gate array;interrupt;low-power broadcasting;microprocessor;peripheral;platform-based design;profiling (computer programming);run time (program lifecycle phase);sleep mode;virtex (fpga);yet another	Greg Stitt;Frank Vahid	2002	IEEE Design & Test of Computers	10.1109/MDT.2002.1047742	chip;system on a chip;embedded system;computer architecture;real-time computing;logic optimization;energy conservation;logic gate;logic family;programmable logic array;computer science;engineering;programmable logic device;simple programmable logic device;field-programmable gate array	EDA	7.381632608989715	50.027859056923305	169810
244ace0f99f58808f57d415a6b340b35fcf7b7c6	run-time self-reconfigurable 2d convolver for adaptive image processing	tratamiento paralelo;systeme temps reel;parallelisme;software;digital signal processing;field programmable gate array;evaluation performance;diseno circuito;random access memory;haute performance;sum of products;static random access memory;memoria acceso directo;performance evaluation;image processing;traitement parallele;systeme embarque;integrated circuit;diminution cout;run time self reconfiguration;execution time;partial reconfiguration;logiciel;dynamic reconfiguration;flexibilidad;reconfigurable architectures;implementation;evaluacion prestacion;circuit design;procesamiento imagen;real time processing;circuito integrado;memoire acces direct statique;real time embedded system;fpga;red puerta programable;memoria no volatil;reseau porte programmable;traitement image;embedded system;tratamiento tiempo real;embedded systems;traitement temps reel;parallelism;memoire non volatile;run time reconfigurable;paralelismo;modelo 2 dimensiones;memoire acces direct;non volatile memory;modele 2 dimensions;alto rendimiento;on the fly;digital signal processor;cost effectiveness;logicial;hardware design;temps execution;2d convolver;flexibilite;real time system;conception circuit;sistema tiempo real;processeur signal numerique;procesador senal numerica;tiempo ejecucion;implementacion;reduccion costes;real time image processing;high performance;architecture reconfigurable;cost lowering;parallel processing;two dimensional model;circuit integre;flexibility	Two-dimensional (2D) convolution is a basic operation in digital signal processing, especially in image and video applications. Although its computation is conceptually simple, a sum of products of constants by variables, its implementation is highly demanding in terms of computational power, especially when addressed to real-time embedded systems. This work brings an innovative approach oriented to dynamically reconfigurable hardware. A flexible 2D convolver is deployed on a SRAM-based FPGA split in two parts: a static region and a partially reconfigurable region (PRR). Just to provide a universal solution, all the configurable aspects of the convolver (kernel dimensions, operands resolution, constant coefficients, pipeline stages, etc.) fit allocated in the PRR. In this way, the computer can self-adapt its structure on the fly, according to the characteristics of the image to be processed each time. Although there are many research articles in the literature encompassing the design of 2D convolution computers, to the best of the authors’ knowledge, this is the first work that implements a 2D convolver based on run-time reconfigurable hardware, while other approaches synthesize it either directly in software or in hardware as fully static designs. This pioneer alternative – exploiting key implementation aspects like parallelism, pipeline, flexibility and functional density – overcomes both computational performance of software solutions and cost-effectiveness of static hardware designs, while delivering an outstanding level of adaptability. The balanced time-area trade-off achieved with this technology makes it appropriate for high-performance low-cost embedded systems. & 2010 Elsevier Ltd. All rights reserved.	abstraction layer;algorithm;central processing unit;coefficient;computation;computer;convolution;digital signal processing;electronic circuit;embedded system;field-programmable gate array;hardware description language;high-level programming language;image processing;library (computing);logic level;on the fly;online and offline;operand;parallel computing;partial template specialization;pipeline (computing);production rule representation;real-time clock;real-time computing;real-time transcription;reconfigurability;reconfigurable computing;run time (program lifecycle phase);scalability;scientific literature;self-reconfiguring modular robot;static random-access memory;xfig	Francisco Fons;Mariano Fons;Enrique Cantó	2011	Microelectronics Journal	10.1016/j.mejo.2010.08.008	embedded system;parallel processing;parallel computing;real-time computing;image processing;computer science;field-programmable gate array	EDA	2.881081362833815	47.33895588100142	170869
8ffbca3558a269d68c29ca733ed53e2324d2ca71	using source-level transformations to improve high-level synthesis debug and validation on fpgas	debugging;hls;simulation;fpga;high level synthesis	This paper proposes a method for extending source-level visibility into the RTL of an HLS-generated design using automated source-level transformations. Using our method, source-level visibility can be extended into co-simulation, in-system simulation, and hardware execution of any HLS tool that provides the ability to infer top-level ports. Experimental results show the feasibility of our method in situations where visibility needs to be added without modifying the timing, latency, or throughput of the design.	co-simulation;debug;field-programmable gate array;high-level synthesis;simulation;throughput	Joshua S. Monson;Brad L. Hutchings	2015		10.1145/2684746.2689087	embedded system;parallel computing;real-time computing;computer science;high-level synthesis;debugging;field-programmable gate array	EDA	3.362043709945393	51.60647376175458	170885
2516997c9461e1d7b9a0d83d001a1adc79293ad8	a new strategy for library-independent layout design	general gate array design system;circuit layout cad;layout synthesis;emitter-coupled logic;library-independent layout design;ggads;logic arrays;configurable gate array master structures;logic partitioning;logic cad;ecl logic	Achim G. Ho mann University of New South Wales School of Cumputer Science and Engineering P.O. Box 1, Kensington, Sydney, NSW 2033, Australia Abstract A new strategy for layout synthesis is presented. The GGADS system which uses the strategy has been implemented and is capable of designing layouts for congurable gate array master structures. GGADS evaluates the e ectiveness of layouts on gate array master. Hence, it supports the development of special purpose gate array master structures. Furthermore, GGADS is suitable to layout circuits which are not tractable by library-based approaches, e.g. ECL logic.	cobham's thesis;emitter-coupled logic;gate array	Achim G. Hoffmann	1993			gate array;computer architecture;electronic engineering;logic gate;computer science;engineering;computer engineering	EDA	9.236392181037097	51.451818361924886	170928
2cdc7e27b5d67957d32be9cd1849245dba1b484f	signal processing implementation with a dual-bank memory	signal processing	Fast digital signal processing (DSP) chips often lack facilities for general system control and therefore are used as subsystems in larger workstations. The signal processing capability of the system can be significantly enhanced if the signal processor and host processor are allowed to operate concurrently. This paper presents an implementation of a dual-bank data memory to enable parallel operations of a TMS32010 DSP chip and a 68000 host processor. The multipass fast Fourier transform algorithm is divided into concurrent tasks for these processors. The results presented show an enhancement in processing speed.	signal processing	G. Umamaheswari;C. Eswaran;Ashok Jhunjhunwala	1988	Microprocessors and Microsystems - Embedded Hardware Design	10.1016/0141-9331(88)90164-0	multidimensional signal processing;embedded system;parallel computing;media processor;computer hardware;audio signal processing;computer science;signal chain;digital signal processing;signal processing;digital image processing	EDA	4.821608458913359	46.66363066333036	170956
6cd8c3ab46811bd83a286601d7962c50b6c8a03a	a scalable heterogeneous multicore architecture for adas: presented at hot chips: a symposium on high performance chips flint center, cupertino, ca	iso standards;advanced driver assistance systems;system on chip;scalability	This article consists of a collection of slides from the author's conference presentation. Agenda items include: highlight challenges of implementing Advanced Driver Assistance Systems (ADAS) in embedded systems; Discuss ADAS system options and compromises; High level overview of TDAx SOC; Mapping ADAS use cases to devices from TDAx SOC families.	architecture design and assessment system;embedded system;hot chips;multi-core processor;scalability	Zoran Nikolic;Rama Venkatasubramanian;Jason A. T. Jones;Peter Labaziewicz	2015	2015 IEEE Hot Chips 27 Symposium (HCS)	10.1109/HOTCHIPS.2015.7477330	embedded system;simulation;telecommunications;engineering	Embedded	4.608885190115377	50.276569985601526	171153
02070774d3dbd7d874c0c4c9679d9210c5c2bd09	measuring the routing costs of fpga circuit components			field-programmable gate array;routing	Michael J. Wirthlin;Navaneethan Sundaramoorthy	2000			computer science;field-programmable gate array;parallel computing;distributed computing;routing (electronic design automation)	EDA	5.556134811701074	50.22315707566456	171325
2cf3f60e7b4a447ec59ffcc83844b189233cf75c	the powerpc 603 c++ verilog interface model	object oriented model;programming language;object oriented programming virtual machines microprocessor chips c language object oriented languages;object oriented programming;verilog mode object oriented model powerpc 603 microprocessor verilog pli interface programming language interface behavioral model c simulation stand alone mode external environment procedural interface;c language;virtual machines;interface model;hardware design languages object oriented modeling power system modeling computational modeling microprocessors circuit simulation discrete event simulation clocks utility programs reduced instruction set computing;object oriented languages;microprocessor chips	Describes an object-oriented model of the PowerPC 603 microprocessor, and the incorporation of this model into Verilog using the Programming Language Interface (PLI). The model is behavioral and written in C++. It has a stand-alone mode with an external environment simulated in C++. In the Verilog mode, this external environment is disabled and would be simulated in Verilog. This paper discusses the stand-alone model, the procedural interface used to communicate with the external world, and the implementation of the Verilog PLI interface. It also discusses uses of the models in the two modes. >	c++;powerpc 600;verilog	Raymond P. Voith	1994		10.1109/CMPCON.1994.282909	interface description language;computer architecture;parallel computing;computer science;hardware description language;programming language	Logic	6.319455585735729	52.565625334245055	171881
12ad0541c4d4e4f2ccf20a5c5e84bbd4cf7ff35b	structured asic, evolution or revolution?	asic;structured asic	This paper describes the structured ASIC technology and impacts to the implementation flow. With an optimized and programmable structure, the structured ASIC technology indeed introduces a dramatically reduce ASIC cost and manufacturing turn-around time. While, the structured ASIC implementation flow is more complex than the conventional cell-based flow. There would be slightly impacts to structured ASIC implementation problems. Finally, the structured ASIC solutions provided by Faraday would be given. There are 3 structured ASIC solutions for customers' different applications. The three solutions are MPCA (Metal programmable Cell Array), MPIO (Metal Programmable I/O), and the structured ASIC platform. With the most competitive architecture, our customers can implement their ASIC at a lower cost with a faster turn-around-time.	application-specific integrated circuit;cell (microprocessor);evolution;faraday cage;input/output;multilinear principal component analysis;structured asic platform	Kun-Cheng Wu;Yu-Wen Tsai	2004		10.1145/981066.981088	embedded system;simulation;application-specific instruction-set processor;mathematics;application-specific integrated circuit;physics;fpga prototype	Networks	5.074833434732785	49.07835923272608	172503
a02d2fd4238650c02af8f5bc546889f8e048dd84	performance verification for esl design methodology from aadl models	xilinx zynq 7000 platform esl design methodology aadl models high quality designs rtl design v diagram performance verification process interconnected components software component modeling hardware component modeling spacestudio esl virtual platform motion jpeg video decoder application video thumbnails;systemes embarques;video coding embedded systems field programmable gate arrays motion estimation;computer architecture;monitoring;streaming media;performance verification requirements aadl esl virtual platform;genie logiciel;computer architecture hardware program processors monitoring field programmable gate arrays streaming media;field programmable gate arrays;program processors;hardware	One of the key issues to ensure high-quality designs is the verification methodology. The typical verification methodology used for RTL design is based on the V diagram. In this article we work at higher levels of abstraction (named ESL) by focusing on the performance verification process. A subsystem and its interconnected components are modeled with AADL. AADL also contains constructs for modeling both software and hardware components. Through the ESL virtual platform SpaceStudioTM, we can rapidly estimate the performance on different architectures. This performance verification flow has been experimented on a Motion-JPEG video decoder application for video thumbnails that targets a Xilinx Zynq-7000 platform.	architecture analysis & design language;diagram;electronic system-level design and verification;jpeg;principle of abstraction;register-transfer level;thumbnail;video decoder;virtual machine	Gaudron Mathieu;Bois Guy;Jérôme Hugues;Fellipe Monteiro	2015	2015 International Symposium on Rapid System Prototyping (RSP)	10.1109/RSP.2015.7416543	embedded system;computer architecture;real-time computing;computer science;operating system;high-level verification;field-programmable gate array	EDA	3.7427369382817304	51.910302644358396	173000
695c1c073e709e86e1878838ef12ab284ec87374	stimuli generation framework for testing multiple processes in vhdl	hardware verification;parallel processes;code coverage evaluation;test bench generation	Hardware Description Languages (HDL) like VHDL are used to design and simulate programmable logic devices. Usually the description of the device under test consists of several processes. This concept introduces problems of how to test and verify complex systems. In this paper, we present a new framework called TestBenchMulti that is able to generate test stimuli for parallel VHDL designs. The framework combines Control Flow Graphs (CFGs), extension of Symbolic Execution (SE) and Satisfiability Modulo Theories (SMT) into a sequence of methods to generate stimuli capable of obtaining high code coverage. The experiments were carried out on synthesizable VHDL circuits at the behavioural level. The obtained code coverage results were confirmed in the real implementation using Xilinx FPGA hardware.  DOI:  http://dx.doi.org/10.5755/j01.itc.43.4.7598	vhdl	Vacius Jusas;Tomas Neverdauskas	2014	ITC	10.5755/j01.itc.43.4.7598	computer architecture;parallel computing;real-time computing;vhdl;computer science;operating system;programming language;algorithm	Logic	5.633185570467423	52.04965297747004	173015
f6f87bf1ae005177fd1bcfa7f92bd50b7f75b320	service management: an interview with alan ganek	reconfigurable multiprocessor platform multiprocessor system on chip portable operating system interface standard multiprocessor hardware platform hardware dependent software;difference operator;software integration;software prototyping;multiprocessor systems;software management;design flow;service management;web service;interviews hardware operating systems application software software prototyping multiprocessing systems prototypes software standards system on a chip digital signal processors;system on chip multiprocessing systems software prototyping;hardware architecture;chip;general purpose processor;software management service management web services;operating system;system on chip;system design;software development;web services;digital signal processor;multiprocessor system on chip;multiprocessing systems;quality of service;strong coupling;reconfigurable hardware	"""A new multiprocessor system-on-chip prototyping flow based on the Portable Operating System Interface (Posix) standard and a multiprocessor hardware platform lets you quickly prototype Posix-based applications. Modern MPSoCs (multiprocessor systems on chip) contain a huge amount of software and rely on complex hardware components. As application complexity grows, programmable multiprocessor platforms are becoming more desirable. In fact, chips with several processors (such as general purpose processors and digital signal processors) are emerging in the industry, either for low-end applications such as audio codec or high-end applications such as video encoders. Reconfigurable hardware platforms recently emerged as effective solutions to validate and prototype MPSoC designs early in a design flow. Such prototyping platforms make simultaneous hardware and software development possible and enable early software design and debugging,1""""3 thus allowing for early software and hardware integration - which is the critical step in MPSoC system designs. Applications running on these new multiprocessor platforms usually require sophisticated multitasking operating systems to execute the system parts mapped to software. These operating systems provide a suitable abstraction, allowing easy development of application software.4 Using a standard API at this level makes this process even more effective and enhances software portability and reuse across different operating systems. However, the same portability doesn't apply from a hardware perspective, where changes to the underlying configurable hardware architecture are still seen as a major source of """"nonportability"""" and usually lead to long, tedious redesign cycles. MPSoC designers have recently introduced the concept of hardware-dependent software (HdS) to tackle such strong coupling between hardware and software within the lower system software layers.1 Here, we describe our experience in MPSoC prototyping using a multiprocessor operating system kernel that implements the Portable Operating System Interface (Posix) API standard on top of a reconfigurable multiprocessor platform using the HdS concept. (We chose Posix as the API owing to its wide acceptance and availability in many runtime environments.5) Investigating the complexity of hardware and software integration in multiprocessor system design, a process still not completely mastered in MPSoC design flows, helped us understand the duality between the low-level software layer (HdS) and the underlying hardware platform in the context of MPSoC design."""	application programming interface;central processing unit;codec;computer multitasking;debugging;digital signal processor;encoder;high- and low-level;kernel (operating system);mpsoc;multiprocessing;operating system;posix;prototype;software design;software development;software portability;system integration;system on a chip;systems design	Dejan S. Milojicic	2007	IEEE Distributed Systems Online	10.1109/MDSO.2007.29	web service;hardware compatibility list;embedded system;computer architecture;real-time computing;computer science;operating system;hardware architecture;distributed computing;law	Arch	3.3220453662155833	50.33305590083477	173740
415285dde000a9eee3b886780fec2b02f5b54aff	customised soft processor design: a compromise between architecture description languages and parameterisable processors	customised soft processor development environment;field programmable gate array;extensible markup language;tone mapping algorithm;sobel edge detection algorithm;xml based description format;soft processor design;performance per cost ratio;architecture description language;instruction set description;logic design embedded systems field programmable gate arrays hardware description languages instruction sets;microarchitectural customisation technique;microarchitectural parameter;polycusp environment;processor customisation;polytechnique customised soft processor;datapath customisation;customisation flexibility;design space exploration;customisation complexity;design complexity;instruction set modelling;parameterisable processor;field programmable gate array soft processor design architecture description language parameterisable processor processor customisation customised soft processor development environment polytechnique customised soft processor polycusp environment adl design space exploration customisation flexibility instruction set description datapath customisation microarchitectural parameter microarchitectural customisation technique xml based description format extensible markup language instruction set modelling design complexity customisation complexity sobel edge detection algorithm performance per cost ratio tone mapping algorithm fpga based embedded system design;fpga based embedded system design;adl	Processor customisation is an effective technique to enhance performance across an application domain. In this study, the authors present a new customised soft processor development environment called polytechnique customised soft processor (PolyCuSP), which bridges the gap between architecture description languages (ADLs) and extensible soft processors. The main objective of this environment is to facilitate rapid design space exploration while preserving a wide range of customisation flexibility. For this purpose, PolyCuSP offers full flexibility in instruction-set description, while limiting the datapath customisation to a predefined set of tunable microarchitectural parameters. The environment avoids extensive datapath description that is unnecessary for usual microarchitectural customisation techniques in order to simplify the development process. A new XML-based description format is introduced for instruction-set modelling. Experimental results evaluate and compare the design and customisation complexities offered by PolyCuSP with competitive approaches. Results demonstrate the efficiency of applying customisation techniques in the proposed environment. For the Sobel edge detection algorithm, the results show that microarchitectural tuning and instruction-set architecture customisation improve the performance-per-cost ratio by an average of 44 and 27%, respectively. Furthermore, in a case study of a tone-mapping algorithm, PolyCuSP achieves an average improvement of 38% in performance-per-cost ratio over an ADL-based design applying the same customisations.	algorithm;application domain;architecture description language;central processing unit;datapath;design space exploration;edge detection;microarchitecture;personalization;processor design;sobel operator;tone mapping;xml	Shervin Vakili;J. M. Pierre Langlois;Guy Bois	2013	IET Computers & Digital Techniques	10.1049/iet-cdt.2012.0088	embedded system;architecture description language;computer architecture;parallel computing;xml;activities of daily living;computer hardware;computer science;operating system;field-programmable gate array	EDA	2.9839961043538397	50.02577654888514	174084
a9acef36f52261c6c7c9695b43a8626b9861c825	fine-grain reconfigurable functional unit for embedded processors	look up table;rfu fine grain reconfigurable functional unit embedded processors word oriented microprocessors reconfigurable architectures elementary reconfigurable cells look up tables lut;reconfigurable architectures;table lookup embedded systems microprocessor chips reconfigurable architectures;embedded systems;reconfigurable architecture;settore ing inf 01 elettronica;program processors hardware signal processing algorithms table lookup arrays microprocessors;table lookup;embedded processor;reconfigurable functional unit;microprocessor chips	In standard word-oriented microprocessors, the processing of short data decreases the computation performance. In order to overcome this issue various methods based on reconfigurable architectures have been presented in the literature [1] [2] [3]. These structures are normally composed by an array of elementary reconfigurable cells. A common solution for elementary reconfigurable cells realization is based on Look-Up Tables (LUTs). In [4] [5] the authors proposed a new Reconfigurable Functional Unit (RFU) based on full adders and reprogrammable interconnects named ADAPTO. The final aim is to obtain a new structure that requires less silicon area and power, being ever faster than the “traditional” solutions. In this paper we present the main characteristics of the proposed structure evaluating its performance (in terms of speed-up and complexity) when integrated in an embedded processor.	adder (electronics);array data structure;central processing unit;complexity;computation;electrical connection;embedded system;execution unit;microprocessor;reconfigurable computing;speedup	Gian-Carlo Cardarilli;Luca Di Nunzio;Rocco Fazzolari;Marco Re	2011	2011 Conference Record of the Forty Fifth Asilomar Conference on Signals, Systems and Computers (ASILOMAR)	10.1109/ACSSC.2011.6190048	computer architecture;parallel computing;real-time computing;computer science	EDA	6.7267694145497705	46.441649524045246	174825
32cca46812ed3ebe3dd4f6a84d1d1e3024fed598	a case study on modeling shared memory access effects during performance analysis of hw/sw systems	electrical capacitance tomography;task classification model;programming environments;shared memory;performance evaluation;computer aided software engineering performance analysis hardware electrical capacitance tomography national electric code software performance timing read only memory operating systems tcpip;performance estimation;hw sw systems;tcpip;real time operating system;system level performance analysis;system level design trade offs;software performance;high level synthesis;network interfaces;computer aided software engineering;rapid prototyping;shared memory systems;polis co design environment;design environment;tcp ip;shared memory systems network interfaces high level synthesis programming environments performance evaluation;system level design;shared memory access;performance analysis;performance model;network interface system;shared memory buses;ip networks;national electric code;behavioral simulation;shared memory bus;timing annotations;performance modeling;sdl;read only memory;communication synthesis;shared memory bus shared memory access performance analysis hw sw systems behavioral simulation timing annotations performance modeling system level design trade offs polis co design environment shared memory buses system level performance analysis tcp ip network interface system;hard real time;operating systems;hardware;timing	Behavioral simulation with timing annotations derived from performance modeling and analysis is a promising alternative for use in evaluating system-level design trade-offs. The accuracy of such approaches is determined by how well the effects of various HW and SW architectural features, like the Real Time Operating System (RTOS), shared memories and buses, HW/SW communication mechanisms, etc are modeled at this level. We present a study of the effects of shared memory buses during system-level performance analysis in the POLIS co-design environment using the example of a TCP/IP Network Interface System. We demonstrate how the effects of the memory arbiter and shared memory bus can be modeled efficiently at the behavioral level, and used to evaluate various design tradeoffs. Experimental results demonstrate that modeling these effects can significantly increase the accuracy of system-level performance estimates.	profiling (computer programming);shared memory;shattered world	Marcello Lajolo;Anand Raghunathan;Sujit Dey;Luciano Lavagno;Alberto L. Sangiovanni-Vincentelli	1998		10.1109/HSC.1998.666248	embedded system;parallel computing;real-time computing;computer science	HPC	3.7517162711863272	53.29662386253363	175126
0b6aa21fc8f27861147ecd6704c5e671fe1d61c6	the use of software simulators in the testing and debugging of microprogram logic	debugging;software testing;design engineering;testing and debugging;testing;processor simulation;computer architecture;computational modeling;logic testing;system testing;software debugging;testing debugging microprogramming processor simulation;microprogramming;microcomputers;hardware	Recent trends in computer architecture have increased the amount of control logic (e.g., microinstructions) in digital systems, thus making testing and debugging a more formidable task. This correspondence discusses the needs and objectives of software simulators for testing and debugging microprogram logic, and discusses a simulator developed to aid the development of a large microprogrammed system.	computer architecture;debugging;digital electronics;logic simulation;microcode	Glenford J. Myers;David G. Hocker	1981	IEEE Transactions on Computers	10.1109/TC.1981.1675831	computer architecture;parallel computing;software performance testing;system integration testing;computer science;software reliability testing;operating system;software construction;software testing;real-time testing;algorithmic program debugging;programming language;background debug mode interface;debugging	SE	7.780880718701485	52.085288645172426	175353
fe32ecbcae0f46539c151a35167f8ae3a3e573c2	instruction set extension in the nios ii: a floating point divider for complex numbers	software;complex numbers instruction set extension floating point divider clock frequency processor instruction set instruction multicycle nios ii soft processor embedded systems custom instruction;floating point divider;clocks;power efficiency;complex numbers;hardware clocks registers assembly adders software computer architecture;embedded system;instruction multicycle;chip;assembly;custom instruction;computer architecture;embedded systems;instruction set extension;microprocessor chips embedded systems floating point arithmetic instruction sets;nios ii soft processor;registers;adders;power dissipation;processor instruction set;floating point;floating point arithmetic;clock frequency;microprocessor chips;instruction sets;hardware	As increasing the clock frequency leads to unmanageable heat and power dissipation the search is on for another way to get more power efficient and faster embedded systems. Given that chip area is also a constraint, we investigate the addition of a custom instruction to the processor instruction set which enables the execution of an efficient complex division. The instruction we designed is a hardware divider for complex numbers which receives four input values and returns two output values. The data bandwidth constraint of 2 inputs and 1 output is loosened by making the instruction multicycle as described in previous work. We uses the custom instruction interface of the NIOS II soft processor and achieve a speedup of up to 3x over the unmodified instruction set.	american and british english spelling differences;clock rate;computation;embedded system;mimo;pipeline (computing);pipelining (dsp implementation);signal processing;speedup	Philipp Digeser;Marco Tubolino;Martin Klemm;Daniel Shapiro;Miodrag Bolic	2010	CCECE 2010	10.1109/CCECE.2010.5575173	computer architecture;parallel computing;application-specific instruction-set processor;computer hardware;computer science;floating point;minimal instruction set computer;operating system;instruction set;instruction register;orthogonal instruction set	Arch	5.6924690001666685	48.516005917214514	175843
f7e87fac296e75087f95f13bb75e867e9d90e189	s. sutherland, s. davidman and p. flake, system verilog for design: a guide to using system verilog for hardware design and modeling hardcover, kluwer academic publishers, norwell, ma (2004) isbn 1-4020-7530-8 pp 374, plus xxviii, euro 119		In a high speed automatic fine wire bonding machine of the type adapted to produce a wire interconnection between two bonding points on a semiconductor device there is provided a method of making consistent, exact predetermined lengths of wire under the working face of a bonding tool after a second bond is finished and in preparation for making the next first bond of a wire interconnection.	flake (software);international standard book number;n-flake;systemverilog;verilog	Mile K. Stojcev	2006	Microelectronics Reliability	10.1016/j.microrel.2005.06.012	engineering physics	EDA	9.88183067640245	53.17884366690777	176300
4be23fe76d2dae26c6bdacb4bc1f16f782ae4fa2	on-the-fly verification of reconfigurable image processing modules based on a proof-carrying hardware approach		Proof-carrying hardware is an approach that has recently been proposed for the efficient verification of reconfigurable modules. We present an application of proof-carrying hardware to guarantee the correct functionality of dynamically reconfigured image processing modules. Our prototype comprises a reconfigurable-system-on-chip with an embedded virtual FPGA fabric. This setup allows us to leverage open source FPGA synthesis and backend tools to produce FPGA configuration bitstreams with an open format and, thus, to demonstrate and experimentally evaluate proof-carrying hardware at the bitstream level.	image processing	Tobias Wiersema;Sen Wu;Marco Platzner	2015		10.1007/978-3-319-16214-0_32	high-level verification;intelligent verification	EDA	3.979246985129761	51.02833623987484	177308
5738a119f614e94121d3507afb1d7137c1a5ec1c	a web eda tool for the automatic generation of synthesizable vhdl architectures for a rapid design space exploration	generators hardware design languages vectors data structures space exploration adders integrated circuit modeling;web eda tool parametrized netlist generators skeleton test benches multiple vhdl files compact netlist format hardware description languages circuit methodology rapid design space exploration synthesizable vhdl architecture automatic generation;network synthesis electronic design automation hardware description languages internet	Design space exploration of new circuit methodologies require the creation of models in hardware description languages to evaluate the characteristics for different parameters, a time consuming process. To alleviate the burden of HDL construction, we present a compact netlist format and a web tool that creates syntactically correct VHDL files. The designer can use our tool, together with an easy to create netlist generator, to quickly create multiple VHDL files and skeleton test benches, to evaluate his model. Our parametrized netlist generators illustrate the efficiency of our EDA tool.	design space exploration;hardware description language;logic synthesis;netlist;vhdl	Minas Dasygenis	2014	2014 9th IEEE International Conference on Design & Technology of Integrated Systems in Nanoscale Era (DTIS)	10.1109/DTIS.2014.6850659	embedded system;computer architecture;parallel computing;netlist;computer science;register-transfer level	EDA	6.105567104610526	52.86417164363069	177924
ca5d969a6fb4ab35c719ed66a54e20d85de57ae2	pad structures for the rainbow workstation			rainbow 100;workstation	B. A. Styne;T. R. King;Neil E. Wiseman	1985	Comput. J.	10.1093/comjnl/28.1.68	embedded system;computer hardware;operating system	Logic	4.870151034092878	48.57859764702473	178253
5f8c581fa95dae3b9837aab7fda0b784a331b796	explorations in design space: unconventional electronics design through artificial evolution	tolerancia falta;electronic circuit;space exploration hardware evolutionary computation algorithm design and analysis electronic circuits design methodology robot control robot sensing systems field programmable gate arrays process design;concepcion circuito;design automation;software tool;design process;evolutionary computation;fault tolerant;circuit design;circuito electronico;hardware tools design space exploration unconventional electronics design artificial evolution evolutionary algorithms reconfigurable hardware controller tone discriminator circuit fpga nonbehavioral requirements fault tolerance software tools;indexing terms;design space;fault tolerant computing;conception electronique;design method;estudio caso;methode conventionnelle;fault tolerance;espace conception;etude cas;electronic design automation evolutionary computation fault tolerant computing field programmable gate arrays software tools;algorithme evolutionniste;algoritmo evolucionista;conception circuit;software tools;evolutionary algorithm;field programmable gate arrays;artificial evolution;evolutionary theory;circuit electronique;reconfigurable hardware;tolerance faute;conception numerique;electronic design automation	"""Three hypotheses are formulated. First, in the """"design space"""" of possible electronic circuits, conventional design methods work within constrained regions, never considering most of the whole. Second, evolutionary algorithms can explore some of the regions beyond the scope of contentional methods, raising the possibility that better designs can be found. Third, evolutionary algorithms can in practice produce designs that are beyond the scope of conventional methods, and that are in some sense better. A reconfigurable hardware controller for a robot is evolved, using a conventional architecture with and without orthodox design constraints. In the unconstrained case, evolution exploited the enhanced capabilities of the hardware. A tone discriminator circuit is evolved on an FPGA without constraints, resulting in a structure and dynamics that are foreign to conventional design and analysis. The first two hypotheses are true. Evolution can explore the forms and processes that are natural to the electronic medium, and nonbehavioral requirements can be integrated into this design process, such as fault tolerance. A strategy to evolve circuit robustness tailored to the task, the circuit, and the medium, is presented. Hardware and software tools enabling research progress are discussed. The third hypothesis is a good working one: practically useful but radically unconventional evolved circuits are in sight."""	electronic design automation;evolutionary algorithm	Adrian Thompson;Paul J. Layzell;Ricardo Salem Zebulum	1999	IEEE Trans. Evolutionary Computation	10.1109/4235.788489	fault tolerance;simulation;electronic design automation;computer science;artificial intelligence;machine learning;evolutionary algorithm;algorithm	EDA	9.422992598820422	49.06936811444054	178540
f32f2fff88fc1fbe4cfaa77895f17961e597e1f8	a multimicroprocessor system for real-time classification of railroad track flaws	real time;multiple processor;pattern recognition;real time system;pipeline system;real time system multiple processor pattern recognition pipeline system railroad track flaws;railroad track flaws	A multiple microprocessor system is described which was developed for real-time detection and classification of railroad track flaws. Multiple processors were necessary to achieve the desired test vehicle velocity while maintaining the desired density (rate) of testing. The system is organized logically as a tree-structured pipeline of processing stages where the effective data rate from data input toward classification decision output is successively reduced as processing function potential is increased. A corresponding partitioning of the pattern recognition process was organized as a set of hierarchies, where successive patterns are modeled as regular probabilistic grammars and their recognizers implemented as finite state procedures. Interprocessor communications was achieved using shared (2-port) memories. A system prototype was designed and implemented, using real-time data from earlier work to ensure a performance level equivalent to a vehicle velocity of 40 km/h. The resulting system, while applied to a railroad track problem, is applicable to other real-time environments, with suitable parameterization.	central processing unit;data rate units;finite-state machine;microprocessor;pattern recognition;probabilistic automaton;prototype;real-time clock;real-time computing;real-time data;velocity (software development)	Howard A. Sholl;Kevin Morris;James Norris	1982	IEEE Transactions on Computers	10.1109/TC.1982.1675910	embedded system;parallel computing;real-time computing;simulation;real-time operating system;computer science	Embedded	3.0667802723961084	52.19571279378479	179519
96b1bddf40cbefdb3dc097a0cf71941e442c2f6f	ant colony optimization algorithm design and its fpga implementation	sopc ant colony algorithm fpga hardware software codesign;ant colony optimisation;mathematics computing;hardware software codesign;hardware description languages;nios ii processor ant colony optimization hardware software codesign fpga chip c language hardware description language verilog hdl sopc system on a programmable chip path selecting path analysis;programmable circuits ant colony optimisation c language field programmable gate arrays hardware description languages hardware software codesign mathematics computing microprocessor chips;c language;programmable circuits;hardware software algorithm design and analysis software algorithms field programmable gate arrays robots path planning;field programmable gate arrays;microprocessor chips	In this paper, a Hardware/Software (HW/SW) co-design method of ant colony optimization (ACO) algorithm is proposed to implement on the FPGA chip. In this paper, the software is designed with C language and hardware is designed with Verilog hardware description language (HDL). The HW/SW co-design method is a technique based on a SOPC (System on a Programmable Chip). In this paper, the path selecting and path analysis are designed in SOPC. The path selecting belongs to the pre-processing of the ACO algorithm and it cost a longer computing processing time. Therefore, a hardware circuit is designed to speed up processing. The path analysis will be designed by the C language within the NIOS II processor. In the experimental results, the processing time can be reduced by the proposed method.	algorithm design;ant colony optimization algorithms;electronic circuit;field-programmable gate array;hardware description language;mathematical optimization;path analysis (statistics);preprocessor;verilog	Shih-An Li;Min-Hao Yang;Chung-Wei Weng;Yi-Hong Chen;Chia-Hung Lo;Ching-Chang Wong	2012	2012 International Symposium on Intelligent Signal Processing and Communications Systems	10.1109/ISPACS.2012.6473492	embedded system;computer architecture;parallel computing;computer science;hardware architecture	EDA	9.890889412663748	48.82181280939762	179596
e2101cec94829645807b5b717f7cf0595474e5e2	high speed fpga-based data acquisition system		An application that involves high speed signal changes at input side makes it very important to have a high speed Data Acquisition without loss of any data. This paper discusses FPGA design architecture programed by VHDL firmware which involves high speed Analog to digital converter (ADC) with sampling rate of 80 mega samples per second, Direct Memory Access (DMA) programed in such a way which transfers data without loss of single data sample and high speed Dual Data Rate 3 (DDR3) SDRAM to store digitized data for further manipulations. It also describes data-rate, and speed achieved to transfer data and plot a graph of digital value which shows there is no loss of data.	data acquisition;field-programmable gate array	Aboli Audumbar Khedkar;R. H. Khade	2017	Microprocessors and Microsystems - Embedded Hardware Design	10.1016/j.micpro.2016.11.006	embedded system;parallel computing;computer hardware;computer science;operating system	EDA	7.04348838182999	47.797541048255866	179844
4ad42722c4081d32b40dc277b3006bc044d1dc8b	design of an automotive traffic sign recognition system targeting a multi-core soc implementation	automobiles;field programmable gate arrays;image recognition;integrated circuit design;microprocessor chips;multiprocessing systems;road traffic;fpga;analysis strategy;automotive traffic sign recognition system design;model-based performance evaluation;multicore soc;real-time operating system;system-level design process	This paper describes the design of an automotive traffic sign recognition application. All stages of the design process, starting on system-level with an abstract, pure functional model down to final hardware/software implementations on an FPGA, are shown. The proposed design flow tackles existing bottlenecks of today's system-level design processes, following an early model-based performance evaluation and analysis strategy, which takes into account hardware, software and real-time operating system aspects. The experiments with the traffic sign recognition application show, that the developed mechanisms are able to identify appropriate system configurations and to provide a seamless link into the underlying implementation flows.	electronic system-level design and verification;experiment;field-programmable gate array;function model;level design;multi-core processor;performance evaluation;real-time operating system;real-time transcription;seamless3d;system on a chip;traffic sign recognition	Matthias Müller;Axel G. Braun;Joachim Gerlach;Wolfgang Rosenstiel;Dennis Nienhüser;Johann Marius Zöllner;Oliver Bringmann	2010	2010 Design, Automation & Test in Europe Conference & Exhibition (DATE 2010)		embedded system;electronic engineering;real-time computing;real-time operating system;computer science;engineering;electrical engineering;operating system;field-programmable gate array	EDA	3.810692264379643	52.75198145014893	179915
69607bd8591084211267ba14af73564ffe4ce82c	interfacing the transputer to the tms320 in an image processing environment	image processing	Abstract   This paper describes a technique for interfacing the Texas Instruments TMS320 series of digital signal processing microprocessors to the Inmos transputer. This has been developed for an image processing/understanding architecture whose guiding principles are that it should operate in real time and be constructed from commercially available devices, for reasons of cost and design time. The interface is flexible and may be used for one-to-one, many-to-one or one-to-many TMS320 to transputer connections and provides a two-way communications link, though with the emphasis on the TMS320 to transputer direction, as this will be the primary direction of flow of information in the intended application.	image processing;texas instruments tms320;transputer	Mark B. Sandler	1988	Microprocessors and Microsystems - Embedded Hardware Design	10.1016/0141-9331(88)90114-7	embedded system;real-time computing;computer hardware;image processing;computer science	EDA	5.816158305642672	48.19931444361056	180424
59f73ef8df116fe5f3df9df005c61d23d37860e2	automatic optimization of hardware accelerators for image processing		In the domain of image processing, often real-time constraints are required. In particular, in safety-critical applications, such as X-ray computed tomography in medical imaging or advanced driver assistance systems in the automotive domain, timing is of utmost importance. A common approach to maintain real-time capabilities of compute-intensive applications is to offload those computations to dedicated accelerator hardware, such as Field Programmable Gate Arrays (FPGAs). Programming such architectures is a challenging task, with respect to the typical FPGA-specific design criteria: Achievable overall algorithm latency and resource usage of FPGA primitives (BRAM, FF, LUT, and DSP). High-Level Synthesis (HLS) dramatically simplifies this task by enabling the description of algorithms in well-known higher languages (C/C++) and its automatic synthesis that can be accomplished by HLS tools. However, algorithm developers still need expert knowledge about the target architecture, in order to achieve satisfying results. Therefore, in previous work, we have shown that elevating the description of image algorithms to an even higher abstraction level, by using a Domain-Specific Language (DSL), can significantly cut down the complexity for designing such algorithms for FPGAs. To give the developer even more control over the common trade-off, latency vs. resource usage, we will present an automatic optimization process where these criteria are analyzed and fed back to the DSL compiler, in order to generate code that is closer to the desired design specifications. Finally, we generate code for stereo block matching algorithms and compare it with handwritten implementations to quantify the quality of our results.	abstraction layer;algorithm;c++;ct scan;compiler;computation;digital subscriber line;domain-specific language;field-programmable gate array;high-level synthesis;image processing;mathematical optimization;medical imaging;real-time locating system;real-time transcription;tomography	Oliver Reiche;Konrad Häublein;Marc Reichenbach;Frank Hannig;Jürgen Teich;Dietmar Fey	2015	CoRR		embedded system;real-time computing;computer science;theoretical computer science;programming language	EDA	2.838076956851694	51.68490710153405	180449
21892c590df3587f0a49b936a6b98957a2c78fa4	an analysis of the propagation delay in reconfigurable processor arrays	propagation delay		propagation delay;reconfigurable computing;software propagation	Massimo Maresca;Pierpaolo Baglietto;A. Giordano	1993			parallel computing;computer science;propagation delay;reconfigurable antenna	EDA	5.784101335074127	50.11727791710305	180462
1b7e67bf3427a7743bfaa2a4ef9113e07fa9b1fb	a fine-grain phased logic cpu	logic design;flip flops;lookup table fine grain phased logic cpu early evaluation pipelined mips isa self timed logic design d flip flop logic gate netlist mapping control logic;logic gates microprocessor chips pipeline processing flip flops table lookup logic design;logic gates;phased logic;lookup table;programmable logic devices programmable logic arrays clocks logic design application specific integrated circuits costs design methodology logic devices table lookup automatic control;table lookup;flip flop;pipeline processing;microprocessor chips	A five-stage pipelined CPU based on the MIPs ISA is mapped to a self-timed logic family known as Phased Logic (PL). The mapping is performed automatically from a netlist of D-Flip-Flops and 4-input Lookup Tables (LUT4s) to a netlist of Phased Logic gates. Each PL gate implements a 4-input Lookup Table in addition to control logic required for the PL control scheme. PL offers a speedup technique known as Early Evaluation that can be used to boost performance at the cost of additional PL gates. Several different PL gate-level implementations are produced to explore different architectural tradeoffs using early evaluation. Simulations run for five benchmark programs show an average speedup of 1.48 over the clocked netlist at the cost of 17% additional PL gates.	benchmark (computing);central processing unit;clock rate;computer simulation;flops;logic family;logic gate;lookup table;netlist;pipeline (computing);speedup	Robert B. Reese;Mitchell A. Thornton;Cherrice Traver	2003		10.1109/ISVLSI.2003.1183355	and-or-invert;computer architecture;parallel computing;logic synthesis;real-time computing;nor logic;logic optimization;diode–transistor logic;logic level;logic gate;logic family;programmable logic array;computer science;programmable logic device;pass transistor logic;sequential logic;simple programmable logic device;digital electronics;programmable array logic;register-transfer level;resistor–transistor logic	Arch	6.942769821180708	50.94045015323849	180670
2cd6c63fce59789838c83c2489d380caf952e8c4	virtual machine code for embedded systems	virtual machine;embedded system		embedded system;machine code;virtual machine	Sung-Lim Yun;Dong-Keun Nam;Se Man Oh;Jung-Sook Kim	2004			full virtualization;pointer machine;computer architecture;embedded system;virtual finite-state machine;computer science;virtual machine	EDA	4.359325287537892	49.56323283275978	181525
aa54e2ef6d73b1e5d5fd92a78db4e3d08906b6ad	cast.fsm applied to vlsi synthesis: experimental results and requirements for industrial use	controller synthesis;industrial application;digital circuits;finite state machine	 Cast.fsm is a method bank for the treatment of finite state machines. In this paper we report on the practical application of Cast.fsm to the controller synthesis as part of the VLSI synthesis. We present experimental results for the algebraic decomposition and the shift register realization of the MCNC benchmark FSMs and controllers of digital circuits. Requirements for further developments with respect to industrial applications are discussed for the two specific methods used in this work as well as for CAST method banks in general.	requirement;very-large-scale integration	Martin Geiger	1991		10.1007/BFb0021033	computer science;finite-state machine;digital electronics	EDA	8.47818246964762	50.454714512273675	181589
f20e1452690a258810ce564c18fb68a220bad2d7	colif: a design representation for application-specific multiprocessor socs	soc architecture colif design representation application specific multiprocessor socs divide and conquer;divide and conquer methods;design representation;hardware computer architecture testing laboratories communication networks design methodology software tools;high level synthesis;multiprocessing systems;microprocessor chips high level synthesis divide and conquer methods multiprocessing systems;divide and conquer;microprocessor chips	ion levels for communication modeling Table 1 summarizes the semantics associated with Colif’s communication channels, or generalized nets, at the various abstraction levels. The service, message, and driver levels collectively constitute what is usually called the system level. Three features characterize communication channels: medium, data type, and behavior. The medium is the infrastructure for carrying data of a certain type while performing actions that transform this data. The behavior is the transformations performed on the data. The service level is the highest abstraction level with specified communication semantics. At this level, the design representation uses a combination of requests and services, and tasks can request services from one another. This model completely abstracts out the underlying protocols, connection topologies, and essential timing issues. The service level can support several time models based on the concurrency structure and local time capabilities of the tasks themselves. The Common Object Request Broker Architecture4 is a good example of the request-service model in the software domain. In Corba, programs or libraries register their services through descriptions in an interface definition language, and one or more object request brokers route communication between a mutual request-service pair. At the message level, hierarchical modules communicate through active channels that encapsulate all low-level protocol details. Active channels can abstract data and/or protocol conversions. Access ports provide methods such as send or receive of data; thus, tasks can use a high-level interface to access the active channels. Data can be generic, and its size is not necessarily predetermined, so communication time is nonzero and nondeterministic. The message level is a simple model, but changing the underlying semantics and channel behavior enables it to describe diverse communication schemes. Refining active channels into logical interconnections normally requires that a module describing the channel behavior act as a communication controller. An example of a message-level design model is the Specification and Description Language.5 SDL uses channels with the basic send or receive primitives and infinite queuing. Some projects have used this level for functional specification for synthesis, but they impose restrictions on the specification and communication.6 The popular remote procedure call (RPC) technique is often used to implement this level of communication.7 A driver-level design uses logical connections that exchange fixed, enumerated data types (such as integers and real numbers). The basic channel behavior is logical transmission according to a fixed protocol. Communication time is nonzero but predictable because the data size and structure and the transmission protocol are well known. Typical driver-level communication abstractions are master-slave buses and rendezvous or point-to-point communications based on first-in, first-out (FIFO) protocols. For a 13 September–October 2001 Table 1. Communication channel semantics at different abstraction levels. Abstraction Typical level Medium Data type Behavior primitive Exampleion Typical level Medium Data type Behavior primitive Example Service Abstract network Namespaces and Routing Request Corba abstract data types (service, data)data types (service, data) Message Active channels Concrete generic Protocol Send SDL data types conversion (data, disk) Driver Logical connections Fixed enumerated Logical Write Cossap, StateCharts, data types transmission (data, port) SystemC2.0 Register transfer Physical Fixed bit-vector Physical Set VHDL, Verilog, connections data representation transmission (value, port) SystemC0.9-1.0 Corba: Common Object Request Broker Architecture VHDL: VHSIC Hardware Description Language SDL: Specification and Description Language	abstract data type;abstraction layer;bit array;common object request broker architecture;concurrency (computer science);data (computing);fifo (computing and electronics);front-end processor;functional specification;hardware description language;high- and low-level;interface description language;level design;library (computing);multiprocessing;nondeterministic algorithm;point-to-point (telecommunications);remote procedure call;routing;specification and description language;subroutine;system on a chip;vhdl;vhsic;verilog;namespaces	Wander O. Cesário;Gabriela Nicolescu;Lovic Gauthier;Damien Lyonnard;Ahmed Amine Jerraya	2001	IEEE Design & Test of Computers	10.1109/54.953268	computer architecture;parallel computing;real-time computing;divide and conquer algorithms;computer science;high-level synthesis;programming language	PL	4.202645867259399	53.13717490819099	181603
340647c97d317828f758b9701c841d00dd1de3fe	a distributed memory mimd multi-computer with reconfigurable custom computing capabilities	distributed memory;distributed memory systems;reconfigurable architectures;man machine system;parallel architectures;distributed computing field programmable gate arrays reduced instruction set computing hidden markov models computer architecture communication cables application software computer performance computer applications sun;speech recognition;reconfigurable platform armstrong iii distributed memory mimd multi computer reconfigurable custom computing lems risc processor reconfigurable resources speech recognition;parallel architectures reconfigurable architectures distributed memory systems	Armstrong III* is a multi node multi-computer designed and built at the Laboratory for Engineering MardMachine System(LEMS) of Brown University. Each node contains a RISC processor and reconfigurable resources implemented with FPGAs. The primaly benefit in using FPGAs is that the resulting hardware is neither rigid nor permanent but is in-circuit reprogrammable. This allows each node to be tailored to the computational requirements of an application. This paper describes the Armstrong 111 architecture and concludes with a substantive example application that performs HMM Training for speech recognition with the reconfigurable platform.	armstrong's axioms;computation;distributed memory;field-programmable gate array;hidden markov model;mimd;requirement;speech recognition	Hyun-Kyu Yun;Harvey F. Silverman	1997		10.1109/ICPADS.1997.652523	computer architecture;parallel computing;real-time computing;distributed memory;reconfigurable computing;computer science;operating system;distributed computing	Robotics	2.9997357284605006	47.79134236656935	182509
9258253115b451373a11a7cb29f8f6e9aed5652a	accelerating statistical texture analysis with an fpga-dsp hybrid architecture	hardware software codesign;image processing;software libraries;data processing;chip;texture analysis;performance improvement;feature extraction;hybrid architecture;digital signal processor;floating point;high performance;real time application;hardware implementation	Nowadays, most image processing systems are implemented using either MMX-optimized software libraries or, when time requirements are limited, expensive high performance DSP-based boards. In this paper we present a texture analysis co-processor concept that permits the efficient hardware implementation of statistical feature extraction, and hardware-software codesign to achieve high-performance low-cost solutions. We propose a hybrid architecture based on FPGA chips, for massive data processing, and digital signal processor (DSP) for floating-point computations. In our preliminary trials with test images, we achieved sufficient performance improvements to handle a wide range of real-time applications.	computation;coprocessor;device driver synthesis and verification;digital signal processor;feature extraction;field-programmable gate array;image processing;library (computing);mmx (instruction set);real-time clock;requirement;signal processing	Francisco Ibarra Picó;Sergio Cuenca-Asensi;Víctor Córcoles López	2001	The 9th Annual IEEE Symposium on Field-Programmable Custom Computing Machines (FCCM'01)		chip;reference architecture;digital signal processor;data processing;image processing;feature extraction;floating point;hardware architecture	Arch	2.919571724482839	46.77257467968209	182882
260c70a3c2f49e70d25cd461fe87644c77583d01	use of microprocessor in real-time synthesis of sounds			microprocessor;real-time transcription	Sylviane Sapir;Ricard Kronland-Martinet	1982			microprocessor;computer hardware;computer science	Logic	5.118965769268904	48.96644414569485	183208
a95dd5ea1aa4395a1a7154acbb73c0287ee7fb96	creating 3d specific systems: architecture, design and cad	cad;digital signal processing chips;integrated circuit design;integrated memory circuits;logic circuits;logic design;stacking;three-dimensional integrated circuits;3d ic;3d stacking;cad;dsp;creating 3d specific systems;design planning;logic;memory;test management;thermal management;3d ic;3dic;tsv;memory on logic;stacked memor;three dimensional ic	3D stacking and integration can provide system advantages. Following a brief technology review, this abstract explores application drivers, design and CAD for 3D ICs. The main application area explored in detail is that of logic on memory. This application is explored in a specific DSP example. Finally critical areas that need better solutions are explored. These include design planning, test management, and thermal management.	automation;computer-aided design;dhrystone;digital signal processor;equalization (communications);microprocessor;rumble pak;solid-state drive;stacking;system on a chip;test management;thermal grease;thermal management of high-power leds;three-dimensional integrated circuit	Paul D. Franzon;William Rhett Davis;Thorlindur Thorolfsson	2010	2010 Design, Automation & Test in Europe Conference & Exhibition (DATE 2010)		embedded system;computer architecture;electronic engineering;computer science;engineering;stacking;cad;silicon;memory;logic;bandwidth;systems architecture;integrated circuit design;memory management	EDA	9.64275028032123	51.88613645518813	183601
3c6527c0e1f4ec6b8fcf94ef5175af74609df591	epiphany-v: a 1024 processor 64-bit risc system-on-chip		"""This paper describes the design of a 1024-core processor chip in 16nm FinFet technology. The chip ("""" Epiphany-V """") contains an array of 1024 64-bit RISC processors, 64MB of on-chip SRAM, three 136-bit wide mesh Networks-On-Chip, and 1024 programmable IO pins. The chip has taped out and is being manufactured by TSMC."""	64-bit computing;areal density (computer storage);central processing unit;epiphany eyewear;parallel computing;static random-access memory;system on a chip;tape-out	Andreas Olofsson	2016	CoRR		embedded system;parallel computing;real-time computing;telecommunications;engineering;electrical engineering;operating system	HPC	6.721899294110358	50.081763028434715	184638
f1eeeee9e328949ad78a882015a9b1932a32b5ff	from gates to embedded systems: a bottom-up approach to digital design	interrupt controller embedded systems digital design deeds educational tool sequential logic network microcomputer assembly programming combinational logic network quasi professional simulation features user interface learning environment logic gates laboratory;deeds;bottom up;logic design;sequential logic network;user interface;user interfaces computer aided instruction embedded systems logic design logic gates;computer aided instruction;state machine;interrupt controller;learning environment;embedded system;automata;embedded systems;computational modeling;combinational logic network;logic gates;quasi professional simulation features;digital design;embedded system logic programming microcomputers automata assembly programming profession user interfaces logic gates logic design solids;integrated circuit modeling;microcomputer assembly programming;laboratory;educational tool;logic gate;user interfaces;finite state machine;microcomputers;hardware	The paper presents Deeds, an educational tool for digital design. Deeds covers combinational and sequential logic networks, finite state machines, microcomputer assembly programming and interfacing. It provides quasi-professional simulation features with an extremely simple user interface. Deeds can be seen as a learning environment based on three simulators integrated together, associated with a large repository of application projects, available on the web. Deeds supports the learning of contemporary digital design, from logic gates to the basics of embedded systems, helping to build a solid foundation for further study. The paper contains an example of a laboratory session dealing with a system including a state machine, standard logic and a microcomputer with a simple interrupt controller.	assembly language;combinational logic;embedded system;finite-state machine;logic gate;logic synthesis;microcomputer;sequential logic;simulation;software repository;top-down and bottom-up design;user interface	Giuliano Donzellini;Domenico Ponta	2009	2009 IEEE International Conference on Microelectronic Systems Education	10.1109/MSE.2009.5270830	embedded system;computer architecture;real-time computing;logic gate;computer science;operating system;finite-state machine;user interface;computer engineering	EDA	8.582458278658416	50.9569867609211	184827
40db8ad6c3164fdac519d112aea7834818fd59e5	a scalable and embedded fpga architecture for efficient computation of grey level co-occurrence matrices and haralick textures features	g900 others in mathematical and computing sciences;fpga;texture features;embedded system;chip;general purpose processor;texture analysis;fpga architecture;image analysis;external memory;halarick features;image and texture analysis;high throughput;co occurrence matrix;software implementation	0141-9331/$ see front matter 2009 Elsevier B.V. A doi:10.1016/j.micpro.2009.11.001 * Corresponding author. Tel.: +33 3 87 54 71 36. E-mail addresses: l.sieler@lasmea.univ-bpclermon gast@univ-metz.fr (C. Tanougast), Ahmed.Bouridane@ This paper presents a novel and optimized embedded architecture based FPGA for an efficient and fast computation of grey level co-occurrence matrices (GLCM) and Haralick textures features for use in high throughput image analysis applications where time performance is critical. The originality of this architecture allows for a scalable and a totally embedded on Chip FPGA for the processing of large images. The architecture was implemented on Xilinx Virtex-FPGAs without the use of external memory and/or host machine. The implementations demonstrate that our proposed architecture can deliver a high reduction of the memory and FPGA logic requirements when compared with the state of the art counterparts and it also achieves much improved processing times when compared against optimized software implementation running on a conventional general purpose processor. 2009 Elsevier B.V. All rights reserved.	co-occurrence matrix;coefficient;computation;embedded system;field-programmable gate array;grayscale;hypervisor;image analysis;performance;real-time computing;requirement;robert haralick;run time (program lifecycle phase);scalability;throughput;vhdl;virtex (fpga)	Loïc Siéler;Camel Tanougast;Ahmed Bouridane	2010	Microprocessors and Microsystems - Embedded Hardware Design	10.1016/j.micpro.2009.11.001	chip;high-throughput screening;embedded system;computer vision;parallel computing;image analysis;computer hardware;computer science;co-occurrence matrix;field-programmable gate array	EDA	2.8634375098118134	46.8256290188738	185035
5c6fcf53a8274343678b778916efe4da2fbfaa5e	network facility for a reconfigurable computer architecture	reconfigurable computing		computer architecture;reconfigurable computing	Manjai Lee;Eric Fiene;Chuan-lin Wu;Geoffrey Brown;Nader Bagherzadeh	1985			piperench;computer architecture;parallel computing;reconfigurable computing;computer science	Arch	4.286522413515831	49.08895313192221	185653
4398bc847f1dddd0cf7b4a24db5350dbd4adda8f	dynamic partial reconfigurable fft for ofdm based communication systems		This paper presents a novel scalable and runtime dynamically reconfigurable FFT architecture for different wireless standards. With only 8 butterfly units, a reconfigurable FFT architecture for three different FFT points is realized using mixed radix-22/23/24 FFT algorithm in a modified Single-path Delay Feedback (SDF) pipelined architecture. Via a proper data flow reconfiguration it can support 64, 128 and 256. It can even be extended up to 8192-point transforms and uses only 13 butterfly units to realize 8192 points. This paper describes the implementation method of 256 and 128 point FFT, which is reconfigured partially from 64 point FFT. The whole system is implemented on a Xilinx XC2VP30 FPGA device. The implementation design addresses area efficiency and flexibility allowing the insertion of the partial modules dynamically to realize various FFT sizes. To verify the efficacy of this dynamic partial reconfigurable FFT design method, a conventional multiplexer based reconfigurable architecture was designed and tested on the same platform. Tested FPGA results for the Dynamic Partial Reconfigurable (DPR) method show the configuration time improvement and good area efficiency as compared to the reconfigurable architecture using conventional multiplexer techniques.	fast fourier transform	C. Vennila;G. Lakshminarayanan;Seok-Bum Ko	2012	CSSP	10.1007/s00034-011-9367-9	embedded system;parallel computing;real-time computing;computer science	EDA	7.619339352797803	48.49292011832409	185833
3a4210e4767f503f2ae0edea7146594f76bcc12f	design methods of multi-dsp parallel processing system	single chip design method;digital signal processing;field programmable gate array;topology;multi dsp parallel processing system;2 level bus structure;2 level bus structure multi dsp parallel processing system single chip design method cascaded topology parallel architecture field programmable gate array fpga;logic design;real time processing;fpga;design methodology parallel processing digital signal processing radar signal processing field programmable gate arrays digital signal processing chips signal processing data communication real time systems topology;field buses;hardware architecture;network topology;computer architecture;design method;parallel architectures;parallel architectures digital signal processing chips field buses field programmable gate arrays logic design network topology;parallel systems;hardware architecture parallel processing multi dsp real time processing;digital signal processor;digital signal processing chips;parallel architecture;field programmable gate arrays;multi dsp;titanium;parallel processing;cascaded topology;real time systems	In this paper, the cascaded topology of Multi-Digital Signal Processor (DSP) parallel processing system is presented, and the common architecture for multi-DSP parallel systems is summarized. In addition, according to the features of Field Programmable Gate Array (FPGA) and DSP, a parallel system based on 2-level bus structure has been proposed. Two parallel systems, respectively based on TMS320C641x and TS201, have been realized too. Having compared their advantages and performances, we finally conclude the design methods of multi-DSP parallel processing system.	digital signal processor;field-programmable gate array;parallel computing;parallel processing (dsp implementation);performance	Wei Wu;Wei Li;Wenhao Zhang	2009	2009 WRI World Congress on Computer Science and Information Engineering	10.1109/CSIE.2009.40	parallel processing;computer architecture;parallel computing;computer science;hardware architecture;field-programmable gate array	EDA	4.809336105154484	46.46121559386188	186267
a772f927ab62583678c0c4a637d6fa47d27aeda9	allocation of multiport memory with ports of different type in register transfer level synthesis	code sequence;read ports;data path design;multiport networks;register allocation;code sequence memory allocation register transfer level synthesis multiport memory synthesis data path design register allocation partitioned dependence matrix read ports write ports design generator behavioral description;design generator;multiport memory synthesis;registers read write memory space exploration high level synthesis merging multiplexing testing delta modulation;register transfer;space exploration;testing;matrix algebra;write ports;delta modulation;design space;multiplexing;high level synthesis;registers;register transfer level synthesis;behavioral description;merging;storage management chips matrix algebra multiport networks;storage management chips;partitioned dependence matrix;memory allocation;read write memory;register transfer level	At present, there is no efficient synthesis approach for multiport memory synthesis in data path design and only single port memory is considered for register allocation in most synthesis systems. An efficient method, partitioned dependence matrix (PDM), is presented to explore the design space for multiport memory synthesis in which the maximum number of read ports can be same as or different from the maximum number of write ports according to the design constraints. The design generator based on the PDM method was developed and implemented to facilitate the register transfer (RT) level synthesis. The input to the design generator is a behavioral description at the RT level which is viewed as a code sequence. PDM provides the memory mechanism as the output. >	register-transfer level	Chien-In Henry Chen	1991		10.1109/ICCD.1991.139934	delta modulation;electronic engineering;parallel computing;computer hardware;computer science;space exploration;operating system;software testing;processor register;high-level synthesis;register allocation;register-transfer level;multiplexing;memory management	EDA	9.83368613839696	50.21417238543359	187022
8191423dd016ee52543cfcacf1c74afe56a0a989	jbits implementation and design verification in space compressor design of digital circuits	digital circuits			Mansour H. Assaf;Rami S. Abielmona;Payam Abolghasem;Sunil R. Das;Emil M. Petriu;Voicu Groza	2003			intelligent verification;gas compressor;computer architecture;computer engineering;mathematics;digital electronics;high-level verification	EDA	8.597505472310178	51.87757894469438	187057
5991902e51b1dde8fd134abe7a4a9d6ee4eb36cc	automatic and correct register transfer level annotations for low power microprocessor design			register-transfer level	Vinod Viswanath;Jacob A. Abraham	2012	J. Low Power Electronics	10.1166/jolpe.2012.1204	computer architecture;computer hardware;computer science;programming language	EDA	6.250537334963209	50.56736635803243	187166
b429bd65f995e7533ed26e0194e4c8c948973dfd	flexible core reallocation for virtex ii structures			virtex (fpga)	Yana Esteves Krasteva;Ana B. Jimeno;Eduardo de la Torre;Teresa Riesgo	2005			embedded system;parallel computing;virtex;computer science	Logic	4.494754548053236	49.11693412611485	187419
d15688d8ce8a355e02e474cc9b86a872a5945f95	embedded systems design using fpga	field programmable gate array;logic design;design and development;xilinx embedded development kit software embedded system design field programmable gate arrays xilinx fpga technology;embedded system;chip;development tool;logic cad field programmable gate arrays integrated circuit design embedded systems;embedded systems;integrated circuit design;embedded system design;field programmable gate arrays;logic cad	Embedded systems design is a hot application field which merges logic design and processor-based hardware development in a single or few chips solution. In recent years, embedded applications have emerged at a fast rate and used in every field of one can think of ranging from household products such as microwaves, to automotive products such as air bags sensing and control, to industrial robots which employ distributed processing and coordination. Various technologies have been used in the development of embedded systems; microcontroller, DSP processor, ASIC, and now FPGA. Embedded systems development involves hardware and software development as they co-exist in such systems. The software is unique to a system and varies in complexity from system to system and application to application. This peculiar characteristic makes the system development unique and challenging. Typically, such system development involves another system on which design and development takes place. Field Programmable Gate Arrays (FPGA) from Xilinx started as glue logic usage stitching functions together. Through generations of development, more and more functional blocks were added, increasing applications area envelope. With the introduction of Virtex-II Pro, Xilinx entered embedded processing area. Through the rigorous development of supporting tools and introduction of most recent family, Virtex-4, Xilinx has positioned itself as a major player in the embedded applications area. Xilinx FPGA families carry hard core and soft core processors. The development kits provide hardware/software tools which facilitate implementation of functions, which are not yet realized, by embedding them as soft intellectual property in the FPGA fabric. Thus a specific ASIC chip need not be developed for every application, reducing time to market and development cost. In this tutorial, we will show how Xilinx FPGAs can be used in embedded applications. The strengths of Xilinx FPGAs and the supporting development tools will be described. A demonstration will be provided to show the ease of design and development of a complete system using Xilinx Embedded Development Kit (EDK) software.	application-specific integrated circuit;central processing unit;complexity;digital signal processor;distributed computing;embedded system;field-programmable gate array;functional derivative;industrial robot;microcontroller;microwave;programming tool;software development kit;software development process;systems design;virtex (fpga)	Parimal Patel	2006		10.1109/VLSID.2006.83	embedded system;computer architecture;reconfigurable computing;programmable logic array;computer science;engineering;quality of results;computer-on-module;field-programmable gate array;computer engineering	EDA	4.662482591003737	51.229505723413396	187737
c65b9de2545e471c6c7db4ea9946555d7e147d8a	performance through hierarchy in static timing verification	design aids;reliability and testing;integrated circuits		static timing analysis;verification and validation	P. Johannes;Luc J. M. Claesen;Hugo De Man	1992			reliability engineering;computer architecture;real-time computing;computer science;static timing analysis;functional verification	EDA	8.491685763406046	52.73247338562197	188261
39486836f2e9853d0f3f49039aa2eb54bae7f324	estimating functional coverage in bounded model checking	formal verification;integrated circuit modelling;logic design;risc cpu;bounded model checking;circuit design;formal verification;functional coverage estimation;system design	Formal verification is an important issue in circuit and system design. In this context, Bounded Model Checking (BMC) is one of the most successful techniques. But even if all specified properties can be verified, it is difficult to determine whether they cover the complete functional behavior of a design. We propose a pragmatic approach to estimate coverage in BMC. The approach can easily be integrated in a BMC tool with only minor changes. In our approach, a coverage property is generated for each important signal. If the considered properties do not describe the signal's entire behavior, the coverage property fails and a counter-example is generated. From the counter-example an uncovered scenario can be derived. In this way the approach also helps in design understanding. Our method is demonstrated on a RISC CPU. Based on the results we identified coverage gaps. We were able to close all of them and achieved 100% functional coverage.	central processing unit;formal verification;functional testing;intelligent platform management interface;model checking;systems design	Daniel Große;Ulrich Kühne;Rolf Drechsler	2007	2007 Design, Automation & Test in Europe Conference & Exhibition	10.1145/1266366.1266620	memory footprint;embedded system;computer architecture;electronic engineering;logic synthesis;real-time computing;formal verification;computer science;theoretical computer science;operating system;circuit design;symmetric-key algorithm;programming language;algorithm;systems design	EDA	7.682554385204462	52.855708943673626	188762
a76de5a7232b888468ad983c5e425df5d4d19c92	a scalable platform for intrinsic hardware and in materio ev olution	evolutionary computation;hardware software codesign;reconfigurable architectures;evolvable hardware scalable platform intrinsic hardware evolvable motherboard intrinsic evolution platform circuit signal probing modular design field programmable matter array physical primitive parallel evolution silicon liquid crystal evolutionary algorithm system design;modules reconfigurable architectures evolutionary computation hardware software codesign field programmable gate arrays parallel architectures;parallel architectures;hardware field programmable analog arrays field programmable gate arrays silicon physics electronic circuits liquid crystal devices computer science chemical technology proteins;modular design;field programmable gate arrays;liquid crystal;modules	An evolvable motherboard is an intrinsic evolution platform that allows the detailed probing of internal signals of circuits that have been evolved. Several designs for an evolvable motherboard have already been demonstrated to work sucessfully as a platform for the evolution of electronic circuits. This paper proposes a new platform that is suitable for intrinsic evolution using a wider variety of media. The platform presents a more modular design, making it suitable for use in evolving more complex physcial primitives whilst affording the possiblity of performing evolution in parallel for simpler problems. The construction of the device is discussed and examples of potential experiments in silicon, liquid crystal and other media are described.	computation;electronic circuit;embedded system;experiment;language primitive;map (parallel pattern);modular design;motherboard;scalability;while	Simon Harding;Julian Francis Miller	2003		10.1109/EH.2003.1217669	embedded system;electronic engineering;engineering;computer engineering	EDA	9.125956187159751	49.56902046429493	189522
cd1e016b03a67b59838d9f6498029fe71ea5eff9	implementing fine grain processor arrays on field-programmable logic	detailed layout algorithm;field-programmable logic;binary morphology;fine grain array algorithm;fpga-based processor array;fine grain processor array;parametrized array processor;critical path;large processor array;field programmable gate arrays;parallel processor array;basic processor	The structure of Field Programmable Gate Arrays (FPGAs) naturally fits that of fine grain array algorithms. The paper investigates the geometrical and layout-related implementation problems of FPGA-based processor arrays. A general methodology for implementing parametrized array processors on FPGAs is presented. Then, a detailed layout algorithm is proposed. A new feature of the algorithm is the uniform treatment of inter- and intra-module nets that allows the layout of the basic processor to be optimized with respect to the critical path of the whole, arbitrarily large processor array. The approach is demonstrated on a massively parallel processor array for binary morphology.	field-programmability;programmable logic device	István Vassányi	2000	Integrated Computer-Aided Engineering		computer architecture;parallel computing;computer science;theoretical computer science	EDA	6.523122126455607	46.529787747219075	189847
a893865bb23b36821ad785e767e7cc564edaddd3	data acquisition with direct memory access		This paper is concerned about using Direct Memory Access (DMA) transfer for real-time data acquisitions from a plug-in data acquisition board Aquarius DSP-1. Since the conversion speed of the modern Analog to Digital Converters is increase-vealy, the using of the interrupts for reading of the conversion results becomes impossible. For the data acquisition system, presented in this paper, this speed is up to 100 kS/s. This problem can be successfully solved using DMA technique. We subsequently describe the hardware of the data acquisition board, which has been used to acquire data. Next, have been presented the functions, in C programming language, for programming a data acquisition via DMA. Finally, we present some results obtained using this kind of data acquisitions, and some conclusions. Keywords and Phrases: real-time data acquisition systems, driver software development and DMA transfer mode.	data acquisition;device driver;direct memory access;interrupt;plug-in (computing);programming language;real-time data;software development	Iurie Guzun	1999	The Computer Science Journal of Moldova		mathematics;theoretical computer science;discrete mathematics;data acquisition;direct memory access	ML	7.029441287995796	47.80689005350329	190339
db84a9e6cdddeb4d25dd694fbed79fea46a035e6	design methodology for real-time fpga-based sound synthesis	musical instruments field programmable gate arrays finite difference methods logic design;digital signal processors;field programmable gate array;evaluation performance;art;condiciones limites;instruments;reproduccion sonido;performance evaluation;ucl;reproduction son;field programmable gate array fpga implementation;metodo diferencia finita;sound synthesis;logic design;condition aux limites;signal audio;boundary conditions;synthese son;implementation;real time;evaluacion prestacion;audio signal;appareil numerique;discovery;acoustic signal processing;theses;conference proceedings;finite difference;sound reproduction;red puerta programable;physical models;field programmable gate array fpga based sound synthesis finite difference scheme;musical instruments;reseau porte programmable;physics computing;computer applications;finite difference method;biomembranes;finite difference fd;sintesis sonido;digital music;methode difference finie;fpga implementation;digital instrument;finite difference scheme;digital web resources;musical instrument;instrumento musical;digital instruments;boundary condition;ucl discovery;open access;instrument musique;physical models digital instruments finite difference fd field programmable gate array fpga implementation;signal acoustique;digital signal processor;aparato numerico;ucl library;acoustic signal;traitement signal acoustique;processeur signal numerique;book chapters;physical model;open access repository;field programmable gate arrays;fpga based sound synthesis;procesador senal numerica;implementacion;design methodology instruments finite difference methods field programmable gate arrays art boundary conditions biomembranes physics computing computer applications digital signal processors;audio acoustics;finite difference methods;senal acustica;senal audio;acoustique audio;design methodology;ucl research	Explicit finite difference (FD) schemes can realize highly realistic physical models of musical instruments but are computationally complex. A design methodology is presented for the creation of field-programmable gate array (FPGA)-based micro-architectures for FD schemes which can be applied to a range of applications with varying computational requirements, excitation and output patterns and boundary conditions. It has been applied to membrane and plate-based sound producing models, resulting in faster than real-time performance on a Xilinx XC2VP50 device which is 10 to 35 times faster than general purpose and digital signal processors. The models have developed in such a way to allow a wide range of interaction (by a musician) thereby leading to the possibility of creating a highly realistic digital musical instrument.	central processing unit;computation;digital signal processor;field-programmability;field-programmable gate array;finite difference;finite-difference time-domain method;real-time clock;real-time computing;real-time transcription;requirement;software propagation	Erdem Motuk;Roger F. Woods;Stefan Bilbao;John McAllister	2007	IEEE Transactions on Signal Processing	10.1109/TSP.2007.898785	digital signal processor;telecommunications;physical model;boundary value problem;computer science;finite difference method;field-programmable gate array	Graphics	3.600653357604511	47.10610127002779	190541
2c6a5ad2e9404e47f814dba8b2a718089848205d	i2c interface design for hardware master devices		In the paper, we present the design of I 2 C compatible interface for hardware master devices that outputs data irregularly in time. The corresponding interface was implemented by developing the relevant VHDL code and a synthesis into standard VLSI cells. The interface operation was validated by tests using the ActiveHDL simulator. Furthermore, the evaluation of power consumption of the interface chip obtained on the basis of Cadence SoC Encounter System is reported.		Lukasz Plachno;Marcin Oleksiak;Dariusz Koscielnik;Marek Jableka	2012		10.3182/20120523-3-CZ-3015.00033	embedded system;computer architecture;computer hardware;computer science	EDA	6.598153960903697	48.94738044400157	190882
ca0a7d30e6641a0cc3b48b68240279e528698bf9	application specific instruction set processor for sensor conditioning in automotive applications		In the automotive electronic market, sensor conditioning is one of the driving applications. Sensor solutions are pervasive in the vehicle, while signal processing in such application is getting more and more complex. Currently the design strategy is often the standard ASIC flow, but the design effort can be reduced by automatic or platform-aided design strategies, or by using software-based solutions. In this paper SensASIP platform is presented. It is a design platform targeting a microprocessor architecture enhanced by dedicated instructions for computing intensive sensor signal processing tasks. SensASIP allows a seamless design flow from MATLAB-based algorithm definition and instruction set design and simulation, down to hardware macrocell HDL description and implementation in CMOS technology. SensASIP features are described through two automotive sensor conditioning examples. Special focus is put on its increased flexibility and reduced design-effort vs. standard ASIC design approach and on its low complexity overhead vs. other state-of-art software-based solutions.	algorithm;application-specific instruction set processor;application-specific integrated circuit;cmos;graphic art software;hardware description language;matlab;microprocessor;overhead (computing);pervasive informatics;seamless3d;sensor;signal processing;simulation	Arcangelo Sisto;Luca Pilato;Riccardo Serventi;Sergio Saponara;Luca Fanucci	2016	Microprocessors and Microsystems - Embedded Hardware Design	10.1016/j.micpro.2016.10.001	embedded system;parallel computing;real-time computing;computer hardware;computer science;operating system	EDA	3.805309977519484	49.94758908680549	191577
ef22418352b2644eda6b56b10d08690ebf0b6f9f	experiences with vhdl and fpgas	field programmable gate array;real time;data flow;development time;product development	Abstract   In order to remain competitive,a company needs to reduce its product development time,and consequently the development time for prototyping has to be reduced as well.One way to decrease the development time of a product is to synthesize the design description automatically to FPGAs (Field Programmable Gate Arrays).This article describes the experience of implementing a real-time kernel in hardware using VHDL for behavioral and data flow (RTL) description, simulation,synthesis to gate level,back-annotation and programming FPGAs for a prototype.		Lennart Lindh;Johan Stärner;Joakim Adomat	1996	Journal of Systems Architecture	10.1016/1383-7621(96)00016-1	embedded system;data flow diagram;computer architecture;parallel computing;real-time computing;vhdl;computer science;software engineering;new product development;field-programmable gate array	EDA	4.247321719925768	51.44384669091961	191843
04bdfbf62ecd5ac95b7cc4433408d03e89de5c9a	prophid: a data-driven multi-processor architecture for high-performance dsp	multiprocessor interconnection networks;high throughput signal processing;processor architecture;digital signal processing;design automation;prophid;digital signal processing chips multiprocessor interconnection networks;communication networks;clocks;processor scheduling;variable rate;stream based multiprocessor architecture;interconnection network;design method;data dependence;communication arbiter;scheduling;signal processing;multiprocessor architecture;digital signal processing processor scheduling communication system control bandwidth communication networks clocks laboratories design automation design methodology signal processing;data driven autonomous processors;bandwidth;digital signal processing chips;scheduling prophid high performance dsp high throughput signal processing stream based multiprocessor architecture data driven autonomous processors programmable connection network communication arbiter;programmable connection network;high throughput;communication system control;high performance;high performance dsp;design methodology	PROPHID is a design method for high-performance systems with a focus on high-throughput signal processing applications. It makes use of a novel stream-based multi-processor architecture, consisting of data-driven autonomous processors interconnected by a programmable connection network. The key element is the communication arbiter which controls the flow of data between processors. Variable rates and data-dependent processing times are handled efficiently by performing scheduling at run time. We give an overview of the characteristics and advantages of the architecture as well as some implementation results.	arbiter (electronics);autonomous robot;central processing unit;data dependency;dataflow;digital signal processor;high-throughput computing;microarchitecture;multiprocessing;run time (program lifecycle phase);scheduling (computing);signal processing;throughput	Jeroen A. J. Leijten;Jef L. van Meerbergen;Adwin H. Timmer;Jochen A. G. Jess	1997		10.1109/EDTC.1997.582425	reference architecture;computer architecture;parallel computing;real-time computing;computer science;data architecture	Arch	4.470579559671036	46.83897727896794	192530
bb353bec303190f3e65ba9cd2c032cc85b04921f	an architecture of prototyping system for dynamic partial reconfiguration on fpga			field-programmable gate array	Akira Yamawaki;Seiichi Serikawa	2010			field-programmable gate array;control reconfiguration;architecture;fpga prototype;computer architecture;computer science	EDA	4.863277355239537	49.63174758168324	193655
a94a5e49d5020251a640277d71e208ffca3f807f	a design philosophy for microcomputers	silicon;microprocessors;control systems;cybernetics;keyboards;computer aided instruction;design rules;large scale integration;communication system control;high level architecture;microcomputers communication system control silicon cybernetics read only memory large scale integration control systems keyboards microprocessors computer aided instruction;read only memory;microcomputers	These eight design rules lead to better utilization of VLSI power, as the implementation of one high-level architecture shows.	high-level architecture;microcomputer;very-large-scale integration	Edwin E. Klingman	1981	IEEE Micro	10.1109/MM.1981.290828	computer architecture;parallel computing;cybernetics;computer science;operating system;microcomputer;silicon;read-only memory	Arch	7.9827129814638536	50.28116340000431	193698
ce79dede29df4f9e657d3112f7b1aa44287c0d16	hdls modeling technique for burst-mode and extended burst-mode asynchronous circuits	asynchronous circuit;burst mode;vhdl;asynchronous	A hardware description languages (HDLs) based modeling technique for asynchronous circuits is presented in this paper. A HDLs handshake package has been developed for expressing handshake-style digital systems in both VHDL and Verilog. Burst-mode and extended burst-mode (BM/XBM) circuits were used to demonstrate the usefulness of this work. This research successfully prototyped comparators, adders, RSA encoder/decoder, and several self-timed circuits for the full-custom IC and FPGAs designs. Furthermore, the HDLs handshake package implemented by this research can be utilized to develop behavioral test benches for studying and analyzing asynchronous designs. Extracting detailed timing information from asynchronous finite state machines (AFSMs), detecting delay faults for synthesized self-timed functional modules, and locating fundamental mode violation within realized AFSMs are proven applications. The anticipated HDL modeling technique and the transformation procedure are detailed in the rest of this paper.	hardware description language	Jung-Lin Yang;Jau-Cheng Wei;Shin-Nung Lu	2010	IEICE Transactions		embedded system;parallel computing;real-time computing;asynchronous circuit;vhdl;computer science;asynchronous communication;burst mode	EDA	5.846546518604325	52.07602799216734	194164
a678bee9d0bc891d53d46677ff5a66c27c97950d	comparing transformation schemes for vlsi array processor design - a case study.				Anders Færgemand Nielsen;Poul Martin Rands Jensen;Kallol Kumar Bagchi;Ole Olsen	1991			computer architecture;electronic engineering;parallel computing;computer science	EDA	5.643834601762649	50.00173602822017	194769
9a642abce76ad65a4e4c29b6b9a75a76e5e725e2	automatic code generation for simd dsp architectures: an algebraic approach	programming language;computer model;algorithm design and analysis;parallel processing;parallel programming;computational modeling;parallel algorithms;high level programming language;mobile communication;algebra;digital signal processing;computer languages;signal processing;computational complexity;computer architecture;concurrent computing	Driven by the ever increasing algorithm complexity on the field of mobile communications systems, SIMD DSP architectures have emerged as an approach that offers the necessary processing power at reasonable levels of die size and power consumption. However, this kind of DSP architectures imposes new challenges for programmers, since algorithms have to be designed to exploit the available parallelism on the processor. Taking as a starting point an algebraic framework that captures the SIMD computational model, we report in this paper about our efforts to design and automatically generate object code for our family of DSP architectures independent of the available SIMD parallelism. We show how these algebraic structures can be used as a high level programming language that offers a unified approach to design and describe algorithms using SIMD parallelism. Moreover, we show how these algebraic structures offer concise rules for the automatic code generation.	algorithm;automatic programming;code generation (compiler);compiler;computational model;finite impulse response;high-level programming language;instruction list;object code;parallel computing;programmer;real-time clock;recursion;recursive filter;simd;signal processing;unix signal	Pablo Robelly;Gordon Cichon;Hendrik Seidel;Gerhard P. Fettweis	2004	Parallel Computing in Electrical Engineering, 2004. International Conference on	10.1109/PCEE.2004.17	parallel processing;algorithm design;computer architecture;parallel computing;mobile telephony;concurrent computing;computer science;theoretical computer science;operating system;digital signal processing;signal processing;parallel algorithm;programming language;computational complexity theory;computational model;high-level programming language	EDA	5.555403182767713	46.79726917077018	194781
020e125a5e10057d68baef7192de4e44595b512e	a reconfigurable platform for multi-service edge routers	performance evaluation;dynamic reconfiguration;edge routers;reconfigurable logic;hardware accelerator;fpga;network traffic	A main feature of current FPGAs is that they can be dynamically reconfigured to meet the network traffic requirements. In this paper we present a case study for a multi-service edge router in which the number of processors and co-processors is dynamically reconfigured to meet the network traffic workload. The system targets the Xilinx Virtex4 FPGA platform and uses the MicroBlaze soft processors for header processing and hardware acceleration units for payload processing. Furthermore, two schemes are compared for the reconfiguration of the system. The first one has fast response time but is prone to network burst traffic while the second one has slower response time but is more robust to burst traffic. The performance evaluation shows that the reconfigurable platform can achieve up to 1.5x speedup compared to a static system.	benchmark (computing);central processing unit;coprocessor;field-programmable gate array;functional programming;global communications conference;hardware acceleration;ieee transactions on computers;koch snowflake;link prefetching;network packet;network traffic control;octal;opencores;performance evaluation;proceedings of the ieee;programmable logic device;reconfigurability;reconfigurable computing;relocation (computing);requirement;response time (technology);router (computing);schedule (project management);scheduling (computing);speedup;very-large-scale integration	Christoforos Kachris;Stamatis Vassiliadis	2007		10.1145/1284480.1284529	embedded system;parallel computing;real-time computing;hardware acceleration;computer science;engineering;operating system;field-programmable gate array	Metrics	3.9499960628945927	49.28146542193661	195260
e439fe2edc95d80b675939b8314c447a4cdac4ea	an expandable real-time transputer sound generator			real-time clock;transputer	Avi Parash;Uri Shimony	1991			embedded system;parallel computing;computer hardware	EDA	4.680127613614579	48.26377014138781	195698
acd146b6cb2176d380b69c583a5c702b7cf56047	a multiple delay simulator for mos lsi circuits	analytical models;human interaction;delay circuit simulation large scale integration computational modeling timing logic devices mosfets analytical models costs permission;input tools and techniques;mosfets;computer graphics;chip;circuit simulation;computational modeling;large scale integration;permission;system design;design verification;logic devices;programming languages;timing	This paper describes a multiple delay simulator for MOS LSI circuits. The basic primitives for this simulator are MOS transistor structures where the transistors are evaluated logically. Integer rise and fall delays are associated with each transition and these delays are computed automatically based on device characteristics and circuit capacitances. The simulator has been extensively used for the design verification of production LSI chips.	integrated circuit;transistor	Hao N. Nham;Ajoy K. Bose	1980	17th Design Automation Conference	10.1145/800139.804594	chip;embedded system;interpersonal relationship;electronic engineering;real-time computing;computer architecture simulator;telecommunications;computer science;electrical engineering;computer graphics;computational model;computer engineering;systems design	EDA	8.32416273919411	51.656328674516004	195958
90621947243ebb9b8ff1c67844764033f3201706	a multilevel approach to teaching hardware description languages	education hardware design languages circuit synthesis digital systems logic very large scale integration field programmable gate arrays engineering students books focusing;computer aided instruction;hardware description languages;electrical and computer engineering;computer science education;educational courses;electronic engineering education;hdl courses multilevel teaching approach hardware description languages electronic engineering students computer engineering students tool sets;hardware description language;teaching hardware description languages computer science education electronic engineering education educational courses computer aided instruction;graduate student;teaching	Knowledge of hardware description languages is an important element in the educational background of both undergraduate and graduate electrical and computer engineering students. However, the manner in which they are exposed to hardware description languages should differ because of the different level of maturity of the student populations. Graduate students are mature intellectually and thus can handle extensive exposure to the underlying abstraction of the language. Undergraduates have more difficulty handling abstraction and thus should be given controlled doses of the language. This paper describes a multilevel approach to teaching hardware description languages that accounts for these differences. Tool sets used in both courses are also	capability maturity model;computer engineering;hardware description language;intellect;population	Jim Armstrong	1997		10.1109/MSE.1997.612523	education;computer science;theoretical computer science;hardware architecture;hardware description language;computer engineering	AI	9.113661168241588	51.58615615376409	196211
fc2013da35818b9dfe20f2aa16759774912c1bc8	a design environment for synthesis of embedded fuzzy controllers on fpgas	libraries;software;fpga synthesis;design tool;fuzzy controller;mathematics computing;cad tools;functional verification;development strategy;tool support;modeling and simulation;cad;comunicacion de congreso;fuzzy control;design space;fuzzy logic;embedded systems;control system;xilinx;matlab design environment embedded fuzzy controller synthesis complex control systems cad tools xfuzzy fpga synthesis xilinx;xfuzzy;design environment;control system synthesis;complex control systems;solid modeling;software component;mathematical model;mathematics computing cad control system synthesis embedded systems field programmable gate arrays fuzzy control large scale systems;field programmable gate arrays software hardware solid modeling libraries mathematical model fuzzy systems;field programmable gate arrays;matlab;fuzzy systems;embedded fuzzy controller synthesis;large scale systems;hardware	This paper presents a design environment for the synthesis of embedded fuzzy controllers on FPGAs. It provides a novel implementation technique that allows accelerating the exploration of the design space of fuzzy control modules, as well as a codesign flow that eases their integration into complex control systems and the joint development of hardware and software components. The set of CAD tools supporting this environment includes specific fuzzy logic design tools provided by Xfuzzy, FPGA synthesis and implementation tools from Xilinx, and modeling and simulation facilities from Matlab. As demonstrated by the analyzed design examples, the described development strategy takes advantage of flexibility and ease of configuration offered by the different tools to dramatically speed up the stages of description, synthesis, and functional verification of embedded fuzzy control systems.	automatic parking;component-based software engineering;computer-aided design;design flow (eda);embedded system;field-programmable gate array;fuzzy control system;fuzzy logic;matlab;simulation	Santiago Sánchez-Solano;Ernesto del Toro;María Brox;Iluminada Baturone;Angel Barriga Barros	2010	International Conference on Fuzzy Systems	10.1109/FUZZY.2010.5584812	fuzzy logic;fuzzy electronics;computer architecture;computer science;artificial intelligence;component-based software engineering;mathematical model;cad;solid modeling;functional verification;fuzzy control system;field-programmable gate array	EDA	4.723735053285652	51.78698982977755	196284
69ff3502e59f7699462619edf20f943200bf90df	hidra: a new architecture for heterogeneous embedded systems	embedded system		embedded system	Zoran A. Salcic;Partha S. Roop;Dong Hui;Ivan Radojevic	2004			discrete mathematics;theoretical computer science;computer science;architecture	Embedded	4.723119250121385	49.982119071700915	199762
